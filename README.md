# Tealeaves

Tealeaves is a Coq framework for proving theorems about syntax abstractly, i.e. independently of a concrete grammar. This independence makes syntactical theory reusable between developments, and is achieved by separating a choice of grammar from a choice of variable representation. Our central abstraction is a "structured" kind of monad that we call *decorated traversable,* which is an abstraction of abstract syntax trees. Tealeaves "core" is a Coq implementation of the equational theory of such monads, as well as higher-level principles built on top of this theory.

![Abstract syntax tree](/images/tree.svg)

## How to build Tealeaves
System requirements:
- `make` (see [GNU Make](https://www.gnu.org/software/make/))
- An installation of Coq >= 8.13 (see the Coq [downloads page](https://coq.inria.fr/download)).

Compilation instructions:
- Run `make` in the top-level directory
- Run `make clean` to remove all build artifacts (including compiled files) and start over

We have tested with Coq 8.13, but other versions may work too. We observe a compilation time of approximately 4-5 minutes on a typical desktop computer. On multicore systems you may want to use the `-j` flag to use several build threads. We have sometimes observed that `-j` leads to cryptic build errors. The solution to these is simply to re-run the build command again.

Tealeaves is built with the [coq_makefile](https://coq.inria.fr/refman/practical-tools/utilities.html#building-a-coq-project-with-coq-makefile), which is distributed with Coq itself. This utility generates a customized Makefile to build a Coq project. For simplicity, we provide a top-level `Makefile` which will call `coq_makefile` for you, and then recursively call `make` on the generated Makefile, so that you should not have to do anything except call `make` once in the top-level directory.

## Generating the documentation

Pretty-printed HTML documentation is generated by default in the `html/` directory.

## Module organization

### Typeclasses
Classes of "structured" functors (like monads, decorated monads, traversable functors, etc.) are found in under `Tealeaves/Classes`. The internal implementation of Tealeaves uses an *algebraic* rather than *Kleisli-style* implementation of our typeclasses, so that operations like `bind` are derived rather than taken as primitive. For example, decorated monads are defined [here](https://github.com/dunnl/tealeaves/blob/master/Tealeaves/Classes/DecoratedMonad.v) as monads equipped with a "decoration" operation. Their equivalent Kleisli presentation is derived [here](https://github.com/dunnl/tealeaves/blob/master/Tealeaves/Classes/DecoratedMonad.v#L200) in the same file. A characterization of decorated functors as comodules of the reader/writer bimonad is found [here](https://github.com/dunnl/tealeaves/blob/master/Tealeaves/Theory/Decorated.v).

### The locally nameless backend
Our locally nameless backend library is formalized under the `LN/` directory. The operations (opening, closing, local closure, etc) are defined [here](https://github.com/dunnl/tealeaves/blob/master/LN/Operations.v). Various lemmas about these operations, proved polymorphically over a decorated traversable monad `T`, are proved [here](https://github.com/dunnl/tealeaves/blob/master/LN/Theory.v).

### Simply typed lambda calculus
Our formalization of STLC is under the `STLC/` directory. A formalization of STLC's syntax as a DTM is found [here](https://github.com/dunnl/tealeaves/blob/master/STLC/Language.v). Basic metatheory such as a progress theorem are proved [here](https://github.com/dunnl/tealeaves/blob/master/STLC/Theory.v).

### Multisorted
Our multisorted classes live under `Multisorted/`. Our extension of the locally nameless backend lives under `LN/Multisorted/.` SystemF lives under `SystemF`.

## Typeclasses hierarchy
![Tealeaves typeclass hierarchy](/images/cube.svg)

| **Tealeaves Typeclasses** | Functor                                                                                                                       | Monad                                                                                                                     |
|---------------------------|-------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------|
| Plain                     | [Classes/Functor.v](/Tealeaves/Classes/Functor.v)                                                                             | [Algebraic](/Tealeaves/Classes/Algebraic/Monad.v) / [Kleisli](/Tealeaves/Classes/Kleisli/Monad.v)                         |
| Decorated                 | [Algebraic](/Tealeaves/Classes/Algebraic/Decorated/Functor.v) / [Kleisli](/Tealeaves/Classes/Kleisli/Decorated/Functor.v)     | [Algebraic](/Tealeaves/Classes/Algebraic/Decorated/Monad.v) / [Kleisli](/Tealeaves/Classes/Kleisli/Decorated/Monad.v)     |
| Traversable               | [Algebraic](/Tealeaves/Classes/Algebraic/Traversable/Functor.v) / [Kleisli](/Tealeaves/Classes/Kleisli/Traversable/Functor.v) | [Algebraic](/Tealeaves/Classes/Algebraic/Traversable/Monad.v) / [Kleisli](/Tealeaves/Classes/Kleisli/Traversable/Monad.v) |
| Decorated+Traversable     | [Algebraic](/Tealeaves/Classes/Algebraic/DT/Functor.v) / [Kleisli](/Tealeaves/Classes/Kleisli/DT/Functor.v)                   | [Algebraic](/Tealeaves/Classes/Algebraic/DT/Monad.v) / [Kleisli](/Tealeaves/Classes/Kleisli/DT/Monad.v)                   |

## Other notes

### Axioms used in Tealeaves
Tealeaves currently uses two axioms commonly used in Coq formalizations, which have been proven (on paper) to be equi-consistent with Coq itself. They are the following.
- [Propositional extensionality](https://coq.github.io/doc/v8.12/stdlib/Coq.Logic.PropExtensionality.html#propositional_extensionality), which says that equivalent propositions (`P <-> Q`) are propositionally equal (`P = Q`)
- [Functional extensionality](https://coq.inria.fr/library/Coq.Logic.FunctionalExtensionality.html#functional_extensionality), which is the statement `forall x, f x = g x -> f = g`.

There axioms are assumed [here](https://github.com/dunnl/tealeaves/blob/1e69a99b9376506c5c28c243112e74c9282535aa/Tealeaves/Util/Prelude.v#L6). They are a convenience to use Coq's rewriting features. In principle one can eliminate these at the cost of ``setoid hell'' (see [this question](https://stackoverflow.com/questions/65493694/why-do-calculus-of-construction-based-languages-use-setoids-so-much) on StackOverflow).
