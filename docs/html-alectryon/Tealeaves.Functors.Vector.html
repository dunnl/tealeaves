<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<title>Vector.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.16.0+0.16.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Tealeaves <span class="kn">Require Export</span>
  Classes.Categorical.Applicative
  Classes.Kleisli.TraversableFunctor
  Classes.Categorical.TraversableFunctor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(*</span>
<span class="c">From Tealeaves Require Import</span>
<span class="c">  Adapters.CategoricalToKleisli.TraversableFunctor.</span>
<span class="c">*)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Generalizable Variables</span> <span class="nf">œï</span> T G A M F.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Applicative.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(*</span>
<span class="c">(** * Vectors *)</span>
<span class="c">(******************************************************************************)</span>
<span class="c">Inductive Vector (A : Type) : forall (n : nat), Type :=</span>
<span class="c">| Vnil : Vector A 0</span>
<span class="c">| Vcons : A -&gt; forall (n : nat), Vector A n -&gt; Vector A (S n).</span>
<span class="c"> *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Notation</span> <span class="s2">&quot;&#39;VEC&#39; n&quot;</span> := (<span class="kr">fun</span> <span class="nv">A</span> =&gt; Vector.t A n) (<span class="kn">at level</span> <span class="mi">3</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk0"><span class="kn">Definition</span> <span class="nf">unone</span> {<span class="nv">A</span> : <span class="kt">Type</span>} : Vector.t A <span class="mi">1</span> -&gt; A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vector.t A <span class="mi">1</span> -&gt; A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vector.t A <span class="mi">1</span> -&gt; A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk2"><span class="nb">intros</span> v.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t A <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk3"><span class="nb">remember</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heqn</var><span class="hyp-type"><b>: </b><span>n = <span class="mi">1</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t A n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk4"><span class="nb">induction</span> v.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Heqn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="vector-v-chk5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heqn</var><span class="hyp-type"><b>: </b><span>S n = <span class="mi">1</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t A n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>n = <span class="mi">1</span> -&gt; A</span></span></span><br></div><label class="goal-separator" for="vector-v-chk5"><hr></label><div class="goal-conclusion">A</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Heqn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">inversion</span> Heqn.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heqn</var><span class="hyp-type"><b>: </b><span>S n = <span class="mi">1</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t A n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>n = <span class="mi">1</span> -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Properties of vectors *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk8"><span class="kn">Lemma</span> <span class="nf">toNil</span> {<span class="nv">B</span> : <span class="kt">Type</span>} : <span class="kr">forall</span> (<span class="nv">b</span> : Vector.t B <span class="mi">0</span>), b = Vector.nil B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : Vector.t B <span class="mi">0</span>, b = Vector.nil B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : Vector.t B <span class="mi">0</span>, b = Vector.nil B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chka"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Vector.t B <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">b = Vector.nil B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chkb"><span class="nb">apply</span> (Vector.case0 (A := B) (<span class="kr">fun</span> <span class="nv">v</span> : Vector.t B <span class="mi">0</span> =&gt; v = Vector.nil B)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Vector.t B <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vector.nil B = Vector.nil B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Functor instance *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">map_Vector</span> (<span class="nv">n</span> : nat) {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">v</span> : VEC n A) : VEC n B :=
  <span class="kr">match</span> v <span class="kr">in</span> Vector.t _ n <span class="kr">return</span> Vector.t B n <span class="kr">with</span>
  | Vector.nil _<span class="c">(*=A*)</span> =&gt; Vector.nil B
  | Vector.cons _<span class="c">(*=A*)</span> a<span class="c">(*:A*)</span> m<span class="c">(*n = S m*)</span> rest =&gt;
      Vector.cons B (f a) m (map_Vector m f rest)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Map_Vector</span> (<span class="nv">n</span> : nat) : Map (VEC n) := @map_Vector n.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chkc"><span class="kn">Lemma</span> <span class="nf">fun_map_id_Vector</span> : <span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">A</span> : <span class="kt">Type</span>),
    map (F := VEC n) id = @id (VEC n A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">A</span> : <span class="kt">Type</span>), map id = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chkd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">A</span> : <span class="kt">Type</span>), map id = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chke"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map id = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chkf">ext v.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t A n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map id v = id v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk10"><span class="nb">induction</span> v.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map id (Vector.nil A) = id (Vector.nil A)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="vector-v-chk11" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t A n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>map id v = id v</span></span></span><br></div><label class="goal-separator" for="vector-v-chk11"><hr></label><div class="goal-conclusion">map id (Vector.cons A h n v) =
id (Vector.cons A h n v)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk12">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map id (Vector.nil A) = id (Vector.nil A)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk13">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t A n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>map id v = id v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map id (Vector.cons A h n v) =
id (Vector.cons A h n v)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk14"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t A n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>map id v = id v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vector.cons A (id h) n (map_Vector n id v) =
id (Vector.cons A h n v)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk15"><span class="nb">unfold</span> id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t A n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>map id v = id v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vector.cons A h n (map_Vector n (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; x) v) =
Vector.cons A h n v</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk16">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t A n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>map id v = id v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map_Vector n (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; x) v = v</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IHv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk17"><span class="kn">Lemma</span> <span class="nf">fun_map_map_Vector</span> : <span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : B -&gt; C),
    map (F := VEC n) g ‚àò map (F := VEC n) f = map (F := VEC n) (g ‚àò f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">g</span> : B -&gt; C), map g ‚àò map f = map (g ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk18"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">g</span> : B -&gt; C), map g ‚àò map f = map (g ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk19"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map g ‚àò map f = map (g ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk1a">ext v.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t A n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map g ‚àò map f) v = map (g ‚àò f) v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk1b"><span class="nb">induction</span> v.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map g ‚àò map f) (Vector.nil A) =
map (g ‚àò f) (Vector.nil A)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="vector-v-chk1c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t A n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>(map g ‚àò map f) v = map (g ‚àò f) v</span></span></span><br></div><label class="goal-separator" for="vector-v-chk1c"><hr></label><div class="goal-conclusion">(map g ‚àò map f) (Vector.cons A h n v) =
map (g ‚àò f) (Vector.cons A h n v)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk1d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map g ‚àò map f) (Vector.nil A) =
map (g ‚àò f) (Vector.nil A)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk1e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t A n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>(map g ‚àò map f) v = map (g ‚àò f) v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map g ‚àò map f) (Vector.cons A h n v) =
map (g ‚àò f) (Vector.cons A h n v)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk1f"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t A n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>(map g ‚àò map f) v = map (g ‚àò f) v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vector.cons C (g (f h)) n
  (map_Vector n g (map_Vector n f v)) =
Vector.cons C ((g ‚àò f) h) n (map_Vector n (g ‚àò f) v)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk20"><span class="nb">unfold</span> id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t A n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>(map g ‚àò map f) v = map (g ‚àò f) v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vector.cons C (g (f h)) n
  (map_Vector n g (map_Vector n f v)) =
Vector.cons C ((g ‚àò f) h) n (map_Vector n (g ‚àò f) v)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk21">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t A n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>(map g ‚àò map f) v = map (g ‚àò f) v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map_Vector n g (map_Vector n f v) =
map_Vector n (g ‚àò f) v</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IHv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Functor_Vector</span> (<span class="nv">n</span> : nat) : Functor (VEC n) :=
  {| fun_map_id := fun_map_id_Vector n;
    fun_map_map := fun_map_map_Vector n;
  |}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Traversable instance *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">dist_Vector</span> (<span class="nv">n</span> : nat) (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) `{Map G} `{Pure G} `{Mult G}
  {A : <span class="kt">Type</span>} (v : VEC n (G A)) : G (VEC n A) :=
  <span class="kr">match</span> v <span class="kr">in</span> Vector.t _ n <span class="kr">return</span> G (Vector.t A n) <span class="kr">with</span>
  | Vector.nil _<span class="c">(*=A*)</span> =&gt; pure (F := G) (Vector.nil A)
  | Vector.cons _<span class="c">(*=A*)</span> a<span class="c">(*:FA*)</span> m<span class="c">(*n = S m*)</span> rest =&gt;
      pure (F := G) (Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> =&gt; Vector.cons A a m))
      &lt;‚ãÜ&gt; dist_Vector m G rest
      &lt;‚ãÜ&gt; a
      <span class="c">(*</span>
<span class="c">      pure (F := G) (fun a =&gt; Vector.cons A a m) &lt;‚ãÜ&gt; a &lt;‚ãÜ&gt; dist_Vector m G rest</span>
<span class="c">       *)</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Dist_Vector</span> (<span class="nv">n</span> : nat):
  ApplicativeDist (VEC n) := @dist_Vector n.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cleanup_Vector&quot;</span> :=
  <span class="kp">repeat</span> (<span class="nb">change</span> (map_Vector <span class="nl">?n</span> (A := <span class="nl">?x</span>) (B := <span class="nl">?y</span>))
           <span class="kr">with</span> (map (F := VEC n) (A := x) (B := y)) +
                  <span class="nb">change</span> (dist_Vector <span class="nl">?n</span> <span class="nl">?G</span> (A := <span class="nl">?x</span>))
             <span class="kr">with</span> (dist (VEC n) G (A := x))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cleanup_Vector_*&quot;</span> :=
  <span class="kp">repeat</span> ((<span class="nb">change</span> (map_Vector <span class="nl">?n</span> (A := <span class="nl">?x</span>) (B := <span class="nl">?y</span>))
            <span class="kr">with</span> (map (F := VEC n) (A := x) (B := y)) <span class="kr">in</span> *) ||
                   <span class="nb">change</span> (dist_Vector <span class="nl">?n</span> <span class="nl">?G</span> (A := <span class="nl">?x</span>))
              <span class="kr">with</span> (dist (VEC n) G (A := x)) <span class="kr">in</span> *).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk22"><span class="kn">Lemma</span> <span class="nf">dist_natural_Vector</span> (<span class="nv">n</span> : nat) :
  <span class="kr">forall</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H1</span> : Map G)
    (<span class="nv">H2</span> : Pure G) (<span class="nv">H3</span> : Mult G),
    Applicative G -&gt; Natural (F := (VEC n ‚àò G)) (G := (G ‚àò VEC n)) (@dist_Vector n G _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H1</span> : Map G) (<span class="nv">H2</span> : Pure G)
  (<span class="nv">H3</span> : Mult G),
Applicative G -&gt; Natural (@dist_Vector n G H1 H2 H3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk23"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H1</span> : Map G) (<span class="nv">H2</span> : Pure G)
  (<span class="nv">H3</span> : Mult G),
Applicative G -&gt; Natural (@dist_Vector n G H1 H2 H3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk24"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural (@dist_Vector n G H1 H2 H3)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk25"><span class="nb">constructor</span>; <span class="kp">try</span> <span class="nb">typeclasses eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
map f ‚àò dist_Vector n G = dist_Vector n G ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk26"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f ‚àò dist_Vector n G = dist_Vector n G ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk27">unfold_ops @Map_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map f) ‚àò dist_Vector n G =
dist_Vector n G ‚àò map (map f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk28"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">3</span> <span class="mi">7</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map f) ‚óã dist_Vector n G =
dist_Vector n G ‚óã map (map f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk29">ext v.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>(VEC n ‚àò G) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map f) (dist_Vector n G v) =
dist_Vector n G (map (map f) v)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk2a"><span class="nb">induction</span> v.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map f) (dist_Vector <span class="mi">0</span> G (Vector.nil (G A))) =
dist_Vector <span class="mi">0</span> G (map (map f) (Vector.nil (G A)))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="vector-v-chk2b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t (G A) n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>map (map f) (dist_Vector n G v) = dist_Vector n G (map (map f) v)</span></span></span><br></div><label class="goal-separator" for="vector-v-chk2b"><hr></label><div class="goal-conclusion">map (map f)
  (dist_Vector (S n) G (Vector.cons (G A) h n v)) =
dist_Vector (S n) G
  (map (map f) (Vector.cons (G A) h n v))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk2c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map f) (dist_Vector <span class="mi">0</span> G (Vector.nil (G A))) =
dist_Vector <span class="mi">0</span> G (map (map f) (Vector.nil (G A)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk2d"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map f) (pure (Vector.nil A)) =
pure (Vector.nil B)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk2e">compose near (Vector.nil A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (map f) ‚àò pure) (Vector.nil A) =
pure (Vector.nil B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (app_pure_natural (G := G)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk2f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t (G A) n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>map (map f) (dist_Vector n G v) = dist_Vector n G (map (map f) v)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map f)
  (dist_Vector (S n) G (Vector.cons (G A) h n v)) =
dist_Vector (S n) G
  (map (map f) (Vector.cons (G A) h n v))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk30"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t (G A) n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>map (map f) (dist_Vector n G v) = dist_Vector n G (map (map f) v)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map f)
  (pure (Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; Vector.cons A a n)) &lt;‚ãÜ&gt;
   dist_Vector n G v &lt;‚ãÜ&gt; h) =
pure (Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : B =&gt; Vector.cons B a n)) &lt;‚ãÜ&gt;
dist_Vector n G (map_Vector n (map f) v) &lt;‚ãÜ&gt; map f h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* LHS *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk31"><span class="nb">rewrite</span> (map_ap).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t (G A) n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>map (map f) (dist_Vector n G v) = dist_Vector n G (map (map f) v)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (map f))
  (pure (Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; Vector.cons A a n)) &lt;‚ãÜ&gt;
   dist_Vector n G v) &lt;‚ãÜ&gt; h =
pure (Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : B =&gt; Vector.cons B a n)) &lt;‚ãÜ&gt;
dist_Vector n G (map_Vector n (map f) v) &lt;‚ãÜ&gt; map f h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk32"><span class="nb">rewrite</span> (map_ap).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t (G A) n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>map (map f) (dist_Vector n G v) = dist_Vector n G (map (map f) v)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (compose (map f)))
  (pure (Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; Vector.cons A a n))) &lt;‚ãÜ&gt;
dist_Vector n G v &lt;‚ãÜ&gt; h =
pure (Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : B =&gt; Vector.cons B a n)) &lt;‚ãÜ&gt;
dist_Vector n G (map_Vector n (map f) v) &lt;‚ãÜ&gt; map f h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk33"><span class="nb">rewrite</span> (app_pure_natural (G := G)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t (G A) n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>map (map f) (dist_Vector n G v) = dist_Vector n G (map (map f) v)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (compose (map f)
   ‚àò Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; Vector.cons A a n)) &lt;‚ãÜ&gt;
dist_Vector n G v &lt;‚ãÜ&gt; h =
pure (Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : B =&gt; Vector.cons B a n)) &lt;‚ãÜ&gt;
dist_Vector n G (map_Vector n (map f) v) &lt;‚ãÜ&gt; map f h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* RHS *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk34">cleanup_Vector_*.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t (G A) n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>map (map f) (dist VEC n G v) = dist VEC n G (map (map f) v)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (compose (map f)
   ‚àò Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; Vector.cons A a n)) &lt;‚ãÜ&gt;
dist VEC n G v &lt;‚ãÜ&gt; h =
pure (Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : B =&gt; Vector.cons B a n)) &lt;‚ãÜ&gt;
dist VEC n G (map (map f) v) &lt;‚ãÜ&gt; map f h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk35"><span class="nb">rewrite</span> &lt;- IHv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t (G A) n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>map (map f) (dist VEC n G v) = dist VEC n G (map (map f) v)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (compose (map f)
   ‚àò Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; Vector.cons A a n)) &lt;‚ãÜ&gt;
dist VEC n G v &lt;‚ãÜ&gt; h =
pure (Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : B =&gt; Vector.cons B a n)) &lt;‚ãÜ&gt;
map (map f) (dist VEC n G v) &lt;‚ãÜ&gt; map f h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk36"><span class="nb">rewrite</span> &lt;- (ap_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t (G A) n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>map (map f) (dist VEC n G v) = dist VEC n G (map (map f) v)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (compose (map f)
   ‚àò Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; Vector.cons A a n)) &lt;‚ãÜ&gt;
dist VEC n G v &lt;‚ãÜ&gt; h =
map (precompose f)
  (pure (Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : B =&gt; Vector.cons B a n)) &lt;‚ãÜ&gt;
   map (map f) (dist VEC n G v)) &lt;‚ãÜ&gt; h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk37"><span class="nb">rewrite</span> &lt;- (ap_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t (G A) n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>map (map f) (dist VEC n G v) = dist VEC n G (map (map f) v)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (compose (map f)
   ‚àò Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; Vector.cons A a n)) &lt;‚ãÜ&gt;
dist VEC n G v &lt;‚ãÜ&gt; h =
map (precompose f)
  (map (precompose (map f))
     (pure
        (Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : B =&gt; Vector.cons B a n))) &lt;‚ãÜ&gt;
   dist VEC n G v) &lt;‚ãÜ&gt; h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk38"><span class="nb">rewrite</span> (map_ap).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t (G A) n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>map (map f) (dist VEC n G v) = dist VEC n G (map (map f) v)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (compose (map f)
   ‚àò Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; Vector.cons A a n)) &lt;‚ãÜ&gt;
dist VEC n G v &lt;‚ãÜ&gt; h =
map (compose (precompose f))
  (map (precompose (map f))
     (pure
        (Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : B =&gt; Vector.cons B a n)))) &lt;‚ãÜ&gt;
dist VEC n G v &lt;‚ãÜ&gt; h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk39">compose near (pure (F := G) (Basics.flip (<span class="kr">fun</span> <span class="nv">a0</span> : B =&gt; Vector.cons B a0 n))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t (G A) n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>map (map f) (dist VEC n G v) = dist VEC n G (map (map f) v)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (compose (map f)
   ‚àò Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; Vector.cons A a n)) &lt;‚ãÜ&gt;
dist VEC n G v &lt;‚ãÜ&gt; h =
(map (compose (precompose f))
 ‚àò map (precompose (map f)))
  (pure
     (Basics.flip (<span class="kr">fun</span> <span class="nv">a0</span> : B =&gt; Vector.cons B a0 n))) &lt;‚ãÜ&gt;
dist VEC n G v &lt;‚ãÜ&gt; h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk3a"><span class="nb">rewrite</span> (fun_map_map (F := G)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t (G A) n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>map (map f) (dist VEC n G v) = dist VEC n G (map (map f) v)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (compose (map f)
   ‚àò Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; Vector.cons A a n)) &lt;‚ãÜ&gt;
dist VEC n G v &lt;‚ãÜ&gt; h =
map (compose (precompose f) ‚àò precompose (map f))
  (pure
     (Basics.flip (<span class="kr">fun</span> <span class="nv">a0</span> : B =&gt; Vector.cons B a0 n))) &lt;‚ãÜ&gt;
dist VEC n G v &lt;‚ãÜ&gt; h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk3b"><span class="nb">rewrite</span> (app_pure_natural).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t (G A) n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>map (map f) (dist VEC n G v) = dist VEC n G (map (map f) v)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (compose (map f)
   ‚àò Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; Vector.cons A a n)) &lt;‚ãÜ&gt;
dist VEC n G v &lt;‚ãÜ&gt; h =
pure
  ((compose (precompose f) ‚àò precompose (map f))
     (Basics.flip (<span class="kr">fun</span> <span class="nv">a0</span> : B =&gt; Vector.cons B a0 n))) &lt;‚ãÜ&gt;
dist VEC n G v &lt;‚ãÜ&gt; h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk3c"><span class="kn">Lemma</span> <span class="nf">dist_morph_Vector</span> (<span class="nv">n</span> : nat) :
  <span class="kr">forall</span> (<span class="nv">G1</span> <span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H1</span> : Map G1) (<span class="nv">H3</span> : Mult G1) (<span class="nv">H2</span> : Pure G1) (<span class="nv">H4</span> : Map G2)
    (<span class="nv">H6</span> : Mult G2) (<span class="nv">H5</span> : Pure G2) (<span class="nv">œï</span> : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A),
    ApplicativeMorphism G1 G2 œï -&gt; <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
      dist (VEC n) G2 ‚àò map (F := VEC n) (œï A) = œï (VEC n A) ‚àò dist (VEC n) G1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G1</span> <span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H1</span> : Map G1)
  (<span class="nv">H3</span> : Mult G1) (<span class="nv">H2</span> : Pure G1) (<span class="nv">H4</span> : Map G2)
  (<span class="nv">H6</span> : Mult G2) (<span class="nv">H5</span> : Pure G2)
  (<span class="nv">œï</span> : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A),
ApplicativeMorphism G1 G2 œï -&gt;
<span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
dist VEC n G2 ‚àò map (œï A) =
œï (VEC n A) ‚àò dist VEC n G1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk3d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G1</span> <span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H1</span> : Map G1)
  (<span class="nv">H3</span> : Mult G1) (<span class="nv">H2</span> : Pure G1) (<span class="nv">H4</span> : Map G2)
  (<span class="nv">H6</span> : Mult G2) (<span class="nv">H5</span> : Pure G2)
  (<span class="nv">œï</span> : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A),
ApplicativeMorphism G1 G2 œï -&gt;
<span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
dist VEC n G2 ‚àò map (œï A) =
œï (VEC n A) ‚àò dist VEC n G1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk3e"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist VEC n G2 ‚àò map (œï A) =
œï (VEC n A) ‚àò dist VEC n G1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk3f"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">1</span> <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist VEC n G2 ‚óã map (œï A) =
œï (Vector.t A n) ‚óã dist VEC n G1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk40">ext v.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t (G1 A) n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist VEC n G2 (map (œï A) v) =
œï (Vector.t A n) (dist VEC n G1 v)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk41"><span class="nb">induction</span> v.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist VEC <span class="mi">0</span> G2 (map (œï A) (Vector.nil (G1 A))) =
œï (Vector.t A <span class="mi">0</span>) (dist VEC <span class="mi">0</span> G1 (Vector.nil (G1 A)))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="vector-v-chk42" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>G1 A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t (G1 A) n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>dist VEC n G2 (map (œï A) v) = œï (Vector.t A n) (dist VEC n G1 v)</span></span></span><br></div><label class="goal-separator" for="vector-v-chk42"><hr></label><div class="goal-conclusion">dist VEC (S n) G2
  (map (œï A) (Vector.cons (G1 A) h n v)) =
œï (Vector.t A (S n))
  (dist VEC (S n) G1 (Vector.cons (G1 A) h n v))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk43">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist VEC <span class="mi">0</span> G2 (map (œï A) (Vector.nil (G1 A))) =
œï (Vector.t A <span class="mi">0</span>) (dist VEC <span class="mi">0</span> G1 (Vector.nil (G1 A)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk44"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (Vector.nil A) =
œï (Vector.t A <span class="mi">0</span>) (pure (Vector.nil A))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk45"><span class="nb">rewrite</span> (appmor_pure (F := G1) (G := G2)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (Vector.nil A) = pure (Vector.nil A)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk46">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>G1 A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t (G1 A) n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>dist VEC n G2 (map (œï A) v) = œï (Vector.t A n) (dist VEC n G1 v)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist VEC (S n) G2
  (map (œï A) (Vector.cons (G1 A) h n v)) =
œï (Vector.t A (S n))
  (dist VEC (S n) G1 (Vector.cons (G1 A) h n v))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk47"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>G1 A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t (G1 A) n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>dist VEC n G2 (map (œï A) v) = œï (Vector.t A n) (dist VEC n G1 v)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; Vector.cons A a n)) &lt;‚ãÜ&gt;
dist_Vector n G2 (map_Vector n (œï A) v) &lt;‚ãÜ&gt; œï A h =
œï (Vector.t A (S n))
  (pure (Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; Vector.cons A a n)) &lt;‚ãÜ&gt;
   dist_Vector n G1 v &lt;‚ãÜ&gt; h)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk48">cleanup_Vector.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>G1 A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t (G1 A) n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>dist VEC n G2 (map (œï A) v) = œï (Vector.t A n) (dist VEC n G1 v)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; Vector.cons A a n)) &lt;‚ãÜ&gt;
dist VEC n G2 (map (œï A) v) &lt;‚ãÜ&gt; œï A h =
œï (Vector.t A (S n))
  (pure (Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; Vector.cons A a n)) &lt;‚ãÜ&gt;
   dist VEC n G1 v &lt;‚ãÜ&gt; h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* LHS *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk49"><span class="nb">rewrite</span> IHv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>G1 A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t (G1 A) n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>dist VEC n G2 (map (œï A) v) = œï (Vector.t A n) (dist VEC n G1 v)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; Vector.cons A a n)) &lt;‚ãÜ&gt;
œï (Vector.t A n) (dist VEC n G1 v) &lt;‚ãÜ&gt; œï A h =
œï (Vector.t A (S n))
  (pure (Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; Vector.cons A a n)) &lt;‚ãÜ&gt;
   dist VEC n G1 v &lt;‚ãÜ&gt; h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk4a"><span class="nb">inversion</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>G1 A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t (G1 A) n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>dist VEC n G2 (map (œï A) v) = œï (Vector.t A n) (dist VEC n G1 v)</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (map f x) = map f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (pure a) = pure a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; Vector.cons A a n)) &lt;‚ãÜ&gt;
œï (Vector.t A n) (dist VEC n G1 v) &lt;‚ãÜ&gt; œï A h =
œï (Vector.t A (S n))
  (pure (Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; Vector.cons A a n)) &lt;‚ãÜ&gt;
   dist VEC n G1 v &lt;‚ãÜ&gt; h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* RHS *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk4b"><span class="nb">rewrite</span> (ap_morphism_1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>G1 A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t (G1 A) n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>dist VEC n G2 (map (œï A) v) =
œï (Vector.t A n) (dist VEC n G1 v)</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (map f x) = map f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (pure a) = pure a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; Vector.cons A a n)) &lt;‚ãÜ&gt;
œï (Vector.t A n) (dist VEC n G1 v) &lt;‚ãÜ&gt; 
œï A h =
œï (A -&gt; Vector.t A (S n))
  (pure (Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; Vector.cons A a n)) &lt;‚ãÜ&gt;
   dist VEC n G1 v) &lt;‚ãÜ&gt; 
œï A h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk4c"><span class="nb">rewrite</span> (ap_morphism_1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>G1 A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t (G1 A) n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>dist VEC n G2 (map (œï A) v) =
œï (Vector.t A n) (dist VEC n G1 v)</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (map f x) = map f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (pure a) = pure a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; Vector.cons A a n)) &lt;‚ãÜ&gt;
œï (Vector.t A n) (dist VEC n G1 v) &lt;‚ãÜ&gt; 
œï A h =
œï (Vector.t A n -&gt; A -&gt; Vector.t A (S n))
  (pure (Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; Vector.cons A a n))) &lt;‚ãÜ&gt;
œï (Vector.t A n) (dist VEC n G1 v) &lt;‚ãÜ&gt; 
œï A h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk4d"><span class="nb">rewrite</span> (appmor_pure).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>G1 A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t (G1 A) n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>dist VEC n G2 (map (œï A) v) =
œï (Vector.t A n) (dist VEC n G1 v)</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (map f x) = map f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (pure a) = pure a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; Vector.cons A a n)) &lt;‚ãÜ&gt;
œï (Vector.t A n) (dist VEC n G1 v) &lt;‚ãÜ&gt; 
œï A h =
pure (Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; Vector.cons A a n)) &lt;‚ãÜ&gt;
œï (Vector.t A n) (dist VEC n G1 v) &lt;‚ãÜ&gt; 
œï A h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk4e"><span class="kn">Lemma</span> <span class="nf">dist_unit_Vector</span> (<span class="nv">n</span> : nat) : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, dist (A := A) (VEC n) (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) = id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, dist VEC n (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0) = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk4f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, dist VEC n (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0) = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk50"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist VEC n (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk51">ext v.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t A n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist VEC n (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) v = id v</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk52"><span class="nb">induction</span> v.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist VEC <span class="mi">0</span> (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (Vector.nil A) =
id (Vector.nil A)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="vector-v-chk53" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t A n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>dist VEC n (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) v = id v</span></span></span><br></div><label class="goal-separator" for="vector-v-chk53"><hr></label><div class="goal-conclusion">dist VEC (S n) (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (Vector.cons A h n v) = id (Vector.cons A h n v)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk54">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist VEC <span class="mi">0</span> (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (Vector.nil A) =
id (Vector.nil A)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk55"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (Vector.nil A) = id (Vector.nil A)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk56">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t A n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>dist VEC n (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) v = id v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist VEC (S n) (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (Vector.cons A h n v) = id (Vector.cons A h n v)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk57"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t A n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>dist VEC n (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) v = id v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; Vector.cons A a n))
  (dist_Vector n (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) v) h =
id (Vector.cons A h n v)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk58">cleanup_Vector.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t A n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>dist VEC n (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) v = id v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; Vector.cons A a n))
  (dist VEC n (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) v) h =
id (Vector.cons A h n v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* LHS *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk59"><span class="nb">rewrite</span> IHv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t A n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>dist VEC n (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) v = id v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; Vector.cons A a n))
  (id v) h = id (Vector.cons A h n v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk5a"><span class="kn">Lemma</span> <span class="nf">dist_linear_Vector</span> (<span class="nv">n</span> : nat) :
  <span class="kr">forall</span> (<span class="nv">G1</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H1</span> : Map G1) (<span class="nv">H2</span> : Pure G1) (<span class="nv">H3</span> : Mult G1),
    Applicative G1 -&gt;
    <span class="kr">forall</span> (<span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H5</span> : Map G2) (<span class="nv">H6</span> : Pure G2) (<span class="nv">H7</span> : Mult G2),
      Applicative G2 -&gt;
      <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, dist (A := A) (VEC n) (G1 ‚àò G2) = map (F := G1) (dist (VEC n) G2) ‚àò dist (VEC n) G1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G1</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H1</span> : Map G1)
  (<span class="nv">H2</span> : Pure G1) (<span class="nv">H3</span> : Mult G1),
Applicative G1 -&gt;
<span class="kr">forall</span> (<span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H5</span> : Map G2)
  (<span class="nv">H6</span> : Pure G2) (<span class="nv">H7</span> : Mult G2),
Applicative G2 -&gt;
<span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
dist VEC n (G1 ‚àò G2) =
map (dist VEC n G2) ‚àò dist VEC n G1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk5b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G1</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H1</span> : Map G1)
  (<span class="nv">H2</span> : Pure G1) (<span class="nv">H3</span> : Mult G1),
Applicative G1 -&gt;
<span class="kr">forall</span> (<span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H5</span> : Map G2)
  (<span class="nv">H6</span> : Pure G2) (<span class="nv">H7</span> : Mult G2),
Applicative G2 -&gt;
<span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
dist VEC n (G1 ‚àò G2) =
map (dist VEC n G2) ‚àò dist VEC n G1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk5c"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist VEC n (G1 ‚àò G2) =
map (dist VEC n G2) ‚àò dist VEC n G1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk5d"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">4</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist VEC n (G1 ‚àò G2) =
map (dist VEC n G2) ‚óã dist VEC n G1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk5e">ext v.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t ((G1 ‚àò G2) A) n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist VEC n (G1 ‚àò G2) v =
map (dist VEC n G2) (dist VEC n G1 v)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk5f"><span class="nb">induction</span> v.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist VEC <span class="mi">0</span> (G1 ‚àò G2) (Vector.nil ((G1 ‚àò G2) A)) =
map (dist VEC <span class="mi">0</span> G2)
  (dist VEC <span class="mi">0</span> G1 (Vector.nil ((G1 ‚àò G2) A)))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="vector-v-chk60" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>(G1 ‚àò G2) A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t ((G1 ‚àò G2) A) n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>dist VEC n (G1 ‚àò G2) v = map (dist VEC n G2) (dist VEC n G1 v)</span></span></span><br></div><label class="goal-separator" for="vector-v-chk60"><hr></label><div class="goal-conclusion">dist VEC (S n) (G1 ‚àò G2)
  (Vector.cons ((G1 ‚àò G2) A) h n v) =
map (dist VEC (S n) G2)
  (dist VEC (S n) G1 (Vector.cons ((G1 ‚àò G2) A) h n v))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk61">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist VEC <span class="mi">0</span> (G1 ‚àò G2) (Vector.nil ((G1 ‚àò G2) A)) =
map (dist VEC <span class="mi">0</span> G2)
  (dist VEC <span class="mi">0</span> G1 (Vector.nil ((G1 ‚àò G2) A)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk62"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (Vector.nil A) =
map (dist VEC <span class="mi">0</span> G2) (pure (Vector.nil (G2 A)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk63">unfold_ops @Pure_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (pure (Vector.nil A)) =
map (dist VEC <span class="mi">0</span> G2) (pure (Vector.nil (G2 A)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk64"><span class="nb">rewrite</span> (app_pure_natural (G := G1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (pure (Vector.nil A)) =
pure (dist VEC <span class="mi">0</span> G2 (Vector.nil (G2 A)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk65">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>(G1 ‚àò G2) A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t ((G1 ‚àò G2) A) n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>dist VEC n (G1 ‚àò G2) v = map (dist VEC n G2) (dist VEC n G1 v)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist VEC (S n) (G1 ‚àò G2)
  (Vector.cons ((G1 ‚àò G2) A) h n v) =
map (dist VEC (S n) G2)
  (dist VEC (S n) G1 (Vector.cons ((G1 ‚àò G2) A) h n v))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk66"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>(G1 ‚àò G2) A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t ((G1 ‚àò G2) A) n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>dist VEC n (G1 ‚àò G2) v = map (dist VEC n G2) (dist VEC n G1 v)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; Vector.cons A a n)) &lt;‚ãÜ&gt;
dist_Vector n (G1 ‚àò G2) v &lt;‚ãÜ&gt; h =
map (dist VEC (S n) G2)
  (pure
     (Basics.flip
        (<span class="kr">fun</span> <span class="nv">a</span> : G2 A =&gt; Vector.cons (G2 A) a n)) &lt;‚ãÜ&gt;
   dist_Vector n G1 v &lt;‚ãÜ&gt; h)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk67">cleanup_Vector.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>(G1 ‚àò G2) A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t ((G1 ‚àò G2) A) n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>dist VEC n (G1 ‚àò G2) v = map (dist VEC n G2) (dist VEC n G1 v)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; Vector.cons A a n)) &lt;‚ãÜ&gt;
dist VEC n (G1 ‚àò G2) v &lt;‚ãÜ&gt; h =
map (dist VEC (S n) G2)
  (pure
     (Basics.flip
        (<span class="kr">fun</span> <span class="nv">a</span> : G2 A =&gt; Vector.cons (G2 A) a n)) &lt;‚ãÜ&gt;
   dist VEC n G1 v &lt;‚ãÜ&gt; h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* LHS *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk68"><span class="nb">rewrite</span> IHv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>(G1 ‚àò G2) A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t ((G1 ‚àò G2) A) n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>dist VEC n (G1 ‚àò G2) v = map (dist VEC n G2) (dist VEC n G1 v)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; Vector.cons A a n)) &lt;‚ãÜ&gt;
map (dist VEC n G2) (dist VEC n G1 v) &lt;‚ãÜ&gt; h =
map (dist VEC (S n) G2)
  (pure
     (Basics.flip
        (<span class="kr">fun</span> <span class="nv">a</span> : G2 A =&gt; Vector.cons (G2 A) a n)) &lt;‚ãÜ&gt;
   dist VEC n G1 v &lt;‚ãÜ&gt; h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk69">unfold_ops @Pure_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>(G1 ‚àò G2) A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t ((G1 ‚àò G2) A) n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>dist VEC n (G1 ‚àò G2) v = map (dist VEC n G2) (dist VEC n G1 v)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (pure (Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; Vector.cons A a n))) &lt;‚ãÜ&gt;
map (dist VEC n G2) (dist VEC n G1 v) &lt;‚ãÜ&gt; h =
map (dist VEC (S n) G2)
  (pure
     (Basics.flip
        (<span class="kr">fun</span> <span class="nv">a</span> : G2 A =&gt; Vector.cons (G2 A) a n)) &lt;‚ãÜ&gt;
   dist VEC n G1 v &lt;‚ãÜ&gt; h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk6a"><span class="nb">rewrite</span> (ap_compose2 G2 G1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>(G1 ‚àò G2) A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t ((G1 ‚àò G2) A) n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>dist VEC n (G1 ‚àò G2) v = map (dist VEC n G2) (dist VEC n G1 v)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (ap G2)
  (pure
     (pure
        (Basics.flip (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; Vector.cons A a n))) &lt;‚ãÜ&gt;
   map (dist VEC n G2) (dist VEC n G1 v)) &lt;‚ãÜ&gt; h =
map (dist VEC (S n) G2)
  (pure
     (Basics.flip
        (<span class="kr">fun</span> <span class="nv">a</span> : G2 A =&gt; Vector.cons (G2 A) a n)) &lt;‚ãÜ&gt;
   dist VEC n G1 v &lt;‚ãÜ&gt; h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk6b"><span class="nb">rewrite</span> (ap_compose2 G2 G1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>(G1 ‚àò G2) A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t ((G1 ‚àò G2) A) n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>dist VEC n (G1 ‚àò G2) v = map (dist VEC n G2) (dist VEC n G1 v)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (ap G2)
  (map (ap G2)
     (pure
        (pure
           (Basics.flip
              (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; Vector.cons A a n)))) &lt;‚ãÜ&gt;
   map (dist VEC n G2) (dist VEC n G1 v)) &lt;‚ãÜ&gt; h =
map (dist VEC (S n) G2)
  (pure
     (Basics.flip
        (<span class="kr">fun</span> <span class="nv">a</span> : G2 A =&gt; Vector.cons (G2 A) a n)) &lt;‚ãÜ&gt;
   dist VEC n G1 v &lt;‚ãÜ&gt; h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk6c"><span class="nb">rewrite</span> &lt;- (ap_map (G := G1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>(G1 ‚àò G2) A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t ((G1 ‚àò G2) A) n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>dist VEC n (G1 ‚àò G2) v = map (dist VEC n G2) (dist VEC n G1 v)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (ap G2)
  (map (precompose (dist VEC n G2))
     (map (ap G2)
        (pure
           (pure
              (Basics.flip
                 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; Vector.cons A a n))))) &lt;‚ãÜ&gt;
   dist VEC n G1 v) &lt;‚ãÜ&gt; h =
map (dist VEC (S n) G2)
  (pure
     (Basics.flip
        (<span class="kr">fun</span> <span class="nv">a</span> : G2 A =&gt; Vector.cons (G2 A) a n)) &lt;‚ãÜ&gt;
   dist VEC n G1 v &lt;‚ãÜ&gt; h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk6d"><span class="nb">rewrite</span> (map_ap (G := G1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>(G1 ‚àò G2) A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t ((G1 ‚àò G2) A) n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>dist VEC n (G1 ‚àò G2) v = map (dist VEC n G2) (dist VEC n G1 v)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (ap G2))
  (map (precompose (dist VEC n G2))
     (map (ap G2)
        (pure
           (pure
              (Basics.flip
                 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; Vector.cons A a n)))))) &lt;‚ãÜ&gt;
dist VEC n G1 v &lt;‚ãÜ&gt; h =
map (dist VEC (S n) G2)
  (pure
     (Basics.flip
        (<span class="kr">fun</span> <span class="nv">a</span> : G2 A =&gt; Vector.cons (G2 A) a n)) &lt;‚ãÜ&gt;
   dist VEC n G1 v &lt;‚ãÜ&gt; h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk6e"><span class="nb">rewrite</span> (map_ap (G := G1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>(G1 ‚àò G2) A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t ((G1 ‚àò G2) A) n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>dist VEC n (G1 ‚àò G2) v = map (dist VEC n G2) (dist VEC n G1 v)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (ap G2))
  (map (precompose (dist VEC n G2))
     (map (ap G2)
        (pure
           (pure
              (Basics.flip
                 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; Vector.cons A a n)))))) &lt;‚ãÜ&gt;
dist VEC n G1 v &lt;‚ãÜ&gt; h =
map (compose (dist VEC (S n) G2))
  (pure
     (Basics.flip
        (<span class="kr">fun</span> <span class="nv">a</span> : G2 A =&gt; Vector.cons (G2 A) a n)) &lt;‚ãÜ&gt;
   dist VEC n G1 v) &lt;‚ãÜ&gt; h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk6f">compose near (pure (F := G1) (pure (F := G2)
                                       (Basics.flip (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt; Vector.cons A a0 n)))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>(G1 ‚àò G2) A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t ((G1 ‚àò G2) A) n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>dist VEC n (G1 ‚àò G2) v = map (dist VEC n G2) (dist VEC n G1 v)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (ap G2))
  ((map (precompose (dist VEC n G2)) ‚àò map (ap G2))
     (pure
        (pure
           (Basics.flip
              (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt; Vector.cons A a0 n))))) &lt;‚ãÜ&gt;
dist VEC n G1 v &lt;‚ãÜ&gt; h =
map (compose (dist VEC (S n) G2))
  (pure
     (Basics.flip
        (<span class="kr">fun</span> <span class="nv">a</span> : G2 A =&gt; Vector.cons (G2 A) a n)) &lt;‚ãÜ&gt;
   dist VEC n G1 v) &lt;‚ãÜ&gt; h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk70"><span class="nb">rewrite</span> (fun_map_map (F := G1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>(G1 ‚àò G2) A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t ((G1 ‚àò G2) A) n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>dist VEC n (G1 ‚àò G2) v = map (dist VEC n G2) (dist VEC n G1 v)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (ap G2))
  (map (precompose (dist VEC n G2) ‚àò ap G2)
     (pure
        (pure
           (Basics.flip
              (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt; Vector.cons A a0 n))))) &lt;‚ãÜ&gt;
dist VEC n G1 v &lt;‚ãÜ&gt; h =
map (compose (dist VEC (S n) G2))
  (pure
     (Basics.flip
        (<span class="kr">fun</span> <span class="nv">a</span> : G2 A =&gt; Vector.cons (G2 A) a n)) &lt;‚ãÜ&gt;
   dist VEC n G1 v) &lt;‚ãÜ&gt; h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk71">compose near (pure (F := G1) (pure (F := G2)
                                       (Basics.flip (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt; Vector.cons A a0 n)))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>(G1 ‚àò G2) A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t ((G1 ‚àò G2) A) n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>dist VEC n (G1 ‚àò G2) v = map (dist VEC n G2) (dist VEC n G1 v)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (compose (ap G2))
 ‚àò map (precompose (dist VEC n G2) ‚àò ap G2))
  (pure
     (pure
        (Basics.flip
           (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt; Vector.cons A a0 n)))) &lt;‚ãÜ&gt;
dist VEC n G1 v &lt;‚ãÜ&gt; h =
map (compose (dist VEC (S n) G2))
  (pure
     (Basics.flip
        (<span class="kr">fun</span> <span class="nv">a</span> : G2 A =&gt; Vector.cons (G2 A) a n)) &lt;‚ãÜ&gt;
   dist VEC n G1 v) &lt;‚ãÜ&gt; h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk72"><span class="nb">rewrite</span> (fun_map_map (F := G1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>(G1 ‚àò G2) A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t ((G1 ‚àò G2) A) n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>dist VEC n (G1 ‚àò G2) v = map (dist VEC n G2) (dist VEC n G1 v)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (compose (ap G2)
   ‚àò (precompose (dist VEC n G2) ‚àò ap G2))
  (pure
     (pure
        (Basics.flip
           (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt; Vector.cons A a0 n)))) &lt;‚ãÜ&gt;
dist VEC n G1 v &lt;‚ãÜ&gt; h =
map (compose (dist VEC (S n) G2))
  (pure
     (Basics.flip
        (<span class="kr">fun</span> <span class="nv">a</span> : G2 A =&gt; Vector.cons (G2 A) a n)) &lt;‚ãÜ&gt;
   dist VEC n G1 v) &lt;‚ãÜ&gt; h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk73"><span class="nb">rewrite</span> (app_pure_natural (G := G1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>(G1 ‚àò G2) A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t ((G1 ‚àò G2) A) n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>dist VEC n (G1 ‚àò G2) v = map (dist VEC n G2) (dist VEC n G1 v)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  ((compose (ap G2)
    ‚àò (precompose (dist VEC n G2) ‚àò ap G2))
     (pure
        (Basics.flip
           (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt; Vector.cons A a0 n)))) &lt;‚ãÜ&gt;
dist VEC n G1 v &lt;‚ãÜ&gt; h =
map (compose (dist VEC (S n) G2))
  (pure
     (Basics.flip
        (<span class="kr">fun</span> <span class="nv">a</span> : G2 A =&gt; Vector.cons (G2 A) a n)) &lt;‚ãÜ&gt;
   dist VEC n G1 v) &lt;‚ãÜ&gt; h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* RHS *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk74"><span class="nb">rewrite</span> (map_ap (G := G1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>(G1 ‚àò G2) A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t ((G1 ‚àò G2) A) n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>dist VEC n (G1 ‚àò G2) v = map (dist VEC n G2) (dist VEC n G1 v)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  ((compose (ap G2)
    ‚àò (precompose (dist VEC n G2) ‚àò ap G2))
     (pure
        (Basics.flip
           (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt; Vector.cons A a0 n)))) &lt;‚ãÜ&gt;
dist VEC n G1 v &lt;‚ãÜ&gt; h =
map (compose (compose (dist VEC (S n) G2)))
  (pure
     (Basics.flip
        (<span class="kr">fun</span> <span class="nv">a</span> : G2 A =&gt; Vector.cons (G2 A) a n))) &lt;‚ãÜ&gt;
dist VEC n G1 v &lt;‚ãÜ&gt; h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="vector-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="vector-v-chk75"><span class="nb">rewrite</span> (app_pure_natural (G := G1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>(G1 ‚àò G2) A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector.t ((G1 ‚àò G2) A) n</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>dist VEC n (G1 ‚àò G2) v = map (dist VEC n G2) (dist VEC n G1 v)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  ((compose (ap G2)
    ‚àò (precompose (dist VEC n G2) ‚àò ap G2))
     (pure
        (Basics.flip
           (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt; Vector.cons A a0 n)))) &lt;‚ãÜ&gt;
dist VEC n G1 v &lt;‚ãÜ&gt; h =
pure
  (compose (dist VEC (S n) G2)
   ‚àò Basics.flip
       (<span class="kr">fun</span> <span class="nv">a</span> : G2 A =&gt; Vector.cons (G2 A) a n)) &lt;‚ãÜ&gt;
dist VEC n G1 v &lt;‚ãÜ&gt; h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">TraversableFunctor_Vector</span> (<span class="nv">n</span> : nat):
  Categorical.TraversableFunctor.TraversableFunctor (VEC n) :=
  {| dist_natural := dist_natural_Vector n;
    dist_morph := dist_morph_Vector n;
    dist_unit := dist_unit_Vector n;
    dist_linear := dist_linear_Vector n;
  |}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(*</span>
<span class="c">#[export] Instance Traverse_Vector (n : nat): Traverse (VEC n) :=</span>
<span class="c">  Adapters.CategoricalToKleisli.TraversableFunctor.ToKleisli.Traverse_dist (VEC n).</span>

<span class="c">#[export] Instance KleisliTraversableFunctor_Vector (n : nat):</span>
<span class="c">  Kleisli.TraversableFunctor.TraversableFunctor (VEC n) :=</span>
<span class="c">  Adapters.CategoricalToKleisli.TraversableFunctor.ToKleisli.TraversableFunctor_instance_0.</span>
<span class="c">*)</span></span></pre>
</div>
</div></body>
</html>
