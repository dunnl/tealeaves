<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<title>List_Telescoping.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.16.0+0.16.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Tealeaves <span class="kn">Require Import</span>
  Classes.Kleisli.DecoratedTraversableFunctor
  Classes.Kleisli.Theory.DecoratedTraversableFunctor
  Functors.List
  Misc.NaturalNumbers
  Theory.DecoratedTraversableFunctor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Applicative.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Monoid.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> DecoratedTraversableFunctor.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Kleisli.TraversableFunctor.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk0"><span class="kn">Lemma</span> <span class="nf">toctxset_nil</span>: <span class="kr">forall</span> (<span class="nv">E</span> <span class="nv">A</span>: <span class="kt">Type</span>),
    toctxset (F := env E) (@nil (E * A)) = subset_empty.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">E</span> <span class="nv">A</span> : <span class="kt">Type</span>, toctxset nil = subset_empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">E</span> <span class="nv">A</span> : <span class="kt">Type</span>, toctxset nil = subset_empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Subset.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk2"><span class="kn">Lemma</span> <span class="nf">toctxset_cons</span>: <span class="kr">forall</span> (<span class="nv">E</span> <span class="nv">A</span>: <span class="kt">Type</span>) (<span class="nv">e</span>: E) (<span class="nv">a</span>: A) (<span class="nv">l</span>: env E A),
    toctxset (F := env E) ((e, a) :: l) =
      {{(e, a)}} ‚à™ (toctxset l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">E</span> <span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">e</span> : E) (<span class="nv">a</span> : A) (<span class="nv">l</span> : env E A),
toctxset ((e, a) :: l) = {{(e, a)}} ‚à™ toctxset l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">E</span> <span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">e</span> : E) (<span class="nv">a</span> : A) (<span class="nv">l</span> : env E A),
toctxset ((e, a) :: l) = {{(e, a)}} ‚à™ toctxset l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">decorate_telescoping_list_rec</span> (<span class="nv">n</span>: nat) {<span class="nv">A</span>: <span class="kt">Type</span>} (<span class="nv">l</span>: list A):
  list (nat * A) :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | nil =&gt; nil
  | x :: xs =&gt;
      (n, x) :: decorate_telescoping_list_rec (S n) xs
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">decorate_telescoping_list</span> {<span class="nv">A</span>: <span class="kt">Type</span>} (<span class="nv">l</span>: list A):
  list (nat * A) := decorate_telescoping_list_rec <span class="mi">0</span> l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">decorate_telescoping_list_alt</span> {<span class="nv">A</span>: <span class="kt">Type</span>} (<span class="nv">l</span>: list A):
  list (nat * A) :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | nil =&gt; nil
  | x :: xs =&gt;
      (<span class="mi">0</span>, x) :: map (F := list) (incr <span class="mi">1</span>) (decorate_telescoping_list_alt xs)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk4"><span class="kn">Lemma</span> <span class="nf">decorate_telescoping_list_equiv</span>: <span class="kr">forall</span> (<span class="nv">A</span>: <span class="kt">Type</span>) (<span class="nv">l</span>: list A),
    decorate_telescoping_list l = decorate_telescoping_list_alt l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list A),
decorate_telescoping_list l =
decorate_telescoping_list_alt l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list A),
decorate_telescoping_list l =
decorate_telescoping_list_alt l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk6"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">decorate_telescoping_list l =
decorate_telescoping_list_alt l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk7"><span class="nb">unfold</span> decorate_telescoping_list.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">decorate_telescoping_list_rec <span class="mi">0</span> l =
decorate_telescoping_list_alt l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk8"><span class="nb">assert</span>
    (<span class="kr">forall</span> <span class="nv">n</span>, decorate_telescoping_list_rec n l =
            map (incr n) (decorate_telescoping_list_alt l)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat,
decorate_telescoping_list_rec n l =
map (incr n) (decorate_telescoping_list_alt l)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-v-chk9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
decorate_telescoping_list_rec n l =
map (incr n) (decorate_telescoping_list_alt l)</span></span></span><br></div><label class="goal-separator" for="list-telescoping-v-chk9"><hr></label><div class="goal-conclusion">decorate_telescoping_list_rec <span class="mi">0</span> l =
decorate_telescoping_list_alt l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chka">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat,
decorate_telescoping_list_rec n l =
map (incr n) (decorate_telescoping_list_alt l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkb"><span class="nb">induction</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat,
decorate_telescoping_list_rec n nil =
map (incr n) (decorate_telescoping_list_alt nil)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-v-chkc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
decorate_telescoping_list_rec n l =
map (incr n) (decorate_telescoping_list_alt l)</span></span></span><br></div><label class="goal-separator" for="list-telescoping-v-chkc"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat,
decorate_telescoping_list_rec n (a :: l) =
map (incr n) (decorate_telescoping_list_alt (a :: l))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkd">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat,
decorate_telescoping_list_rec n nil =
map (incr n) (decorate_telescoping_list_alt nil)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chke">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
decorate_telescoping_list_rec n l =
map (incr n) (decorate_telescoping_list_alt l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat,
decorate_telescoping_list_rec n (a :: l) =
map (incr n) (decorate_telescoping_list_alt (a :: l))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkf"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
decorate_telescoping_list_rec n l =
map (incr n) (decorate_telescoping_list_alt l)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">decorate_telescoping_list_rec n (a :: l) =
map (incr n) (decorate_telescoping_list_alt (a :: l))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk10"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
decorate_telescoping_list_rec n l =
map (incr n) (decorate_telescoping_list_alt l)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(n, a) :: decorate_telescoping_list_rec (S n) l =
(n ‚óè <span class="mi">0</span>, a)
:: map (incr n)
     (map (incr <span class="mi">1</span>) (decorate_telescoping_list_alt l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk11"><span class="nb">rewrite</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
decorate_telescoping_list_rec n l =
map (incr n) (decorate_telescoping_list_alt l)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(n, a)
:: map (incr (S n)) (decorate_telescoping_list_alt l) =
(n ‚óè <span class="mi">0</span>, a)
:: map (incr n)
     (map (incr <span class="mi">1</span>) (decorate_telescoping_list_alt l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk12"><span class="nb">change</span> <span class="mi">0</span> <span class="kr">with</span> (∆µ: nat) <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
decorate_telescoping_list_rec n l =
map (incr n) (decorate_telescoping_list_alt l)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(n, a)
:: map (incr (S n)) (decorate_telescoping_list_alt l) =
(n ‚óè (∆µ : nat), a)
:: map (incr n)
     (map (incr <span class="mi">1</span>) (decorate_telescoping_list_alt l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk13"><span class="nb">rewrite</span> monoid_id_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
decorate_telescoping_list_rec n l =
map (incr n) (decorate_telescoping_list_alt l)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(n, a)
:: map (incr (S n)) (decorate_telescoping_list_alt l) =
(n, a)
:: map (incr n)
     (map (incr <span class="mi">1</span>) (decorate_telescoping_list_alt l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk14">compose near (decorate_telescoping_list_alt l) on <span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
decorate_telescoping_list_rec n l =
map (incr n) (decorate_telescoping_list_alt l)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(n, a)
:: map (incr (S n)) (decorate_telescoping_list_alt l) =
(n, a)
:: (map (incr n) ‚àò map (incr <span class="mi">1</span>))
     (decorate_telescoping_list_alt l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk15"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
decorate_telescoping_list_rec n l =
map (incr n) (decorate_telescoping_list_alt l)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(n, a)
:: map (incr (S n)) (decorate_telescoping_list_alt l) =
(n, a)
:: map (incr n ‚àò incr <span class="mi">1</span>)
     (decorate_telescoping_list_alt l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk16"><span class="nb">rewrite</span> incr_incr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
decorate_telescoping_list_rec n l =
map (incr n) (decorate_telescoping_list_alt l)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(n, a)
:: map (incr (S n)) (decorate_telescoping_list_alt l) =
(n, a)
:: map (incr (n ‚óè <span class="mi">1</span>))
     (decorate_telescoping_list_alt l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk17"><span class="nb">replace</span> (n ‚óè <span class="mi">1</span>) <span class="kr">with</span> (S n) <span class="bp">by</span> (unfold_ops @Monoid_op_plus; <span class="bp">lia</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
decorate_telescoping_list_rec n l =
map (incr n) (decorate_telescoping_list_alt l)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(n, a)
:: map (incr (S n)) (decorate_telescoping_list_alt l) =
(n, a)
:: map (incr (S n)) (decorate_telescoping_list_alt l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk18">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
decorate_telescoping_list_rec n l =
map (incr n) (decorate_telescoping_list_alt l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">decorate_telescoping_list_rec <span class="mi">0</span> l =
decorate_telescoping_list_alt l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk19"><span class="nb">specialize</span> (H <span class="mi">0</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>decorate_telescoping_list_rec <span class="mi">0</span> l =
map (incr <span class="mi">0</span>) (decorate_telescoping_list_alt l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">decorate_telescoping_list_rec <span class="mi">0</span> l =
decorate_telescoping_list_alt l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk1a"><span class="nb">replace</span> (incr <span class="mi">0</span>) <span class="kr">with</span> (@id (nat * A)) <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>decorate_telescoping_list_rec <span class="mi">0</span> l =
map id (decorate_telescoping_list_alt l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">decorate_telescoping_list_rec <span class="mi">0</span> l =
decorate_telescoping_list_alt l</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-v-chk1b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>decorate_telescoping_list_rec <span class="mi">0</span> l =
map (incr <span class="mi">0</span>) (decorate_telescoping_list_alt l)</span></span></span><br></div><label class="goal-separator" for="list-telescoping-v-chk1b"><hr></label><div class="goal-conclusion">id = incr <span class="mi">0</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk1c"><span class="nb">rewrite</span> (fun_map_id) <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>decorate_telescoping_list_rec <span class="mi">0</span> l =
id (decorate_telescoping_list_alt l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">decorate_telescoping_list_rec <span class="mi">0</span> l =
decorate_telescoping_list_alt l</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-v-chk1d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>decorate_telescoping_list_rec <span class="mi">0</span> l =
map (incr <span class="mi">0</span>) (decorate_telescoping_list_alt l)</span></span></span><br></div><label class="goal-separator" for="list-telescoping-v-chk1d"><hr></label><div class="goal-conclusion">id = incr <span class="mi">0</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk1e"><span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>decorate_telescoping_list_rec <span class="mi">0</span> l =
map (incr <span class="mi">0</span>) (decorate_telescoping_list_alt l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">id = incr <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk1f"><span class="nb">change</span> <span class="mi">0</span> <span class="kr">with</span> (∆µ: nat).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>decorate_telescoping_list_rec <span class="mi">0</span> l =
map (incr <span class="mi">0</span>) (decorate_telescoping_list_alt l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">id = incr (∆µ : nat)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> incr_zero.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">mapdt_list_telescope</span>
           {<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>} `{Map G} `{Pure G} `{Mult G}
           {A B : <span class="kt">Type</span>} (f : nat * A -&gt; G B) (l : list A)
  : G (list B) :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | nil =&gt; pure (@nil B)
  | x :: xs =&gt;
      pure (@List.cons B) &lt;‚ãÜ&gt; f (<span class="mi">0</span>, x) &lt;‚ãÜ&gt;
        mapdt_list_telescope (f ‚¶ø <span class="mi">1</span>) xs
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Mapdt_List_Telescope</span>: Mapdt nat list := @mapdt_list_telescope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Mapd_List_Telescope</span>: Mapd nat list := Mapd_Mapdt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span>: Compat_Mapd_Mapdt := <span class="kp">ltac</span>:(<span class="nb">typeclasses eauto</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk20">#[export] <span class="kn">Instance</span>: @Compat_Traverse_Mapdt nat list Traverse_list Mapdt_List_Telescope.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Compat_Traverse_Mapdt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk21"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Compat_Traverse_Mapdt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk22"><span class="nb">unfold</span> Compat_Traverse_Mapdt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">Map_inst</span> : Map G)
  (<span class="nv">Mult_inst</span> : Mult G) (<span class="nv">Pure_inst</span> : Pure G),
Applicative G -&gt;
@traverse list Traverse_list G Map_inst Pure_inst
  Mult_inst =
@traverse list Traverse_Mapdt G Map_inst Pure_inst
  Mult_inst</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk23"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_inst</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Mult_inst</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Pure_inst</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@traverse list Traverse_list G Map_inst Pure_inst
  Mult_inst =
@traverse list Traverse_Mapdt G Map_inst Pure_inst
  Mult_inst</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk24">ext A B f l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_inst</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Mult_inst</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Pure_inst</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f l = traverse f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk25"><span class="nb">induction</span> l <span class="kr">as</span> [|a rest IHrest].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_inst</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Mult_inst</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Pure_inst</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f nil = traverse f nil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-v-chk26" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_inst</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Mult_inst</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Pure_inst</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHrest</var><span class="hyp-type"><b>: </b><span>traverse f rest = traverse f rest</span></span></span><br></div><label class="goal-separator" for="list-telescoping-v-chk26"><hr></label><div class="goal-conclusion">traverse f (a :: rest) = traverse f (a :: rest)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk27">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_inst</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Mult_inst</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Pure_inst</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f nil = traverse f nil</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk28">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_inst</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Mult_inst</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Pure_inst</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHrest</var><span class="hyp-type"><b>: </b><span>traverse f rest = traverse f rest</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f (a :: rest) = traverse f (a :: rest)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk29"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_inst</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Mult_inst</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Pure_inst</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHrest</var><span class="hyp-type"><b>: </b><span>traverse f rest = traverse f rest</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; traverse f rest =
pure cons &lt;‚ãÜ&gt; (f ‚àò extract) (<span class="mi">0</span>, a) &lt;‚ãÜ&gt;
mapdt ((f ‚àò extract) ‚¶ø <span class="mi">1</span>) rest</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk2a">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_inst</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Mult_inst</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Pure_inst</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHrest</var><span class="hyp-type"><b>: </b><span>traverse f rest = traverse f rest</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f rest = mapdt ((f ‚àò extract) ‚¶ø <span class="mi">1</span>) rest</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk2b"><span class="nb">rewrite</span> IHrest.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_inst</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Mult_inst</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Pure_inst</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHrest</var><span class="hyp-type"><b>: </b><span>traverse f rest = traverse f rest</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f rest = mapdt ((f ‚àò extract) ‚¶ø <span class="mi">1</span>) rest</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk2c"><span class="nb">rewrite</span> extract_preincr2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_inst</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Mult_inst</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Pure_inst</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHrest</var><span class="hyp-type"><b>: </b><span>traverse f rest = traverse f rest</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f rest = mapdt (f ‚àò extract) rest</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk2d">#[export] <span class="kn">Instance</span>: @Compat_Map_Mapdt nat list Map_list Mapdt_List_Telescope.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Compat_Map_Mapdt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk2e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Compat_Map_Mapdt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk2f"><span class="nb">unfold</span> Compat_Map_Mapdt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">@map list Map_list = @map list Map_Mapdt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk30">ext A B f l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f l = map f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk31"><span class="nb">induction</span> l <span class="kr">as</span> [|a rest IHrest].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f nil = map f nil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-v-chk32" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHrest</var><span class="hyp-type"><b>: </b><span>map f rest = map f rest</span></span></span><br></div><label class="goal-separator" for="list-telescoping-v-chk32"><hr></label><div class="goal-conclusion">map f (a :: rest) = map f (a :: rest)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk33">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f nil = map f nil</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk34">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHrest</var><span class="hyp-type"><b>: </b><span>map f rest = map f rest</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f (a :: rest) = map f (a :: rest)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk35"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHrest</var><span class="hyp-type"><b>: </b><span>map f rest = map f rest</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a :: map f rest =
pure cons ((f ‚àò extract) (<span class="mi">0</span>, a))
  (mapdt ((f ‚àò extract) ‚¶ø <span class="mi">1</span>) rest)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk36">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHrest</var><span class="hyp-type"><b>: </b><span>map f rest = map f rest</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f rest = mapdt ((f ‚àò extract) ‚¶ø <span class="mi">1</span>) rest</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk37"><span class="nb">rewrite</span> IHrest.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHrest</var><span class="hyp-type"><b>: </b><span>map f rest = map f rest</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f rest = mapdt ((f ‚àò extract) ‚¶ø <span class="mi">1</span>) rest</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk38"><span class="nb">rewrite</span> extract_preincr2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHrest</var><span class="hyp-type"><b>: </b><span>map f rest = map f rest</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f rest = mapdt (f ‚àò extract) rest</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk39"><span class="kn">Lemma</span> <span class="nf">mapdt_list_spec</span>:
  <span class="kr">forall</span> {<span class="nv">G</span>} `{Applicative G} {A B : <span class="kt">Type</span>} (f : nat * A -&gt; G B) (l : list A),
    mapdt f l = traverse f (decorate_telescoping_list_alt l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Map G) (<span class="nv">H0</span> : Pure G)
  (<span class="nv">H1</span> : Mult G),
Applicative G -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : nat * A -&gt; G B) (<span class="nv">l</span> : list A),
mapdt f l =
traverse f (decorate_telescoping_list_alt l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk3a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Map G) (<span class="nv">H0</span> : Pure G)
  (<span class="nv">H1</span> : Mult G),
Applicative G -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : nat * A -&gt; G B) (<span class="nv">l</span> : list A),
mapdt f l =
traverse f (decorate_telescoping_list_alt l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk3b"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt f l =
traverse f (decorate_telescoping_list_alt l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk3c"><span class="nb">generalize dependent</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G B,
mapdt f l =
traverse f (decorate_telescoping_list_alt l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk3d"><span class="nb">induction</span> l; <span class="nb">intro</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt f nil =
traverse f (decorate_telescoping_list_alt nil)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-v-chk3e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G B,
mapdt f l = traverse f (decorate_telescoping_list_alt l)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G B</span></span></span><br></div><label class="goal-separator" for="list-telescoping-v-chk3e"><hr></label><div class="goal-conclusion">mapdt f (a :: l) =
traverse f (decorate_telescoping_list_alt (a :: l))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk3f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt f nil =
traverse f (decorate_telescoping_list_alt nil)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk40">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G B,
mapdt f l = traverse f (decorate_telescoping_list_alt l)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt f (a :: l) =
traverse f (decorate_telescoping_list_alt (a :: l))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk41"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G B,
mapdt f l = traverse f (decorate_telescoping_list_alt l)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; f (<span class="mi">0</span>, a) &lt;‚ãÜ&gt; mapdt (f ‚¶ø <span class="mi">1</span>) l =
pure cons &lt;‚ãÜ&gt; f (<span class="mi">0</span>, a) &lt;‚ãÜ&gt;
traverse f
  (map (incr <span class="mi">1</span>) (decorate_telescoping_list_alt l))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk42">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G B,
mapdt f l = traverse f (decorate_telescoping_list_alt l)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt (f ‚¶ø <span class="mi">1</span>) l =
traverse f
  (map (incr <span class="mi">1</span>) (decorate_telescoping_list_alt l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk43"><span class="nb">rewrite</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G B,
mapdt f l = traverse f (decorate_telescoping_list_alt l)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (f ‚¶ø <span class="mi">1</span>) (decorate_telescoping_list_alt l) =
traverse f
  (map (incr <span class="mi">1</span>) (decorate_telescoping_list_alt l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk44">compose near (decorate_telescoping_list_alt l) on <span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G B,
mapdt f l = traverse f (decorate_telescoping_list_alt l)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (f ‚¶ø <span class="mi">1</span>) (decorate_telescoping_list_alt l) =
(traverse f ‚àò map (incr <span class="mi">1</span>))
  (decorate_telescoping_list_alt l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk45"><span class="nb">rewrite</span> (traverse_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G B,
mapdt f l = traverse f (decorate_telescoping_list_alt l)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (f ‚¶ø <span class="mi">1</span>) (decorate_telescoping_list_alt l) =
traverse (f ‚àò incr <span class="mi">1</span>)
  (decorate_telescoping_list_alt l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">CtxToList_List_Telescoping</span>:
  ToCtxlist nat list := ToCtxlist_Mapdt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">ToCtxset_List_Telescoping</span>:
  ToCtxset nat list := ToCtxset_ToCtxlist.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk46">#[export] <span class="kn">Instance</span> <span class="nf">Compat_ToSubset_ToCtxset_List_Telescoping</span>:
  @Compat_ToSubset_ToCtxset
    nat list ToCtxset_List_Telescoping ToSubset_list.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Compat_ToSubset_ToCtxset</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk47"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Compat_ToSubset_ToCtxset</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk48"><span class="nb">unfold</span> Compat_ToSubset_ToCtxset.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">@tosubset list ToSubset_list =
@tosubset list ToSubset_ToCtxset</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk49">ext A l a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tosubset l a = tosubset l a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk4a">unfold_ops @ToSubset_ToCtxset
               @ToCtxset_List_Telescoping
               @ToCtxset_ToCtxlist.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tosubset l a =
(map extract ‚àò (toctxset ‚àò toctxlist)) l a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk4b">unfold_ops @CtxToList_List_Telescoping
               @ToCtxlist_Mapdt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tosubset l a =
(map extract ‚àò (toctxset ‚àò foldMapd ret)) l a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk4c"><span class="nb">rewrite</span> foldMapd_to_mapdt1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tosubset l a =
(map extract ‚àò (toctxset ‚àò mapdt ret)) l a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk4d"><span class="nb">rewrite</span> &lt;- (preincr_zero ret).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tosubset l a =
(map extract ‚àò (toctxset ‚àò mapdt (ret ‚¶ø ∆µ))) l a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk4e"><span class="nb">generalize</span> (∆µ: nat).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat,
tosubset l a =
(map extract ‚àò (toctxset ‚àò mapdt (ret ‚¶ø n))) l a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk4f"><span class="nb">induction</span> l; <span class="nb">intro</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tosubset nil a =
(map extract ‚àò (toctxset ‚àò mapdt (ret ‚¶ø n))) nil a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-v-chk50" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
tosubset l a = (map extract ‚àò (toctxset ‚àò mapdt (ret ‚¶ø n))) l a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="list-telescoping-v-chk50"><hr></label><div class="goal-conclusion">tosubset (a0 :: l) a =
(map extract ‚àò (toctxset ‚àò mapdt (ret ‚¶ø n))) (a0 :: l)
  a</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk51">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tosubset nil a =
(map extract ‚àò (toctxset ‚àò mapdt (ret ‚¶ø n))) nil a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk52"><span class="nb">cbv</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span> =
(<span class="kr">exists</span> <span class="nv">a0</span> : nat * A,
   <span class="kt">False</span> /\ (<span class="kr">let</span> &#39;(_, a) := a0 <span class="kr">in</span> a) = a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk53">propext.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span> -&gt;
<span class="kr">exists</span> <span class="nv">a0</span> : nat * A,
  <span class="kt">False</span> /\ (<span class="kr">let</span> &#39;(_, a) := a0 <span class="kr">in</span> a) = a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-v-chk54" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="list-telescoping-v-chk54"><hr></label><div class="goal-conclusion">(<span class="kr">exists</span> <span class="nv">a0</span> : nat * A,
   <span class="kt">False</span> /\ (<span class="kr">let</span> &#39;(_, a) := a0 <span class="kr">in</span> a) = a) -&gt; <span class="kt">False</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk55">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span> -&gt;
<span class="kr">exists</span> <span class="nv">a0</span> : nat * A,
  <span class="kt">False</span> /\ (<span class="kr">let</span> &#39;(_, a) := a0 <span class="kr">in</span> a) = a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk56">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">exists</span> <span class="nv">a0</span> : nat * A,
   <span class="kt">False</span> /\ (<span class="kr">let</span> &#39;(_, a) := a0 <span class="kr">in</span> a) = a) -&gt; <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk57"><span class="nb">intros</span> [[n&#39; a&#39;] [contra rest]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n, n'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>contra</var><span class="hyp-type"><b>: </b><span><span class="kt">False</span></span></span></span><br><span><var>rest</var><span class="hyp-type"><b>: </b><span>a&#39; = a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk58">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
tosubset l a =
(map extract ‚àò (toctxset ‚àò mapdt (ret ‚¶ø n))) l a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tosubset (a0 :: l) a =
(map extract ‚àò (toctxset ‚àò mapdt (ret ‚¶ø n))) 
  (a0 :: l) a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk59"><span class="nb">rename</span> a0 <span class="nb">into</span> a&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
tosubset l a =
(map extract ‚àò (toctxset ‚àò mapdt (ret ‚¶ø n))) l a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tosubset (a&#39; :: l) a =
(map extract ‚àò (toctxset ‚àò mapdt (ret ‚¶ø n))) 
  (a&#39; :: l) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk5a"><span class="nb">unfold</span> compose <span class="kr">in</span> *; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
tosubset l a =
map extract (toctxset (mapdt (ret ‚¶ø n) l)) a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a&#39; = a \/ List.In a l) =
map extract
  (toctxset ((n ‚óè <span class="mi">0</span>, a&#39;) :: mapdt ((ret ‚¶ø n) ‚¶ø <span class="mi">1</span>) l))
  a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk5b"><span class="nb">rewrite</span> toctxset_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
tosubset l a =
map extract (toctxset (mapdt (ret ‚¶ø n) l)) a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a&#39; = a \/ List.In a l) =
map extract
  ({{(n ‚óè <span class="mi">0</span>, a&#39;)}}
   ‚à™ toctxset (mapdt ((ret ‚¶ø n) ‚¶ø <span class="mi">1</span>) l)) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk5c"><span class="nb">autorewrite with</span> tea_set.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
tosubset l a =
map extract (toctxset (mapdt (ret ‚¶ø n) l)) a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a&#39; = a \/ List.In a l) =
(extract (n ‚óè <span class="mi">0</span>, a&#39;) = a \/
 map extract (toctxset (mapdt ((ret ‚¶ø n) ‚¶ø <span class="mi">1</span>) l)) a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk5d"><span class="nb">rewrite</span> preincr_preincr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
tosubset l a =
map extract (toctxset (mapdt (ret ‚¶ø n) l)) a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a&#39; = a \/ List.In a l) =
(extract (n ‚óè <span class="mi">0</span>, a&#39;) = a \/
 map extract (toctxset (mapdt (ret ‚¶ø (n ‚óè <span class="mi">1</span>)) l)) a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk5e"><span class="nb">rewrite</span> &lt;- (IHl (n ‚óè <span class="mi">1</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
tosubset l a =
map extract (toctxset (mapdt (ret ‚¶ø n) l)) a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a&#39; = a \/ List.In a l) =
(extract (n ‚óè <span class="mi">0</span>, a&#39;) = a \/ tosubset l a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">change</span> <span class="mi">0</span> <span class="kr">with</span> (∆µ:nat); <span class="bp">now</span> <span class="nb">rewrite</span> monoid_id_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk5f">#[export] <span class="kn">Instance</span> <span class="nf">DecoratedTraversableFunctor_List_Telescope</span>:
  @DecoratedTraversableFunctor
    nat list Mapdt_List_Telescope.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">DecoratedTraversableFunctor nat list</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk60"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">DecoratedTraversableFunctor nat list</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk61"><span class="nb">constructor</span>; <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt extract = id</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-v-chk62" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><label class="goal-separator" for="list-telescoping-v-chk62"><hr></label><div class="goal-conclusion">map (mapdt g) ‚àò mapdt f = mapdt (g ‚ãÜ<span class="mi">6</span> f)</div></blockquote><input class="alectryon-extra-goal-toggle" id="list-telescoping-v-chk63" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><label class="goal-separator" for="list-telescoping-v-chk63"><hr></label><div class="goal-conclusion">mapdt (œï B ‚àò f) = œï (list B) ‚àò mapdt f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk64">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt extract = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk65">ext l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt extract l = id l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk66"><span class="nb">induction</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt extract nil = id nil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-v-chk67" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>mapdt extract l = id l</span></span></span><br></div><label class="goal-separator" for="list-telescoping-v-chk67"><hr></label><div class="goal-conclusion">mapdt extract (a :: l) = id (a :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk68">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt extract nil = id nil</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk69">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>mapdt extract l = id l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt extract (a :: l) = id (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk6a"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>mapdt extract l = id l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons a (mapdt (extract ‚¶ø <span class="mi">1</span>) l) = id (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk6b"><span class="nb">rewrite</span> extract_preincr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>mapdt extract l = id l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons a (mapdt extract l) = id (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> IHl.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk6c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mapdt g) ‚àò mapdt f = mapdt (g ‚ãÜ<span class="mi">6</span> f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk6d">ext l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (mapdt g) ‚àò mapdt f) l = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk6e"><span class="nb">generalize dependent</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 B,
(map (mapdt g) ‚àò mapdt f) l = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk6f"><span class="nb">generalize dependent</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">g</span> : nat * B -&gt; G2 C) (<span class="nv">f</span> : nat * A -&gt; G1 B),
(map (mapdt g) ‚àò mapdt f) l = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk70"><span class="nb">induction</span> l; <span class="nb">intros</span> f g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (mapdt f) ‚àò mapdt g) nil = mapdt (f ‚ãÜ<span class="mi">6</span> g) nil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-v-chk71" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : nat * B -&gt; G2 C) (<span class="nv">f</span> : nat * A -&gt; G1 B),
(map (mapdt g) ‚àò mapdt f) l = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><label class="goal-separator" for="list-telescoping-v-chk71"><hr></label><div class="goal-conclusion">(map (mapdt f) ‚àò mapdt g) (a :: l) =
mapdt (f ‚ãÜ<span class="mi">6</span> g) (a :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk72">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (mapdt f) ‚àò mapdt g) nil = mapdt (f ‚ãÜ<span class="mi">6</span> g) nil</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk73"><span class="nb">unfold</span> compose; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mapdt f) (pure nil) = pure nil</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk74"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (mapdt f nil) = pure nil</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk75">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : nat * B -&gt; G2 C) (<span class="nv">f</span> : nat * A -&gt; G1 B),
(map (mapdt g) ‚àò mapdt f) l = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (mapdt f) ‚àò mapdt g) (a :: l) =
mapdt (f ‚ãÜ<span class="mi">6</span> g) (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk76"><span class="nb">unfold</span> compose; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : nat * B -&gt; G2 C) (<span class="nv">f</span> : nat * A -&gt; G1 B),
(map (mapdt g) ‚àò mapdt f) l = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mapdt f)
  (pure cons &lt;‚ãÜ&gt; g (<span class="mi">0</span>, a) &lt;‚ãÜ&gt; mapdt (g ‚¶ø <span class="mi">1</span>) l) =
pure cons &lt;‚ãÜ&gt; (f ‚ãÜ<span class="mi">6</span> g) (<span class="mi">0</span>, a) &lt;‚ãÜ&gt;
mapdt ((f ‚ãÜ<span class="mi">6</span> g) ‚¶ø <span class="mi">1</span>) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="c">(* left *)</span>
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk77"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : nat * B -&gt; G2 C) (<span class="nv">f</span> : nat * A -&gt; G1 B),
(map (mapdt g) ‚àò mapdt f) l = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (mapdt f)) (pure cons &lt;‚ãÜ&gt; g (<span class="mi">0</span>, a)) &lt;‚ãÜ&gt;
mapdt (g ‚¶ø <span class="mi">1</span>) l =
pure cons &lt;‚ãÜ&gt; (f ‚ãÜ<span class="mi">6</span> g) (<span class="mi">0</span>, a) &lt;‚ãÜ&gt;
mapdt ((f ‚ãÜ<span class="mi">6</span> g) ‚¶ø <span class="mi">1</span>) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk78"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : nat * B -&gt; G2 C) (<span class="nv">f</span> : nat * A -&gt; G1 B),
(map (mapdt g) ‚àò mapdt f) l = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (compose (mapdt f))) (pure cons) &lt;‚ãÜ&gt;
g (<span class="mi">0</span>, a) &lt;‚ãÜ&gt; mapdt (g ‚¶ø <span class="mi">1</span>) l =
pure cons &lt;‚ãÜ&gt; (f ‚ãÜ<span class="mi">6</span> g) (<span class="mi">0</span>, a) &lt;‚ãÜ&gt;
mapdt ((f ‚ãÜ<span class="mi">6</span> g) ‚¶ø <span class="mi">1</span>) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk79"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : nat * B -&gt; G2 C) (<span class="nv">f</span> : nat * A -&gt; G1 B),
(map (mapdt g) ‚àò mapdt f) l = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt f) ‚àò cons) &lt;‚ãÜ&gt; g (<span class="mi">0</span>, a) &lt;‚ãÜ&gt;
mapdt (g ‚¶ø <span class="mi">1</span>) l =
pure cons &lt;‚ãÜ&gt; (f ‚ãÜ<span class="mi">6</span> g) (<span class="mi">0</span>, a) &lt;‚ãÜ&gt;
mapdt ((f ‚ãÜ<span class="mi">6</span> g) ‚¶ø <span class="mi">1</span>) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk7a"><span class="nb">change</span> (<span class="kr">fun</span> <span class="nv">a</span> =&gt; G1 (G2 a)) <span class="kr">with</span> (G1 ‚àò G2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : nat * B -&gt; G2 C) (<span class="nv">f</span> : nat * A -&gt; G1 B),
(map (mapdt g) ‚àò mapdt f) l = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt f) ‚àò cons) &lt;‚ãÜ&gt; g (<span class="mi">0</span>, a) &lt;‚ãÜ&gt;
mapdt (g ‚¶ø <span class="mi">1</span>) l =
pure cons &lt;‚ãÜ&gt; (f ‚ãÜ<span class="mi">6</span> g) (<span class="mi">0</span>, a) &lt;‚ãÜ&gt;
mapdt ((f ‚ãÜ<span class="mi">6</span> g) ‚¶ø <span class="mi">1</span>) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="c">(* right *)</span>
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk7b">unfold_ops @Pure_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : nat * B -&gt; G2 C) (<span class="nv">f</span> : nat * A -&gt; G1 B),
(map (mapdt g) ‚àò mapdt f) l = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt f) ‚àò cons) &lt;‚ãÜ&gt; g (<span class="mi">0</span>, a) &lt;‚ãÜ&gt;
mapdt (g ‚¶ø <span class="mi">1</span>) l =
pure (pure cons) &lt;‚ãÜ&gt; (f ‚ãÜ<span class="mi">6</span> g) (<span class="mi">0</span>, a) &lt;‚ãÜ&gt;
mapdt ((f ‚ãÜ<span class="mi">6</span> g) ‚¶ø <span class="mi">1</span>) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk7c"><span class="nb">rewrite_strat</span> innermost (terms (ap_compose2 G2 G1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : nat * B -&gt; G2 C) (<span class="nv">f</span> : nat * A -&gt; G1 B),
(map (mapdt g) ‚àò mapdt f) l = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt f) ‚àò cons) &lt;‚ãÜ&gt; g (<span class="mi">0</span>, a) &lt;‚ãÜ&gt;
mapdt (g ‚¶ø <span class="mi">1</span>) l =
map (ap G2) (pure (pure cons)) &lt;‚ãÜ&gt; (f ‚ãÜ<span class="mi">6</span> g) (<span class="mi">0</span>, a) &lt;‚ãÜ&gt;
mapdt ((f ‚ãÜ<span class="mi">6</span> g) ‚¶ø <span class="mi">1</span>) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk7d"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : nat * B -&gt; G2 C) (<span class="nv">f</span> : nat * A -&gt; G1 B),
(map (mapdt g) ‚àò mapdt f) l = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt f) ‚àò cons) &lt;‚ãÜ&gt; g (<span class="mi">0</span>, a) &lt;‚ãÜ&gt;
mapdt (g ‚¶ø <span class="mi">1</span>) l =
pure (ap G2 (pure cons)) &lt;‚ãÜ&gt; (f ‚ãÜ<span class="mi">6</span> g) (<span class="mi">0</span>, a) &lt;‚ãÜ&gt;
mapdt ((f ‚ãÜ<span class="mi">6</span> g) ‚¶ø <span class="mi">1</span>) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk7e"><span class="nb">replace</span> ((f ‚ãÜ<span class="mi">6</span> g) (<span class="mi">0</span>, a)) <span class="kr">with</span> <span class="c">(* this is annoying *)</span>
        (map (f ‚àò pair <span class="mi">0</span>) (g (<span class="mi">0</span>, a))) <span class="bp">by</span> <span class="bp">now</span> <span class="nb">rewrite</span> kc6_spec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : nat * B -&gt; G2 C) (<span class="nv">f</span> : nat * A -&gt; G1 B),
(map (mapdt g) ‚àò mapdt f) l = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt f) ‚àò cons) &lt;‚ãÜ&gt; g (<span class="mi">0</span>, a) &lt;‚ãÜ&gt;
mapdt (g ‚¶ø <span class="mi">1</span>) l =
pure (ap G2 (pure cons)) &lt;‚ãÜ&gt;
map (f ‚àò pair <span class="mi">0</span>) (g (<span class="mi">0</span>, a)) &lt;‚ãÜ&gt; mapdt ((f ‚ãÜ<span class="mi">6</span> g) ‚¶ø <span class="mi">1</span>) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk7f"><span class="nb">rewrite</span> &lt;- ap_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : nat * B -&gt; G2 C) (<span class="nv">f</span> : nat * A -&gt; G1 B),
(map (mapdt g) ‚àò mapdt f) l = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt f) ‚àò cons) &lt;‚ãÜ&gt; g (<span class="mi">0</span>, a) &lt;‚ãÜ&gt;
mapdt (g ‚¶ø <span class="mi">1</span>) l =
map (precompose (f ‚àò pair <span class="mi">0</span>))
  (pure (ap G2 (pure cons))) &lt;‚ãÜ&gt; g (<span class="mi">0</span>, a) &lt;‚ãÜ&gt;
mapdt ((f ‚ãÜ<span class="mi">6</span> g) ‚¶ø <span class="mi">1</span>) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk80"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : nat * B -&gt; G2 C) (<span class="nv">f</span> : nat * A -&gt; G1 B),
(map (mapdt g) ‚àò mapdt f) l = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt f) ‚àò cons) &lt;‚ãÜ&gt; g (<span class="mi">0</span>, a) &lt;‚ãÜ&gt;
mapdt (g ‚¶ø <span class="mi">1</span>) l =
pure (precompose (f ‚àò pair <span class="mi">0</span>) (ap G2 (pure cons))) &lt;‚ãÜ&gt;
g (<span class="mi">0</span>, a) &lt;‚ãÜ&gt; mapdt ((f ‚ãÜ<span class="mi">6</span> g) ‚¶ø <span class="mi">1</span>) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk81"><span class="nb">rewrite_strat</span> innermost (terms (ap_compose2 G2 G1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : nat * B -&gt; G2 C) (<span class="nv">f</span> : nat * A -&gt; G1 B),
(map (mapdt g) ‚àò mapdt f) l = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt f) ‚àò cons) &lt;‚ãÜ&gt; g (<span class="mi">0</span>, a) &lt;‚ãÜ&gt;
mapdt (g ‚¶ø <span class="mi">1</span>) l =
map (ap G2)
  (pure (precompose (f ‚àò pair <span class="mi">0</span>) (ap G2 (pure cons))) &lt;‚ãÜ&gt;
   g (<span class="mi">0</span>, a)) &lt;‚ãÜ&gt; mapdt ((f ‚ãÜ<span class="mi">6</span> g) ‚¶ø <span class="mi">1</span>) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk82"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : nat * B -&gt; G2 C) (<span class="nv">f</span> : nat * A -&gt; G1 B),
(map (mapdt g) ‚àò mapdt f) l = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt f) ‚àò cons) &lt;‚ãÜ&gt; g (<span class="mi">0</span>, a) &lt;‚ãÜ&gt;
mapdt (g ‚¶ø <span class="mi">1</span>) l =
map (compose (ap G2))
  (pure (precompose (f ‚àò pair <span class="mi">0</span>) (ap G2 (pure cons)))) &lt;‚ãÜ&gt;
g (<span class="mi">0</span>, a) &lt;‚ãÜ&gt; mapdt ((f ‚ãÜ<span class="mi">6</span> g) ‚¶ø <span class="mi">1</span>) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk83"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : nat * B -&gt; G2 C) (<span class="nv">f</span> : nat * A -&gt; G1 B),
(map (mapdt g) ‚àò mapdt f) l = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt f) ‚àò cons) &lt;‚ãÜ&gt; g (<span class="mi">0</span>, a) &lt;‚ãÜ&gt;
mapdt (g ‚¶ø <span class="mi">1</span>) l =
pure
  (ap G2 ‚àò precompose (f ‚àò pair <span class="mi">0</span>) (ap G2 (pure cons))) &lt;‚ãÜ&gt;
g (<span class="mi">0</span>, a) &lt;‚ãÜ&gt; mapdt ((f ‚ãÜ<span class="mi">6</span> g) ‚¶ø <span class="mi">1</span>) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk84"><span class="nb">rewrite</span> kc6_preincr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : nat * B -&gt; G2 C) (<span class="nv">f</span> : nat * A -&gt; G1 B),
(map (mapdt g) ‚àò mapdt f) l = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt f) ‚àò cons) &lt;‚ãÜ&gt; g (<span class="mi">0</span>, a) &lt;‚ãÜ&gt;
mapdt (g ‚¶ø <span class="mi">1</span>) l =
pure
  (ap G2 ‚àò precompose (f ‚àò pair <span class="mi">0</span>) (ap G2 (pure cons))) &lt;‚ãÜ&gt;
g (<span class="mi">0</span>, a) &lt;‚ãÜ&gt; mapdt (f ‚¶ø <span class="mi">1</span> ‚ãÜ<span class="mi">6</span> g ‚¶ø <span class="mi">1</span>) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk85"><span class="nb">rewrite</span> &lt;- IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : nat * B -&gt; G2 C) (<span class="nv">f</span> : nat * A -&gt; G1 B),
(map (mapdt g) ‚àò mapdt f) l = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt f) ‚àò cons) &lt;‚ãÜ&gt; g (<span class="mi">0</span>, a) &lt;‚ãÜ&gt;
mapdt (g ‚¶ø <span class="mi">1</span>) l =
pure
  (ap G2 ‚àò precompose (f ‚àò pair <span class="mi">0</span>) (ap G2 (pure cons))) &lt;‚ãÜ&gt;
g (<span class="mi">0</span>, a) &lt;‚ãÜ&gt; (map (mapdt (f ‚¶ø <span class="mi">1</span>)) ‚àò mapdt (g ‚¶ø <span class="mi">1</span>)) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk86"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">5</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : nat * B -&gt; G2 C) (<span class="nv">f</span> : nat * A -&gt; G1 B),
(map (mapdt g) ‚àò mapdt f) l = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt f) ‚àò cons) &lt;‚ãÜ&gt; g (<span class="mi">0</span>, a) &lt;‚ãÜ&gt;
mapdt (g ‚¶ø <span class="mi">1</span>) l =
pure
  (ap G2 ‚àò precompose (f ‚àò pair <span class="mi">0</span>) (ap G2 (pure cons))) &lt;‚ãÜ&gt;
g (<span class="mi">0</span>, a) &lt;‚ãÜ&gt; map (mapdt (f ‚¶ø <span class="mi">1</span>)) (mapdt (g ‚¶ø <span class="mi">1</span>) l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk87"><span class="nb">rewrite</span> &lt;- ap_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : nat * B -&gt; G2 C) (<span class="nv">f</span> : nat * A -&gt; G1 B),
(map (mapdt g) ‚àò mapdt f) l = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt f) ‚àò cons) &lt;‚ãÜ&gt; g (<span class="mi">0</span>, a) &lt;‚ãÜ&gt;
mapdt (g ‚¶ø <span class="mi">1</span>) l =
map (precompose (mapdt (f ‚¶ø <span class="mi">1</span>)))
  (pure
     (ap G2
      ‚àò precompose (f ‚àò pair <span class="mi">0</span>) (ap G2 (pure cons))) &lt;‚ãÜ&gt;
   g (<span class="mi">0</span>, a)) &lt;‚ãÜ&gt; mapdt (g ‚¶ø <span class="mi">1</span>) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk88"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : nat * B -&gt; G2 C) (<span class="nv">f</span> : nat * A -&gt; G1 B),
(map (mapdt g) ‚àò mapdt f) l = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt f) ‚àò cons) &lt;‚ãÜ&gt; g (<span class="mi">0</span>, a) &lt;‚ãÜ&gt;
mapdt (g ‚¶ø <span class="mi">1</span>) l =
map (compose (precompose (mapdt (f ‚¶ø <span class="mi">1</span>))))
  (pure
     (ap G2
      ‚àò precompose (f ‚àò pair <span class="mi">0</span>) (ap G2 (pure cons)))) &lt;‚ãÜ&gt;
g (<span class="mi">0</span>, a) &lt;‚ãÜ&gt; mapdt (g ‚¶ø <span class="mi">1</span>) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk89"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : nat * B -&gt; G2 C) (<span class="nv">f</span> : nat * A -&gt; G1 B),
(map (mapdt g) ‚àò mapdt f) l = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt f) ‚àò cons) &lt;‚ãÜ&gt; g (<span class="mi">0</span>, a) &lt;‚ãÜ&gt;
mapdt (g ‚¶ø <span class="mi">1</span>) l =
pure
  (precompose (mapdt (f ‚¶ø <span class="mi">1</span>))
   ‚àò (ap G2
      ‚àò precompose (f ‚àò pair <span class="mi">0</span>) (ap G2 (pure cons)))) &lt;‚ãÜ&gt;
g (<span class="mi">0</span>, a) &lt;‚ãÜ&gt; mapdt (g ‚¶ø <span class="mi">1</span>) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk8a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt (œï B ‚àò f) = œï (list B) ‚àò mapdt f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk8b">ext l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt (œï B ‚àò f) l = (œï (list B) ‚àò mapdt f) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk8c"><span class="nb">generalize dependent</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 B,
mapdt (œï B ‚àò f) l = (œï (list B) ‚àò mapdt f) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk8d"><span class="nb">induction</span> l; <span class="nb">intro</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt (œï B ‚àò f) nil = (œï (list B) ‚àò mapdt f) nil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-v-chk8e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 B, mapdt (œï B ‚àò f) l = (œï (list B) ‚àò mapdt f) l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><label class="goal-separator" for="list-telescoping-v-chk8e"><hr></label><div class="goal-conclusion">mapdt (œï B ‚àò f) (a :: l) =
(œï (list B) ‚àò mapdt f) (a :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk8f">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt (œï B ‚àò f) nil = (œï (list B) ‚àò mapdt f) nil</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk90"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt (œï B ‚óã f) nil = œï (list B) (mapdt f nil)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk91"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure nil = œï (list B) (pure nil)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> appmor_pure.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk92">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 B, mapdt (œï B ‚àò f) l = (œï (list B) ‚àò mapdt f) l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt (œï B ‚àò f) (a :: l) =
(œï (list B) ‚àò mapdt f) (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk93"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 B, mapdt (œï B ‚àò f) l = (œï (list B) ‚àò mapdt f) l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt (œï B ‚óã f) (a :: l) =
œï (list B) (mapdt f (a :: l))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk94"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 B, mapdt (œï B ‚àò f) l = (œï (list B) ‚àò mapdt f) l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; œï B (f (<span class="mi">0</span>, a)) &lt;‚ãÜ&gt;
mapdt ((œï B ‚óã f) ‚¶ø <span class="mi">1</span>) l =
œï (list B)
  (pure cons &lt;‚ãÜ&gt; f (<span class="mi">0</span>, a) &lt;‚ãÜ&gt; mapdt (f ‚¶ø <span class="mi">1</span>) l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk95"><span class="nb">rewrite</span> ap_morphism_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 B, mapdt (œï B ‚àò f) l = (œï (list B) ‚àò mapdt f) l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; œï B (f (<span class="mi">0</span>, a)) &lt;‚ãÜ&gt;
mapdt ((œï B ‚óã f) ‚¶ø <span class="mi">1</span>) l =
œï (list B -&gt; list B) (pure cons &lt;‚ãÜ&gt; f (<span class="mi">0</span>, a)) &lt;‚ãÜ&gt;
œï (list B) (mapdt (f ‚¶ø <span class="mi">1</span>) l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk96"><span class="nb">rewrite</span> ap_morphism_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 B, mapdt (œï B ‚àò f) l = (œï (list B) ‚àò mapdt f) l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; œï B (f (<span class="mi">0</span>, a)) &lt;‚ãÜ&gt;
mapdt ((œï B ‚óã f) ‚¶ø <span class="mi">1</span>) l =
œï (B -&gt; list B -&gt; list B) (pure cons) &lt;‚ãÜ&gt;
œï B (f (<span class="mi">0</span>, a)) &lt;‚ãÜ&gt; œï (list B) (mapdt (f ‚¶ø <span class="mi">1</span>) l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk97">compose near l on <span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 B, mapdt (œï B ‚àò f) l = (œï (list B) ‚àò mapdt f) l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; œï B (f (<span class="mi">0</span>, a)) &lt;‚ãÜ&gt;
mapdt ((œï B ‚óã f) ‚¶ø <span class="mi">1</span>) l =
œï (B -&gt; list B -&gt; list B) (pure cons) &lt;‚ãÜ&gt;
œï B (f (<span class="mi">0</span>, a)) &lt;‚ãÜ&gt; (œï (list B) ‚àò mapdt (f ‚¶ø <span class="mi">1</span>)) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk98"><span class="nb">rewrite</span> &lt;- IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 B, mapdt (œï B ‚àò f) l = (œï (list B) ‚àò mapdt f) l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; œï B (f (<span class="mi">0</span>, a)) &lt;‚ãÜ&gt;
mapdt ((œï B ‚óã f) ‚¶ø <span class="mi">1</span>) l =
œï (B -&gt; list B -&gt; list B) (pure cons) &lt;‚ãÜ&gt;
œï B (f (<span class="mi">0</span>, a)) &lt;‚ãÜ&gt; mapdt (œï B ‚àò f ‚¶ø <span class="mi">1</span>) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk99"><span class="nb">rewrite</span> appmor_pure.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : nat * A -&gt; G1 B, mapdt (œï B ‚àò f) l = (œï (list B) ‚àò mapdt f) l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; œï B (f (<span class="mi">0</span>, a)) &lt;‚ãÜ&gt;
mapdt ((œï B ‚óã f) ‚¶ø <span class="mi">1</span>) l =
pure cons &lt;‚ãÜ&gt; œï B (f (<span class="mi">0</span>, a)) &lt;‚ãÜ&gt; mapdt (œï B ‚àò f ‚¶ø <span class="mi">1</span>) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">decorate_list_full</span> {<span class="nv">A</span>: <span class="kt">Type</span>} (<span class="nv">l</span>: list A):
  list (nat * A) :=
  map (pair (length l)) l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">mapdt_list_full</span>
           {<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>} `{Map G} `{Pure G} `{Mult G}
           {A B : <span class="kt">Type</span>} (f : nat * A -&gt; G B) (l : list A)
  : G (list B) :=
  traverse (T := list) (G := G) (f ‚àò pair (length l)) l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Mapdt_List_Full</span>: Mapdt nat list := @mapdt_list_full.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Mapd_List_Full</span>: Mapd nat list :=
  @Mapd_Mapdt nat list Mapdt_List_Full.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk9a">#[export] <span class="kn">Instance</span>: @Compat_Traverse_Mapdt nat list Traverse_list Mapdt_List_Full.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Compat_Traverse_Mapdt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk9b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Compat_Traverse_Mapdt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk9c"><span class="nb">unfold</span> Compat_Traverse_Mapdt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">Map_inst</span> : Map G)
  (<span class="nv">Mult_inst</span> : Mult G) (<span class="nv">Pure_inst</span> : Pure G),
Applicative G -&gt;
@traverse list Traverse_list G Map_inst Pure_inst
  Mult_inst =
@traverse list Traverse_Mapdt G Map_inst Pure_inst
  Mult_inst</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span>: Compat_Mapd_Mapdt := <span class="kp">ltac</span>:(<span class="nb">typeclasses eauto</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk9d">#[export] <span class="kn">Instance</span>: @Compat_Map_Mapdt nat list Map_list Mapdt_List_Full.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Compat_Map_Mapdt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk9e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Compat_Map_Mapdt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chk9f"><span class="nb">unfold</span> Compat_Map_Mapdt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">@map list Map_list = @map list Map_Mapdt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chka0">unfold_ops @Map_Mapdt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">@map list Map_list =
(<span class="kr">fun</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) =&gt; mapdt (f ‚àò extract))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chka1">unfold_ops @Mapdt_List_Full.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">@map list Map_list =
(<span class="kr">fun</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) =&gt;
 mapdt_list_full (f ‚àò extract))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chka2"><span class="nb">unfold</span> mapdt_list_full.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">@map list Map_list =
(<span class="kr">fun</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">l</span> : list A) =&gt;
 traverse (f ‚àò extract ‚àò pair (length l)) l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chka3">ext A B f l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f l = traverse (f ‚àò extract ‚àò pair (length l)) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chka4">reassociate -&gt; on <span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f l = traverse (f ‚àò (extract ‚àò pair (length l))) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chka5"><span class="nb">rewrite</span> extract_pair.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f l = traverse (f ‚àò id) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chka6"><span class="nb">change</span> (<span class="nl">?f</span> ‚àò id) <span class="kr">with</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f l = traverse f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chka7"><span class="nb">rewrite</span> &lt;- map_to_traverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f l = map f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">CtxToList_List_Full</span>:
  ToCtxlist nat list := ToCtxlist_Mapdt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">ToCtxset_List_Full</span>:
  ToCtxset nat list := ToCtxset_ToCtxlist.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chka8">#[export] <span class="kn">Instance</span> <span class="nf">Compat_ToSubset_ToCtxset_List_Full</span>:
  @Compat_ToSubset_ToCtxset
    nat list ToCtxset_List_Full ToSubset_list.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Compat_ToSubset_ToCtxset</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chka9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Compat_ToSubset_ToCtxset</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkaa"><span class="nb">unfold</span> Compat_ToSubset_ToCtxset.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">@tosubset list ToSubset_list =
@tosubset list ToSubset_ToCtxset</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkab">ext A l a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tosubset l a = tosubset l a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkac">unfold_ops @ToSubset_ToCtxset
               @ToCtxset_List_Full
               @ToCtxset_ToCtxlist.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tosubset l a =
(map extract ‚àò (toctxset ‚àò toctxlist)) l a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkad">unfold_ops @CtxToList_List_Full
               @ToCtxlist_Mapdt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tosubset l a =
(map extract ‚àò (toctxset ‚àò foldMapd ret)) l a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkae"><span class="nb">rewrite</span> foldMapd_to_mapdt1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tosubset l a =
(map extract ‚àò (toctxset ‚àò mapdt ret)) l a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkaf">unfold_ops @ToCtxset_env.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tosubset l a =
(map extract
 ‚àò ((<span class="kr">fun</span> <span class="nv">s</span> : env nat A =&gt; tosubset s) ‚àò mapdt ret)) l
  a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkb0">reassociate &lt;-.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tosubset l a =
(map extract ‚àò (<span class="kr">fun</span> <span class="nv">s</span> : env nat A =&gt; tosubset s)
 ‚àò mapdt ret) l a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkb1"><span class="nb">change</span> (<span class="kr">fun</span> <span class="nv">s</span> : env nat A =&gt; @tosubset list ToSubset_list (nat * A) s)
    <span class="kr">with</span> (@tosubset list ToSubset_list (nat * A)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tosubset l a =
(map extract ‚àò tosubset ‚àò mapdt ret) l a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkb2"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tosubset l a = map extract (tosubset (mapdt ret l)) a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkb3">unfold_ops @Mapdt_List_Full.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tosubset l a =
map extract (tosubset (mapdt_list_full ret l)) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkb4"><span class="nb">unfold</span> mapdt_list_full.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tosubset l a =
map extract
  (tosubset (traverse (ret ‚àò pair (length l)) l)) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkb5"><span class="nb">generalize</span> (length l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat,
tosubset l a =
map extract (tosubset (traverse (ret ‚àò pair n) l)) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkb6"><span class="nb">induction</span> l; <span class="nb">intro</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tosubset nil a =
map extract (tosubset (traverse (ret ‚àò pair n) nil)) a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-v-chkb7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
tosubset l a = map extract (tosubset (traverse (ret ‚àò pair n) l)) a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="list-telescoping-v-chkb7"><hr></label><div class="goal-conclusion">tosubset (a0 :: l) a =
map extract
  (tosubset (traverse (ret ‚àò pair n) (a0 :: l))) a</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkb8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tosubset nil a =
map extract (tosubset (traverse (ret ‚àò pair n) nil)) a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkb9"><span class="nb">cbv</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span> =
(<span class="kr">exists</span> <span class="nv">a0</span> : nat * A,
   <span class="kt">False</span> /\ (<span class="kr">let</span> &#39;(_, a) := a0 <span class="kr">in</span> a) = a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkba">propext.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span> -&gt;
<span class="kr">exists</span> <span class="nv">a0</span> : nat * A,
  <span class="kt">False</span> /\ (<span class="kr">let</span> &#39;(_, a) := a0 <span class="kr">in</span> a) = a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-v-chkbb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="list-telescoping-v-chkbb"><hr></label><div class="goal-conclusion">(<span class="kr">exists</span> <span class="nv">a0</span> : nat * A,
   <span class="kt">False</span> /\ (<span class="kr">let</span> &#39;(_, a) := a0 <span class="kr">in</span> a) = a) -&gt; <span class="kt">False</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkbc">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span> -&gt;
<span class="kr">exists</span> <span class="nv">a0</span> : nat * A,
  <span class="kt">False</span> /\ (<span class="kr">let</span> &#39;(_, a) := a0 <span class="kr">in</span> a) = a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkbd">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">exists</span> <span class="nv">a0</span> : nat * A,
   <span class="kt">False</span> /\ (<span class="kr">let</span> &#39;(_, a) := a0 <span class="kr">in</span> a) = a) -&gt; <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkbe"><span class="nb">intros</span> [[n&#39; a&#39;] [contra rest]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n, n'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>contra</var><span class="hyp-type"><b>: </b><span><span class="kt">False</span></span></span></span><br><span><var>rest</var><span class="hyp-type"><b>: </b><span>a&#39; = a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkbf">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
tosubset l a =
map extract
  (tosubset (traverse (ret ‚àò pair n) l)) a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tosubset (a0 :: l) a =
map extract
  (tosubset (traverse (ret ‚àò pair n) (a0 :: l))) a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkc0"><span class="nb">rename</span> a0 <span class="nb">into</span> a&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
tosubset l a =
map extract
  (tosubset (traverse (ret ‚àò pair n) l)) a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tosubset (a&#39; :: l) a =
map extract
  (tosubset (traverse (ret ‚àò pair n) (a&#39; :: l))) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkc1"><span class="nb">autorewrite with</span> tea_list tea_set.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
tosubset l a =
map extract
  (tosubset (traverse (ret ‚àò pair n) l)) a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a&#39; = a \/ tosubset l a) =
map extract
  (tosubset
     (pure cons &lt;‚ãÜ&gt; (ret ‚àò pair n) a&#39; &lt;‚ãÜ&gt;
      traverse (ret ‚àò pair n) l)) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkc2"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
tosubset l a =
map extract
  (tosubset (traverse (ret ‚àò pair n) l)) a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a&#39; = a \/ tosubset l a) =
map extract
  (tosubset ((n, a&#39;) :: traverse (ret ‚àò pair n) l)) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkc3"><span class="nb">rewrite</span> tosubset_list_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
tosubset l a =
map extract
  (tosubset (traverse (ret ‚àò pair n) l)) a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a&#39; = a \/ tosubset l a) =
map extract
  ({{(n, a&#39;)}} ‚à™ tosubset (traverse (ret ‚àò pair n) l))
  a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkc4"><span class="nb">rewrite</span> map_set_add, map_set_one.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
tosubset l a =
map extract
  (tosubset (traverse (ret ‚àò pair n) l)) a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a&#39; = a \/ tosubset l a) =
({{extract (n, a&#39;)}}
 ‚à™ map extract (tosubset (traverse (ret ‚àò pair n) l)))
  a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkc5"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
tosubset l a =
map extract
  (tosubset (traverse (ret ‚àò pair n) l)) a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a&#39; = a \/ tosubset l a) =
({{a&#39;}}
 ‚à™ map extract (tosubset (traverse (ret ‚àò pair n) l)))
  a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkc6"><span class="nb">rewrite</span> subset_in_add.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
tosubset l a =
map extract
  (tosubset (traverse (ret ‚àò pair n) l)) a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a&#39; = a \/ tosubset l a) =
({{a&#39;}} a \/
 map extract (tosubset (traverse (ret ‚àò pair n) l)) a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkc7"><span class="nb">rewrite</span> (IHl n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
tosubset l a =
map extract
  (tosubset (traverse (ret ‚àò pair n) l)) a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a&#39; = a \/
 map extract (tosubset (traverse (ret ‚àò pair n) l)) a) =
({{a&#39;}} a \/
 map extract (tosubset (traverse (ret ‚àò pair n) l)) a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkc8">#[export] <span class="kn">Instance</span> <span class="nf">DecoratedTraversableFunctor_List_Full</span>:
  @DecoratedTraversableFunctor
    nat list Mapdt_List_Full.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">DecoratedTraversableFunctor nat list</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkc9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">DecoratedTraversableFunctor nat list</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkca"><span class="nb">constructor</span>; <span class="nb">intros</span>; ext l;
    unfold_ops @Mapdt_List_Full;
    <span class="nb">unfold</span> mapdt_list_full.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (extract ‚àò pair (length l)) l = id l</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-v-chkcb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><label class="goal-separator" for="list-telescoping-v-chkcb"><hr></label><div class="goal-conclusion">(map
   (<span class="kr">fun</span> <span class="nv">l</span> : list B =&gt; traverse (g ‚àò pair (length l)) l)
 ‚àò (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; traverse (f ‚àò pair (length l)) l))
  l = traverse ((g ‚ãÜ<span class="mi">6</span> f) ‚àò pair (length l)) l</div></blockquote><input class="alectryon-extra-goal-toggle" id="list-telescoping-v-chkcc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><label class="goal-separator" for="list-telescoping-v-chkcc"><hr></label><div class="goal-conclusion">traverse (œï B ‚àò f ‚àò pair (length l)) l =
(œï (list B)
 ‚àò (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; traverse (f ‚àò pair (length l)) l))
  l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkcd">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (extract ‚àò pair (length l)) l = id l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkce"><span class="nb">rewrite</span> extract_pair.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse id l = id l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> trf_traverse_id.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkcf">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map
   (<span class="kr">fun</span> <span class="nv">l</span> : list B =&gt; traverse (g ‚àò pair (length l)) l)
 ‚àò (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; traverse (f ‚àò pair (length l)) l))
  l = traverse ((g ‚ãÜ<span class="mi">6</span> f) ‚àò pair (length l)) l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkd0"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (<span class="kr">fun</span> <span class="nv">l</span> : list B =&gt; traverse (g ‚àò pair (length l)) l)
  (traverse (f ‚àò pair (length l)) l) =
traverse ((g ‚ãÜ<span class="mi">6</span> f) ‚àò pair (length l)) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkd1"><span class="nb">assert</span> (Functor G1) <span class="bp">by</span> <span class="bp">now</span> <span class="nb">inversion</span> H3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (<span class="kr">fun</span> <span class="nv">l</span> : list B =&gt; traverse (g ‚àò pair (length l)) l)
  (traverse (f ‚àò pair (length l)) l) =
traverse ((g ‚ãÜ<span class="mi">6</span> f) ‚àò pair (length l)) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkd2"><span class="nb">assert</span> (Functor G2) <span class="bp">by</span> <span class="bp">now</span> <span class="nb">inversion</span> H7.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (<span class="kr">fun</span> <span class="nv">l</span> : list B =&gt; traverse (g ‚àò pair (length l)) l)
  (traverse (f ‚àò pair (length l)) l) =
traverse ((g ‚ãÜ<span class="mi">6</span> f) ‚àò pair (length l)) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkd3"><span class="nb">assert</span> (kc_spec: kc6 (G1 := G1)(G2 := G2) g f ‚àò pair (length l) =
                       kc2 (g ‚àò pair (length l)) (f ‚àò pair (length l))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(g ‚ãÜ<span class="mi">6</span> f) ‚àò pair (length l) =
g ‚àò pair (length l) ‚ãÜ<span class="mi">2</span> f ‚àò pair (length l)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-v-chkd4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br><span><var>kc_spec</var><span class="hyp-type"><b>: </b><span>(g ‚ãÜ<span class="mi">6</span> f) ‚àò pair (length l) =
g ‚àò pair (length l) ‚ãÜ<span class="mi">2</span> f ‚àò pair (length l)</span></span></span><br></div><label class="goal-separator" for="list-telescoping-v-chkd4"><hr></label><div class="goal-conclusion">map
  (<span class="kr">fun</span> <span class="nv">l</span> : list B =&gt; traverse (g ‚àò pair (length l)) l)
  (traverse (f ‚àò pair (length l)) l) =
traverse ((g ‚ãÜ<span class="mi">6</span> f) ‚àò pair (length l)) l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkd5">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(g ‚ãÜ<span class="mi">6</span> f) ‚àò pair (length l) =
g ‚àò pair (length l) ‚ãÜ<span class="mi">2</span> f ‚àò pair (length l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkd6">ext a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((g ‚ãÜ<span class="mi">6</span> f) ‚àò pair (length l)) a =
(g ‚àò pair (length l) ‚ãÜ<span class="mi">2</span> f ‚àò pair (length l)) a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkd7"><span class="nb">unfold</span> kc6, kc2, compose; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map g (map (pair (length l)) (f (length l, a))) =
map (g ‚óã pair (length l)) (f (length l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkd8">compose near (f (length l, a)) on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map g ‚àò map (pair (length l))) (f (length l, a)) =
map (g ‚óã pair (length l)) (f (length l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> (fun_map_map (F := G1)).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkd9">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br><span><var>kc_spec</var><span class="hyp-type"><b>: </b><span>(g ‚ãÜ<span class="mi">6</span> f) ‚àò pair (length l) =
g ‚àò pair (length l) ‚ãÜ<span class="mi">2</span> f ‚àò pair (length l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (<span class="kr">fun</span> <span class="nv">l</span> : list B =&gt; traverse (g ‚àò pair (length l)) l)
  (traverse (f ‚àò pair (length l)) l) =
traverse ((g ‚ãÜ<span class="mi">6</span> f) ‚àò pair (length l)) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkda"><span class="kn">Set Keyed Unification</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br><span><var>kc_spec</var><span class="hyp-type"><b>: </b><span>(g ‚ãÜ<span class="mi">6</span> f) ‚àò pair (length l) =
g ‚àò pair (length l) ‚ãÜ<span class="mi">2</span> f ‚àò pair (length l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (<span class="kr">fun</span> <span class="nv">l</span> : list B =&gt; traverse (g ‚àò pair (length l)) l)
  (traverse (f ‚àò pair (length l)) l) =
traverse ((g ‚ãÜ<span class="mi">6</span> f) ‚àò pair (length l)) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkdb"><span class="nb">rewrite</span> kc_spec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br><span><var>kc_spec</var><span class="hyp-type"><b>: </b><span>(g ‚ãÜ<span class="mi">6</span> f) ‚àò pair (length l) =
g ‚àò pair (length l) ‚ãÜ<span class="mi">2</span> f ‚àò pair (length l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (<span class="kr">fun</span> <span class="nv">l</span> : list B =&gt; traverse (g ‚àò pair (length l)) l)
  (traverse (f ‚àò pair (length l)) l) =
traverse (g ‚àò pair (length l) ‚ãÜ<span class="mi">2</span> f ‚àò pair (length l))
  l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkdc"><span class="kn">Unset Keyed Unification</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br><span><var>kc_spec</var><span class="hyp-type"><b>: </b><span>(g ‚ãÜ<span class="mi">6</span> f) ‚àò pair (length l) =
g ‚àò pair (length l) ‚ãÜ<span class="mi">2</span> f ‚àò pair (length l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (<span class="kr">fun</span> <span class="nv">l</span> : list B =&gt; traverse (g ‚àò pair (length l)) l)
  (traverse (f ‚àò pair (length l)) l) =
traverse (g ‚àò pair (length l) ‚ãÜ<span class="mi">2</span> f ‚àò pair (length l))
  l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkdd"><span class="nb">rewrite</span> &lt;- trf_traverse_traverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br><span><var>kc_spec</var><span class="hyp-type"><b>: </b><span>(g ‚ãÜ<span class="mi">6</span> f) ‚àò pair (length l) =
g ‚àò pair (length l) ‚ãÜ<span class="mi">2</span> f ‚àò pair (length l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (<span class="kr">fun</span> <span class="nv">l</span> : list B =&gt; traverse (g ‚àò pair (length l)) l)
  (traverse (f ‚àò pair (length l)) l) =
(map (traverse (g ‚àò pair (length l)))
 ‚àò traverse (f ‚àò pair (length l))) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkde">#[local] <span class="kn">Existing Instance</span> <span class="nf">ToBatch_Traverse</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br><span><var>kc_spec</var><span class="hyp-type"><b>: </b><span>(g ‚ãÜ<span class="mi">6</span> f) ‚àò pair (length l) =
g ‚àò pair (length l) ‚ãÜ<span class="mi">2</span> f ‚àò pair (length l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (<span class="kr">fun</span> <span class="nv">l</span> : list B =&gt; traverse (g ‚àò pair (length l)) l)
  (traverse (f ‚àò pair (length l)) l) =
(map (traverse (g ‚àò pair (length l)))
 ‚àò traverse (f ‚àò pair (length l))) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkdf"><span class="nb">rewrite</span> traverse_repr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br><span><var>kc_spec</var><span class="hyp-type"><b>: </b><span>(g ‚ãÜ<span class="mi">6</span> f) ‚àò pair (length l) =
g ‚àò pair (length l) ‚ãÜ<span class="mi">2</span> f ‚àò pair (length l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (<span class="kr">fun</span> <span class="nv">l</span> : list B =&gt; traverse (g ‚àò pair (length l)) l)
  (map (trav_make l)
     (forwards
        (traverse
           (mkBackwards ‚àò (f ‚àò pair (length l)))
           (trav_contents l)))) =
(map (traverse (g ‚àò pair (length l)))
 ‚àò traverse (f ‚àò pair (length l))) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chke0"><span class="nb">change</span> (map <span class="nl">?g</span> (map <span class="nl">?f</span> <span class="nl">?x</span>)) <span class="kr">with</span> ((map g ‚àò map f) x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br><span><var>kc_spec</var><span class="hyp-type"><b>: </b><span>(g ‚ãÜ<span class="mi">6</span> f) ‚àò pair (length l) =
g ‚àò pair (length l) ‚ãÜ<span class="mi">2</span> f ‚àò pair (length l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map
   (<span class="kr">fun</span> <span class="nv">l</span> : list B =&gt; traverse (g ‚àò pair (length l)) l)
 ‚àò map (trav_make l))
  (forwards
     (traverse (mkBackwards ‚àò (f ‚àò pair (length l)))
        (trav_contents l))) =
(map (traverse (g ‚àò pair (length l)))
 ‚àò traverse (f ‚àò pair (length l))) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chke1"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br><span><var>kc_spec</var><span class="hyp-type"><b>: </b><span>(g ‚ãÜ<span class="mi">6</span> f) ‚àò pair (length l) =
g ‚àò pair (length l) ‚ãÜ<span class="mi">2</span> f ‚àò pair (length l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  ((<span class="kr">fun</span> <span class="nv">l</span> : list B =&gt; traverse (g ‚àò pair (length l)) l)
   ‚àò trav_make l)
  (forwards
     (traverse (mkBackwards ‚àò (f ‚àò pair (length l)))
        (trav_contents l))) =
(map (traverse (g ‚àò pair (length l)))
 ‚àò traverse (f ‚àò pair (length l))) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chke2"><span class="nb">cbn</span> beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br><span><var>kc_spec</var><span class="hyp-type"><b>: </b><span>(g ‚ãÜ<span class="mi">6</span> f) ‚àò pair (length l) =
g ‚àò pair (length l) ‚ãÜ<span class="mi">2</span> f ‚àò pair (length l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  ((<span class="kr">fun</span> <span class="nv">l</span> : list B =&gt; traverse (g ‚àò pair (length l)) l)
   ‚àò trav_make l)
  (forwards
     (traverse (mkBackwards ‚àò (f ‚àò pair (length l)))
        (trav_contents l))) =
(map (traverse (g ‚àò pair (length l)))
 ‚àò traverse (f ‚àò pair (length l))) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chke3"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br><span><var>kc_spec</var><span class="hyp-type"><b>: </b><span>(g ‚ãÜ<span class="mi">6</span> f) ‚àò pair (length l) =
g ‚àò pair (length l) ‚ãÜ<span class="mi">2</span> f ‚àò pair (length l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (<span class="kr">fun</span> <span class="nv">a</span> : Vector (plength l) B =&gt;
   traverse (g ‚àò pair (length (trav_make l a)))
     (trav_make l a))
  (forwards
     (traverse (mkBackwards ‚àò (f ‚àò pair (length l)))
        (trav_contents l))) =
(map (traverse (g ‚àò pair (length l)))
 ‚àò traverse (f ‚àò pair (length l))) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chke4"><span class="nb">assert</span> (<span class="nb">cut</span>: (<span class="kr">fun</span> (<span class="nv">a</span>: Vector (plength l) B) =&gt;
                traverse (g ‚àò pair (length (trav_make l a))) (trav_make l a))
             =
               (<span class="kr">fun</span> (<span class="nv">a</span>: Vector (plength l) B) =&gt;
                  traverse (g ‚àò pair (length l)) (trav_make l a))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br><span><var>kc_spec</var><span class="hyp-type"><b>: </b><span>(g ‚ãÜ<span class="mi">6</span> f) ‚àò pair (length l) =
g ‚àò pair (length l) ‚ãÜ<span class="mi">2</span> f ‚àò pair (length l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">a</span> : Vector (plength l) B =&gt;
 traverse (g ‚àò pair (length (trav_make l a)))
   (trav_make l a)) =
traverse (g ‚àò pair (length l)) ‚óã trav_make l</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-v-chke5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br><span><var>kc_spec</var><span class="hyp-type"><b>: </b><span>(g ‚ãÜ<span class="mi">6</span> f) ‚àò pair (length l) =
g ‚àò pair (length l) ‚ãÜ<span class="mi">2</span> f ‚àò pair (length l)</span></span></span><br><span><var>cut</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">a</span> : Vector (plength l) B =&gt;
 traverse (g ‚àò pair (length (trav_make l a)))
   (trav_make l a)) =
traverse (g ‚àò pair (length l)) ‚óã trav_make l</span></span></span><br></div><label class="goal-separator" for="list-telescoping-v-chke5"><hr></label><div class="goal-conclusion">map
  (<span class="kr">fun</span> <span class="nv">a</span> : Vector (plength l) B =&gt;
   traverse (g ‚àò pair (length (trav_make l a)))
     (trav_make l a))
  (forwards
     (traverse (mkBackwards ‚àò (f ‚àò pair (length l)))
        (trav_contents l))) =
(map (traverse (g ‚àò pair (length l)))
 ‚àò traverse (f ‚àò pair (length l))) l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chke6">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br><span><var>kc_spec</var><span class="hyp-type"><b>: </b><span>(g ‚ãÜ<span class="mi">6</span> f) ‚àò pair (length l) =
g ‚àò pair (length l) ‚ãÜ<span class="mi">2</span> f ‚àò pair (length l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">a</span> : Vector (plength l) B =&gt;
 traverse (g ‚àò pair (length (trav_make l a)))
   (trav_make l a)) =
traverse (g ‚àò pair (length l)) ‚óã trav_make l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chke7">ext a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br><span><var>kc_spec</var><span class="hyp-type"><b>: </b><span>(g ‚ãÜ<span class="mi">6</span> f) ‚àò pair (length l) =
g ‚àò pair (length l) ‚ãÜ<span class="mi">2</span> f ‚àò pair (length l)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Vector (plength l) B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (g ‚àò pair (length (trav_make l a)))
  (trav_make l a) =
traverse (g ‚àò pair (length l)) (trav_make l a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chke8"><span class="nb">rewrite</span> &lt;- list_plength_length.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br><span><var>kc_spec</var><span class="hyp-type"><b>: </b><span>(g ‚ãÜ<span class="mi">6</span> f) ‚àò pair (length l) =
g ‚àò pair (length l) ‚ãÜ<span class="mi">2</span> f ‚àò pair (length l)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Vector (plength l) B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (g ‚àò pair (plength (trav_make l a)))
  (trav_make l a) =
traverse (g ‚àò pair (length l)) (trav_make l a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chke9"><span class="nb">rewrite</span> &lt;- list_plength_length.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br><span><var>kc_spec</var><span class="hyp-type"><b>: </b><span>(g ‚ãÜ<span class="mi">6</span> f) ‚àò pair (length l) =
g ‚àò pair (length l) ‚ãÜ<span class="mi">2</span> f ‚àò pair (length l)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Vector (plength l) B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (g ‚àò pair (plength (trav_make l a)))
  (trav_make l a) =
traverse (g ‚àò pair (plength l)) (trav_make l a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkea"><span class="nb">rewrite</span> &lt;- TraversableFunctor.plength_trav_make.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br><span><var>kc_spec</var><span class="hyp-type"><b>: </b><span>(g ‚ãÜ<span class="mi">6</span> f) ‚àò pair (length l) =
g ‚àò pair (length l) ‚ãÜ<span class="mi">2</span> f ‚àò pair (length l)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Vector (plength l) B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (g ‚àò pair (plength l)) (trav_make l a) =
traverse (g ‚àò pair (plength l)) (trav_make l a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkeb">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br><span><var>kc_spec</var><span class="hyp-type"><b>: </b><span>(g ‚ãÜ<span class="mi">6</span> f) ‚àò pair (length l) =
g ‚àò pair (length l) ‚ãÜ<span class="mi">2</span> f ‚àò pair (length l)</span></span></span><br><span><var>cut</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">a</span> : Vector (plength l) B =&gt;
 traverse (g ‚àò pair (length (trav_make l a)))
   (trav_make l a)) =
traverse (g ‚àò pair (length l)) ‚óã trav_make l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (<span class="kr">fun</span> <span class="nv">a</span> : Vector (plength l) B =&gt;
   traverse (g ‚àò pair (length (trav_make l a)))
     (trav_make l a))
  (forwards
     (traverse (mkBackwards ‚àò (f ‚àò pair (length l)))
        (trav_contents l))) =
(map (traverse (g ‚àò pair (length l)))
 ‚àò traverse (f ‚àò pair (length l))) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkec"><span class="nb">rewrite</span> <span class="nb">cut</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br><span><var>kc_spec</var><span class="hyp-type"><b>: </b><span>(g ‚ãÜ<span class="mi">6</span> f) ‚àò pair (length l) =
g ‚àò pair (length l) ‚ãÜ<span class="mi">2</span> f ‚àò pair (length l)</span></span></span><br><span><var>cut</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">a</span> : Vector (plength l) B =&gt;
 traverse (g ‚àò pair (length (trav_make l a)))
   (trav_make l a)) =
traverse (g ‚àò pair (length l)) ‚óã trav_make l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (traverse (g ‚àò pair (length l)) ‚óã trav_make l)
  (forwards
     (traverse (mkBackwards ‚àò (f ‚àò pair (length l)))
        (trav_contents l))) =
(map (traverse (g ‚àò pair (length l)))
 ‚àò traverse (f ‚àò pair (length l))) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chked"><span class="nb">change</span> (<span class="nl">?g</span> ‚óã trav_make l) <span class="kr">with</span> (g ‚àò trav_make l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br><span><var>kc_spec</var><span class="hyp-type"><b>: </b><span>(g ‚ãÜ<span class="mi">6</span> f) ‚àò pair (length l) =
g ‚àò pair (length l) ‚ãÜ<span class="mi">2</span> f ‚àò pair (length l)</span></span></span><br><span><var>cut</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">a</span> : Vector (plength l) B =&gt;
 traverse (g ‚àò pair (length (trav_make l a)))
   (trav_make l a)) =
traverse (g ‚àò pair (length l)) ‚óã trav_make l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (traverse (g ‚àò pair (length l)) ‚àò trav_make l)
  (forwards
     (traverse (mkBackwards ‚àò (f ‚àò pair (length l)))
        (trav_contents l))) =
(map (traverse (g ‚àò pair (length l)))
 ‚àò traverse (f ‚àò pair (length l))) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkee" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkee"><span class="nb">rewrite</span> &lt;- (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br><span><var>kc_spec</var><span class="hyp-type"><b>: </b><span>(g ‚ãÜ<span class="mi">6</span> f) ‚àò pair (length l) =
g ‚àò pair (length l) ‚ãÜ<span class="mi">2</span> f ‚àò pair (length l)</span></span></span><br><span><var>cut</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">a</span> : Vector (plength l) B =&gt;
 traverse (g ‚àò pair (length (trav_make l a)))
   (trav_make l a)) =
traverse (g ‚àò pair (length l)) ‚óã trav_make l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (traverse (g ‚àò pair (length l)))
 ‚àò map (trav_make l))
  (forwards
     (traverse (mkBackwards ‚àò (f ‚àò pair (length l)))
        (trav_contents l))) =
(map (traverse (g ‚àò pair (length l)))
 ‚àò traverse (f ‚àò pair (length l))) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkef"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br><span><var>kc_spec</var><span class="hyp-type"><b>: </b><span>(g ‚ãÜ<span class="mi">6</span> f) ‚àò pair (length l) =
g ‚àò pair (length l) ‚ãÜ<span class="mi">2</span> f ‚àò pair (length l)</span></span></span><br><span><var>cut</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">a</span> : Vector (plength l) B =&gt;
 traverse (g ‚àò pair (length (trav_make l a)))
   (trav_make l a)) =
traverse (g ‚àò pair (length l)) ‚óã trav_make l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (traverse (g ‚àò pair (length l)))
  (map (trav_make l)
     (forwards
        (traverse
           (mkBackwards ‚àò (f ‚àò pair (length l)))
           (trav_contents l)))) =
(map (traverse (g ‚àò pair (length l)))
 ‚àò traverse (f ‚àò pair (length l))) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkf0"><span class="nb">rewrite</span> &lt;- traverse_repr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>nat * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br><span><var>kc_spec</var><span class="hyp-type"><b>: </b><span>(g ‚ãÜ<span class="mi">6</span> f) ‚àò pair (length l) =
g ‚àò pair (length l) ‚ãÜ<span class="mi">2</span> f ‚àò pair (length l)</span></span></span><br><span><var>cut</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">a</span> : Vector (plength l) B =&gt;
 traverse (g ‚àò pair (length (trav_make l a)))
   (trav_make l a)) =
traverse (g ‚àò pair (length l)) ‚óã trav_make l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (traverse (g ‚àò pair (length l)))
  (traverse (f ‚àò pair (length l)) l) =
(map (traverse (g ‚àò pair (length l)))
 ‚àò traverse (f ‚àò pair (length l))) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkf1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (œï B ‚àò f ‚àò pair (length l)) l =
(œï (list B)
 ‚àò (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; traverse (f ‚àò pair (length l)) l))
  l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkf2"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; œï B (f (length l, a))) l =
œï (list B) (traverse (f ‚óã pair (length l)) l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkf3" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkf3">compose near l on <span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; œï B (f (length l, a))) l =
(œï (list B) ‚àò traverse (f ‚óã pair (length l))) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-v-chkf4"><span class="nb">rewrite</span> (trf_traverse_morphism).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; œï B (f (length l, a))) l =
traverse (œï B ‚àò (f ‚óã pair (length l))) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre>
</div>
</div></body>
</html>
