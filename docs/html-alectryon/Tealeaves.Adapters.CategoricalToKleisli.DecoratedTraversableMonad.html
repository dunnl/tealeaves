<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<title>DecoratedTraversableMonad.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.16.0+0.16.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Tealeaves <span class="kn">Require Import</span>
  Classes.Categorical.DecoratedTraversableMonad
  Classes.Kleisli.DecoratedTraversableMonad
  CategoricalToKleisli.DecoratedMonad
  CategoricalToKleisli.DecoratedFunctor (cobind_dec).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Product.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Kleisli.Monad.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Kleisli.DecoratedTraversableMonad.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Categorical.Monad.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Categorical.TraversableFunctor.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Strength.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Generalizable Variables</span> <span class="nf">W</span> T G œï A B C.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Kleisli presentation of D-T monads *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">ToKleisli</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Binddt_categorical</span>
    (<span class="nv">W</span> : <span class="kt">Type</span>)
    (<span class="nv">T</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    `{Map T}
    `{Decorate W T}
    `{ApplicativeDist T}
    `{Join T} : Binddt W T T :=
  <span class="kr">fun</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) `{Map G} `{Pure G} `{Mult G} (A B : <span class="kt">Type</span>)
    (f : W * A -&gt; G (T B)) =&gt;
    map (F := G) join ‚àò dist T G ‚àò map f ‚àò dec T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Tactic Notation</span> <span class="s2">&quot;bring&quot;</span> <span class="kp">constr</span>(x) <span class="s2">&quot;and&quot;</span> <span class="kp">constr</span>(y) <span class="s2">&quot;together&quot;</span> :=
    <span class="nb">change</span> (<span class="nl">?f</span> ‚àò x ‚àò y ‚àò <span class="nl">?g</span>) <span class="kr">with</span> (f ‚àò (x ‚àò y) ‚àò g).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">adapter</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
      `{Classes.Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad W T}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
      (<span class="nv">G1</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) `{Map G1} `{Pure G1} `{Mult G1} `{! Applicative G1}
      (G2 : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) `{Map G2} `{Pure G2} `{Mult G2} `{! Applicative G2}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">kcompose_dtm_alt</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>} :=
      <span class="kr">fun</span> `(g : W * B -&gt; G2 (T C))
        `(f : W * A -&gt; G1 (T B))
      =&gt; (map (F := G1) ((map (F := G2) (Œº))
                    ‚àò Œ¥ T G2
                    ‚àò map (F := T) (g ‚àò Œº (T := (W √ó)))
                    ‚àò œÉ
                    ‚àò map (F := (W √ó)) (dec T)))
          ‚àò œÉ
          ‚àò cobind (W := (W √ó)) f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk0"><span class="kn">Lemma</span> <span class="nf">equiv&#39;</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>} :
      <span class="kr">forall</span>  `(g : W * B -&gt; G2 (T C))
         `(f : W * A -&gt; G1 (T B)),
        g ‚ãÜ<span class="mi">7</span> f =
          kcompose_dtm_alt g f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">g</span> : W * B -&gt; G2 (T C)) (<span class="nv">f</span> : W * A -&gt; G1 (T B)),
g ‚ãÜ<span class="mi">7</span> f = kcompose_dtm_alt g f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">g</span> : W * B -&gt; G2 (T C)) (<span class="nv">f</span> : W * A -&gt; G1 (T B)),
g ‚ãÜ<span class="mi">7</span> f = kcompose_dtm_alt g f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk2"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g ‚ãÜ<span class="mi">7</span> f = kcompose_dtm_alt g f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk3"><span class="nb">unfold</span> kc7.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> &#39;(w, a) =&gt; map (binddt (preincr g w)) (f (w, a))) =
kcompose_dtm_alt g f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk4">unfold_ops @Binddt_categorical.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> &#39;(w, a) =&gt;
 map (map (Œº) ‚àò Œ¥ T G2 ‚àò map (preincr g w) ‚àò dec T)
   (f (w, a))) = kcompose_dtm_alt g f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk5">ext [w a].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map (Œº) ‚àò Œ¥ T G2 ‚àò map (preincr g w) ‚àò dec T)
  (f (w, a)) = kcompose_dtm_alt g f (w, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk6"><span class="nb">unfold</span> kcompose_dtm_alt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map (Œº) ‚àò Œ¥ T G2 ‚àò map (preincr g w) ‚àò dec T)
  (f (w, a)) =
(map
   (map (Œº) ‚àò Œ¥ T G2 ‚àò map (g ‚àò Œº) ‚àò œÉ ‚àò map (dec T))
 ‚àò œÉ ‚àò cobind f) (w, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk7"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">6</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map (Œº) ‚àò Œ¥ T G2 ‚àò map (preincr g w) ‚àò dec T)
  (f (w, a)) =
(map
   (map (Œº) ‚àò Œ¥ T G2 ‚àò map (g ‚àò Œº) ‚àò œÉ ‚àò map (dec T))
 ‚àò œÉ) (cobind f (w, a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk8"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map (Œº) ‚àò Œ¥ T G2 ‚àò map (preincr g w) ‚àò dec T)
  (f (w, a)) =
(map
   (map (Œº) ‚àò Œ¥ T G2 ‚àò map (g ‚àò Œº) ‚àò œÉ ‚àò map (dec T))
 ‚àò œÉ) (w, f (w, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk9"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">6</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map (Œº) ‚àò Œ¥ T G2 ‚àò map (preincr g w) ‚àò dec T)
  (f (w, a)) =
map (map (Œº) ‚àò Œ¥ T G2 ‚àò map (g ‚àò Œº) ‚àò œÉ ‚àò map (dec T))
  (œÉ (w, f (w, a)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chka"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map (Œº) ‚àò Œ¥ T G2 ‚àò map (preincr g w) ‚àò dec T)
  (f (w, a)) =
map (map (Œº) ‚àò Œ¥ T G2 ‚àò map (g ‚àò Œº) ‚àò œÉ ‚àò map (dec T))
  (map (pair w) (f (w, a)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chkb">compose near (f (w, a)) on <span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map (Œº) ‚àò Œ¥ T G2 ‚àò map (preincr g w) ‚àò dec T)
  (f (w, a)) =
(map
   (map (Œº) ‚àò Œ¥ T G2 ‚àò map (g ‚àò Œº) ‚àò œÉ ‚àò map (dec T))
 ‚àò map (pair w)) (f (w, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chkc"><span class="nb">rewrite</span> (fun_map_map (F := G1) (Functor := app_functor)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map (Œº) ‚àò Œ¥ T G2 ‚àò map (preincr g w) ‚àò dec T)
  (f (w, a)) =
map
  (map (Œº) ‚àò Œ¥ T G2 ‚àò map (g ‚àò Œº) ‚àò œÉ ‚àò map (dec T)
   ‚àò pair w) (f (w, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chkd"><span class="kp">repeat</span> fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Œº) ‚àò Œ¥ T G2 ‚àò map (preincr g w) ‚àò dec T =
map (Œº) ‚àò Œ¥ T G2 ‚àò map (g ‚àò Œº) ‚àò œÉ ‚àò map (dec T)
‚àò pair w</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chke">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (Œº) ‚àò Œ¥ T G2 ‚àò map (preincr g w) ‚àò dec T) t =
(map (Œº) ‚àò Œ¥ T G2 ‚àò map (g ‚àò Œº) ‚àò œÉ ‚àò map (dec T)
 ‚àò pair w) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chkf"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Œº) (Œ¥ T G2 (map (preincr g w) (dec T t))) =
map (Œº)
  (Œ¥ T G2 (map (g ‚óã Œº) (œÉ (map (dec T) (w, t)))))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk10"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Œº) (Œ¥ T G2 (map (preincr g w) (dec T t))) =
map (Œº)
  (Œ¥ T G2
     (map (g ‚óã Œº)
        (map (pair w) ((dec T ‚àò extract) (w, t)))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk11">compose near (dec T t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Œº) ((Œ¥ T G2 ‚àò map (preincr g w)) (dec T t)) =
map (Œº)
  (Œ¥ T G2
     (map (g ‚óã Œº)
        (map (pair w) ((dec T ‚àò extract) (w, t)))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk12"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Œº) (Œ¥ T G2 (map (preincr g w) (dec T t))) =
map (Œº)
  (Œ¥ T G2
     (map (g ‚óã Œº)
        (map (pair w) (dec T (extract (w, t))))))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk13"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Œº) (Œ¥ T G2 (map (preincr g w) (dec T t))) =
map (Œº)
  (Œ¥ T G2 (map (g ‚óã Œº) (map (pair w) (dec T t))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk14">compose near (dec T t) on <span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Œº) (Œ¥ T G2 (map (preincr g w) (dec T t))) =
map (Œº)
  (Œ¥ T G2 ((map (g ‚óã Œº) ‚àò map (pair w)) (dec T t)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk15"><span class="nb">rewrite</span> (fun_map_map (F := T)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Œº) (Œ¥ T G2 (map (preincr g w) (dec T t))) =
map (Œº) (Œ¥ T G2 (map (g ‚óã Œº ‚àò pair w) (dec T t)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk16"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Œº) (Œ¥ T G2 (map (preincr g w) (dec T t))) =
map (Œº)
  (Œ¥ T G2
     (map (<span class="kr">fun</span> <span class="nv">a</span> : W * B =&gt; g (Œº (w, a))) (dec T t)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk17"><span class="kp">repeat</span> fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">preincr g w = (<span class="kr">fun</span> <span class="nv">a</span> : W * B =&gt; g (Œº (w, a)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> ext [w&#39; b].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">adapter</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">with_monad</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
      `{Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad W T}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk18"><span class="kn">Theorem</span> <span class="nf">kdtm_binddt1_T</span> {<span class="nv">A</span>} :
      binddt (G := <span class="kr">fun</span> <span class="nv">A</span> =&gt; A) (Œ∑ (T := T) ‚àò extract) = @id (T A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">binddt (Œ∑ ‚àò extract) = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk19"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">binddt (Œ∑ ‚àò extract) = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk1a">unfold_ops @Binddt_categorical.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Œº) ‚àò Œ¥ T (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) ‚àò map (Œ∑ ‚àò extract)
‚àò dec T = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk1b"><span class="nb">change</span> (map (F := <span class="kr">fun</span> <span class="nv">A</span> =&gt; A) <span class="nl">?f</span>) <span class="kr">with</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œº ‚àò Œ¥ T (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) ‚àò map (Œ∑ ‚àò extract)
‚àò dec T = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk1c"><span class="nb">rewrite</span> (dist_unit (F := T)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œº ‚àò id ‚àò map (Œ∑ ‚àò extract) ‚àò dec T = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk1d"><span class="nb">change</span> (<span class="nl">?mu</span> ‚àò id) <span class="kr">with</span> mu.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œº ‚àò map (Œ∑ ‚àò extract) ‚àò dec T = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk1e"><span class="nb">rewrite</span> &lt;- fun_map_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œº ‚àò (map (Œ∑) ‚àò map extract) ‚àò dec T = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk1f"><span class="kp">do</span> <span class="mi">2</span> reassociate -&gt; on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œº ‚àò (map (Œ∑) ‚àò (map extract ‚àò dec T)) = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk20"><span class="nb">rewrite</span> dfun_dec_extract.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œº ‚àò (map (Œ∑) ‚àò id) = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk21">reassociate &lt;- on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œº ‚àò map (Œ∑) ‚àò id = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk22"><span class="nb">rewrite</span> (mon_join_map_ret (T := T)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">id ‚àò id = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk23"><span class="kn">Theorem</span> <span class="nf">kdtm_binddt0_T</span> : <span class="kr">forall</span>
        (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) `{Map G} `{Pure G} `{Mult G} `{! Applicative G}
        (A B : <span class="kt">Type</span>)
        (f : W * A -&gt; G (T B)),
        binddt f ‚àò Œ∑ (T := T) = f ‚àò Œ∑ (T := (W √ó)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H5</span> : Map G) (<span class="nv">H6</span> : Pure G)
  (<span class="nv">H7</span> : Mult G),
Applicative G -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : W * A -&gt; G (T B)),
binddt f ‚àò Œ∑ = f ‚àò Œ∑</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk24"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H5</span> : Map G) (<span class="nv">H6</span> : Pure G)
  (<span class="nv">H7</span> : Mult G),
Applicative G -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : W * A -&gt; G (T B)),
binddt f ‚àò Œ∑ = f ‚àò Œ∑</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk25"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G (T B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">binddt f ‚àò Œ∑ = f ‚àò Œ∑</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk26">unfold_ops @Binddt_categorical.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G (T B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Œº) ‚àò Œ¥ T G ‚àò map f ‚àò dec T ‚àò Œ∑ = f ‚àò Œ∑</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk27">reassociate -&gt; on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G (T B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Œº) ‚àò Œ¥ T G ‚àò map f ‚àò (dec T ‚àò Œ∑) = f ‚àò Œ∑</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk28"><span class="nb">rewrite</span> (dmon_ret (W := W) (T := T)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G (T B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Œº) ‚àò Œ¥ T G ‚àò map f ‚àò (Œ∑ ‚àò pair (monoid_unit W)) =
f ‚àò Œ∑</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk29">reassociate &lt;- on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G (T B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Œº) ‚àò Œ¥ T G ‚àò map f ‚àò Œ∑ ‚àò pair (monoid_unit W) =
f ‚àò Œ∑</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk2a">reassociate -&gt; near (Œ∑ (A := W * A)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G (T B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Œº) ‚àò Œ¥ T G ‚àò (map f ‚àò Œ∑) ‚àò pair (monoid_unit W) =
f ‚àò Œ∑</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk2b"><span class="nb">rewrite</span> (natural (œï := @ret T _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G (T B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Œº) ‚àò Œ¥ T G ‚àò (Œ∑ ‚àò map f) ‚àò pair (monoid_unit W) =
f ‚àò Œ∑</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk2c">unfold_ops @Map_I.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G (T B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Œº) ‚àò Œ¥ T G ‚àò (Œ∑ ‚àò f) ‚àò pair (monoid_unit W) =
f ‚àò Œ∑</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk2d">reassociate &lt;- on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G (T B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Œº) ‚àò Œ¥ T G ‚àò Œ∑ ‚àò f ‚àò pair (monoid_unit W) = f ‚àò Œ∑</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk2e">reassociate -&gt; near (Œ∑ (A := G (T B))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G (T B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Œº) ‚àò (Œ¥ T G ‚àò Œ∑) ‚àò f ‚àò pair (monoid_unit W) =
f ‚àò Œ∑</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk2f"><span class="nb">rewrite</span> (trvmon_ret (T := T)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G (T B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Œº) ‚àò map (Œ∑) ‚àò f ‚àò pair (monoid_unit W) = f ‚àò Œ∑</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk30"><span class="nb">rewrite</span> (fun_map_map (F := G) (Functor := app_functor)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G (T B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Œº ‚àò Œ∑) ‚àò f ‚àò pair (monoid_unit W) = f ‚àò Œ∑</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk31"><span class="nb">rewrite</span> (mon_join_ret (T := T)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G (T B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map id ‚àò f ‚àò pair (monoid_unit W) = f ‚àò Œ∑</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk32"><span class="nb">rewrite</span> (fun_map_id (F := G) (Functor := app_functor)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G (T B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">id ‚àò f ‚àò pair (monoid_unit W) = f ‚àò Œ∑</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">binddt_binddt</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
        (<span class="nv">G1</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
          `{Map G1} `{Pure G1} `{Mult G1} `{! Applicative G1}
          (G2 : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
          `{Map G2} `{Pure G2} `{Mult G2} `{! Applicative G2}
          `(g : W * B -&gt; G2 (T C)) `(f : W * A -&gt; G1 (T B)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Arguments</span> map (F)%function_scope {Map} {A B}%type_scope f%function_scope _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Arguments</span> dist F%function_scope {ApplicativeDist} G%function_scope {H H0 H1} (A)%type_scope _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Arguments</span> dec {E}%type_scope F%function_scope {Decorate} (A)%type_scope _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Arguments</span> join {T}%function_scope {Join} (A)%type_scope _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk33"><span class="kn">Theorem</span> <span class="nf">kdtm_binddt2_T</span> :
        map G1 (binddt (G := G2) g) ‚àò binddt (G := G1) f = binddt (G := G1 ‚àò G2) (g ‚ãÜ<span class="mi">7</span> f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1 (binddt g) ‚àò binddt f = binddt (g ‚ãÜ<span class="mi">7</span> f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk34"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1 (binddt g) ‚àò binddt f = binddt (g ‚ãÜ<span class="mi">7</span> f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk35"><span class="nb">rewrite</span> (equiv&#39; _ _ g f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1 (binddt g) ‚àò binddt f =
binddt (kcompose_dtm_alt G1 G2 g f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk36"><span class="nb">unfold</span> kcompose_dtm_alt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1 (binddt g) ‚àò binddt f =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        <span class="c">(* ********** *)</span>
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk37"><span class="nb">unfold</span> binddt <span class="nb">at</span> <span class="mi">1</span> <span class="mi">2</span>; <span class="nb">unfold</span> Binddt_categorical.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1
  (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g ‚àò dec T B)
‚àò (map G1 (Œº B) ‚àò Œ¥ T G1 (T B) ‚àò map T f ‚àò dec T A) =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk38"><span class="nb">assert</span> (Functor G1) <span class="bp">by</span> <span class="bp">now</span> <span class="nb">inversion</span> Applicative0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1
  (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g ‚àò dec T B)
‚àò (map G1 (Œº B) ‚àò Œ¥ T G1 (T B) ‚àò map T f ‚àò dec T A) =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk39"><span class="nb">assert</span> (Functor G2) <span class="bp">by</span> <span class="bp">now</span> <span class="nb">inversion</span> Applicative1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1
  (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g ‚àò dec T B)
‚àò (map G1 (Œº B) ‚àò Œ¥ T G1 (T B) ‚àò map T f ‚àò dec T A) =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        <span class="c">(* Normalize associativity *)</span>
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk3a"><span class="kp">do</span> <span class="mi">3</span> reassociate &lt;-.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1
  (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g ‚àò dec T B)
‚àò map G1 (Œº B) ‚àò Œ¥ T G1 (T B) ‚àò map T f ‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        <span class="c">(* Bring together &lt;&lt;map G1 (dec T B)&gt;&gt; and &lt;&lt;map G1 (Œº B)&gt;&gt; *)</span>
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk3b"><span class="nb">rewrite</span> &lt;- (fun_map_map (F := G1) (Functor := app_functor)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1 (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g)
‚àò map G1 (dec T B) ‚àò map G1 (Œº B) ‚àò Œ¥ T G1 (T B)
‚àò map T f ‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk3c">bring (map G1 (dec T B)) <span class="kn">and</span> (map G1 (Œº B)) together.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1 (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g)
‚àò (map G1 (dec T B) ‚àò map G1 (Œº B)) ‚àò Œ¥ T G1 (T B)
‚àò map T f ‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk3d"><span class="nb">rewrite</span> (fun_map_map (F := G1) (Functor := app_functor)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1 (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g)
‚àò map G1 (dec T B ‚àò Œº B) ‚àò Œ¥ T G1 (T B) ‚àò map T f
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk3e"><span class="nb">rewrite</span> dmon_join.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1 (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g)
‚àò map G1
    (Œº (W * B) ‚àò map T (shift T) ‚àò dec T (T (W * B))
     ‚àò map T (dec T B)) ‚àò Œ¥ T G1 (T B) ‚àò map T f
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        <span class="c">(* Move &lt;&lt;dec T (T (W * B))&gt;&gt; towards &lt;&lt;dec T A&gt;&gt; *)</span>
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk3f">reassociate -&gt; near (map T (dec T B)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1 (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g)
‚àò map G1
    (Œº (W * B) ‚àò map T (shift T)
     ‚àò (dec T (T (W * B)) ‚àò map T (dec T B)))
‚àò Œ¥ T G1 (T B) ‚àò map T f ‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk40"><span class="nb">rewrite</span> &lt;- (natural (œï := @dec W T _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1 (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g)
‚àò map G1
    (Œº (W * B) ‚àò map T (shift T)
     ‚àò (map (T ‚óã prod W) (dec T B) ‚àò dec T (T B)))
‚àò Œ¥ T G1 (T B) ‚àò map T f ‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk41">reassociate &lt;- on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1 (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g)
‚àò map G1
    (Œº (W * B) ‚àò map T (shift T)
     ‚àò map (T ‚óã prod W) (dec T B) ‚àò dec T (T B))
‚àò Œ¥ T G1 (T B) ‚àò map T f ‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk42"><span class="nb">rewrite</span> &lt;- (fun_map_map
                     (F := G1)
                     _ _ _
                     (dec T (T B))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1 (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g)
‚àò (map G1
     (Œº (W * B) ‚àò map T (shift T)
      ‚àò map (T ‚óã prod W) (dec T B))
   ‚àò map G1 (dec T (T B))) ‚àò Œ¥ T G1 (T B) ‚àò map T f
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk43">reassociate &lt;- on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1 (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g)
‚àò map G1
    (Œº (W * B) ‚àò map T (shift T)
     ‚àò map (T ‚óã prod W) (dec T B))
‚àò map G1 (dec T (T B)) ‚àò Œ¥ T G1 (T B) ‚àò map T f
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk44">bring (map G1 (dec T (T B))) <span class="kn">and</span> (Œ¥ T G1 (T B)) together.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1 (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g)
‚àò map G1
    (Œº (W * B) ‚àò map T (shift T)
     ‚àò map (T ‚óã prod W) (dec T B))
‚àò (map G1 (dec T (T B)) ‚àò Œ¥ T G1 (T B)) ‚àò map T f
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk45"><span class="nb">rewrite</span> &lt;- (dtfun_compat (F := T) (G := G1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1 (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g)
‚àò map G1
    (Œº (W * B) ‚àò map T (shift T)
     ‚àò map (T ‚óã prod W) (dec T B))
‚àò (Œ¥ T G1 (W * T B) ‚àò map T (œÉ) ‚àò dec T (G1 (T B)))
‚àò map T f ‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk46"><span class="kp">do</span> <span class="mi">2</span> reassociate &lt;- on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1 (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g)
‚àò map G1
    (Œº (W * B) ‚àò map T (shift T)
     ‚àò map (T ‚óã prod W) (dec T B)) ‚àò Œ¥ T G1 (W * T B)
‚àò map T (œÉ) ‚àò dec T (G1 (T B)) ‚àò map T f ‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk47">bring (dec T (G1 (T B))) <span class="kn">and</span> (map T f) together.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1 (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g)
‚àò map G1
    (Œº (W * B) ‚àò map T (shift T)
     ‚àò map (T ‚óã prod W) (dec T B)) ‚àò Œ¥ T G1 (W * T B)
‚àò map T (œÉ) ‚àò (dec T (G1 (T B)) ‚àò map T f) ‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk48"><span class="nb">rewrite</span> &lt;- (natural (œï := @dec W T _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1 (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g)
‚àò map G1
    (Œº (W * B) ‚àò map T (shift T)
     ‚àò map (T ‚óã prod W) (dec T B)) ‚àò Œ¥ T G1 (W * T B)
‚àò map T (œÉ) ‚àò (map (T ‚óã prod W) f ‚àò dec T (W * A))
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk49"><span class="nb">change</span> (map (T ‚óã prod W) f) <span class="kr">with</span> (map (T ‚àò prod W) f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1 (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g)
‚àò map G1
    (Œº (W * B) ‚àò map T (shift T)
     ‚àò map (T ‚óã prod W) (dec T B)) ‚àò Œ¥ T G1 (W * T B)
‚àò map T (œÉ) ‚àò (map (T ‚àò prod W) f ‚àò dec T (W * A))
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk4a">reassociate &lt;- on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1 (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g)
‚àò map G1
    (Œº (W * B) ‚àò map T (shift T)
     ‚àò map (T ‚óã prod W) (dec T B)) ‚àò Œ¥ T G1 (W * T B)
‚àò map T (œÉ) ‚àò map (T ‚àò prod W) f ‚àò dec T (W * A)
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk4b">reassociate -&gt; near (dec T A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1 (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g)
‚àò map G1
    (Œº (W * B) ‚àò map T (shift T)
     ‚àò map (T ‚óã prod W) (dec T B)) ‚àò Œ¥ T G1 (W * T B)
‚àò map T (œÉ) ‚àò map (T ‚àò prod W) f
‚àò (dec T (W * A) ‚àò dec T A) =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        <span class="c">(* Change decorate-then-decorate into decorate-then-duplicate *)</span>
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk4c"><span class="nb">rewrite</span> dfun_dec_dec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1 (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g)
‚àò map G1
    (Œº (W * B) ‚àò map T (shift T)
     ‚àò map (T ‚óã prod W) (dec T B)) ‚àò Œ¥ T G1 (W * T B)
‚àò map T (œÉ) ‚àò map (T ‚àò prod W) f
‚àò (map T cojoin ‚àò dec T A) =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk4d">reassociate &lt;- on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1 (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g)
‚àò map G1
    (Œº (W * B) ‚àò map T (shift T)
     ‚àò map (T ‚óã prod W) (dec T B)) ‚àò Œ¥ T G1 (W * T B)
‚àò map T (œÉ) ‚àò map (T ‚àò prod W) f ‚àò map T cojoin
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        <span class="c">(* Now move &lt;&lt;Œº B&gt;&gt; towards &lt;&lt;Œº C&gt;&gt; *)</span>
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk4e"><span class="nb">unfold</span> shift; <span class="nb">rewrite</span> incr_spec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1 (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g)
‚àò map G1
    (Œº (W * B) ‚àò map T (map T (Œº B) ‚àò œÉ)
     ‚àò map (T ‚óã prod W) (dec T B)) ‚àò Œ¥ T G1 (W * T B)
‚àò map T (œÉ) ‚àò map (T ‚àò prod W) f ‚àò map T cojoin
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk4f"><span class="nb">change</span> (Œº (W * B) ‚àò map T (map T (Œº B) ‚àò œÉ) ‚àò map (T ‚óã prod W) (dec T B)) <span class="kr">with</span>
          (Œº (W * B) ‚àò (map T (map T (Œº B) ‚àò œÉ) ‚àò map (T ‚óã prod W) (dec T B))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1 (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g)
‚àò map G1
    (Œº (W * B)
     ‚àò (map T (map T (Œº B) ‚àò œÉ)
        ‚àò map (T ‚óã prod W) (dec T B)))
‚àò Œ¥ T G1 (W * T B) ‚àò map T (œÉ) ‚àò map (T ‚àò prod W) f
‚àò map T cojoin ‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk50"><span class="nb">rewrite</span> &lt;- (fun_map_map (F := G1) (Functor := app_functor) _ _ _ _ (Œº (W * B))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1 (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g)
‚àò (map G1 (Œº (W * B))
   ‚àò map G1
       (map T (map T (Œº B) ‚àò œÉ)
        ‚àò map (T ‚óã prod W) (dec T B)))
‚àò Œ¥ T G1 (W * T B) ‚àò map T (œÉ) ‚àò map (T ‚àò prod W) f
‚àò map T cojoin ‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk51">reassociate &lt;- on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1 (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g)
‚àò map G1 (Œº (W * B))
‚àò map G1
    (map T (map T (Œº B) ‚àò œÉ)
     ‚àò map (T ‚óã prod W) (dec T B)) ‚àò Œ¥ T G1 (W * T B)
‚àò map T (œÉ) ‚àò map (T ‚àò prod W) f ‚àò map T cojoin
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk52"><span class="nb">rewrite</span> (fun_map_map (F := G1) _ _ _ (Œº (W * B))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1
  (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g ‚àò Œº (W * B))
‚àò map G1
    (map T (map T (Œº B) ‚àò œÉ)
     ‚àò map (T ‚óã prod W) (dec T B)) ‚àò Œ¥ T G1 (W * T B)
‚àò map T (œÉ) ‚àò map (T ‚àò prod W) f ‚àò map T cojoin
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk53">reassociate -&gt; near (Œº (W * B)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1
  (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò (map T g ‚àò Œº (W * B)))
‚àò map G1
    (map T (map T (Œº B) ‚àò œÉ)
     ‚àò map (T ‚óã prod W) (dec T B)) ‚àò Œ¥ T G1 (W * T B)
‚àò map T (œÉ) ‚àò map (T ‚àò prod W) f ‚àò map T cojoin
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk54"><span class="nb">rewrite</span> (natural (œï := join)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1
  (map G2 (Œº C) ‚àò Œ¥ T G2 (T C)
   ‚àò (Œº (G2 (T C)) ‚àò map (T ‚àò T) g))
‚àò map G1
    (map T (map T (Œº B) ‚àò œÉ)
     ‚àò map (T ‚óã prod W) (dec T B)) ‚àò Œ¥ T G1 (W * T B)
‚àò map T (œÉ) ‚àò map (T ‚àò prod W) f ‚àò map T cojoin
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk55">reassociate &lt;- on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1
  (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò Œº (G2 (T C))
   ‚àò map (T ‚àò T) g)
‚àò map G1
    (map T (map T (Œº B) ‚àò œÉ)
     ‚àò map (T ‚óã prod W) (dec T B)) ‚àò Œ¥ T G1 (W * T B)
‚àò map T (œÉ) ‚àò map (T ‚àò prod W) f ‚àò map T cojoin
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk56">bring (Œ¥ T G2 (T C)) <span class="kn">and</span> (Œº (G2 (T C))) together.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1
  (map G2 (Œº C) ‚àò (Œ¥ T G2 (T C) ‚àò Œº (G2 (T C)))
   ‚àò map (T ‚àò T) g)
‚àò map G1
    (map T (map T (Œº B) ‚àò œÉ)
     ‚àò map (T ‚óã prod W) (dec T B)) ‚àò Œ¥ T G1 (W * T B)
‚àò map T (œÉ) ‚àò map (T ‚àò prod W) f ‚àò map T cojoin
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk57"><span class="nb">rewrite</span> trvmon_join.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1
  (map G2 (Œº C)
   ‚àò (map G2 (Œº (T C)) ‚àò Œ¥ T G2 (T (T C))
      ‚àò map T (Œ¥ T G2 (T C))) ‚àò map (T ‚àò T) g)
‚àò map G1
    (map T (map T (Œº B) ‚àò œÉ)
     ‚àò map (T ‚óã prod W) (dec T B)) ‚àò Œ¥ T G1 (W * T B)
‚àò map T (œÉ) ‚àò map (T ‚àò prod W) f ‚àò map T cojoin
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk58"><span class="kp">do</span> <span class="mi">2</span> reassociate &lt;- on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1
  (map G2 (Œº C) ‚àò map G2 (Œº (T C)) ‚àò Œ¥ T G2 (T (T C))
   ‚àò map T (Œ¥ T G2 (T C)) ‚àò map (T ‚àò T) g)
‚àò map G1
    (map T (map T (Œº B) ‚àò œÉ)
     ‚àò map (T ‚óã prod W) (dec T B)) ‚àò Œ¥ T G1 (W * T B)
‚àò map T (œÉ) ‚àò map (T ‚àò prod W) f ‚àò map T cojoin
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk59"><span class="nb">rewrite</span> (fun_map_map (F := G2)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1
  (map G2 (Œº C ‚àò Œº (T C)) ‚àò Œ¥ T G2 (T (T C))
   ‚àò map T (Œ¥ T G2 (T C)) ‚àò map (T ‚àò T) g)
‚àò map G1
    (map T (map T (Œº B) ‚àò œÉ)
     ‚àò map (T ‚óã prod W) (dec T B)) ‚àò Œ¥ T G1 (W * T B)
‚àò map T (œÉ) ‚àò map (T ‚àò prod W) f ‚àò map T cojoin
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        <span class="c">(* Change map-join-then-join into join-then-join *)</span>
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk5a"><span class="nb">rewrite</span> (mon_join_join (T := T)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1
  (map G2 (Œº C ‚àò map T (Œº C)) ‚àò Œ¥ T G2 (T (T C))
   ‚àò map T (Œ¥ T G2 (T C)) ‚àò map (T ‚àò T) g)
‚àò map G1
    (map T (map T (Œº B) ‚àò œÉ)
     ‚àò map (T ‚óã prod W) (dec T B)) ‚àò Œ¥ T G1 (W * T B)
‚àò map T (œÉ) ‚àò map (T ‚àò prod W) f ‚àò map T cojoin
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        <span class="c">(* Now rearrange to match RHS *)</span>
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk5b"><span class="nb">rewrite</span> &lt;- (fun_map_map (F := G2)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1
  (map G2 (Œº C) ‚àò map G2 (map T (Œº C))
   ‚àò Œ¥ T G2 (T (T C)) ‚àò map T (Œ¥ T G2 (T C))
   ‚àò map (T ‚àò T) g)
‚àò map G1
    (map T (map T (Œº B) ‚àò œÉ)
     ‚àò map (T ‚óã prod W) (dec T B)) ‚àò Œ¥ T G1 (W * T B)
‚àò map T (œÉ) ‚àò map (T ‚àò prod W) f ‚àò map T cojoin
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk5c"><span class="nb">change</span> (map G2 (Œº C) ‚àò map G2 (map T (Œº C)) ‚àò Œ¥ T G2 (T (T C)) ‚àò map T (Œ¥ T G2 (T C)) ‚àò map (T ‚àò T) g)
          <span class="kr">with</span> (map G2 (Œº C) ‚àò (map G2 (map T (Œº C)) ‚àò Œ¥ T G2 (T (T C)) ‚àò map T (Œ¥ T G2 (T C)) ‚àò map (T ‚àò T) g)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1
  (map G2 (Œº C)
   ‚àò (map G2 (map T (Œº C)) ‚àò Œ¥ T G2 (T (T C))
      ‚àò map T (Œ¥ T G2 (T C)) ‚àò map (T ‚àò T) g))
‚àò map G1
    (map T (map T (Œº B) ‚àò œÉ)
     ‚àò map (T ‚óã prod W) (dec T B)) ‚àò Œ¥ T G1 (W * T B)
‚àò map T (œÉ) ‚àò map (T ‚àò prod W) f ‚àò map T cojoin
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk5d"><span class="nb">rewrite</span> &lt;- (fun_map_map (F := G1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map G1 (map G2 (Œº C))
‚àò map G1
    (map G2 (map T (Œº C)) ‚àò Œ¥ T G2 (T (T C))
     ‚àò map T (Œ¥ T G2 (T C)) ‚àò map (T ‚àò T) g)
‚àò map G1
    (map T (map T (Œº B) ‚àò œÉ)
     ‚àò map (T ‚óã prod W) (dec T B)) ‚àò Œ¥ T G1 (W * T B)
‚àò map T (œÉ) ‚àò map (T ‚àò prod W) f ‚àò map T cojoin
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk5e"><span class="nb">change</span> (map G1 (map G2 <span class="nl">?f</span>)) <span class="kr">with</span> (map (G1 ‚àò G2) f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (G1 ‚àò G2) (Œº C)
‚àò map G1
    (map G2 (map T (Œº C)) ‚àò Œ¥ T G2 (T (T C))
     ‚àò map T (Œ¥ T G2 (T C)) ‚àò map (T ‚àò T) g)
‚àò map G1
    (map T (map T (Œº B) ‚àò œÉ)
     ‚àò map (T ‚óã prod W) (dec T B)) ‚àò Œ¥ T G1 (W * T B)
‚àò map T (œÉ) ‚àò map (T ‚àò prod W) f ‚àò map T cojoin
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk5f"><span class="nb">change</span> (map G2 (map T <span class="nl">?mu</span>)) <span class="kr">with</span> (map (G2 ‚àò T) mu).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (G1 ‚àò G2) (Œº C)
‚àò map G1
    (map (G2 ‚àò T) (Œº C) ‚àò Œ¥ T G2 (T (T C))
     ‚àò map T (Œ¥ T G2 (T C)) ‚àò map (T ‚àò T) g)
‚àò map G1
    (map T (map T (Œº B) ‚àò œÉ)
     ‚àò map (T ‚óã prod W) (dec T B)) ‚àò Œ¥ T G1 (W * T B)
‚àò map T (œÉ) ‚àò map (T ‚àò prod W) f ‚àò map T cojoin
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk60"><span class="nb">rewrite</span> (natural (œï := dist T G2)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (G1 ‚àò G2) (Œº C)
‚àò map G1
    (Œ¥ T G2 (T C) ‚àò map (T ‚óã G2) (Œº C)
     ‚àò map T (Œ¥ T G2 (T C)) ‚àò map (T ‚àò T) g)
‚àò map G1
    (map T (map T (Œº B) ‚àò œÉ)
     ‚àò map (T ‚óã prod W) (dec T B)) ‚àò Œ¥ T G1 (W * T B)
‚àò map T (œÉ) ‚àò map (T ‚àò prod W) f ‚àò map T cojoin
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk61"><span class="nb">change</span> (map (T ‚óã G2) <span class="nl">?f</span>) <span class="kr">with</span> (map T (map G2 f)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (G1 ‚àò G2) (Œº C)
‚àò map G1
    (Œ¥ T G2 (T C) ‚àò map T (map G2 (Œº C))
     ‚àò map T (Œ¥ T G2 (T C)) ‚àò map (T ‚àò T) g)
‚àò map G1
    (map T (map T (Œº B) ‚àò œÉ)
     ‚àò map (T ‚óã prod W) (dec T B)) ‚àò Œ¥ T G1 (W * T B)
‚àò map T (œÉ) ‚àò map (T ‚àò prod W) f ‚àò map T cojoin
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk62">reassociate -&gt; near (map T (Œ¥ T G2 (T C))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (G1 ‚àò G2) (Œº C)
‚àò map G1
    (Œ¥ T G2 (T C)
     ‚àò (map T (map G2 (Œº C)) ‚àò map T (Œ¥ T G2 (T C)))
     ‚àò map (T ‚àò T) g)
‚àò map G1
    (map T (map T (Œº B) ‚àò œÉ)
     ‚àò map (T ‚óã prod W) (dec T B)) ‚àò Œ¥ T G1 (W * T B)
‚àò map T (œÉ) ‚àò map (T ‚àò prod W) f ‚àò map T cojoin
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk63"><span class="nb">rewrite</span> (fun_map_map (F := T)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (G1 ‚àò G2) (Œº C)
‚àò map G1
    (Œ¥ T G2 (T C)
     ‚àò map T (map G2 (Œº C) ‚àò Œ¥ T G2 (T C))
     ‚àò map (T ‚àò T) g)
‚àò map G1
    (map T (map T (Œº B) ‚àò œÉ)
     ‚àò map (T ‚óã prod W) (dec T B)) ‚àò Œ¥ T G1 (W * T B)
‚àò map T (œÉ) ‚àò map (T ‚àò prod W) f ‚àò map T cojoin
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk64"><span class="nb">change</span> (map (T ‚óã prod W) <span class="nl">?f</span>) <span class="kr">with</span> (map T (map (W √ó) f)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (G1 ‚àò G2) (Œº C)
‚àò map G1
    (Œ¥ T G2 (T C)
     ‚àò map T (map G2 (Œº C) ‚àò Œ¥ T G2 (T C))
     ‚àò map (T ‚àò T) g)
‚àò map G1
    (map T (map T (Œº B) ‚àò œÉ)
     ‚àò map T (map (prod W) (dec T B)))
‚àò Œ¥ T G1 (W * T B) ‚àò map T (œÉ) ‚àò map (T ‚àò prod W) f
‚àò map T cojoin ‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk65"><span class="nb">rewrite</span> (fun_map_map (F := T)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (G1 ‚àò G2) (Œº C)
‚àò map G1
    (Œ¥ T G2 (T C)
     ‚àò map T (map G2 (Œº C) ‚àò Œ¥ T G2 (T C))
     ‚àò map (T ‚àò T) g)
‚àò map G1
    (map T (map T (Œº B) ‚àò œÉ ‚àò map (prod W) (dec T B)))
‚àò Œ¥ T G1 (W * T B) ‚àò map T (œÉ) ‚àò map (T ‚àò prod W) f
‚àò map T cojoin ‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk66">reassociate -&gt; near (Œ¥ T G1 (W * T B)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (G1 ‚àò G2) (Œº C)
‚àò map G1
    (Œ¥ T G2 (T C)
     ‚àò map T (map G2 (Œº C) ‚àò Œ¥ T G2 (T C))
     ‚àò map (T ‚àò T) g)
‚àò (map G1
     (map T (map T (Œº B) ‚àò œÉ ‚àò map (prod W) (dec T B)))
   ‚àò Œ¥ T G1 (W * T B)) ‚àò map T (œÉ)
‚àò map (T ‚àò prod W) f ‚àò map T cojoin ‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk67"><span class="nb">change</span> (map G1 (map T <span class="nl">?f</span>)) <span class="kr">with</span> (map (G1 ‚óã T) f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (G1 ‚àò G2) (Œº C)
‚àò map G1
    (Œ¥ T G2 (T C)
     ‚àò map T (map G2 (Œº C) ‚àò Œ¥ T G2 (T C))
     ‚àò map (T ‚àò T) g)
‚àò (map (G1 ‚óã T)
     (map T (Œº B) ‚àò œÉ ‚àò map (prod W) (dec T B))
   ‚àò Œ¥ T G1 (W * T B)) ‚àò map T (œÉ)
‚àò map (T ‚àò prod W) f ‚àò map T cojoin ‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk68"><span class="nb">rewrite</span> (natural (œï := dist T G1) (A := (W * T B)) (B := (T (W * B)))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (G1 ‚àò G2) (Œº C)
‚àò map G1
    (Œ¥ T G2 (T C)
     ‚àò map T (map G2 (Œº C) ‚àò Œ¥ T G2 (T C))
     ‚àò map (T ‚àò T) g)
‚àò (Œ¥ T G1 (T (W * B))
   ‚àò map (T ‚óã G1)
       (map T (Œº B) ‚àò œÉ ‚àò map (prod W) (dec T B)))
‚àò map T (œÉ) ‚àò map (T ‚àò prod W) f ‚àò map T cojoin
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk69">reassociate &lt;- on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (G1 ‚àò G2) (Œº C)
‚àò map G1
    (Œ¥ T G2 (T C)
     ‚àò map T (map G2 (Œº C) ‚àò Œ¥ T G2 (T C))
     ‚àò map (T ‚àò T) g) ‚àò Œ¥ T G1 (T (W * B))
‚àò map (T ‚óã G1)
    (map T (Œº B) ‚àò œÉ ‚àò map (prod W) (dec T B))
‚àò map T (œÉ) ‚àò map (T ‚àò prod W) f ‚àò map T cojoin
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk6a"><span class="nb">change</span> (map (T ‚àò T) <span class="nl">?g</span>) <span class="kr">with</span> (map T (map T g)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (G1 ‚àò G2) (Œº C)
‚àò map G1
    (Œ¥ T G2 (T C)
     ‚àò map T (map G2 (Œº C) ‚àò Œ¥ T G2 (T C))
     ‚àò map T (map T g)) ‚àò Œ¥ T G1 (T (W * B))
‚àò map (T ‚óã G1)
    (map T (Œº B) ‚àò œÉ ‚àò map (prod W) (dec T B))
‚àò map T (œÉ) ‚àò map (T ‚àò prod W) f ‚àò map T cojoin
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk6b">reassociate -&gt; near (map T (map T g)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (G1 ‚àò G2) (Œº C)
‚àò map G1
    (Œ¥ T G2 (T C)
     ‚àò (map T (map G2 (Œº C) ‚àò Œ¥ T G2 (T C))
        ‚àò map T (map T g))) ‚àò Œ¥ T G1 (T (W * B))
‚àò map (T ‚óã G1)
    (map T (Œº B) ‚àò œÉ ‚àò map (prod W) (dec T B))
‚àò map T (œÉ) ‚àò map (T ‚àò prod W) f ‚àò map T cojoin
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk6c"><span class="nb">rewrite</span> (fun_map_map (F := T)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (G1 ‚àò G2) (Œº C)
‚àò map G1
    (Œ¥ T G2 (T C)
     ‚àò map T (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g))
‚àò Œ¥ T G1 (T (W * B))
‚àò map (T ‚óã G1)
    (map T (Œº B) ‚àò œÉ ‚àò map (prod W) (dec T B))
‚àò map T (œÉ) ‚àò map (T ‚àò prod W) f ‚àò map T cojoin
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk6d"><span class="nb">rewrite</span> &lt;- (fun_map_map (F := G1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (G1 ‚àò G2) (Œº C)
‚àò (map G1 (Œ¥ T G2 (T C))
   ‚àò map G1
       (map T (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g)))
‚àò Œ¥ T G1 (T (W * B))
‚àò map (T ‚óã G1)
    (map T (Œº B) ‚àò œÉ ‚àò map (prod W) (dec T B))
‚àò map T (œÉ) ‚àò map (T ‚àò prod W) f ‚àò map T cojoin
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk6e">reassociate &lt;- on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (G1 ‚àò G2) (Œº C) ‚àò map G1 (Œ¥ T G2 (T C))
‚àò map G1
    (map T (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g))
‚àò Œ¥ T G1 (T (W * B))
‚àò map (T ‚óã G1)
    (map T (Œº B) ‚àò œÉ ‚àò map (prod W) (dec T B))
‚àò map T (œÉ) ‚àò map (T ‚àò prod W) f ‚àò map T cojoin
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk6f"><span class="nb">change</span> (map G1 (map T <span class="nl">?f</span>)) <span class="kr">with</span> (map (G1 ‚óã T) f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (G1 ‚àò G2) (Œº C) ‚àò map G1 (Œ¥ T G2 (T C))
‚àò map (G1 ‚óã T) (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g)
‚àò Œ¥ T G1 (T (W * B))
‚àò map (T ‚óã G1)
    (map T (Œº B) ‚àò œÉ ‚àò map (prod W) (dec T B))
‚àò map T (œÉ) ‚àò map (T ‚àò prod W) f ‚àò map T cojoin
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk70">reassociate -&gt; near (Œ¥ T G1 (T (W * B))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (G1 ‚àò G2) (Œº C) ‚àò map G1 (Œ¥ T G2 (T C))
‚àò (map (G1 ‚óã T)
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g)
   ‚àò Œ¥ T G1 (T (W * B)))
‚àò map (T ‚óã G1)
    (map T (Œº B) ‚àò œÉ ‚àò map (prod W) (dec T B))
‚àò map T (œÉ) ‚àò map (T ‚àò prod W) f ‚àò map T cojoin
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk71"><span class="nb">rewrite</span> (natural (œï := Œ¥ T G1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (G1 ‚àò G2) (Œº C) ‚àò map G1 (Œ¥ T G2 (T C))
‚àò (Œ¥ T G1 (G2 (T C))
   ‚àò map (T ‚óã G1)
       (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g))
‚àò map (T ‚óã G1)
    (map T (Œº B) ‚àò œÉ ‚àò map (prod W) (dec T B))
‚àò map T (œÉ) ‚àò map (T ‚àò prod W) f ‚àò map T cojoin
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk72">reassociate &lt;- on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (G1 ‚àò G2) (Œº C) ‚àò map G1 (Œ¥ T G2 (T C))
‚àò Œ¥ T G1 (G2 (T C))
‚àò map (T ‚óã G1) (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g)
‚àò map (T ‚óã G1)
    (map T (Œº B) ‚àò œÉ ‚àò map (prod W) (dec T B))
‚àò map T (œÉ) ‚àò map (T ‚àò prod W) f ‚àò map T cojoin
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk73">reassociate -&gt; near (map (T ‚óã G1) (map T (Œº B) ‚àò œÉ ‚àò map (prod W) (dec T B))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (G1 ‚àò G2) (Œº C) ‚àò map G1 (Œ¥ T G2 (T C))
‚àò Œ¥ T G1 (G2 (T C))
‚àò (map (T ‚óã G1)
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g)
   ‚àò map (T ‚óã G1)
       (map T (Œº B) ‚àò œÉ ‚àò map (prod W) (dec T B)))
‚àò map T (œÉ) ‚àò map (T ‚àò prod W) f ‚àò map T cojoin
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk74"><span class="nb">rewrite</span> (fun_map_map (F := T ‚óã G1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (G1 ‚àò G2) (Œº C) ‚àò map G1 (Œ¥ T G2 (T C))
‚àò Œ¥ T G1 (G2 (T C))
‚àò map (T ‚óã G1)
    (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g
     ‚àò (map T (Œº B) ‚àò œÉ ‚àò map (prod W) (dec T B)))
‚àò map T (œÉ) ‚àò map (T ‚àò prod W) f ‚àò map T cojoin
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk75"><span class="nb">change</span> (map (T ‚àò prod W) f) <span class="kr">with</span> (map T (map (prod W) f)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (G1 ‚àò G2) (Œº C) ‚àò map G1 (Œ¥ T G2 (T C))
‚àò Œ¥ T G1 (G2 (T C))
‚àò map (T ‚óã G1)
    (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g
     ‚àò (map T (Œº B) ‚àò œÉ ‚àò map (prod W) (dec T B)))
‚àò map T (œÉ) ‚àò map T (map (prod W) f) ‚àò map T cojoin
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk76"><span class="nb">change</span> (map (T ‚óã G1) <span class="nl">?f</span>) <span class="kr">with</span> (map T (map G1 f)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (G1 ‚àò G2) (Œº C) ‚àò map G1 (Œ¥ T G2 (T C))
‚àò Œ¥ T G1 (G2 (T C))
‚àò map T
    (map G1
       (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g
        ‚àò (map T (Œº B) ‚àò œÉ ‚àò map (prod W) (dec T B))))
‚àò map T (œÉ) ‚àò map T (map (prod W) f) ‚àò map T cojoin
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk77">reassociate -&gt; near (map T cojoin).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (G1 ‚àò G2) (Œº C) ‚àò map G1 (Œ¥ T G2 (T C))
‚àò Œ¥ T G1 (G2 (T C))
‚àò map T
    (map G1
       (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g
        ‚àò (map T (Œº B) ‚àò œÉ ‚àò map (prod W) (dec T B))))
‚àò map T (œÉ) ‚àò (map T (map (prod W) f) ‚àò map T cojoin)
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk78"><span class="nb">rewrite</span> (fun_map_map (F := T)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (G1 ‚àò G2) (Œº C) ‚àò map G1 (Œ¥ T G2 (T C))
‚àò Œ¥ T G1 (G2 (T C))
‚àò map T
    (map G1
       (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g
        ‚àò (map T (Œº B) ‚àò œÉ ‚àò map (prod W) (dec T B))))
‚àò map T (œÉ) ‚àò map T (map (prod W) f ‚àò cojoin)
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk79">reassociate -&gt; near (map T (map (prod W) f ‚àò cojoin)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (G1 ‚àò G2) (Œº C) ‚àò map G1 (Œ¥ T G2 (T C))
‚àò Œ¥ T G1 (G2 (T C))
‚àò map T
    (map G1
       (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g
        ‚àò (map T (Œº B) ‚àò œÉ ‚àò map (prod W) (dec T B))))
‚àò (map T (œÉ) ‚àò map T (map (prod W) f ‚àò cojoin))
‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk7a"><span class="nb">rewrite</span> (fun_map_map (F := T)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (G1 ‚àò G2) (Œº C) ‚àò map G1 (Œ¥ T G2 (T C))
‚àò Œ¥ T G1 (G2 (T C))
‚àò map T
    (map G1
       (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g
        ‚àò (map T (Œº B) ‚àò œÉ ‚àò map (prod W) (dec T B))))
‚àò map T (œÉ ‚àò (map (prod W) f ‚àò cojoin)) ‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk7b">reassociate -&gt; near (map T (œÉ ‚àò (map (prod W) f ‚àò cojoin))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (G1 ‚àò G2) (Œº C) ‚àò map G1 (Œ¥ T G2 (T C))
‚àò Œ¥ T G1 (G2 (T C))
‚àò (map T
     (map G1
        (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g
         ‚àò (map T (Œº B) ‚àò œÉ ‚àò map (prod W) (dec T B))))
   ‚àò map T (œÉ ‚àò (map (prod W) f ‚àò cojoin))) ‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk7c"><span class="nb">rewrite</span> (fun_map_map (F := T)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (G1 ‚àò G2) (Œº C) ‚àò map G1 (Œ¥ T G2 (T C))
‚àò Œ¥ T G1 (G2 (T C))
‚àò map T
    (map G1
       (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g
        ‚àò (map T (Œº B) ‚àò œÉ ‚àò map (prod W) (dec T B)))
     ‚àò (œÉ ‚àò (map (prod W) f ‚àò cojoin))) ‚àò dec T A =
binddt
  (map G1
     (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
      ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        <span class="c">(* ********** *)</span>
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk7d"><span class="nb">unfold</span> binddt, kc7, binddt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (G1 ‚àò G2) (Œº C) ‚àò map G1 (Œ¥ T G2 (T C))
‚àò Œ¥ T G1 (G2 (T C))
‚àò map T
    (map G1
       (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g
        ‚àò (map T (Œº B) ‚àò œÉ ‚àò map (prod W) (dec T B)))
     ‚àò (œÉ ‚àò (map (prod W) f ‚àò cojoin))) ‚àò dec T A =
map (G1 ‚àò G2) (Œº C) ‚àò Œ¥ T (G1 ‚àò G2) (T C)
‚àò map T
    (map G1
       (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
        ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)
‚àò dec T A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk7e"><span class="nb">rewrite</span> dist_linear.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (G1 ‚àò G2) (Œº C) ‚àò map G1 (Œ¥ T G2 (T C))
‚àò Œ¥ T G1 (G2 (T C))
‚àò map T
    (map G1
       (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g
        ‚àò (map T (Œº B) ‚àò œÉ ‚àò map (prod W) (dec T B)))
     ‚àò (œÉ ‚àò (map (prod W) f ‚àò cojoin))) ‚àò dec T A =
map (G1 ‚àò G2) (Œº C)
‚àò (map G1 (Œ¥ T G2 (T C)) ‚àò Œ¥ T G1 (G2 (T C)))
‚àò map T
    (map G1
       (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
        ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)
‚àò dec T A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk7f"><span class="kp">do</span> <span class="mi">4</span> reassociate &lt;- on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (G1 ‚àò G2) (Œº C) ‚àò map G1 (Œ¥ T G2 (T C))
‚àò Œ¥ T G1 (G2 (T C))
‚àò map T
    (map G1
       (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T g
        ‚àò map T (Œº B) ‚àò œÉ ‚àò map (prod W) (dec T B))
     ‚àò œÉ ‚àò map (prod W) f ‚àò cojoin) ‚àò dec T A =
map (G1 ‚àò G2) (Œº C)
‚àò (map G1 (Œ¥ T G2 (T C)) ‚àò Œ¥ T G1 (G2 (T C)))
‚àò map T
    (map G1
       (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
        ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)
‚àò dec T A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk80">reassociate -&gt; near (map T (Œº B)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (G1 ‚àò G2) (Œº C) ‚àò map G1 (Œ¥ T G2 (T C))
‚àò Œ¥ T G1 (G2 (T C))
‚àò map T
    (map G1
       (map G2 (Œº C) ‚àò Œ¥ T G2 (T C)
        ‚àò (map T g ‚àò map T (Œº B)) ‚àò œÉ
        ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò map (prod W) f
     ‚àò cojoin) ‚àò dec T A =
map (G1 ‚àò G2) (Œº C)
‚àò (map G1 (Œ¥ T G2 (T C)) ‚àò Œ¥ T G1 (G2 (T C)))
‚àò map T
    (map G1
       (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
        ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)
‚àò dec T A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk81"><span class="nb">rewrite</span> (fun_map_map (F := T)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (G1 ‚àò G2) (Œº C) ‚àò map G1 (Œ¥ T G2 (T C))
‚àò Œ¥ T G1 (G2 (T C))
‚àò map T
    (map G1
       (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
        ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ
     ‚àò map (prod W) f ‚àò cojoin) ‚àò dec T A =
map (G1 ‚àò G2) (Œº C)
‚àò (map G1 (Œ¥ T G2 (T C)) ‚àò Œ¥ T G1 (G2 (T C)))
‚àò map T
    (map G1
       (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
        ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ ‚àò cobind f)
‚àò dec T A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk82"><span class="nb">replace</span> (cobind f) <span class="kr">with</span> (map (prod W) f ‚àò cojoin).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (G1 ‚àò G2) (Œº C) ‚àò map G1 (Œ¥ T G2 (T C))
‚àò Œ¥ T G1 (G2 (T C))
‚àò map T
    (map G1
       (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
        ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ
     ‚àò map (prod W) f ‚àò cojoin) ‚àò dec T A =
map (G1 ‚àò G2) (Œº C)
‚àò (map G1 (Œ¥ T G2 (T C)) ‚àò Œ¥ T G1 (G2 (T C)))
‚àò map T
    (map G1
       (map G2 (Œº C) ‚àò Œ¥ T G2 (T C) ‚àò map T (g ‚àò Œº B)
        ‚àò œÉ ‚àò map (prod W) (dec T B)) ‚àò œÉ
     ‚àò (map (prod W) f ‚àò cojoin)) ‚àò dec T A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="decoratedtraversablemonad-v-chk83" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><label class="goal-separator" for="decoratedtraversablemonad-v-chk83"><hr></label><div class="goal-conclusion">map (prod W) f ‚àò cojoin = cobind f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk84"><span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (prod W) f ‚àò cojoin = cobind f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk85">ext [w a].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>W * B -&gt; G2 (T C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Functor G1</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Functor G2</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (prod W) f ‚àò cojoin) (w, a) = cobind f (w, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">binddt_binddt</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk86"><span class="kn">Lemma</span> <span class="nf">kdtm_morph_T</span> :
      <span class="kr">forall</span> `{ApplicativeMorphism G1 G2 œï},
      <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : W * A -&gt; G1 (T B)),
        œï (T B) ‚àò binddt (G := G1) f = binddt (G := G2) (œï (T B) ‚àò f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G1</span> <span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H5</span> : Map G1)
  (<span class="nv">H6</span> : Mult G1) (<span class="nv">H7</span> : Pure G1) (<span class="nv">H8</span> : Map G2)
  (<span class="nv">H9</span> : Mult G2) (<span class="nv">H10</span> : Pure G2)
  (<span class="nv">œï</span> : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A),
ApplicativeMorphism G1 G2 œï -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : W * A -&gt; G1 (T B)),
œï (T B) ‚àò binddt f = binddt (œï (T B) ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk87"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G1</span> <span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H5</span> : Map G1)
  (<span class="nv">H6</span> : Mult G1) (<span class="nv">H7</span> : Pure G1) (<span class="nv">H8</span> : Map G2)
  (<span class="nv">H9</span> : Mult G2) (<span class="nv">H10</span> : Pure G2)
  (<span class="nv">œï</span> : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A),
ApplicativeMorphism G1 G2 œï -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : W * A -&gt; G1 (T B)),
œï (T B) ‚àò binddt f = binddt (œï (T B) ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk88">introv morph.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>morph</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : W * A -&gt; G1 (T B)),
œï (T B) ‚àò binddt f = binddt (œï (T B) ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk89"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>morph</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (T B) ‚àò binddt f = binddt (œï (T B) ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk8a">unfold_ops @Binddt_categorical.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>morph</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (T B) ‚àò (map (Œº) ‚àò Œ¥ T G1 ‚àò map f ‚àò dec T) =
map (Œº) ‚àò Œ¥ T G2 ‚àò map (œï (T B) ‚àò f) ‚àò dec T</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk8b"><span class="kp">do</span> <span class="mi">3</span> reassociate &lt;- on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>morph</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (T B) ‚àò map (Œº) ‚àò Œ¥ T G1 ‚àò map f ‚àò dec T =
map (Œº) ‚àò Œ¥ T G2 ‚àò map (œï (T B) ‚àò f) ‚àò dec T</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk8c">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>morph</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (T B) ‚àò map (Œº) ‚àò Œ¥ T G1 ‚àò map f =
map (Œº) ‚àò Œ¥ T G2 ‚àò map (œï (T B) ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk8d"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>morph</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">a</span> : T (W * A) =&gt;
 œï (T B) (map (Œº) (Œ¥ T G1 (map f a)))) =
(<span class="kr">fun</span> <span class="nv">a</span> : T (W * A) =&gt;
 map (Œº) (Œ¥ T G2 (map (œï (T B) ‚óã f) a)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk8e">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>morph</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T (W * A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (T B) (map (Œº) (Œ¥ T G1 (map f t))) =
map (Œº) (Œ¥ T G2 (map (œï (T B) ‚óã f) t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk8f"><span class="nb">rewrite</span> appmor_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>morph</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T (W * A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Œº) (œï (T (T B)) (Œ¥ T G1 (map f t))) =
map (Œº) (Œ¥ T G2 (map (œï (T B) ‚óã f) t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk90">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>morph</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T (W * A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (T (T B)) (Œ¥ T G1 (map f t)) =
Œ¥ T G2 (map (œï (T B) ‚óã f) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk91">compose near (map f t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>morph</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T (W * A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(œï (T (T B)) ‚àò Œ¥ T G1) (map f t) =
Œ¥ T G2 (map (œï (T B) ‚óã f) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk92"><span class="nb">rewrite</span> &lt;- (dist_morph (F := T)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>morph</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T (W * A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Œ¥ T G2 ‚àò map (œï (T B))) (map f t) =
Œ¥ T G2 (map (œï (T B) ‚óã f) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk93"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>morph</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T (W * A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ T G2 (map (œï (T B)) (map f t)) =
Œ¥ T G2 (map (œï (T B) ‚óã f) t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablemonad-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablemonad-v-chk94">compose near t on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Join T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Decorate W T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ApplicativeDist T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Categorical.DecoratedTraversableMonad.DecoratedTraversableMonad
  W T</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>morph</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G1 (T B)</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T (W * A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ T G2 ((map (œï (T B)) ‚àò map f) t) =
Œ¥ T G2 (map (œï (T B) ‚óã f) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> (fun_map_map (F := T)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span>: Kleisli.DecoratedTraversableMonad.DecoratedTraversableRightPreModule W T T :=
      {|
        kdtm_binddt1 := @kdtm_binddt1_T;
        kdtm_binddt2 := @kdtm_binddt2_T;
        kdtm_morph := @kdtm_morph_T;
      |}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span>: Kleisli.DecoratedTraversableMonad.DecoratedTraversableMonad W T :=
      {| kdtm_binddt0 := @kdtm_binddt0_T;
      |}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">with_monad</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">ToKleisli</span>.</span></span></pre>
</div>
</div></body>
</html>
