<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<title>SystemF_Binddt.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.16.0+0.16.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Tealeaves <span class="kn">Require Export</span>
  Examples.SystemF.Syntax
  Simplification.Tests.Support
  Classes.Multisorted.Theory.Foldmap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Generalizable Variables</span> <span class="nf">G</span> M.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Arguments</span> mbinddt {ix} {W}%type_scope {T} U%function_scope
  {MBind} {F}%function_scope {H H0 H1 A B} _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">tactic_being_tested</span> := <span class="kp">idtac</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">test_simplification</span> :=
  <span class="nb">intros</span>;
  tactic_being_tested;
  <span class="kp">try</span> normalize_K;
  conclude.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

<span class="sd">(** ** &lt;&lt;mbinddt&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">rw_mbinddt</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
    `{Applicative G}
    (f : <span class="kr">forall</span> <span class="nv">k</span>, list K * A -&gt; G (SystemF k B)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">tactic_being_tested</span> ::= cbn_mbinddt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk0"><span class="kn">Lemma</span> <span class="nf">mbinddt_type_rw1</span> : <span class="kr">forall</span> <span class="nv">c</span>,
      mbinddt typ f (ty_c c) = pure (ty_c c).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K * A -&gt; G (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : base_typ,
mbinddt typ f (ty_c c) = pure (ty_c c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K * A -&gt; G (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : base_typ,
mbinddt typ f (ty_c c) = pure (ty_c c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk2"><span class="kn">Lemma</span> <span class="nf">mbinddt_type_rw2</span> : <span class="kr">forall</span> (<span class="nv">a</span> : A),
      mbinddt typ f (ty_v a) = f ktyp (nil, a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K * A -&gt; G (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, mbinddt typ f (ty_v a) = f ktyp ([], a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K * A -&gt; G (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, mbinddt typ f (ty_v a) = f ktyp ([], a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk4"><span class="kn">Lemma</span> <span class="nf">mbinddt_type_rw3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : typ A),
      mbinddt typ f (ty_ar t1 t2) =
        pure ty_ar &lt;‚ãÜ&gt; mbinddt typ f t1 &lt;‚ãÜ&gt; mbinddt typ f t2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K * A -&gt; G (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : typ A,
mbinddt typ f (ty_ar t1 t2) =
pure ty_ar &lt;‚ãÜ&gt; mbinddt typ f t1 &lt;‚ãÜ&gt; mbinddt typ f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K * A -&gt; G (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : typ A,
mbinddt typ f (ty_ar t1 t2) =
pure ty_ar &lt;‚ãÜ&gt; mbinddt typ f t1 &lt;‚ãÜ&gt; mbinddt typ f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk6"><span class="kn">Lemma</span> <span class="nf">mbinddt_type_rw4</span> : <span class="kr">forall</span> (<span class="nv">body</span> : typ A),
      mbinddt typ f (ty_univ body) =
        pure ty_univ &lt;‚ãÜ&gt; mbinddt typ (f ‚óª allK (incr [ktyp])) body.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K * A -&gt; G (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ A,
mbinddt typ f (ty_univ body) =
pure ty_univ &lt;‚ãÜ&gt;
mbinddt typ (f ‚óª allK (incr [ktyp])) body</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K * A -&gt; G (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ A,
mbinddt typ f (ty_univ body) =
pure ty_univ &lt;‚ãÜ&gt;
mbinddt typ (f ‚óª allK (incr [ktyp])) body</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk8"><span class="kn">Lemma</span> <span class="nf">mbinddt_term_rw1</span> : <span class="kr">forall</span> (<span class="nv">a</span> : A),
      mbinddt term f (tm_var a) = f ktrm (nil, a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K * A -&gt; G (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
mbinddt term f (tm_var a) = f ktrm ([], a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K * A -&gt; G (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
mbinddt term f (tm_var a) = f ktrm ([], a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chka"><span class="kn">Lemma</span> <span class="nf">mbinddt_term_rw2</span> : <span class="kr">forall</span> (<span class="nv">œÑ</span> : typ A) (<span class="nv">t</span> : term A),
      mbinddt term f (tm_abs œÑ t) =
        pure tm_abs &lt;‚ãÜ&gt; mbinddt typ f œÑ &lt;‚ãÜ&gt;
          mbinddt term (f ‚óª allK (incr [ktrm])) t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K * A -&gt; G (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ A) (<span class="nv">t</span> : term A),
mbinddt term f (tm_abs œÑ t) =
pure tm_abs &lt;‚ãÜ&gt; mbinddt typ f œÑ &lt;‚ãÜ&gt;
mbinddt term (f ‚óª allK (incr [ktrm])) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chkb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K * A -&gt; G (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ A) (<span class="nv">t</span> : term A),
mbinddt term f (tm_abs œÑ t) =
pure tm_abs &lt;‚ãÜ&gt; mbinddt typ f œÑ &lt;‚ãÜ&gt;
mbinddt term (f ‚óª allK (incr [ktrm])) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chkc"><span class="kn">Lemma</span> <span class="nf">mbinddt_term_rw3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term A),
      mbinddt term f (tm_app t1 t2) =
        pure tm_app &lt;‚ãÜ&gt; (mbinddt term f t1) &lt;‚ãÜ&gt; (mbinddt term f t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K * A -&gt; G (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term A,
mbinddt term f (tm_app t1 t2) =
pure tm_app &lt;‚ãÜ&gt; mbinddt term f t1 &lt;‚ãÜ&gt;
mbinddt term f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chkd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K * A -&gt; G (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term A,
mbinddt term f (tm_app t1 t2) =
pure tm_app &lt;‚ãÜ&gt; mbinddt term f t1 &lt;‚ãÜ&gt;
mbinddt term f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chke"><span class="kn">Lemma</span> <span class="nf">mbinddt_term_rw4</span> : <span class="kr">forall</span> (<span class="nv">t</span> : term A),
      mbinddt term f (tm_tab t) =
        pure tm_tab &lt;‚ãÜ&gt; mbinddt term (f ‚óª allK (incr [ktyp])) t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K * A -&gt; G (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term A,
mbinddt term f (tm_tab t) =
pure tm_tab &lt;‚ãÜ&gt;
mbinddt term (f ‚óª allK (incr [ktyp])) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chkf"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K * A -&gt; G (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term A,
mbinddt term f (tm_tab t) =
pure tm_tab &lt;‚ãÜ&gt;
mbinddt term (f ‚óª allK (incr [ktyp])) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk10"><span class="kn">Lemma</span> <span class="nf">mbinddt_term_rw5</span> : <span class="kr">forall</span> (<span class="nv">t</span>: term A) (<span class="nv">œÑ</span> : typ A),
      mbinddt term f (tm_tap t œÑ) =
        pure tm_tap &lt;‚ãÜ&gt; mbinddt term f t &lt;‚ãÜ&gt; mbinddt typ f œÑ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K * A -&gt; G (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term A) (<span class="nv">œÑ</span> : typ A),
mbinddt term f (tm_tap t œÑ) =
pure tm_tap &lt;‚ãÜ&gt; mbinddt term f t &lt;‚ãÜ&gt; mbinddt typ f œÑ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk11"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K * A -&gt; G (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term A) (<span class="nv">œÑ</span> : typ A),
mbinddt term f (tm_tap t œÑ) =
pure tm_tap &lt;‚ãÜ&gt; mbinddt term f t &lt;‚ãÜ&gt; mbinddt typ f œÑ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">rw_mbinddt</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** &lt;&lt;mbindd&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">rw_mbindd</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
    (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span>, list K * A -&gt; SystemF k B).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">tactic_being_tested</span> ::= simplify_mbindd.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk12"><span class="kn">Lemma</span> <span class="nf">mbindd_type_rw1</span> : <span class="kr">forall</span> <span class="nv">c</span>,
      mbindd typ f (ty_c c) = ty_c c.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K * A ~k~&gt; SystemF B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : base_typ, mbindd typ f (ty_c c) = ty_c c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk13"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K * A ~k~&gt; SystemF B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : base_typ, mbindd typ f (ty_c c) = ty_c c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk14"><span class="kn">Lemma</span> <span class="nf">mbindd_type_rw2</span> : <span class="kr">forall</span> (<span class="nv">a</span> : A),
      mbindd typ f (ty_v a) = f ktyp (nil, a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K * A ~k~&gt; SystemF B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, mbindd typ f (ty_v a) = f ktyp ([], a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk15"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K * A ~k~&gt; SystemF B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, mbindd typ f (ty_v a) = f ktyp ([], a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk16"><span class="kn">Lemma</span> <span class="nf">mbindd_type_rw3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : typ A),
      mbindd typ f (ty_ar t1 t2) =
        ty_ar (mbindd typ f t1) (mbindd typ f t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K * A ~k~&gt; SystemF B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : typ A,
mbindd typ f (ty_ar t1 t2) =
ty_ar (mbindd typ f t1) (mbindd typ f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk17"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K * A ~k~&gt; SystemF B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : typ A,
mbindd typ f (ty_ar t1 t2) =
ty_ar (mbindd typ f t1) (mbindd typ f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk18"><span class="kn">Lemma</span> <span class="nf">mbindd_type_rw4</span> : <span class="kr">forall</span> (<span class="nv">body</span> : typ A),
      mbindd typ f (ty_univ body) =
        ty_univ (mbindd typ (f ‚óª allK (incr [ktyp])) body).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K * A ~k~&gt; SystemF B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ A,
mbindd typ f (ty_univ body) =
ty_univ (mbindd typ (f ‚óª allK (incr [ktyp])) body)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk19"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K * A ~k~&gt; SystemF B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ A,
mbindd typ f (ty_univ body) =
ty_univ (mbindd typ (f ‚óª allK (incr [ktyp])) body)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk1a"><span class="kn">Lemma</span> <span class="nf">mbindd_term_rw1</span> : <span class="kr">forall</span> (<span class="nv">a</span> : A),
      mbindd term f (tm_var a) = f ktrm (nil, a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K * A ~k~&gt; SystemF B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
mbindd term f (tm_var a) = f ktrm ([], a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk1b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K * A ~k~&gt; SystemF B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
mbindd term f (tm_var a) = f ktrm ([], a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk1c"><span class="kn">Lemma</span> <span class="nf">mbindd_term_rw2</span> : <span class="kr">forall</span> (<span class="nv">œÑ</span> : typ A) (<span class="nv">t</span> : term A),
      mbindd term f (tm_abs œÑ t) =
        tm_abs (mbindd typ f œÑ)
          (mbindd term (f ‚óª allK (incr [ktrm])) t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K * A ~k~&gt; SystemF B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ A) (<span class="nv">t</span> : term A),
mbindd term f (tm_abs œÑ t) =
tm_abs (mbindd typ f œÑ)
  (mbindd term (f ‚óª allK (incr [ktrm])) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk1d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K * A ~k~&gt; SystemF B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ A) (<span class="nv">t</span> : term A),
mbindd term f (tm_abs œÑ t) =
tm_abs (mbindd typ f œÑ)
  (mbindd term (f ‚óª allK (incr [ktrm])) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk1e"><span class="kn">Lemma</span> <span class="nf">mbindd_term_rw3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term A),
      mbindd term f (tm_app t1 t2) =
        tm_app (mbindd term f t1) (mbindd term f t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K * A ~k~&gt; SystemF B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term A,
mbindd term f (tm_app t1 t2) =
tm_app (mbindd term f t1) (mbindd term f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk1f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K * A ~k~&gt; SystemF B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term A,
mbindd term f (tm_app t1 t2) =
tm_app (mbindd term f t1) (mbindd term f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk20"><span class="kn">Lemma</span> <span class="nf">mbindd_term_rw4</span> : <span class="kr">forall</span> (<span class="nv">t</span> : term A),
      mbindd term f (tm_tab t) =
        tm_tab (mbindd term (f ‚óª allK (incr [ktyp])) t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K * A ~k~&gt; SystemF B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term A,
mbindd term f (tm_tab t) =
tm_tab (mbindd term (f ‚óª allK (incr [ktyp])) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk21"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K * A ~k~&gt; SystemF B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term A,
mbindd term f (tm_tab t) =
tm_tab (mbindd term (f ‚óª allK (incr [ktyp])) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk22"><span class="kn">Lemma</span> <span class="nf">mbindd_term_rw5</span> : <span class="kr">forall</span> (<span class="nv">t</span>: term A) (<span class="nv">œÑ</span> : typ A),
      mbindd term f (tm_tap t œÑ) =
        tm_tap (mbindd term f t) (mbindd typ f œÑ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K * A ~k~&gt; SystemF B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term A) (<span class="nv">œÑ</span> : typ A),
mbindd term f (tm_tap t œÑ) =
tm_tap (mbindd term f t) (mbindd typ f œÑ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk23"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K * A ~k~&gt; SystemF B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term A) (<span class="nv">œÑ</span> : typ A),
mbindd term f (tm_tap t œÑ) =
tm_tap (mbindd term f t) (mbindd typ f œÑ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">rw_mbindd</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** &lt;&lt;mbind&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">rw_mbind</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
    (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span>, A -&gt; SystemF k B).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">tactic_being_tested</span> ::= simplify_mbind.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk24"><span class="kn">Lemma</span> <span class="nf">mbind_type_rw1</span> : <span class="kr">forall</span> <span class="nv">c</span>,
      mbind typ f (ty_c c) = ty_c c.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ~k~&gt; SystemF B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : base_typ, mbind typ f (ty_c c) = ty_c c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk25"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ~k~&gt; SystemF B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : base_typ, mbind typ f (ty_c c) = ty_c c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk26"><span class="kn">Lemma</span> <span class="nf">mbind_type_rw2</span> : <span class="kr">forall</span> (<span class="nv">a</span> : A),
      mbind typ f (ty_v a) = f ktyp a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ~k~&gt; SystemF B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, mbind typ f (ty_v a) = f ktyp a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk27"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ~k~&gt; SystemF B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, mbind typ f (ty_v a) = f ktyp a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk28"><span class="kn">Lemma</span> <span class="nf">mbind_type_rw3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : typ A),
      mbind typ f (ty_ar t1 t2) =
        ty_ar (mbind typ f t1) (mbind typ f t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ~k~&gt; SystemF B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : typ A,
mbind typ f (ty_ar t1 t2) =
ty_ar (mbind typ f t1) (mbind typ f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk29"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ~k~&gt; SystemF B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : typ A,
mbind typ f (ty_ar t1 t2) =
ty_ar (mbind typ f t1) (mbind typ f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk2a"><span class="kn">Lemma</span> <span class="nf">mbind_type_rw4</span> : <span class="kr">forall</span> (<span class="nv">body</span> : typ A),
      mbind typ f (ty_univ body) =
        ty_univ (mbind typ f body).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ~k~&gt; SystemF B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ A,
mbind typ f (ty_univ body) =
ty_univ (mbind typ f body)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk2b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ~k~&gt; SystemF B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ A,
mbind typ f (ty_univ body) =
ty_univ (mbind typ f body)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk2c"><span class="kn">Lemma</span> <span class="nf">mbind_term_rw1</span> : <span class="kr">forall</span> (<span class="nv">a</span> : A),
      mbind term f (tm_var a) = f ktrm a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ~k~&gt; SystemF B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, mbind term f (tm_var a) = f ktrm a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk2d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ~k~&gt; SystemF B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, mbind term f (tm_var a) = f ktrm a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk2e"><span class="kn">Lemma</span> <span class="nf">mbind_term_rw2</span> : <span class="kr">forall</span> (<span class="nv">œÑ</span> : typ A) (<span class="nv">t</span> : term A),
      mbind term f (tm_abs œÑ t) =
        tm_abs (mbind typ f œÑ) (mbind term f t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ~k~&gt; SystemF B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ A) (<span class="nv">t</span> : term A),
mbind term f (tm_abs œÑ t) =
tm_abs (mbind typ f œÑ) (mbind term f t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk2f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ~k~&gt; SystemF B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ A) (<span class="nv">t</span> : term A),
mbind term f (tm_abs œÑ t) =
tm_abs (mbind typ f œÑ) (mbind term f t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk30"><span class="kn">Lemma</span> <span class="nf">mbind_term_rw3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term A),
      mbind term f (tm_app t1 t2) =
        tm_app (mbind term f t1) (mbind term f t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ~k~&gt; SystemF B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term A,
mbind term f (tm_app t1 t2) =
tm_app (mbind term f t1) (mbind term f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk31"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ~k~&gt; SystemF B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term A,
mbind term f (tm_app t1 t2) =
tm_app (mbind term f t1) (mbind term f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk32"><span class="kn">Lemma</span> <span class="nf">mbind_term_rw4</span> : <span class="kr">forall</span> (<span class="nv">t</span> : term A),
      mbind term f (tm_tab t) =
        tm_tab (mbind term f t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ~k~&gt; SystemF B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term A,
mbind term f (tm_tab t) = tm_tab (mbind term f t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk33"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ~k~&gt; SystemF B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term A,
mbind term f (tm_tab t) = tm_tab (mbind term f t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk34"><span class="kn">Lemma</span> <span class="nf">mbind_term_rw5</span> : <span class="kr">forall</span> (<span class="nv">t</span>: term A) (<span class="nv">œÑ</span> : typ A),
      mbind term f (tm_tap t œÑ) =
        tm_tap (mbind term f t) (mbind typ f œÑ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ~k~&gt; SystemF B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term A) (<span class="nv">œÑ</span> : typ A),
mbind term f (tm_tap t œÑ) =
tm_tap (mbind term f t) (mbind typ f œÑ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk35"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ~k~&gt; SystemF B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term A) (<span class="nv">œÑ</span> : typ A),
mbind term f (tm_tap t œÑ) =
tm_tap (mbind term f t) (mbind typ f œÑ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">rw_mbind</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** &lt;&lt;mmapdt&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">rw_mmapdt</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
    `{Applicative G}
    (f : <span class="kr">forall</span> (<span class="nv">k</span>: K), list K * A -&gt; G B).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">tactic_being_tested</span> ::= simplify_mmapdt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk36"><span class="kn">Lemma</span> <span class="nf">mmapdt_type_rw1</span> : <span class="kr">forall</span> <span class="nv">c</span>,
      mmapdt typ G f (ty_c c) = pure (ty_c c).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : base_typ,
mmapdt typ G f (ty_c c) = pure (ty_c c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk37"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : base_typ,
mmapdt typ G f (ty_c c) = pure (ty_c c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk38"><span class="kn">Lemma</span> <span class="nf">mmapdt_type_rw2</span> : <span class="kr">forall</span> (<span class="nv">a</span> : A),
      mmapdt typ G f (ty_v a) = pure ty_v &lt;‚ãÜ&gt; f ktyp (nil, a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
mmapdt typ G f (ty_v a) = pure ty_v &lt;‚ãÜ&gt; f ktyp ([], a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk39"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
mmapdt typ G f (ty_v a) = pure ty_v &lt;‚ãÜ&gt; f ktyp ([], a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk3a"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mmapdt typ G f (ty_v a) = pure ty_v &lt;‚ãÜ&gt; f ktyp ([], a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk3b">simplify_mmapdt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (mret SystemF ktyp) &lt;‚ãÜ&gt; f ktyp ([], a) =
pure ty_v &lt;‚ãÜ&gt; f ktyp ([], a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk3c"><span class="kn">Lemma</span> <span class="nf">mmapdt_type_rw3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : typ A),
      mmapdt typ G f (ty_ar t1 t2) =
        pure ty_ar &lt;‚ãÜ&gt; mmapdt typ G f t1 &lt;‚ãÜ&gt; mmapdt typ G f t2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : typ A,
mmapdt typ G f (ty_ar t1 t2) =
pure ty_ar &lt;‚ãÜ&gt; mmapdt typ G f t1 &lt;‚ãÜ&gt; mmapdt typ G f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk3d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : typ A,
mmapdt typ G f (ty_ar t1 t2) =
pure ty_ar &lt;‚ãÜ&gt; mmapdt typ G f t1 &lt;‚ãÜ&gt; mmapdt typ G f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk3e"><span class="kn">Lemma</span> <span class="nf">mmapdt_type_rw4</span> : <span class="kr">forall</span> (<span class="nv">body</span> : typ A),
      mmapdt typ G f (ty_univ body) =
        pure ty_univ &lt;‚ãÜ&gt; mmapdt typ G (f ‚óª allK (incr [ktyp])) body.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ A,
mmapdt typ G f (ty_univ body) =
pure ty_univ &lt;‚ãÜ&gt;
mmapdt typ G (f ‚óª allK (incr [ktyp])) body</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk3f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ A,
mmapdt typ G f (ty_univ body) =
pure ty_univ &lt;‚ãÜ&gt;
mmapdt typ G (f ‚óª allK (incr [ktyp])) body</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk40"><span class="kn">Lemma</span> <span class="nf">mmapdt_term_rw1</span> : <span class="kr">forall</span> (<span class="nv">a</span> : A),
      mmapdt term G f (tm_var a) = pure tm_var &lt;‚ãÜ&gt; f ktrm (nil, a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
mmapdt term G f (tm_var a) =
pure tm_var &lt;‚ãÜ&gt; f ktrm ([], a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk41"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
mmapdt term G f (tm_var a) =
pure tm_var &lt;‚ãÜ&gt; f ktrm ([], a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk42"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mmapdt term G f (tm_var a) =
pure tm_var &lt;‚ãÜ&gt; f ktrm ([], a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk43">simplify_mmapdt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (mret SystemF ktrm) &lt;‚ãÜ&gt; f ktrm ([], a) =
pure tm_var &lt;‚ãÜ&gt; f ktrm ([], a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk44"><span class="kn">Lemma</span> <span class="nf">mmapdt_term_rw2</span> : <span class="kr">forall</span> (<span class="nv">œÑ</span> : typ A) (<span class="nv">t</span> : term A),
      mmapdt term G f (tm_abs œÑ t) =
        pure tm_abs &lt;‚ãÜ&gt; mmapdt typ G f œÑ &lt;‚ãÜ&gt;
          mmapdt term G (f ‚óª allK (incr [ktrm])) t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ A) (<span class="nv">t</span> : term A),
mmapdt term G f (tm_abs œÑ t) =
pure tm_abs &lt;‚ãÜ&gt; mmapdt typ G f œÑ &lt;‚ãÜ&gt;
mmapdt term G (f ‚óª allK (incr [ktrm])) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk45"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ A) (<span class="nv">t</span> : term A),
mmapdt term G f (tm_abs œÑ t) =
pure tm_abs &lt;‚ãÜ&gt; mmapdt typ G f œÑ &lt;‚ãÜ&gt;
mmapdt term G (f ‚óª allK (incr [ktrm])) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk46"><span class="kn">Lemma</span> <span class="nf">mmapdt_term_rw3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term A),
      mmapdt term G f (tm_app t1 t2) =
        pure tm_app &lt;‚ãÜ&gt; mmapdt term G f t1 &lt;‚ãÜ&gt; mmapdt term G f t2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term A,
mmapdt term G f (tm_app t1 t2) =
pure tm_app &lt;‚ãÜ&gt; mmapdt term G f t1 &lt;‚ãÜ&gt;
mmapdt term G f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk47"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term A,
mmapdt term G f (tm_app t1 t2) =
pure tm_app &lt;‚ãÜ&gt; mmapdt term G f t1 &lt;‚ãÜ&gt;
mmapdt term G f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk48"><span class="kn">Lemma</span> <span class="nf">mmapdt_term_rw4</span> : <span class="kr">forall</span> (<span class="nv">t</span> : term A),
      mmapdt term G f (tm_tab t) =
        pure tm_tab &lt;‚ãÜ&gt; mmapdt term G (f ‚óª allK (incr [ktyp])) t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term A,
mmapdt term G f (tm_tab t) =
pure tm_tab &lt;‚ãÜ&gt;
mmapdt term G (f ‚óª allK (incr [ktyp])) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk49"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term A,
mmapdt term G f (tm_tab t) =
pure tm_tab &lt;‚ãÜ&gt;
mmapdt term G (f ‚óª allK (incr [ktyp])) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk4a"><span class="kn">Lemma</span> <span class="nf">mmapdt_term_rw5</span> : <span class="kr">forall</span> (<span class="nv">t</span>: term A) (<span class="nv">œÑ</span> : typ A),
      mmapdt term G f (tm_tap t œÑ) =
        pure tm_tap &lt;‚ãÜ&gt; mmapdt term G f t &lt;‚ãÜ&gt; mmapdt typ G f œÑ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term A) (<span class="nv">œÑ</span> : typ A),
mmapdt term G f (tm_tap t œÑ) =
pure tm_tap &lt;‚ãÜ&gt; mmapdt term G f t &lt;‚ãÜ&gt; mmapdt typ G f œÑ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk4b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term A) (<span class="nv">œÑ</span> : typ A),
mmapdt term G f (tm_tap t œÑ) =
pure tm_tap &lt;‚ãÜ&gt; mmapdt term G f t &lt;‚ãÜ&gt; mmapdt typ G f œÑ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">rw_mmapdt</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** &lt;&lt;mmapd&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">rw_mmapd</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
    (<span class="nv">f</span> : <span class="kr">forall</span> (<span class="nv">k</span>: K), list K * A -&gt; B).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">tactic_being_tested</span> ::= simplify_mmapd.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk4c"><span class="kn">Lemma</span> <span class="nf">mmapd_type_rw1</span> : <span class="kr">forall</span> <span class="nv">c</span>,
      mmapd typ f (ty_c c) = pure (ty_c c).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : base_typ,
mmapd typ f (ty_c c) = pure (ty_c c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk4d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : base_typ,
mmapd typ f (ty_c c) = pure (ty_c c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk4e"><span class="kn">Lemma</span> <span class="nf">mmapd_type_rw2</span> : <span class="kr">forall</span> (<span class="nv">a</span> : A),
      mmapd typ f (ty_v a) = ty_v (f ktyp (nil, a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
mmapd typ f (ty_v a) = ty_v (f ktyp ([], a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk4f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
mmapd typ f (ty_v a) = ty_v (f ktyp ([], a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk50"><span class="kn">Lemma</span> <span class="nf">mmapd_type_rw3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : typ A),
      mmapd typ f (ty_ar t1 t2) =
        ty_ar (mmapd typ f t1) (mmapd typ f t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : typ A,
mmapd typ f (ty_ar t1 t2) =
ty_ar (mmapd typ f t1) (mmapd typ f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk51"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : typ A,
mmapd typ f (ty_ar t1 t2) =
ty_ar (mmapd typ f t1) (mmapd typ f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk52"><span class="kn">Lemma</span> <span class="nf">mmapd_type_rw4</span> : <span class="kr">forall</span> (<span class="nv">body</span> : typ A),
      mmapd typ f (ty_univ body) =
        ty_univ (mmapd typ (f ‚óª allK (incr [ktyp])) body).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ A,
mmapd typ f (ty_univ body) =
ty_univ (mmapd typ (f ‚óª allK (incr [ktyp])) body)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk53"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ A,
mmapd typ f (ty_univ body) =
ty_univ (mmapd typ (f ‚óª allK (incr [ktyp])) body)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk54"><span class="kn">Lemma</span> <span class="nf">mmapd_term_rw1</span> : <span class="kr">forall</span> (<span class="nv">a</span> : A),
      mmapd term f (tm_var a) = tm_var (f ktrm (nil, a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
mmapd term f (tm_var a) = tm_var (f ktrm ([], a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk55"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
mmapd term f (tm_var a) = tm_var (f ktrm ([], a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk56"><span class="kn">Lemma</span> <span class="nf">mmapd_term_rw2</span> : <span class="kr">forall</span> (<span class="nv">œÑ</span> : typ A) (<span class="nv">t</span> : term A),
      mmapd term f (tm_abs œÑ t) =
        tm_abs (mmapd typ f œÑ)
          (mmapd term (f ‚óª allK (incr [ktrm])) t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ A) (<span class="nv">t</span> : term A),
mmapd term f (tm_abs œÑ t) =
tm_abs (mmapd typ f œÑ)
  (mmapd term (f ‚óª allK (incr [ktrm])) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk57"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ A) (<span class="nv">t</span> : term A),
mmapd term f (tm_abs œÑ t) =
tm_abs (mmapd typ f œÑ)
  (mmapd term (f ‚óª allK (incr [ktrm])) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk58"><span class="kn">Lemma</span> <span class="nf">mmapd_term_rw3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term A),
      mmapd term f (tm_app t1 t2) =
        tm_app (mmapd term f t1) (mmapd term f t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term A,
mmapd term f (tm_app t1 t2) =
tm_app (mmapd term f t1) (mmapd term f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk59"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term A,
mmapd term f (tm_app t1 t2) =
tm_app (mmapd term f t1) (mmapd term f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk5a"><span class="kn">Lemma</span> <span class="nf">mmapd_term_rw4</span> : <span class="kr">forall</span> (<span class="nv">t</span> : term A),
      mmapd term f (tm_tab t) =
        tm_tab (mmapd term (f ‚óª allK (incr [ktyp])) t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term A,
mmapd term f (tm_tab t) =
tm_tab (mmapd term (f ‚óª allK (incr [ktyp])) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk5b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term A,
mmapd term f (tm_tab t) =
tm_tab (mmapd term (f ‚óª allK (incr [ktyp])) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk5c"><span class="kn">Lemma</span> <span class="nf">mmapd_term_rw5</span> : <span class="kr">forall</span> (<span class="nv">t</span>: term A) (<span class="nv">œÑ</span> : typ A),
      mmapd term f (tm_tap t œÑ) =
        tm_tap (mmapd term f t) (mmapd typ f œÑ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term A) (<span class="nv">œÑ</span> : typ A),
mmapd term f (tm_tap t œÑ) =
tm_tap (mmapd term f t) (mmapd typ f œÑ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk5d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term A) (<span class="nv">œÑ</span> : typ A),
mmapd term f (tm_tap t œÑ) =
tm_tap (mmapd term f t) (mmapd typ f œÑ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">rw_mmapd</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_foldMapmd_pre_refold_hook</span> ix := <span class="kp">idtac</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_foldMapmd_post_refold_hook</span> M :=
  <span class="kp">repeat</span> simplify_applicative_const;
  <span class="c">(* ^ above step creates some ((∆µ ‚óè m) ‚óè n) *)</span>
  <span class="kp">repeat</span> simplify_monoid_units;
  <span class="nb">change</span> (@const <span class="kt">Type</span> <span class="kt">Type</span> M <span class="nl">?anything</span>) <span class="kr">with</span> M.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_foldMapmd</span> :=
  <span class="kr">match goal with</span>
  | |- <span class="kp">context</span>[foldMapmd (W := <span class="nl">?W</span>) (T := <span class="nl">?T</span>) (ix := <span class="nl">?ix</span>) (M := <span class="nl">?M</span>)
                <span class="nl">?U</span> <span class="nl">?f</span> <span class="nl">?t</span>] =&gt;
      <span class="nb">rewrite</span> <span class="nl">?foldMapmd_to_mmapdt</span>;
      simplify_mmapdt;
      simplify_foldMapmd_pre_refold_hook ix;
      <span class="nb">rewrite</span> &lt;- <span class="nl">?foldMapmd_to_mmapdt</span>;
      simplify_foldMapmd_post_refold_hook M
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** &lt;&lt;foldMapmd&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">rw_foldMapmd</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    (<span class="nv">A</span> : <span class="kt">Type</span>)
      `{Monoid M}
      (f : <span class="kr">forall</span> (<span class="nv">k</span>: K), list K * A -&gt; M).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">tactic_being_tested</span> ::= simplify_foldMapmd.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk5e"><span class="kn">Lemma</span> <span class="nf">foldMapmd_type_rw1</span> : <span class="kr">forall</span> <span class="nv">c</span>,
      foldMapmd typ f (ty_c c) = ∆µ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : base_typ, foldMapmd typ f (ty_c c) = ∆µ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk5f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : base_typ, foldMapmd typ f (ty_c c) = ∆µ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk60"><span class="kn">Lemma</span> <span class="nf">foldMapmd_type_rw2</span> : <span class="kr">forall</span> (<span class="nv">a</span> : A),
      foldMapmd typ f (ty_v a) = f ktyp (nil, a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
foldMapmd typ f (ty_v a) = f ktyp ([], a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk61"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
foldMapmd typ f (ty_v a) = f ktyp ([], a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk62"><span class="kn">Lemma</span> <span class="nf">foldMapmd_type_rw3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : typ A),
      foldMapmd typ f (ty_ar t1 t2) =
        foldMapmd typ f t1 ‚óè foldMapmd typ f t2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : typ A,
foldMapmd typ f (ty_ar t1 t2) =
foldMapmd typ f t1 ‚óè foldMapmd typ f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk63"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : typ A,
foldMapmd typ f (ty_ar t1 t2) =
foldMapmd typ f t1 ‚óè foldMapmd typ f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk64"><span class="kn">Lemma</span> <span class="nf">foldMapmd_type_rw4</span> : <span class="kr">forall</span> (<span class="nv">body</span> : typ A),
      foldMapmd typ f (ty_univ body) =
        foldMapmd typ (f ‚óª allK (incr [ktyp])) body.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ A,
foldMapmd typ f (ty_univ body) =
foldMapmd typ (f ‚óª allK (incr [ktyp])) body</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk65"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ A,
foldMapmd typ f (ty_univ body) =
foldMapmd typ (f ‚óª allK (incr [ktyp])) body</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk66"><span class="kn">Lemma</span> <span class="nf">foldMapmd_term_rw1</span> : <span class="kr">forall</span> (<span class="nv">a</span> : A),
      foldMapmd term f (tm_var a) = f ktrm (nil, a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
foldMapmd term f (tm_var a) = f ktrm ([], a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk67"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
foldMapmd term f (tm_var a) = f ktrm ([], a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk68"><span class="kn">Lemma</span> <span class="nf">foldMapmd_term_rw2</span> : <span class="kr">forall</span> (<span class="nv">œÑ</span> : typ A) (<span class="nv">t</span> : term A),
      foldMapmd term f (tm_abs œÑ t) =
        foldMapmd typ f œÑ ‚óè
          foldMapmd term (f ‚óª allK (incr [ktrm])) t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ A) (<span class="nv">t</span> : term A),
foldMapmd term f (tm_abs œÑ t) =
foldMapmd typ f œÑ
‚óè foldMapmd term (f ‚óª allK (incr [ktrm])) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk69"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ A) (<span class="nv">t</span> : term A),
foldMapmd term f (tm_abs œÑ t) =
foldMapmd typ f œÑ
‚óè foldMapmd term (f ‚óª allK (incr [ktrm])) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk6a"><span class="kn">Lemma</span> <span class="nf">foldMapmd_term_rw3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term A),
      foldMapmd term f (tm_app t1 t2) =
        foldMapmd term f t1 ‚óè foldMapmd term f t2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term A,
foldMapmd term f (tm_app t1 t2) =
foldMapmd term f t1 ‚óè foldMapmd term f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk6b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term A,
foldMapmd term f (tm_app t1 t2) =
foldMapmd term f t1 ‚óè foldMapmd term f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk6c"><span class="kn">Lemma</span> <span class="nf">foldMapmd_term_rw4</span> : <span class="kr">forall</span> (<span class="nv">t</span> : term A),
      foldMapmd term f (tm_tab t) =
        foldMapmd term (f ‚óª allK (incr [ktyp])) t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term A,
foldMapmd term f (tm_tab t) =
foldMapmd term (f ‚óª allK (incr [ktyp])) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk6d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term A,
foldMapmd term f (tm_tab t) =
foldMapmd term (f ‚óª allK (incr [ktyp])) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk6e"><span class="kn">Lemma</span> <span class="nf">foldMapmd_term_rw5</span> : <span class="kr">forall</span> (<span class="nv">t</span>: term A) (<span class="nv">œÑ</span> : typ A),
      foldMapmd term f (tm_tap t œÑ) =
        foldMapmd term f t ‚óè foldMapmd typ f œÑ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term A) (<span class="nv">œÑ</span> : typ A),
foldMapmd term f (tm_tap t œÑ) =
foldMapmd term f t ‚óè foldMapmd typ f œÑ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk6f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term A) (<span class="nv">œÑ</span> : typ A),
foldMapmd term f (tm_tap t œÑ) =
foldMapmd term f t ‚óè foldMapmd typ f œÑ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">rw_foldMapmd</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* after unfolding,</span>
<span class="c">   foldMapmd U (f ‚óª allK extract) (C x1 x2)</span>
<span class="c">   is simplified to</span>
<span class="c">   foldMapmd typ ((f ‚óª allK extract) ‚óª allK (incr [ktyp])) x1) ...</span>
<span class="c"> *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_foldMapm_pre_refold_hook</span> ix :=
  <span class="kp">repeat</span> ( <span class="nb">rewrite</span> <span class="nl">?vec_compose_assoc</span>;
           <span class="nb">rewrite</span> (vec_compose_allK (H := ix));
           <span class="nb">rewrite</span> extract_incr).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_foldMapm_post_refold_hook</span> ix := <span class="kp">idtac</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

<span class="c">(* At a k-annotated leaf,</span>
<span class="c">   foldMapm f (Ret x)</span>
<span class="c">   becomes</span>
<span class="c">   (f ‚óª allK (extract (W := ?W))) k (∆µ, x)] =&gt;</span>
<span class="c"> *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_foldMapm_at_leaf_hook</span> :=
  simplify_mbind_at_leaf_hook.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_foldMapm</span> :=
  <span class="kr">match goal with</span>
  | |- <span class="kp">context</span>[foldMapm (W := <span class="nl">?W</span>) (T := <span class="nl">?T</span>) (ix := <span class="nl">?ix</span>) (M := <span class="nl">?M</span>)
                <span class="nl">?U</span> <span class="nl">?f</span> <span class="nl">?t</span>] =&gt;
      <span class="nb">rewrite</span> <span class="nl">?foldMapm_to_foldMapmd</span>;
      simplify_foldMapmd;
      simplify_foldMapm_pre_refold_hook ix;
      <span class="nb">rewrite</span> &lt;- <span class="nl">?foldMapm_to_foldMapmd</span>;
      simplify_foldMapm_post_refold_hook M;
      simplify_foldMapm_at_leaf_hook
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** &lt;&lt;foldMapm&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">rw_foldMapm</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    (<span class="nv">A</span> : <span class="kt">Type</span>)
      `{Monoid M}
      (f : K -&gt; A -&gt; M).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">tactic_being_tested</span> ::= simplify_foldMapm.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk70"><span class="kn">Lemma</span> <span class="nf">foldMapm_type_rw1</span> : <span class="kr">forall</span> <span class="nv">c</span>,
      foldMapm typ f (ty_c c) = ∆µ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : base_typ, foldMapm typ f (ty_c c) = ∆µ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk71"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : base_typ, foldMapm typ f (ty_c c) = ∆µ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk72"><span class="kn">Lemma</span> <span class="nf">foldMapm_type_rw2</span> : <span class="kr">forall</span> (<span class="nv">a</span> : A),
      foldMapm typ f (ty_v a) = f ktyp a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, foldMapm typ f (ty_v a) = f ktyp a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk73"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, foldMapm typ f (ty_v a) = f ktyp a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk74"><span class="kn">Lemma</span> <span class="nf">foldMapm_type_rw3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : typ A),
      foldMapm typ f (ty_ar t1 t2) =
        foldMapm typ f t1 ‚óè foldMapm typ f t2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : typ A,
foldMapm typ f (ty_ar t1 t2) =
foldMapm typ f t1 ‚óè foldMapm typ f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk75"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : typ A,
foldMapm typ f (ty_ar t1 t2) =
foldMapm typ f t1 ‚óè foldMapm typ f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk76"><span class="kn">Lemma</span> <span class="nf">foldMapm_type_rw4</span> : <span class="kr">forall</span> (<span class="nv">body</span> : typ A),
      foldMapm typ f (ty_univ body) =
        foldMapm typ f body.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ A,
foldMapm typ f (ty_univ body) = foldMapm typ f body</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk77"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ A,
foldMapm typ f (ty_univ body) = foldMapm typ f body</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk78"><span class="kn">Lemma</span> <span class="nf">foldMapm_term_rw1</span> : <span class="kr">forall</span> (<span class="nv">a</span> : A),
      foldMapm term f (tm_var a) = f ktrm a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, foldMapm term f (tm_var a) = f ktrm a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk79"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, foldMapm term f (tm_var a) = f ktrm a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk7a"><span class="kn">Lemma</span> <span class="nf">foldMapm_term_rw2</span> : <span class="kr">forall</span> (<span class="nv">œÑ</span> : typ A) (<span class="nv">t</span> : term A),
      foldMapm term f (tm_abs œÑ t) =
        foldMapm typ f œÑ ‚óè
          foldMapm term f t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ A) (<span class="nv">t</span> : term A),
foldMapm term f (tm_abs œÑ t) =
foldMapm typ f œÑ ‚óè foldMapm term f t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk7b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ A) (<span class="nv">t</span> : term A),
foldMapm term f (tm_abs œÑ t) =
foldMapm typ f œÑ ‚óè foldMapm term f t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk7c"><span class="kn">Lemma</span> <span class="nf">foldMapm_term_rw3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term A),
      foldMapm term f (tm_app t1 t2) =
        foldMapm term f t1 ‚óè foldMapm term f t2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term A,
foldMapm term f (tm_app t1 t2) =
foldMapm term f t1 ‚óè foldMapm term f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk7d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term A,
foldMapm term f (tm_app t1 t2) =
foldMapm term f t1 ‚óè foldMapm term f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk7e"><span class="kn">Lemma</span> <span class="nf">foldMapm_term_rw4</span> : <span class="kr">forall</span> (<span class="nv">t</span> : term A),
      foldMapm term f (tm_tab t) =
        foldMapm term f t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term A,
foldMapm term f (tm_tab t) = foldMapm term f t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk7f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term A,
foldMapm term f (tm_tab t) = foldMapm term f t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk80"><span class="kn">Lemma</span> <span class="nf">foldMapm_term_rw5</span> : <span class="kr">forall</span> (<span class="nv">t</span>: term A) (<span class="nv">œÑ</span> : typ A),
      foldMapm term f (tm_tap t œÑ) =
        foldMapm term f t ‚óè foldMapm typ f œÑ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term A) (<span class="nv">œÑ</span> : typ A),
foldMapm term f (tm_tap t œÑ) =
foldMapm term f t ‚óè foldMapm typ f œÑ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk81"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term A) (<span class="nv">œÑ</span> : typ A),
foldMapm term f (tm_tap t œÑ) =
foldMapm term f t ‚óè foldMapm typ f œÑ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">rw_foldMapm</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_Forallmd_pre_refold_hook</span> := <span class="kp">idtac</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_Forallmd_post_refold_hook</span> :=
  unfold_ops @Monoid_op_and;
  unfold_ops @Monoid_unit_true.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_Forallmd</span> :=
  <span class="kr">match goal with</span>
  | |- <span class="kp">context</span>[Forallmd (W := <span class="nl">?W</span>) (T := <span class="nl">?T</span>) (ix := <span class="nl">?ix</span>)
                <span class="nl">?U</span> <span class="nl">?f</span> <span class="nl">?t</span>] =&gt;
      <span class="nb">rewrite</span> <span class="nl">?Forallmd_to_foldMapmd</span>;
      simplify_foldMapmd;
      simplify_Forallmd_pre_refold_hook;
      <span class="nb">rewrite</span> &lt;- <span class="nl">?Forallmd_to_foldMapmd</span>;
      simplify_Forallmd_post_refold_hook
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** &lt;&lt;Forallmd&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">rw_Forallmd</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    (<span class="nv">A</span> : <span class="kt">Type</span>)
      `{Monoid M}
      (f : <span class="kr">forall</span> (<span class="nv">k</span>: K), list K * A -&gt; <span class="kt">Prop</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">tactic_being_tested</span> ::= simplify_Forallmd.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk82"><span class="kn">Lemma</span> <span class="nf">Forallmd_type_rw1</span> : <span class="kr">forall</span> <span class="nv">c</span>,
      Forallmd typ f (ty_c c) = <span class="kt">True</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : base_typ, Forallmd typ f (ty_c c) = <span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk83"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : base_typ, Forallmd typ f (ty_c c) = <span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk84"><span class="kn">Lemma</span> <span class="nf">Forallmd_type_rw2</span> : <span class="kr">forall</span> (<span class="nv">a</span> : A),
      Forallmd typ f (ty_v a) = f ktyp (nil, a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, Forallmd typ f (ty_v a) = f ktyp ([], a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk85"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, Forallmd typ f (ty_v a) = f ktyp ([], a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk86"><span class="kn">Lemma</span> <span class="nf">Forallmd_type_rw3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : typ A),
      Forallmd typ f (ty_ar t1 t2) =
        (Forallmd typ f t1 /\ Forallmd typ f t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : typ A,
Forallmd typ f (ty_ar t1 t2) =
(Forallmd typ f t1 /\ Forallmd typ f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk87"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : typ A,
Forallmd typ f (ty_ar t1 t2) =
(Forallmd typ f t1 /\ Forallmd typ f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk88"><span class="kn">Lemma</span> <span class="nf">Forallmd_type_rw4</span> : <span class="kr">forall</span> (<span class="nv">body</span> : typ A),
      Forallmd typ f (ty_univ body) =
        Forallmd typ (f ‚óª allK (incr [ktyp])) body.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ A,
Forallmd typ f (ty_univ body) =
Forallmd typ (f ‚óª allK (incr [ktyp])) body</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk89"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ A,
Forallmd typ f (ty_univ body) =
Forallmd typ (f ‚óª allK (incr [ktyp])) body</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk8a"><span class="kn">Lemma</span> <span class="nf">Forallmd_term_rw1</span> : <span class="kr">forall</span> (<span class="nv">a</span> : A),
      Forallmd term f (tm_var a) = f ktrm (nil, a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
Forallmd term f (tm_var a) = f ktrm ([], a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk8b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
Forallmd term f (tm_var a) = f ktrm ([], a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk8c"><span class="kn">Lemma</span> <span class="nf">Forallmd_term_rw2</span> : <span class="kr">forall</span> (<span class="nv">œÑ</span> : typ A) (<span class="nv">t</span> : term A),
      Forallmd term f (tm_abs œÑ t) =
        (Forallmd typ f œÑ /\
          Forallmd term (f ‚óª allK (incr [ktrm])) t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ A) (<span class="nv">t</span> : term A),
Forallmd term f (tm_abs œÑ t) =
(Forallmd typ f œÑ /\
 Forallmd term (f ‚óª allK (incr [ktrm])) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk8d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ A) (<span class="nv">t</span> : term A),
Forallmd term f (tm_abs œÑ t) =
(Forallmd typ f œÑ /\
 Forallmd term (f ‚óª allK (incr [ktrm])) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk8e"><span class="kn">Lemma</span> <span class="nf">Forallmd_term_rw3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term A),
      Forallmd term f (tm_app t1 t2) =
        (Forallmd term f t1 /\ Forallmd term f t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term A,
Forallmd term f (tm_app t1 t2) =
(Forallmd term f t1 /\ Forallmd term f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk8f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term A,
Forallmd term f (tm_app t1 t2) =
(Forallmd term f t1 /\ Forallmd term f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk90"><span class="kn">Lemma</span> <span class="nf">Forallmd_term_rw4</span> : <span class="kr">forall</span> (<span class="nv">t</span> : term A),
      Forallmd term f (tm_tab t) =
        Forallmd term (f ‚óª allK (incr [ktyp])) t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term A,
Forallmd term f (tm_tab t) =
Forallmd term (f ‚óª allK (incr [ktyp])) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk91"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term A,
Forallmd term f (tm_tab t) =
Forallmd term (f ‚óª allK (incr [ktyp])) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk92"><span class="kn">Lemma</span> <span class="nf">Forallmd_term_rw5</span> : <span class="kr">forall</span> (<span class="nv">t</span>: term A) (<span class="nv">œÑ</span> : typ A),
      Forallmd term f (tm_tap t œÑ) =
        (Forallmd term f t /\ Forallmd typ f œÑ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term A) (<span class="nv">œÑ</span> : typ A),
Forallmd term f (tm_tap t œÑ) =
(Forallmd term f t /\ Forallmd typ f œÑ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-binddt-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-binddt-v-chk93"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K -&gt; list K * A -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term A) (<span class="nv">œÑ</span> : typ A),
Forallmd term f (tm_tap t œÑ) =
(Forallmd term f t /\ Forallmd typ f œÑ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">rw_Forallmd</span>.</span></span></pre>
</div>
</div></body>
</html>
