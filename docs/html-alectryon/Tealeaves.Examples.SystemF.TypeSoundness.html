<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<title>TypeSoundness.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.16.0+0.16.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+↑</kbd> <kbd>Ctrl+↓</kbd> to navigate, <kbd>Ctrl+🖱️</kbd> to focus. On Mac, use <kbd>⌘</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Tealeaves <span class="kn">Require Export</span>
  Examples.SystemF.Syntax
  Examples.SystemF.Contexts
  Simplification.Tests.SystemF_LN.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Coq <span class="kn">Require Import</span>
  Sorting.Permutation.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Implicit Types</span> (<span class="nv">x</span> : atom).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Properties of the typing judgment &lt;&lt;Δ ; Γ ⊢ t : τ&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>

<span class="sd">(** ** Structural properties &lt;&lt;Δ ; Γ ⊢ t : τ&gt;&gt; in &lt;&lt;Δ&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>

<span class="sd">(** *** &lt;&lt;Δ&gt;&gt; is always well-formed *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk0"><span class="kn">Lemma</span> <span class="nf">j_kind_ctx_wf</span> : <span class="kr">forall</span> <span class="nv">Δ</span> <span class="nv">Γ</span> <span class="nv">t</span> <span class="nv">τ</span>,
    (Δ ; Γ ⊢ t : τ) -&gt;
    ok_kind_ctx Δ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ</span> : kind_ctx) (<span class="nv">Γ</span> : type_ctx) (<span class="nv">t</span> : term LN)
  (<span class="nv">τ</span> : typ LN), Δ; Γ ⊢ t : τ -&gt; ok_kind_ctx Δ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ</span> : kind_ctx) (<span class="nv">Γ</span> : type_ctx) (<span class="nv">t</span> : term LN)
  (<span class="nv">τ</span> : typ LN), Δ; Γ ⊢ t : τ -&gt; ok_kind_ctx Δ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk2"><span class="nb">unfold</span> ok_kind_ctx; <span class="nb">induction</span> <span class="mi">1</span>; cleanup_cofinite.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x, τ) ∈ Γ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">uniq Δ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>uniq Δ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk3"><hr></label><div class="goal-conclusion">uniq Δ</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t2 : τ1</span></span></span><br><span><var>IHJudgment1, IHJudgment2</var><span class="hyp-type"><b>: </b><span>uniq Δ</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk4"><hr></label><div class="goal-conclusion">uniq Δ</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ ++ e0 ~ tt; Γ ⊢ open term ktyp (ty_v (Fr e0)) t
: open typ ktyp (ty_v (Fr e0)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>uniq (Δ ++ e ~ tt)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk5"><hr></label><div class="goal-conclusion">uniq Δ</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHJudgment</var><span class="hyp-type"><b>: </b><span>uniq Δ</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk6"><hr></label><div class="goal-conclusion">uniq Δ</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: (<span class="nb">autorewrite with</span> tea_rw_uniq <span class="kr">in</span> *; <span class="nb">intuition</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Permutation *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk7"><span class="kn">Theorem</span> <span class="nf">j_kind_ctx_perm</span> : <span class="kr">forall</span> <span class="nv">Δ1</span> <span class="nv">Δ2</span> <span class="nv">Γ</span> <span class="nv">t</span> <span class="nv">τ</span>,
    Permutation Δ1 Δ2 -&gt;
    (Δ1 ; Γ ⊢ t : τ) -&gt;
    (Δ2 ; Γ ⊢ t : τ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ1</span> <span class="nv">Δ2</span> : list (atom * unit)) (<span class="nv">Γ</span> : type_ctx)
  (<span class="nv">t</span> : term LN) (<span class="nv">τ</span> : typ LN),
Permutation Δ1 Δ2 -&gt; Δ1; Γ ⊢ t : τ -&gt; Δ2; Γ ⊢ t : τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ1</span> <span class="nv">Δ2</span> : list (atom * unit)) (<span class="nv">Γ</span> : type_ctx)
  (<span class="nv">t</span> : term LN) (<span class="nv">τ</span> : typ LN),
Permutation Δ1 Δ2 -&gt; Δ1; Γ ⊢ t : τ -&gt; Δ2; Γ ⊢ t : τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk9">introv perm j.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1, Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>perm</var><span class="hyp-type"><b>: </b><span>Permutation Δ1 Δ2</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ1; Γ ⊢ t : τ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ2; Γ ⊢ t : τ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chka"><span class="nb">generalize dependent</span> Δ2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ1; Γ ⊢ t : τ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">Δ2</span> : list (atom * unit),
Permutation Δ1 Δ2 -&gt; Δ2; Γ ⊢ t : τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkb"><span class="nb">induction</span> j; introv Hperm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x, τ) ∈ Γ</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>Hperm</var><span class="hyp-type"><b>: </b><span>Permutation Δ Δ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ2; Γ ⊢ tm_var (Fr x) : τ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chkc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
<span class="kr">forall</span> <span class="nv">Δ2</span> : list (atom * unit),
Permutation Δ Δ2 -&gt;
Δ2; Γ ++ x ~ τ1
⊢ open term ktrm (tm_var (Fr x)) t : τ2</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>Hperm</var><span class="hyp-type"><b>: </b><span>Permutation Δ Δ2</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chkc"><hr></label><div class="goal-conclusion">Δ2; Γ ⊢ tm_abs τ1 t : ty_ar τ1 τ2</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chkd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t2 : τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ2</span> : list (atom * unit),
Permutation Δ Δ2 -&gt; Δ2; Γ ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ2</span> : list (atom * unit),
Permutation Δ Δ2 -&gt; Δ2; Γ ⊢ t2 : τ1</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>Hperm</var><span class="hyp-type"><b>: </b><span>Permutation Δ Δ2</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chkd"><hr></label><div class="goal-conclusion">Δ2; Γ ⊢ tm_app t1 t2 : τ2</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chke" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
<span class="kr">forall</span> <span class="nv">Δ2</span> : list (atom * unit),
Permutation (Δ ++ x ~ tt) Δ2 -&gt;
Δ2; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>Hperm</var><span class="hyp-type"><b>: </b><span>Permutation Δ Δ2</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chke"><hr></label><div class="goal-conclusion">Δ2; Γ ⊢ tm_tab t : ty_univ τ</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chkf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ2</span> : list (atom * unit),
Permutation Δ Δ2 -&gt; Δ2; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>Hperm</var><span class="hyp-type"><b>: </b><span>Permutation Δ Δ2</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chkf"><hr></label><div class="goal-conclusion">Δ2; Γ ⊢ tm_tap t τ1 : open typ ktyp τ1 τ2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk10">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x, τ) ∈ Γ</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>Hperm</var><span class="hyp-type"><b>: </b><span>Permutation Δ Δ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ2; Γ ⊢ tm_var (Fr x) : τ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eauto using</span> Judgment, Permutation_sym <span class="kr">with</span> sysf_ctx.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk11">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
<span class="kr">forall</span> <span class="nv">Δ2</span> : list (atom * unit),
Permutation Δ Δ2 -&gt;
Δ2; Γ ++ x ~ τ1
⊢ open term ktrm (tm_var (Fr x)) t : τ2</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>Hperm</var><span class="hyp-type"><b>: </b><span>Permutation Δ Δ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ2; Γ ⊢ tm_abs τ1 t : ty_ar τ1 τ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eauto using</span> Judgment.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk12">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t2 : τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ2</span> : list (atom * unit),
Permutation Δ Δ2 -&gt; Δ2; Γ ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ2</span> : list (atom * unit),
Permutation Δ Δ2 -&gt; Δ2; Γ ⊢ t2 : τ1</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>Hperm</var><span class="hyp-type"><b>: </b><span>Permutation Δ Δ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ2; Γ ⊢ tm_app t1 t2 : τ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eauto using</span> Judgment.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk13">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
<span class="kr">forall</span> <span class="nv">Δ2</span> : list (atom * unit),
Permutation (Δ ++ x ~ tt) Δ2 -&gt;
Δ2; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>Hperm</var><span class="hyp-type"><b>: </b><span>Permutation Δ Δ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ2; Γ ⊢ tm_tab t : ty_univ τ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk14"><span class="nb">eapply</span> j_univ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
<span class="kr">forall</span> <span class="nv">Δ2</span> : list (atom * unit),
Permutation (Δ ++ x ~ tt) Δ2 -&gt;
Δ2; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>Hperm</var><span class="hyp-type"><b>: </b><span>Permutation Δ Δ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` <span class="nl">?L</span> -&gt;
Δ2 ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eauto using</span> Permutation_app_tail.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk15">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ2</span> : list (atom * unit),
Permutation Δ Δ2 -&gt; Δ2; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>Hperm</var><span class="hyp-type"><b>: </b><span>Permutation Δ Δ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ2; Γ ⊢ tm_tap t τ1 : open typ ktyp τ1 τ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eauto using</span> Judgment, ok_type_perm1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk16"><span class="kn">Corollary</span> <span class="nf">j_kind_ctx_perm1</span> : <span class="kr">forall</span> <span class="nv">Δ1</span> <span class="nv">Δ2</span> <span class="nv">x</span> <span class="nv">Γ</span> <span class="nv">t</span> <span class="nv">τ</span>,
    ((Δ1 ++ x ~ tt) ++ Δ2 ; Γ ⊢ t : τ) -&gt;
    ((Δ1 ++ Δ2) ++ x ~ tt ; Γ ⊢ t : τ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ1</span> <span class="nv">Δ2</span> : list (atom * unit)) <span class="nv">x</span> (<span class="nv">Γ</span> : type_ctx)
  (<span class="nv">t</span> : term LN) (<span class="nv">τ</span> : typ LN),
(Δ1 ++ x ~ tt) ++ Δ2; Γ ⊢ t : τ -&gt;
(Δ1 ++ Δ2) ++ x ~ tt; Γ ⊢ t : τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk17"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ1</span> <span class="nv">Δ2</span> : list (atom * unit)) <span class="nv">x</span> (<span class="nv">Γ</span> : type_ctx)
  (<span class="nv">t</span> : term LN) (<span class="nv">τ</span> : typ LN),
(Δ1 ++ x ~ tt) ++ Δ2; Γ ⊢ t : τ -&gt;
(Δ1 ++ Δ2) ++ x ~ tt; Γ ⊢ t : τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk18"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1, Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(Δ1 ++ x ~ tt) ++ Δ2; Γ ⊢ t : τ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Δ1 ++ Δ2) ++ x ~ tt; Γ ⊢ t : τ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk19"><span class="nb">eapply</span> j_kind_ctx_perm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1, Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(Δ1 ++ x ~ tt) ++ Δ2; Γ ⊢ t : τ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Permutation <span class="nl">?Δ1</span> ((Δ1 ++ Δ2) ++ x ~ tt)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk1a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1, Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(Δ1 ++ x ~ tt) ++ Δ2; Γ ⊢ t : τ</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk1a"><hr></label><div class="goal-conclusion"><span class="nl">?Δ1</span>; Γ ⊢ t : τ</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1b"><span class="mi">2</span>:{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1, Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(Δ1 ++ x ~ tt) ++ Δ2; Γ ⊢ t : τ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?Δ1</span>; Γ ⊢ t : τ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">eassumption</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1c">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1, Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(Δ1 ++ x ~ tt) ++ Δ2; Γ ⊢ t : τ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Permutation ((Δ1 ++ x ~ tt) ++ Δ2)
  ((Δ1 ++ Δ2) ++ x ~ tt)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1d">simpl_alist.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1, Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(Δ1 ++ x ~ tt) ++ Δ2; Γ ⊢ t : τ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Permutation (Δ1 ++ x ~ tt ++ Δ2) (Δ1 ++ Δ2 ++ x ~ tt)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1e"><span class="nb">apply</span> Permutation_app.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1, Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(Δ1 ++ x ~ tt) ++ Δ2; Γ ⊢ t : τ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Permutation Δ1 Δ1</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk1f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1, Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(Δ1 ++ x ~ tt) ++ Δ2; Γ ⊢ t : τ</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk1f"><hr></label><div class="goal-conclusion">Permutation (x ~ tt ++ Δ2) (Δ2 ++ x ~ tt)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">auto using</span> Permutation_refl, Permutation_app_comm.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Weakening *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk20"><span class="kn">Theorem</span> <span class="nf">j_kind_ctx_weak</span> : <span class="kr">forall</span> <span class="nv">Δ1</span> <span class="nv">Δ2</span> <span class="nv">Γ</span> <span class="nv">t</span> <span class="nv">τ</span>,
    ok_kind_ctx Δ2 -&gt;
    disjoint Δ1 Δ2 -&gt;
    Δ1 ; Γ ⊢ t : τ -&gt;
    Δ1 ++ Δ2 ; Γ ⊢ t : τ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ1</span> : alist unit) (<span class="nv">Δ2</span> : kind_ctx)
  (<span class="nv">Γ</span> : type_ctx) (<span class="nv">t</span> : term LN) (<span class="nv">τ</span> : typ LN),
ok_kind_ctx Δ2 -&gt;
disjoint Δ1 Δ2 -&gt; Δ1; Γ ⊢ t : τ -&gt; Δ1 ++ Δ2; Γ ⊢ t : τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk21"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ1</span> : alist unit) (<span class="nv">Δ2</span> : kind_ctx)
  (<span class="nv">Γ</span> : type_ctx) (<span class="nv">t</span> : term LN) (<span class="nv">τ</span> : typ LN),
ok_kind_ctx Δ2 -&gt;
disjoint Δ1 Δ2 -&gt; Δ1; Γ ⊢ t : τ -&gt; Δ1 ++ Δ2; Γ ⊢ t : τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk22">introv ok disj j.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>alist unit</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ2</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Δ1 Δ2</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ1; Γ ⊢ t : τ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ1 ++ Δ2; Γ ⊢ t : τ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk23"><span class="nb">induction</span> j.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ2</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Δ Δ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x, τ) ∈ Γ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ ++ Δ2; Γ ⊢ tm_var (Fr x) : τ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk24" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ2</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Δ Δ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
disjoint Δ Δ2 -&gt;
Δ ++ Δ2; Γ ++ x ~ τ1
⊢ open term ktrm (tm_var (Fr x)) t : τ2</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk24"><hr></label><div class="goal-conclusion">Δ ++ Δ2; Γ ⊢ tm_abs τ1 t : ty_ar τ1 τ2</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk25" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ2</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Δ Δ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t2 : τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span>disjoint Δ Δ2 -&gt; Δ ++ Δ2; Γ ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span>disjoint Δ Δ2 -&gt; Δ ++ Δ2; Γ ⊢ t2 : τ1</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk25"><hr></label><div class="goal-conclusion">Δ ++ Δ2; Γ ⊢ tm_app t1 t2 : τ2</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk26" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ2</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Δ Δ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
disjoint (Δ ++ x ~ tt) Δ2 -&gt;
(Δ ++ x ~ tt) ++ Δ2; Γ
⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk26"><hr></label><div class="goal-conclusion">Δ ++ Δ2; Γ ⊢ tm_tab t : ty_univ τ</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk27" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ2</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Δ Δ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>disjoint Δ Δ2 -&gt; Δ ++ Δ2; Γ ⊢ t : ty_univ τ2</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk27"><hr></label><div class="goal-conclusion">Δ ++ Δ2; Γ ⊢ tm_tap t τ1 : open typ ktyp τ1 τ2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk28">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ2</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Δ Δ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x, τ) ∈ Γ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ ++ Δ2; Γ ⊢ tm_var (Fr x) : τ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> j_var; <span class="nb">auto with</span> sysf_ctx.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk29">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ2</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Δ Δ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
disjoint Δ Δ2 -&gt;
Δ ++ Δ2; Γ ++ x ~ τ1
⊢ open term ktrm (tm_var (Fr x)) t : τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ ++ Δ2; Γ ⊢ tm_abs τ1 t : ty_ar τ1 τ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> j_abs <span class="kr">with</span> (L := L); <span class="nb">auto with</span> sysf_ctx.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk2a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ2</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Δ Δ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t2 : τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span>disjoint Δ Δ2 -&gt; Δ ++ Δ2; Γ ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span>disjoint Δ Δ2 -&gt; Δ ++ Δ2; Γ ⊢ t2 : τ1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ ++ Δ2; Γ ⊢ tm_app t1 t2 : τ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> j_app <span class="kr">with</span> (τ1 := τ1); <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk2b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ2</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Δ Δ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
disjoint (Δ ++ x ~ tt) Δ2 -&gt;
(Δ ++ x ~ tt) ++ Δ2; Γ
⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ ++ Δ2; Γ ⊢ tm_tab t : ty_univ τ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk2c"><span class="nb">rename</span> H0 <span class="nb">into</span> IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ2</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Δ Δ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
disjoint (Δ ++ x ~ tt) Δ2 -&gt;
(Δ ++ x ~ tt) ++ Δ2; Γ
⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ ++ Δ2; Γ ⊢ tm_tab t : ty_univ τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk2d"><span class="nb">apply</span> j_univ <span class="kr">with</span> (L := L ∪ (domset Δ2)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ2</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Δ Δ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
disjoint (Δ ++ x ~ tt) Δ2 -&gt;
(Δ ++ x ~ tt) ++ Δ2; Γ
⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` (L ∪ domset Δ2) -&gt;
(Δ ++ Δ2) ++ x ~ tt; Γ
⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk2e">intros_cof IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ2</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Δ Δ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>disjoint (Δ ++ e ~ tt) Δ2 -&gt;
(Δ ++ e ~ tt) ++ Δ2; Γ
⊢ open term ktyp (ty_v (Fr e)) t
: open typ ktyp (ty_v (Fr e)) τ</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ domset Δ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Δ ++ Δ2) ++ e ~ tt; Γ
⊢ open term ktyp (ty_v (Fr e)) t
: open typ ktyp (ty_v (Fr e)) τ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk2f"><span class="nb">apply</span> j_kind_ctx_perm1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ2</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Δ Δ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>disjoint (Δ ++ e ~ tt) Δ2 -&gt;
(Δ ++ e ~ tt) ++ Δ2; Γ
⊢ open term ktyp (ty_v (Fr e)) t
: open typ ktyp (ty_v (Fr e)) τ</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ domset Δ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Δ ++ e ~ tt) ++ Δ2; Γ
⊢ open term ktyp (ty_v (Fr e)) t
: open typ ktyp (ty_v (Fr e)) τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk30"><span class="nb">autorewrite with</span> tea_rw_disj <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ2</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Δ Δ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>disjoint Δ Δ2 /\ e `notin` domset Δ2 -&gt;
(Δ ++ e ~ tt) ++ Δ2; Γ
⊢ open term ktyp (ty_v (Fr e)) t
: open typ ktyp (ty_v (Fr e)) τ</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ domset Δ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Δ ++ e ~ tt) ++ Δ2; Γ
⊢ open term ktyp (ty_v (Fr e)) t
: open typ ktyp (ty_v (Fr e)) τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intuition</span> fsetdec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk31">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ2</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Δ Δ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>disjoint Δ Δ2 -&gt; Δ ++ Δ2; Γ ⊢ t : ty_univ τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ ++ Δ2; Γ ⊢ tm_tap t τ1 : open typ ktyp τ1 τ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> j_inst; <span class="nb">auto with</span> sysf_ctx.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Substitution *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk32"><span class="kn">Theorem</span> <span class="nf">j_kind_ctx_subst</span> : <span class="kr">forall</span> <span class="nv">Δ1</span> <span class="nv">x</span> <span class="nv">Δ2</span> <span class="nv">Γ</span> <span class="nv">t</span> <span class="nv">τ</span> <span class="nv">τ&#39;</span>,
    ok_type (Δ1 ++ Δ2) τ&#39; -&gt;
    (Δ1 ++ x ~ tt ++ Δ2 ; Γ ⊢ t : τ) -&gt;
    (Δ1 ++ Δ2 ; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ ⊢ <span class="nb">subst</span> term ktyp x τ&#39; t : <span class="nb">subst</span> typ ktyp x τ&#39; τ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ1</span> : list (atom * unit)) <span class="nv">x</span>
  (<span class="nv">Δ2</span> : list (atom * unit)) (<span class="nv">Γ</span> : type_ctx)
  (<span class="nv">t</span> : term LN) (<span class="nv">τ</span> <span class="nv">τ&#39;</span> : typ LN),
ok_type (Δ1 ++ Δ2) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2; Γ ⊢ t : τ -&gt;
Δ1 ++ Δ2; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t : <span class="nb">subst</span> typ ktyp x τ&#39; τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk33"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ1</span> : list (atom * unit)) <span class="nv">x</span>
  (<span class="nv">Δ2</span> : list (atom * unit)) (<span class="nv">Γ</span> : type_ctx)
  (<span class="nv">t</span> : term LN) (<span class="nv">τ</span> <span class="nv">τ&#39;</span> : typ LN),
ok_type (Δ1 ++ Δ2) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2; Γ ⊢ t : τ -&gt;
Δ1 ++ Δ2; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t : <span class="nb">subst</span> typ ktyp x τ&#39; τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk34">introv Hok j.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ, τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ1 ++ x ~ tt ++ Δ2; Γ ⊢ t : τ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ1 ++ Δ2; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t : <span class="nb">subst</span> typ ktyp x τ&#39; τ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk35"><span class="nb">remember</span> (Δ1 ++ x ~ tt ++ Δ2) <span class="kr">as</span> rem.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ, τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br><span><var>rem</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>Heqrem</var><span class="hyp-type"><b>: </b><span>rem = Δ1 ++ x ~ tt ++ Δ2</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>rem; Γ ⊢ t : τ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ1 ++ Δ2; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t : <span class="nb">subst</span> typ ktyp x τ&#39; τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk36"><span class="nb">generalize dependent</span> Δ2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ, τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>rem</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>rem; Γ ⊢ t : τ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">Δ2</span> : list (atom * unit),
ok_type (Δ1 ++ Δ2) τ&#39; -&gt;
rem = Δ1 ++ x ~ tt ++ Δ2 -&gt;
Δ1 ++ Δ2; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t : 
<span class="nb">subst</span> typ ktyp x τ&#39; τ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk37"><span class="nb">induction</span> j; <span class="nb">intros</span>; <span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx (Δ1 ++ x ~ tt ++ Δ2) Γ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx (Δ1 ++ x ~ tt ++ Δ2)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ Γ</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ1 ++ Δ2; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; (tm_var (Fr x0))
: <span class="nb">subst</span> typ ktyp x τ&#39; τ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk38" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
<span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3;
envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) (Γ ++ x0 ~ τ1)
⊢ <span class="nb">subst</span> term ktyp x τ&#39;
    (open term ktrm (tm_var (Fr x0)) t)
: <span class="nb">subst</span> typ ktyp x τ&#39; τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ1 ++ x ~ tt ++ Δ2; Γ ++ x0 ~ τ1
⊢ open term ktrm (tm_var (Fr x0)) t : τ2</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk38"><hr></label><div class="goal-conclusion">Δ1 ++ Δ2; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; (tm_abs τ1 t)
: <span class="nb">subst</span> typ ktyp x τ&#39; (ty_ar τ1 τ2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk39" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t2
: <span class="nb">subst</span> typ ktyp x τ&#39; τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t1
: <span class="nb">subst</span> typ ktyp x τ&#39; (ty_ar τ1 τ2)</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>Δ1 ++ x ~ tt ++ Δ2; Γ ⊢ t2 : τ1</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>Δ1 ++ x ~ tt ++ Δ2; Γ ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk39"><hr></label><div class="goal-conclusion">Δ1 ++ Δ2; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; (tm_app t1 t2)
: <span class="nb">subst</span> typ ktyp x τ&#39; τ2</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk3a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
<span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
(Δ1 ++ x ~ tt ++ Δ2) ++ x0 ~ tt =
Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39;
    (open term ktyp (ty_v (Fr x0)) t)
: <span class="nb">subst</span> typ ktyp x τ&#39;
    (open typ ktyp (ty_v (Fr x0)) τ)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
(Δ1 ++ x ~ tt ++ Δ2) ++ x0 ~ tt; Γ
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk3a"><hr></label><div class="goal-conclusion">Δ1 ++ Δ2; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; (tm_tab t)
: <span class="nb">subst</span> typ ktyp x τ&#39; (ty_univ τ)</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk3b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t
: <span class="nb">subst</span> typ ktyp x τ&#39; (ty_univ τ2)</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ1 ++ x ~ tt ++ Δ2; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ x ~ tt ++ Δ2) τ1</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk3b"><hr></label><div class="goal-conclusion">Δ1 ++ Δ2; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; (tm_tap t τ1)
: <span class="nb">subst</span> typ ktyp x τ&#39; (open typ ktyp τ1 τ2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk3c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx (Δ1 ++ x ~ tt ++ Δ2) Γ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx (Δ1 ++ x ~ tt ++ Δ2)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ Γ</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ1 ++ Δ2; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; (tm_var (Fr x0))
: <span class="nb">subst</span> typ ktyp x τ&#39; τ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk3d"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx (Δ1 ++ x ~ tt ++ Δ2) Γ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx (Δ1 ++ x ~ tt ++ Δ2)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ Γ</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ1 ++ Δ2; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ tm_var (Fr x0) : <span class="nb">subst</span> typ ktyp x τ&#39; τ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk3e"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx (Δ1 ++ x ~ tt ++ Δ2) Γ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx (Δ1 ++ x ~ tt ++ Δ2)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ Γ</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_kind_ctx (Δ1 ++ Δ2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk3f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx (Δ1 ++ x ~ tt ++ Δ2) Γ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx (Δ1 ++ x ~ tt ++ Δ2)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ Γ</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk3f"><hr></label><div class="goal-conclusion">ok_type_ctx (Δ1 ++ Δ2)
  (envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ)</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk40" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx (Δ1 ++ x ~ tt ++ Δ2) Γ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx (Δ1 ++ x ~ tt ++ Δ2)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ Γ</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk40"><hr></label><div class="goal-conclusion">(x0, <span class="nb">subst</span> typ ktyp x τ&#39; τ)
∈ envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk41">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx (Δ1 ++ x ~ tt ++ Δ2) Γ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx (Δ1 ++ x ~ tt ++ Δ2)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ Γ</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_kind_ctx (Δ1 ++ Δ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eauto with</span> sysf_ctx.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk42">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx (Δ1 ++ x ~ tt ++ Δ2) Γ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx (Δ1 ++ x ~ tt ++ Δ2)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ Γ</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type_ctx (Δ1 ++ Δ2)
  (envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk43"><span class="nb">apply</span> ok_type_ctx_sub.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx (Δ1 ++ x ~ tt ++ Δ2) Γ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx (Δ1 ++ x ~ tt ++ Δ2)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ Γ</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type_ctx (Δ1 ++ x ~ tt ++ Δ2) Γ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk44" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx (Δ1 ++ x ~ tt ++ Δ2) Γ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx (Δ1 ++ x ~ tt ++ Δ2)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ Γ</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk44"><hr></label><div class="goal-conclusion">ok_type (Δ1 ++ Δ2) τ&#39;</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk45" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx (Δ1 ++ x ~ tt ++ Δ2) Γ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx (Δ1 ++ x ~ tt ++ Δ2)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ Γ</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk45"><hr></label><div class="goal-conclusion">LC typ ktyp τ&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk46">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx (Δ1 ++ x ~ tt ++ Δ2) Γ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx (Δ1 ++ x ~ tt ++ Δ2)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ Γ</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type_ctx (Δ1 ++ x ~ tt ++ Δ2) Γ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk47">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx (Δ1 ++ x ~ tt ++ Δ2) Γ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx (Δ1 ++ x ~ tt ++ Δ2)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ Γ</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type (Δ1 ++ Δ2) τ&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk48">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx (Δ1 ++ x ~ tt ++ Δ2) Γ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx (Δ1 ++ x ~ tt ++ Δ2)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ Γ</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC typ ktyp τ&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> ok_type_lc; <span class="nb">eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk49">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx (Δ1 ++ x ~ tt ++ Δ2) Γ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx (Δ1 ++ x ~ tt ++ Δ2)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ Γ</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x0, <span class="nb">subst</span> typ ktyp x τ&#39; τ)
∈ envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk4a"><span class="nb">rewrite</span> in_envmap_iff.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx (Δ1 ++ x ~ tt ++ Δ2) Γ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx (Δ1 ++ x ~ tt ++ Δ2)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ Γ</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">a</span> : typ LN,
  (x0, a) ∈ Γ /\
  <span class="nb">subst</span> typ ktyp x τ&#39; a = <span class="nb">subst</span> typ ktyp x τ&#39; τ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk4b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
<span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3;
envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) (Γ ++ x0 ~ τ1)
⊢ <span class="nb">subst</span> term ktyp x τ&#39;
    (open term ktrm (tm_var (Fr x0)) t)
: <span class="nb">subst</span> typ ktyp x τ&#39; τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ1 ++ x ~ tt ++ Δ2; Γ ++ x0 ~ τ1
⊢ open term ktrm (tm_var (Fr x0)) t : τ2</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ1 ++ Δ2; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; (tm_abs τ1 t)
: <span class="nb">subst</span> typ ktyp x τ&#39; (ty_ar τ1 τ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk4c"><span class="nb">rename</span> H0 <span class="nb">into</span> IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
<span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3;
envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) (Γ ++ x0 ~ τ1)
⊢ <span class="nb">subst</span> term ktyp x τ&#39;
    (open term ktrm (tm_var (Fr x0)) t)
: <span class="nb">subst</span> typ ktyp x τ&#39; τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ1 ++ x ~ tt ++ Δ2; Γ ++ x0 ~ τ1
⊢ open term ktrm (tm_var (Fr x0)) t : τ2</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ1 ++ Δ2; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; (tm_abs τ1 t)
: <span class="nb">subst</span> typ ktyp x τ&#39; (ty_ar τ1 τ2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk4d">simplify_subst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
<span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3;
envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) (Γ ++ x0 ~ τ1)
⊢ <span class="nb">subst</span> term ktyp x τ&#39;
    (open term ktrm (tm_var (Fr x0)) t)
: <span class="nb">subst</span> typ ktyp x τ&#39; τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ1 ++ x ~ tt ++ Δ2; Γ ++ x0 ~ τ1
⊢ open term ktrm (tm_var (Fr x0)) t : τ2</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ1 ++ Δ2; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ tm_abs (<span class="nb">subst</span> typ ktyp x τ&#39; τ1)
    (<span class="nb">subst</span> term ktyp x τ&#39; t)
: ty_ar (<span class="nb">subst</span> typ ktyp x τ&#39; τ1)
    (<span class="nb">subst</span> typ ktyp x τ&#39; τ2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk4e"><span class="nb">apply</span> j_abs <span class="kr">with</span> (L := L ∪ {{ x }}).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
<span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3;
envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) (Γ ++ x0 ~ τ1)
⊢ <span class="nb">subst</span> term ktyp x τ&#39;
    (open term ktrm (tm_var (Fr x0)) t)
: <span class="nb">subst</span> typ ktyp x τ&#39; τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ1 ++ x ~ tt ++ Δ2; Γ ++ x0 ~ τ1
⊢ open term ktrm (tm_var (Fr x0)) t : τ2</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` (L ∪ {{x}}) -&gt;
Δ1 ++ Δ2;
envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ ++
x0 ~ <span class="nb">subst</span> typ ktyp x τ&#39; τ1
⊢ open term ktrm (tm_var (Fr x0))
    (<span class="nb">subst</span> term ktyp x τ&#39; t) : 
<span class="nb">subst</span> typ ktyp x τ&#39; τ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk4f">intros_cof IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3;
envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) (Γ ++ e ~ τ1)
⊢ <span class="nb">subst</span> term ktyp x τ&#39;
    (open term ktrm (tm_var (Fr e)) t)
: <span class="nb">subst</span> typ ktyp x τ&#39; τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ1 ++ x ~ tt ++ Δ2; Γ ++ x0 ~ τ1
⊢ open term ktrm (tm_var (Fr x0)) t : τ2</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ1 ++ Δ2;
envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ ++
e ~ <span class="nb">subst</span> typ ktyp x τ&#39; τ1
⊢ open term ktrm (tm_var (Fr e))
    (<span class="nb">subst</span> term ktyp x τ&#39; t) : 
<span class="nb">subst</span> typ ktyp x τ&#39; τ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk50"><span class="nb">rewrite</span> (subst_open_neq term) <span class="kr">in</span> IH;
      [| <span class="bp">discriminate</span> | <span class="nb">apply</span> LC_typ_trm ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3;
envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) (Γ ++ e ~ τ1)
⊢ open term ktrm
    (<span class="nb">subst</span> (SystemF ktrm) ktyp x τ&#39;
       (tm_var (Fr e))) 
    (<span class="nb">subst</span> term ktyp x τ&#39; t)
: <span class="nb">subst</span> typ ktyp x τ&#39; τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ1 ++ x ~ tt ++ Δ2; Γ ++ x0 ~ τ1
⊢ open term ktrm (tm_var (Fr x0)) t : τ2</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ1 ++ Δ2;
envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ ++
e ~ <span class="nb">subst</span> typ ktyp x τ&#39; τ1
⊢ open term ktrm (tm_var (Fr e))
    (<span class="nb">subst</span> term ktyp x τ&#39; t) : 
<span class="nb">subst</span> typ ktyp x τ&#39; τ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk51"><span class="nb">rewrite</span> rw_subst_term_var_neq <span class="kr">in</span> IH;
      [| fsetdec].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3;
envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) (Γ ++ e ~ τ1)
⊢ open term ktrm (tm_var (Fr e))
    (<span class="nb">subst</span> term ktyp x τ&#39; t)
: <span class="nb">subst</span> typ ktyp x τ&#39; τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ1 ++ x ~ tt ++ Δ2; Γ ++ x0 ~ τ1
⊢ open term ktrm (tm_var (Fr x0)) t : τ2</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ1 ++ Δ2;
envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ ++
e ~ <span class="nb">subst</span> typ ktyp x τ&#39; τ1
⊢ open term ktrm (tm_var (Fr e))
    (<span class="nb">subst</span> term ktyp x τ&#39; t) : 
<span class="nb">subst</span> typ ktyp x τ&#39; τ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk52"><span class="nb">rewrite</span> envmap_app <span class="kr">in</span> IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3;
envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ ++
envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) (e ~ τ1)
⊢ open term ktrm (tm_var (Fr e))
    (<span class="nb">subst</span> term ktyp x τ&#39; t)
: <span class="nb">subst</span> typ ktyp x τ&#39; τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ1 ++ x ~ tt ++ Δ2; Γ ++ x0 ~ τ1
⊢ open term ktrm (tm_var (Fr x0)) t : τ2</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ1 ++ Δ2;
envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ ++
e ~ <span class="nb">subst</span> typ ktyp x τ&#39; τ1
⊢ open term ktrm (tm_var (Fr e))
    (<span class="nb">subst</span> term ktyp x τ&#39; t) : 
<span class="nb">subst</span> typ ktyp x τ&#39; τ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk53">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t2
: <span class="nb">subst</span> typ ktyp x τ&#39; τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t1
: <span class="nb">subst</span> typ ktyp x τ&#39; (ty_ar τ1 τ2)</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>Δ1 ++ x ~ tt ++ Δ2; Γ ⊢ t2 : τ1</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>Δ1 ++ x ~ tt ++ Δ2; Γ ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ1 ++ Δ2; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; (tm_app t1 t2)
: <span class="nb">subst</span> typ ktyp x τ&#39; τ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk54">simplify_subst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t2
: <span class="nb">subst</span> typ ktyp x τ&#39; τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t1
: <span class="nb">subst</span> typ ktyp x τ&#39; (ty_ar τ1 τ2)</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>Δ1 ++ x ~ tt ++ Δ2; Γ ⊢ t2 : τ1</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>Δ1 ++ x ~ tt ++ Δ2; Γ ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ1 ++ Δ2; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ tm_app (<span class="nb">subst</span> term ktyp x τ&#39; t1)
    (<span class="nb">subst</span> term ktyp x τ&#39; t2) : 
<span class="nb">subst</span> typ ktyp x τ&#39; τ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk55"><span class="nb">apply</span> j_app <span class="kr">with</span> (τ1 := (<span class="nb">subst</span> (ix := I2) typ ktyp x τ&#39; τ1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t2
: <span class="nb">subst</span> typ ktyp x τ&#39; τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t1
: <span class="nb">subst</span> typ ktyp x τ&#39; (ty_ar τ1 τ2)</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>Δ1 ++ x ~ tt ++ Δ2; Γ ⊢ t2 : τ1</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>Δ1 ++ x ~ tt ++ Δ2; Γ ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ1 ++ Δ2; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t1
: ty_ar (<span class="nb">subst</span> typ ktyp x τ&#39; τ1)
    (<span class="nb">subst</span> typ ktyp x τ&#39; τ2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk56" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t2
: <span class="nb">subst</span> typ ktyp x τ&#39; τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t1
: <span class="nb">subst</span> typ ktyp x τ&#39; (ty_ar τ1 τ2)</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>Δ1 ++ x ~ tt ++ Δ2; Γ ⊢ t2 : τ1</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>Δ1 ++ x ~ tt ++ Δ2; Γ ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk56"><hr></label><div class="goal-conclusion">Δ1 ++ Δ2; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t2 : 
<span class="nb">subst</span> typ ktyp x τ&#39; τ1</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk57">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t2
: <span class="nb">subst</span> typ ktyp x τ&#39; τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t1
: <span class="nb">subst</span> typ ktyp x τ&#39; (ty_ar τ1 τ2)</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>Δ1 ++ x ~ tt ++ Δ2; Γ ⊢ t2 : τ1</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>Δ1 ++ x ~ tt ++ Δ2; Γ ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ1 ++ Δ2; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t1
: ty_ar (<span class="nb">subst</span> typ ktyp x τ&#39; τ1)
    (<span class="nb">subst</span> typ ktyp x τ&#39; τ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk58"><span class="nb">apply</span> IHj1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t2
: <span class="nb">subst</span> typ ktyp x τ&#39; τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t1
: <span class="nb">subst</span> typ ktyp x τ&#39; (ty_ar τ1 τ2)</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>Δ1 ++ x ~ tt ++ Δ2; Γ ⊢ t2 : τ1</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>Δ1 ++ x ~ tt ++ Δ2; Γ ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type (Δ1 ++ Δ2) τ&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk59" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t2
: <span class="nb">subst</span> typ ktyp x τ&#39; τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t1
: <span class="nb">subst</span> typ ktyp x τ&#39; (ty_ar τ1 τ2)</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>Δ1 ++ x ~ tt ++ Δ2; Γ ⊢ t2 : τ1</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>Δ1 ++ x ~ tt ++ Δ2; Γ ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk59"><hr></label><div class="goal-conclusion">Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ2</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk5a"><span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t2
: <span class="nb">subst</span> typ ktyp x τ&#39; τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t1
: <span class="nb">subst</span> typ ktyp x τ&#39; (ty_ar τ1 τ2)</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>Δ1 ++ x ~ tt ++ Δ2; Γ ⊢ t2 : τ1</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>Δ1 ++ x ~ tt ++ Δ2; Γ ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk5b">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t2
: <span class="nb">subst</span> typ ktyp x τ&#39; τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t1
: <span class="nb">subst</span> typ ktyp x τ&#39; (ty_ar τ1 τ2)</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>Δ1 ++ x ~ tt ++ Δ2; Γ ⊢ t2 : τ1</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>Δ1 ++ x ~ tt ++ Δ2; Γ ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ1 ++ Δ2; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t2 : 
<span class="nb">subst</span> typ ktyp x τ&#39; τ1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk5c"><span class="nb">apply</span> IHj2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t2
: <span class="nb">subst</span> typ ktyp x τ&#39; τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t1
: <span class="nb">subst</span> typ ktyp x τ&#39; (ty_ar τ1 τ2)</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>Δ1 ++ x ~ tt ++ Δ2; Γ ⊢ t2 : τ1</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>Δ1 ++ x ~ tt ++ Δ2; Γ ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type (Δ1 ++ Δ2) τ&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk5d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t2
: <span class="nb">subst</span> typ ktyp x τ&#39; τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t1
: <span class="nb">subst</span> typ ktyp x τ&#39; (ty_ar τ1 τ2)</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>Δ1 ++ x ~ tt ++ Δ2; Γ ⊢ t2 : τ1</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>Δ1 ++ x ~ tt ++ Δ2; Γ ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk5d"><hr></label><div class="goal-conclusion">Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ2</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk5e"><span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t2
: <span class="nb">subst</span> typ ktyp x τ&#39; τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t1
: <span class="nb">subst</span> typ ktyp x τ&#39; (ty_ar τ1 τ2)</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>Δ1 ++ x ~ tt ++ Δ2; Γ ⊢ t2 : τ1</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>Δ1 ++ x ~ tt ++ Δ2; Γ ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk5f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
<span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
(Δ1 ++ x ~ tt ++ Δ2) ++ x0 ~ tt =
Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39;
    (open term ktyp (ty_v (Fr x0)) t)
: <span class="nb">subst</span> typ ktyp x τ&#39;
    (open typ ktyp (ty_v (Fr x0)) τ)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
(Δ1 ++ x ~ tt ++ Δ2) ++ x0 ~ tt; Γ
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ1 ++ Δ2; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; (tm_tab t)
: <span class="nb">subst</span> typ ktyp x τ&#39; (ty_univ τ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk60"><span class="nb">rename</span> H0 <span class="nb">into</span> IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
<span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
(Δ1 ++ x ~ tt ++ Δ2) ++ x0 ~ tt =
Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39;
    (open term ktyp (ty_v (Fr x0)) t)
: <span class="nb">subst</span> typ ktyp x τ&#39;
    (open typ ktyp (ty_v (Fr x0)) τ)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
(Δ1 ++ x ~ tt ++ Δ2) ++ x0 ~ tt; Γ
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ1 ++ Δ2; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; (tm_tab t)
: <span class="nb">subst</span> typ ktyp x τ&#39; (ty_univ τ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk61">simplify_subst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
<span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
(Δ1 ++ x ~ tt ++ Δ2) ++ x0 ~ tt =
Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39;
    (open term ktyp (ty_v (Fr x0)) t)
: <span class="nb">subst</span> typ ktyp x τ&#39;
    (open typ ktyp (ty_v (Fr x0)) τ)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
(Δ1 ++ x ~ tt ++ Δ2) ++ x0 ~ tt; Γ
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ1 ++ Δ2; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ tm_tab (<span class="nb">subst</span> term ktyp x τ&#39; t)
: ty_univ (<span class="nb">subst</span> typ ktyp x τ&#39; τ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk62"><span class="nb">apply</span> j_univ <span class="kr">with</span> (L := L ∪ {{x}}).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
<span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
(Δ1 ++ x ~ tt ++ Δ2) ++ x0 ~ tt =
Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39;
    (open term ktyp (ty_v (Fr x0)) t)
: <span class="nb">subst</span> typ ktyp x τ&#39;
    (open typ ktyp (ty_v (Fr x0)) τ)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
(Δ1 ++ x ~ tt ++ Δ2) ++ x0 ~ tt; Γ
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` (L ∪ {{x}}) -&gt;
(Δ1 ++ Δ2) ++ x0 ~ tt; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ open term ktyp (ty_v (Fr x0))
    (<span class="nb">subst</span> term ktyp x τ&#39; t)
: open typ ktyp (ty_v (Fr x0)) (<span class="nb">subst</span> typ ktyp x τ&#39; τ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk63">intros_cof IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
(Δ1 ++ x ~ tt ++ Δ2) ++ e ~ tt =
Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39;
    (open term ktyp (ty_v (Fr e)) t)
: <span class="nb">subst</span> typ ktyp x τ&#39;
    (open typ ktyp (ty_v (Fr e)) τ)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
(Δ1 ++ x ~ tt ++ Δ2) ++ x0 ~ tt; Γ
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Δ1 ++ Δ2) ++ e ~ tt; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ open term ktyp (ty_v (Fr e))
    (<span class="nb">subst</span> term ktyp x τ&#39; t)
: open typ ktyp (ty_v (Fr e)) (<span class="nb">subst</span> typ ktyp x τ&#39; τ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk64">simpl_alist <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 ++ e ~ tt = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39;
    (open term ktyp (ty_v (Fr e)) t)
: <span class="nb">subst</span> typ ktyp x τ&#39;
    (open typ ktyp (ty_v (Fr e)) τ)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
(Δ1 ++ x ~ tt ++ Δ2) ++ x0 ~ tt; Γ
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ1 ++ Δ2 ++ e ~ tt; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ open term ktyp (ty_v (Fr e))
    (<span class="nb">subst</span> term ktyp x τ&#39; t)
: open typ ktyp (ty_v (Fr e)) (<span class="nb">subst</span> typ ktyp x τ&#39; τ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk65"><span class="nb">assert</span> (x &lt;&gt; e) <span class="bp">by</span> fsetdec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 ++ e ~ tt = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39;
    (open term ktyp (ty_v (Fr e)) t)
: <span class="nb">subst</span> typ ktyp x τ&#39;
    (open typ ktyp (ty_v (Fr e)) τ)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
(Δ1 ++ x ~ tt ++ Δ2) ++ x0 ~ tt; Γ
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}})</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ1 ++ Δ2 ++ e ~ tt; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ open term ktyp (ty_v (Fr e))
    (<span class="nb">subst</span> term ktyp x τ&#39; t)
: open typ ktyp (ty_v (Fr e)) (<span class="nb">subst</span> typ ktyp x τ&#39; τ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk66"><span class="nb">rewrite</span> (subst_open_eq term) <span class="kr">in</span> IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 ++ e ~ tt = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ open term ktyp
    (<span class="nb">subst</span> (SystemF ktyp) ktyp x τ&#39; (ty_v (Fr e)))
    (<span class="nb">subst</span> term ktyp x τ&#39; t)
: <span class="nb">subst</span> typ ktyp x τ&#39;
    (open typ ktyp (ty_v (Fr e)) τ)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
(Δ1 ++ x ~ tt ++ Δ2) ++ x0 ~ tt; Γ
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}})</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ1 ++ Δ2 ++ e ~ tt; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ open term ktyp (ty_v (Fr e))
    (<span class="nb">subst</span> term ktyp x τ&#39; t)
: open typ ktyp (ty_v (Fr e)) (<span class="nb">subst</span> typ ktyp x τ&#39; τ)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk67" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 ++ e ~ tt = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39;
    (open term ktyp (ty_v (Fr e)) t)
: <span class="nb">subst</span> typ ktyp x τ&#39;
    (open typ ktyp (ty_v (Fr e)) τ)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
(Δ1 ++ x ~ tt ++ Δ2) ++ x0 ~ tt; Γ
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}})</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; e</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk67"><hr></label><div class="goal-conclusion">LC (SystemF ktyp) ktyp τ&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk68"><span class="mi">2</span>:{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 ++ e ~ tt = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39;
    (open term ktyp (ty_v (Fr e)) t)
: <span class="nb">subst</span> typ ktyp x τ&#39;
    (open typ ktyp (ty_v (Fr e)) τ)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
(Δ1 ++ x ~ tt ++ Δ2) ++ x0 ~ tt; Γ
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}})</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC (SystemF ktyp) ktyp τ&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> inverts Hok.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk69">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 ++ e ~ tt = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ open term ktyp
    (<span class="nb">subst</span> (SystemF ktyp) ktyp x τ&#39; (ty_v (Fr e)))
    (<span class="nb">subst</span> term ktyp x τ&#39; t)
: <span class="nb">subst</span> typ ktyp x τ&#39;
    (open typ ktyp (ty_v (Fr e)) τ)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
(Δ1 ++ x ~ tt ++ Δ2) ++ x0 ~ tt; Γ
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}})</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ1 ++ Δ2 ++ e ~ tt; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ open term ktyp (ty_v (Fr e))
    (<span class="nb">subst</span> term ktyp x τ&#39; t)
: open typ ktyp (ty_v (Fr e)) (<span class="nb">subst</span> typ ktyp x τ&#39; τ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk6a"><span class="nb">rewrite</span> (subst_open_eq typ) <span class="kr">in</span> IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 ++ e ~ tt = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ open term ktyp
    (<span class="nb">subst</span> (SystemF ktyp) ktyp x τ&#39; (ty_v (Fr e)))
    (<span class="nb">subst</span> term ktyp x τ&#39; t)
: open typ ktyp
    (<span class="nb">subst</span> (SystemF ktyp) ktyp x τ&#39; (ty_v (Fr e)))
    (<span class="nb">subst</span> typ ktyp x τ&#39; τ)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
(Δ1 ++ x ~ tt ++ Δ2) ++ x0 ~ tt; Γ
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}})</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ1 ++ Δ2 ++ e ~ tt; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ open term ktyp (ty_v (Fr e))
    (<span class="nb">subst</span> term ktyp x τ&#39; t)
: open typ ktyp (ty_v (Fr e)) (<span class="nb">subst</span> typ ktyp x τ&#39; τ)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk6b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 ++ e ~ tt = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ open term ktyp
    (<span class="nb">subst</span> (SystemF ktyp) ktyp x τ&#39; (ty_v (Fr e)))
    (<span class="nb">subst</span> term ktyp x τ&#39; t)
: <span class="nb">subst</span> typ ktyp x τ&#39;
    (open typ ktyp (ty_v (Fr e)) τ)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
(Δ1 ++ x ~ tt ++ Δ2) ++ x0 ~ tt; Γ
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}})</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; e</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk6b"><hr></label><div class="goal-conclusion">LC (SystemF ktyp) ktyp τ&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk6c"><span class="mi">2</span>:{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 ++ e ~ tt = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ open term ktyp
    (<span class="nb">subst</span> (SystemF ktyp) ktyp x τ&#39; (ty_v (Fr e)))
    (<span class="nb">subst</span> term ktyp x τ&#39; t)
: <span class="nb">subst</span> typ ktyp x τ&#39;
    (open typ ktyp (ty_v (Fr e)) τ)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
(Δ1 ++ x ~ tt ++ Δ2) ++ x0 ~ tt; Γ
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}})</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC (SystemF ktyp) ktyp τ&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> inverts Hok.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk6d">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 ++ e ~ tt = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ open term ktyp
    (<span class="nb">subst</span> (SystemF ktyp) ktyp x τ&#39; (ty_v (Fr e)))
    (<span class="nb">subst</span> term ktyp x τ&#39; t)
: open typ ktyp
    (<span class="nb">subst</span> (SystemF ktyp) ktyp x τ&#39; (ty_v (Fr e)))
    (<span class="nb">subst</span> typ ktyp x τ&#39; τ)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
(Δ1 ++ x ~ tt ++ Δ2) ++ x0 ~ tt; Γ
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}})</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ1 ++ Δ2 ++ e ~ tt; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ open term ktyp (ty_v (Fr e))
    (<span class="nb">subst</span> term ktyp x τ&#39; t)
: open typ ktyp (ty_v (Fr e)) (<span class="nb">subst</span> typ ktyp x τ&#39; τ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk6e"><span class="nb">rewrite</span> rw_subst_type_var_neq <span class="kr">in</span> IH; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 ++ e ~ tt = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ open term ktyp (ty_v (Fr e))
    (<span class="nb">subst</span> term ktyp x τ&#39; t)
: open typ ktyp (ty_v (Fr e))
    (<span class="nb">subst</span> typ ktyp x τ&#39; τ)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
(Δ1 ++ x ~ tt ++ Δ2) ++ x0 ~ tt; Γ
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}})</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ1 ++ Δ2 ++ e ~ tt; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ open term ktyp (ty_v (Fr e))
    (<span class="nb">subst</span> term ktyp x τ&#39; t)
: open typ ktyp (ty_v (Fr e)) (<span class="nb">subst</span> typ ktyp x τ&#39; τ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk6f"><span class="nb">apply</span> IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 ++ e ~ tt = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ open term ktyp (ty_v (Fr e))
    (<span class="nb">subst</span> term ktyp x τ&#39; t)
: open typ ktyp (ty_v (Fr e))
    (<span class="nb">subst</span> typ ktyp x τ&#39; τ)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
(Δ1 ++ x ~ tt ++ Δ2) ++ x0 ~ tt; Γ
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}})</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type (Δ1 ++ Δ2 ++ e ~ tt) τ&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk70" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 ++ e ~ tt = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ open term ktyp (ty_v (Fr e))
    (<span class="nb">subst</span> term ktyp x τ&#39; t)
: open typ ktyp (ty_v (Fr e))
    (<span class="nb">subst</span> typ ktyp x τ&#39; τ)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
(Δ1 ++ x ~ tt ++ Δ2) ++ x0 ~ tt; Γ
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}})</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; e</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk70"><hr></label><div class="goal-conclusion">Δ1 ++ x ~ tt ++ Δ2 ++ e ~ tt =
Δ1 ++ x ~ tt ++ Δ2 ++ e ~ tt</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk71">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 ++ e ~ tt = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ open term ktyp (ty_v (Fr e))
    (<span class="nb">subst</span> term ktyp x τ&#39; t)
: open typ ktyp (ty_v (Fr e))
    (<span class="nb">subst</span> typ ktyp x τ&#39; τ)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
(Δ1 ++ x ~ tt ++ Δ2) ++ x0 ~ tt; Γ
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}})</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type (Δ1 ++ Δ2 ++ e ~ tt) τ&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk72">change_alist ((Δ1 ++ Δ2) ++ e ~ tt).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 ++ e ~ tt = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ open term ktyp (ty_v (Fr e))
    (<span class="nb">subst</span> term ktyp x τ&#39; t)
: open typ ktyp (ty_v (Fr e))
    (<span class="nb">subst</span> typ ktyp x τ&#39; τ)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
(Δ1 ++ x ~ tt ++ Δ2) ++ x0 ~ tt; Γ
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}})</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type ((Δ1 ++ Δ2) ++ e ~ tt) τ&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto using</span> ok_type_weak_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk73">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 ++ e ~ tt = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ open term ktyp (ty_v (Fr e))
    (<span class="nb">subst</span> term ktyp x τ&#39; t)
: open typ ktyp (ty_v (Fr e))
    (<span class="nb">subst</span> typ ktyp x τ&#39; τ)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
(Δ1 ++ x ~ tt ++ Δ2) ++ x0 ~ tt; Γ
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}})</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ1 ++ x ~ tt ++ Δ2 ++ e ~ tt =
Δ1 ++ x ~ tt ++ Δ2 ++ e ~ tt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk74">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t
: <span class="nb">subst</span> typ ktyp x τ&#39; (ty_univ τ2)</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ1 ++ x ~ tt ++ Δ2; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ x ~ tt ++ Δ2) τ1</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ1 ++ Δ2; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; (tm_tap t τ1)
: <span class="nb">subst</span> typ ktyp x τ&#39; (open typ ktyp τ1 τ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk75">simplify_subst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t
: <span class="nb">subst</span> typ ktyp x τ&#39; (ty_univ τ2)</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ1 ++ x ~ tt ++ Δ2; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ x ~ tt ++ Δ2) τ1</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ1 ++ Δ2; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ tm_tap (<span class="nb">subst</span> term ktyp x τ&#39; t)
    (<span class="nb">subst</span> typ ktyp x τ&#39; τ1)
: <span class="nb">subst</span> typ ktyp x τ&#39; (open typ ktyp τ1 τ2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk76"><span class="nb">replace</span> (<span class="nb">subst</span> (ix := I2) typ ktyp x τ&#39; (ty_univ τ2))
      <span class="kr">with</span> (ty_univ (<span class="nb">subst</span> typ ktyp x τ&#39; τ2)) <span class="kr">in</span> IHj.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t
: ty_univ (<span class="nb">subst</span> typ ktyp x τ&#39; τ2)</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ1 ++ x ~ tt ++ Δ2; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ x ~ tt ++ Δ2) τ1</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ1 ++ Δ2; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ tm_tap (<span class="nb">subst</span> term ktyp x τ&#39; t)
    (<span class="nb">subst</span> typ ktyp x τ&#39; τ1)
: <span class="nb">subst</span> typ ktyp x τ&#39; (open typ ktyp τ1 τ2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk77" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t
: <span class="nb">subst</span> typ ktyp x τ&#39; (ty_univ τ2)</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ1 ++ x ~ tt ++ Δ2; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ x ~ tt ++ Δ2) τ1</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk77"><hr></label><div class="goal-conclusion">ty_univ (<span class="nb">subst</span> typ ktyp x τ&#39; τ2) =
<span class="nb">subst</span> typ ktyp x τ&#39; (ty_univ τ2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk78"><span class="mi">2</span>:{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t
: <span class="nb">subst</span> typ ktyp x τ&#39; (ty_univ τ2)</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ1 ++ x ~ tt ++ Δ2; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ x ~ tt ++ Δ2) τ1</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ty_univ (<span class="nb">subst</span> typ ktyp x τ&#39; τ2) =
<span class="nb">subst</span> typ ktyp x τ&#39; (ty_univ τ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> simplify_subst.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk79">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t
: ty_univ (<span class="nb">subst</span> typ ktyp x τ&#39; τ2)</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ1 ++ x ~ tt ++ Δ2; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ x ~ tt ++ Δ2) τ1</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ1 ++ Δ2; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ tm_tap (<span class="nb">subst</span> term ktyp x τ&#39; t)
    (<span class="nb">subst</span> typ ktyp x τ&#39; τ1)
: <span class="nb">subst</span> typ ktyp x τ&#39; (open typ ktyp τ1 τ2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk7a"><span class="nb">rewrite</span> (subst_open_eq typ); <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t
: ty_univ (<span class="nb">subst</span> typ ktyp x τ&#39; τ2)</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ1 ++ x ~ tt ++ Δ2; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ x ~ tt ++ Δ2) τ1</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ1 ++ Δ2; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ tm_tap (<span class="nb">subst</span> term ktyp x τ&#39; t)
    (<span class="nb">subst</span> typ ktyp x τ&#39; τ1)
: open typ ktyp (<span class="nb">subst</span> (SystemF ktyp) ktyp x τ&#39; τ1)
    (<span class="nb">subst</span> typ ktyp x τ&#39; τ2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk7b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t
: ty_univ (<span class="nb">subst</span> typ ktyp x τ&#39; τ2)</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ1 ++ x ~ tt ++ Δ2; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ x ~ tt ++ Δ2) τ1</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk7b"><hr></label><div class="goal-conclusion">LC (SystemF ktyp) ktyp τ&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk7c"><span class="mi">2</span>:{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t
: ty_univ (<span class="nb">subst</span> typ ktyp x τ&#39; τ2)</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ1 ++ x ~ tt ++ Δ2; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ x ~ tt ++ Δ2) τ1</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC (SystemF ktyp) ktyp τ&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk7d"><span class="nb">clear</span> IHj j.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ x ~ tt ++ Δ2) τ1</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC (SystemF ktyp) ktyp τ&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> ok_type_lc; <span class="nb">eauto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk7e">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ1</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ'</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Δ2</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Δ3</span> : list (atom * unit),
ok_type (Δ1 ++ Δ3) τ&#39; -&gt;
Δ1 ++ x ~ tt ++ Δ2 = Δ1 ++ x ~ tt ++ Δ3 -&gt;
Δ1 ++ Δ3; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ <span class="nb">subst</span> term ktyp x τ&#39; t
: ty_univ (<span class="nb">subst</span> typ ktyp x τ&#39; τ2)</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ1 ++ x ~ tt ++ Δ2; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ x ~ tt ++ Δ2) τ1</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type (Δ1 ++ Δ2) τ&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ1 ++ Δ2; envmap (<span class="nb">subst</span> typ ktyp x τ&#39;) Γ
⊢ tm_tap (<span class="nb">subst</span> term ktyp x τ&#39; t)
    (<span class="nb">subst</span> typ ktyp x τ&#39; τ1)
: open typ ktyp (<span class="nb">subst</span> (SystemF ktyp) ktyp x τ&#39; τ1)
    (<span class="nb">subst</span> typ ktyp x τ&#39; τ2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto using</span> j_inst <span class="kr">with</span> sysf_ctx.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk7f"><span class="kn">Theorem</span> <span class="nf">j_kind_ctx_subst1</span> : <span class="kr">forall</span> <span class="nv">Δ</span> <span class="nv">x</span> <span class="nv">Γ</span> <span class="nv">t</span> <span class="nv">τ</span> <span class="nv">τ2</span>,
    ok_type Δ τ2 -&gt;
    (Δ ++ x ~ tt ; Γ ⊢ t : τ) -&gt;
    (Δ ; envmap (<span class="nb">subst</span> typ ktyp x τ2) Γ ⊢ <span class="nb">subst</span> term ktyp x τ2 t : <span class="nb">subst</span> typ ktyp x τ2 τ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ</span> : kind_ctx) <span class="nv">x</span> (<span class="nv">Γ</span> : type_ctx) (<span class="nv">t</span> : term LN)
  (<span class="nv">τ</span> <span class="nv">τ2</span> : typ LN),
ok_type Δ τ2 -&gt;
Δ ++ x ~ tt; Γ ⊢ t : τ -&gt;
Δ; envmap (<span class="nb">subst</span> typ ktyp x τ2) Γ
⊢ <span class="nb">subst</span> term ktyp x τ2 t : <span class="nb">subst</span> typ ktyp x τ2 τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk80"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ</span> : kind_ctx) <span class="nv">x</span> (<span class="nv">Γ</span> : type_ctx) (<span class="nv">t</span> : term LN)
  (<span class="nv">τ</span> <span class="nv">τ2</span> : typ LN),
ok_type Δ τ2 -&gt;
Δ ++ x ~ tt; Γ ⊢ t : τ -&gt;
Δ; envmap (<span class="nb">subst</span> typ ktyp x τ2) Γ
⊢ <span class="nb">subst</span> term ktyp x τ2 t : <span class="nb">subst</span> typ ktyp x τ2 τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk81">introv jτ jt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>jτ</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ2</span></span></span><br><span><var>jt</var><span class="hyp-type"><b>: </b><span>Δ ++ x ~ tt; Γ ⊢ t : τ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; envmap (<span class="nb">subst</span> typ ktyp x τ2) Γ
⊢ <span class="nb">subst</span> term ktyp x τ2 t : <span class="nb">subst</span> typ ktyp x τ2 τ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk82">change_alist (Δ ++ x ~ tt ++ []) <span class="kr">in</span> jt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>jτ</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ2</span></span></span><br><span><var>jt</var><span class="hyp-type"><b>: </b><span>Δ ++ x ~ tt ++ []; Γ ⊢ t : τ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; envmap (<span class="nb">subst</span> typ ktyp x τ2) Γ
⊢ <span class="nb">subst</span> term ktyp x τ2 t : <span class="nb">subst</span> typ ktyp x τ2 τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk83">change_alist (Δ ++ []) <span class="kr">in</span> jτ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>jτ</var><span class="hyp-type"><b>: </b><span>ok_type (Δ ++ []) τ2</span></span></span><br><span><var>jt</var><span class="hyp-type"><b>: </b><span>Δ ++ x ~ tt ++ []; Γ ⊢ t : τ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; envmap (<span class="nb">subst</span> typ ktyp x τ2) Γ
⊢ <span class="nb">subst</span> term ktyp x τ2 t : <span class="nb">subst</span> typ ktyp x τ2 τ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk84">change_alist (Δ ++ []).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>jτ</var><span class="hyp-type"><b>: </b><span>ok_type (Δ ++ []) τ2</span></span></span><br><span><var>jt</var><span class="hyp-type"><b>: </b><span>Δ ++ x ~ tt ++ []; Γ ⊢ t : τ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ ++ []; envmap (<span class="nb">subst</span> typ ktyp x τ2) Γ
⊢ <span class="nb">subst</span> term ktyp x τ2 t : <span class="nb">subst</span> typ ktyp x τ2 τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto using</span> j_kind_ctx_subst.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Properties of &lt;&lt;Δ ; Γ ⊢ t : τ&gt;&gt; in &lt;&lt;Γ&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>

<span class="sd">(** *** &lt;&lt;Γ&gt;&gt; is always well-formed *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk85"><span class="kn">Lemma</span> <span class="nf">j_type_ctx_wf</span> : <span class="kr">forall</span> <span class="nv">Δ</span> <span class="nv">Γ</span> <span class="nv">t</span> <span class="nv">τ</span>,
    (Δ ; Γ ⊢ t : τ) -&gt;
    ok_type_ctx Δ Γ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ</span> : kind_ctx) (<span class="nv">Γ</span> : type_ctx) (<span class="nv">t</span> : term LN)
  (<span class="nv">τ</span> : typ LN), Δ; Γ ⊢ t : τ -&gt; ok_type_ctx Δ Γ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk86"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ</span> : kind_ctx) (<span class="nv">Γ</span> : type_ctx) (<span class="nv">t</span> : term LN)
  (<span class="nv">τ</span> : typ LN), Δ; Γ ⊢ t : τ -&gt; ok_type_ctx Δ Γ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk87">introv j.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : τ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type_ctx Δ Γ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk88"><span class="nb">induction</span> j; <span class="kp">try</span> <span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt; ok_type_ctx Δ (Γ ++ x ~ τ1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type_ctx Δ Γ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk89" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt; ok_type_ctx (Δ ++ x ~ tt) Γ</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk89"><hr></label><div class="goal-conclusion">ok_type_ctx Δ Γ</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk8a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt; ok_type_ctx Δ (Γ ++ x ~ τ1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type_ctx Δ Γ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk8b">cleanup_cofinite.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ (Γ ++ e ~ τ1)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type_ctx Δ Γ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eauto using</span> ok_type_ctx_inv_app_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk8c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt; ok_type_ctx (Δ ++ x ~ tt) Γ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type_ctx Δ Γ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk8d"><span class="nb">rename</span> H0 <span class="nb">into</span> IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt; ok_type_ctx (Δ ++ x ~ tt) Γ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type_ctx Δ Γ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk8e">pick <span class="kp">fresh</span> e <span class="kr">for</span> (L ∪ atoms (bind (T := list) (<span class="kr">fun</span> &#39;(x, t) =&gt; free typ ktyp t) Γ)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt; ok_type_ctx (Δ ++ x ~ tt) Γ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e
`notin` (L
         ∪ atoms
             (bind
                (<span class="kr">fun</span> &#39;(_, t) =&gt;
                 free typ ktyp t) Γ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type_ctx Δ Γ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk8f">specialize_cof IH e.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ok_type_ctx (Δ ++ e ~ tt) Γ</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e
`notin` (L
         ∪ atoms
             (bind
                (<span class="kr">fun</span> &#39;(_, t) =&gt;
                 free typ ktyp t) Γ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type_ctx Δ Γ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk90"><span class="nb">apply</span> (ok_type_ctx_stren1) <span class="kr">with</span> (x := e).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ok_type_ctx (Δ ++ e ~ tt) Γ</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e
`notin` (L
         ∪ atoms
             (bind
                (<span class="kr">fun</span> &#39;(_, t) =&gt;
                 free typ ktyp t) Γ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type_ctx (Δ ++ e ~ tt) Γ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk91" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ok_type_ctx (Δ ++ e ~ tt) Γ</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e
`notin` (L
         ∪ atoms
             (bind
                (<span class="kr">fun</span> &#39;(_, t) =&gt;
                 free typ ktyp t) Γ))</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk91"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : typ LN,
t ∈ range Γ -&gt; e `notin` FV typ ktyp t</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk92">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ok_type_ctx (Δ ++ e ~ tt) Γ</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e
`notin` (L
         ∪ atoms
             (bind
                (<span class="kr">fun</span> &#39;(_, t) =&gt;
                 free typ ktyp t) Γ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type_ctx (Δ ++ e ~ tt) Γ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk93">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ok_type_ctx (Δ ++ e ~ tt) Γ</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e
`notin` (L
         ∪ atoms
             (bind
                (<span class="kr">fun</span> &#39;(_, t) =&gt;
                 free typ ktyp t) Γ))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : typ LN,
t ∈ range Γ -&gt; e `notin` FV typ ktyp t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk94">introv Hin.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ok_type_ctx (Δ ++ e ~ tt) Γ</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e
`notin` (L
         ∪ atoms
             (bind
                (<span class="kr">fun</span> &#39;(_, t) =&gt;
                 free typ ktyp t) Γ))</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>t0 ∈ range Γ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">e `notin` FV typ ktyp t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk95"><span class="nb">enough</span> (lemma : ~ element_of (F := list) e (bind (T := list) (<span class="kr">fun</span> &#39;(x, t) =&gt; free typ ktyp t) Γ)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ok_type_ctx (Δ ++ e ~ tt) Γ</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e
`notin` (L
         ∪ atoms
             (bind
                (<span class="kr">fun</span> &#39;(_, t) =&gt;
                 free typ ktyp t) Γ))</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>t0 ∈ range Γ</span></span></span><br><span><var>lemma</var><span class="hyp-type"><b>: </b><span>~ e ∈ bind (<span class="kr">fun</span> &#39;(_, t) =&gt; free typ ktyp t) Γ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">e `notin` FV typ ktyp t0</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk96" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ok_type_ctx (Δ ++ e ~ tt) Γ</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e
`notin` (L
         ∪ atoms
             (bind
                (<span class="kr">fun</span> &#39;(_, t) =&gt;
                 free typ ktyp t) Γ))</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>t0 ∈ range Γ</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk96"><hr></label><div class="goal-conclusion">~ e ∈ bind (<span class="kr">fun</span> &#39;(_, t) =&gt; free typ ktyp t) Γ</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk97">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ok_type_ctx (Δ ++ e ~ tt) Γ</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e
`notin` (L
         ∪ atoms
             (bind
                (<span class="kr">fun</span> &#39;(_, t) =&gt;
                 free typ ktyp t) Γ))</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>t0 ∈ range Γ</span></span></span><br><span><var>lemma</var><span class="hyp-type"><b>: </b><span>~ e ∈ bind (<span class="kr">fun</span> &#39;(_, t) =&gt; free typ ktyp t) Γ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">e `notin` FV typ ktyp t0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk98"><span class="nb">rewrite</span> (in_bind_iff) <span class="kr">in</span> lemma.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ok_type_ctx (Δ ++ e ~ tt) Γ</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e
`notin` (L
         ∪ atoms
             (bind
                (<span class="kr">fun</span> &#39;(_, t) =&gt;
                 free typ ktyp t) Γ))</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>t0 ∈ range Γ</span></span></span><br><span><var>lemma</var><span class="hyp-type"><b>: </b><span>~
(<span class="kr">exists</span> <span class="nv">a</span> : atom * typ LN,
   a ∈ Γ /\
   e ∈ (<span class="kr">let</span> &#39;(_, t) := a <span class="kr">in</span> free typ ktyp t))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">e `notin` FV typ ktyp t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk99"><span class="nb">rewrite</span> in_range_iff <span class="kr">in</span> Hin.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ok_type_ctx (Δ ++ e ~ tt) Γ</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e
`notin` (L
         ∪ atoms
             (bind
                (<span class="kr">fun</span> &#39;(_, t) =&gt;
                 free typ ktyp t) Γ))</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">x</span>, (x, t0) ∈ Γ</span></span></span><br><span><var>lemma</var><span class="hyp-type"><b>: </b><span>~
(<span class="kr">exists</span> <span class="nv">a</span> : atom * typ LN,
   a ∈ Γ /\
   e ∈ (<span class="kr">let</span> &#39;(_, t) := a <span class="kr">in</span> free typ ktyp t))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">e `notin` FV typ ktyp t0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk9a"><span class="nb">destruct</span> Hin <span class="kr">as</span> [x Hin].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ok_type_ctx (Δ ++ e ~ tt) Γ</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e
`notin` (L
         ∪ atoms
             (bind
                (<span class="kr">fun</span> &#39;(_, t) =&gt;
                 free typ ktyp t) Γ))</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>(x, t0) ∈ Γ</span></span></span><br><span><var>lemma</var><span class="hyp-type"><b>: </b><span>~
(<span class="kr">exists</span> <span class="nv">a</span> : atom * typ LN,
   a ∈ Γ /\
   e ∈ (<span class="kr">let</span> &#39;(_, t) := a <span class="kr">in</span> free typ ktyp t))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">e `notin` FV typ ktyp t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk9b"><span class="bp">contradict</span> lemma.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ok_type_ctx (Δ ++ e ~ tt) Γ</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e
`notin` (L
         ∪ atoms
             (bind
                (<span class="kr">fun</span> &#39;(_, t) =&gt;
                 free typ ktyp t) Γ))</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>(x, t0) ∈ Γ</span></span></span><br><span><var>lemma</var><span class="hyp-type"><b>: </b><span>e `<span class="kr">in</span>` FV typ ktyp t0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">a</span> : atom * typ LN,
  a ∈ Γ /\ e ∈ (<span class="kr">let</span> &#39;(_, t) := a <span class="kr">in</span> free typ ktyp t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk9c"><span class="kr">exists</span> (<span class="nv">x</span>, t0).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ok_type_ctx (Δ ++ e ~ tt) Γ</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e
`notin` (L
         ∪ atoms
             (bind
                (<span class="kr">fun</span> &#39;(_, t) =&gt;
                 free typ ktyp t) Γ))</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>(x, t0) ∈ Γ</span></span></span><br><span><var>lemma</var><span class="hyp-type"><b>: </b><span>e `<span class="kr">in</span>` FV typ ktyp t0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x, t0) ∈ Γ /\ e ∈ free typ ktyp t0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk9d"><span class="nb">split</span>; [<span class="bp">assumption</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ok_type_ctx (Δ ++ e ~ tt) Γ</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e
`notin` (L
         ∪ atoms
             (bind
                (<span class="kr">fun</span> &#39;(_, t) =&gt;
                 free typ ktyp t) Γ))</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>(x, t0) ∈ Γ</span></span></span><br><span><var>lemma</var><span class="hyp-type"><b>: </b><span>e `<span class="kr">in</span>` FV typ ktyp t0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">e ∈ free typ ktyp t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">apply</span> free_iff_FV.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk9e">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ok_type_ctx (Δ ++ e ~ tt) Γ</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e
`notin` (L
         ∪ atoms
             (bind
                (<span class="kr">fun</span> &#39;(_, t) =&gt;
                 free typ ktyp t) Γ))</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>t0 ∈ range Γ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ e ∈ bind (<span class="kr">fun</span> &#39;(_, t) =&gt; free typ ktyp t) Γ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk9f">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ok_type_ctx (Δ ++ e ~ tt) Γ</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e
`notin` (L
         ∪ atoms
             (bind
                (<span class="kr">fun</span> &#39;(_, t) =&gt;
                 free typ ktyp t) Γ))</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>t0 ∈ range Γ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ e ∈ bind (<span class="kr">fun</span> &#39;(_, t) =&gt; free typ ktyp t) Γ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chka0"><span class="nb">rewrite</span> in_atoms_iff.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ok_type_ctx (Δ ++ e ~ tt) Γ</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e
`notin` (L
         ∪ atoms
             (bind
                (<span class="kr">fun</span> &#39;(_, t) =&gt;
                 free typ ktyp t) Γ))</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>t0 ∈ range Γ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">e
`notin` atoms
          (bind (<span class="kr">fun</span> &#39;(_, t) =&gt; free typ ktyp t) Γ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">fsetdec.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Tactical corollaries *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chka1"><span class="kn">Corollary</span> <span class="nf">j_type_ctx1</span> : <span class="kr">forall</span> <span class="nv">Δ</span> <span class="nv">Γ</span> <span class="nv">t</span> <span class="nv">τ</span> <span class="nv">x</span> <span class="nv">τ2</span>,
    (Δ ; Γ ⊢ t : τ) -&gt;
    (x, τ2) ∈ (Γ : list (atom * _)) -&gt;
    ok_type Δ τ2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ</span> : kind_ctx) (<span class="nv">Γ</span> : type_ctx) (<span class="nv">t</span> : term LN)
  (<span class="nv">τ</span> : typ LN) <span class="nv">x</span> (<span class="nv">τ2</span> : typ LN),
Δ; Γ ⊢ t : τ -&gt;
(x, τ2) ∈ (Γ : list (atom * typ LN)) -&gt; ok_type Δ τ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chka2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ</span> : kind_ctx) (<span class="nv">Γ</span> : type_ctx) (<span class="nv">t</span> : term LN)
  (<span class="nv">τ</span> : typ LN) <span class="nv">x</span> (<span class="nv">τ2</span> : typ LN),
Δ; Γ ⊢ t : τ -&gt;
(x, τ2) ∈ (Γ : list (atom * typ LN)) -&gt; ok_type Δ τ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eauto using</span> ok_type_ctx_binds, j_type_ctx_wf.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chka3"><span class="kn">Corollary</span> <span class="nf">j_type_ctx2</span> : <span class="kr">forall</span> <span class="nv">Δ</span> <span class="nv">Γ</span> <span class="nv">t</span> <span class="nv">τ1</span> <span class="nv">τ2</span> <span class="nv">x</span>,
    (Δ ; Γ ++ x ~ τ2 ⊢ t : τ1) -&gt;
    ok_type Δ τ2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ</span> : kind_ctx) (<span class="nv">Γ</span> : list (atom * typ LN))
  (<span class="nv">t</span> : term LN) (<span class="nv">τ1</span> <span class="nv">τ2</span> : typ LN) <span class="nv">x</span>,
Δ; Γ ++ x ~ τ2 ⊢ t : τ1 -&gt; ok_type Δ τ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chka4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ</span> : kind_ctx) (<span class="nv">Γ</span> : list (atom * typ LN))
  (<span class="nv">t</span> : term LN) (<span class="nv">τ1</span> <span class="nv">τ2</span> : typ LN) <span class="nv">x</span>,
Δ; Γ ++ x ~ τ2 ⊢ t : τ1 -&gt; ok_type Δ τ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chka5"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ x ~ τ2 ⊢ t : τ1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type Δ τ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chka6"><span class="nb">eapply</span> j_type_ctx1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ x ~ τ2 ⊢ t : τ1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; <span class="nl">?Γ</span> ⊢ <span class="nl">?t</span> : <span class="nl">?τ</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chka7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ x ~ τ2 ⊢ t : τ1</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chka7"><hr></label><div class="goal-conclusion">(<span class="nl">?x</span>, τ2) ∈ <span class="nl">?Γ</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chka8"><span class="nb">eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ x ~ τ2 ⊢ t : τ1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?x</span>, τ2) ∈ (Γ ++ x ~ τ2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chka9"><span class="nb">autorewrite with</span> tea_list.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ x ~ τ2 ⊢ t : τ1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?x</span>, τ2) ∈ Γ \/ (<span class="nl">?x</span>, τ2) = (x, τ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Permutation *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkaa"><span class="kn">Theorem</span> <span class="nf">j_type_ctx_perm</span> : <span class="kr">forall</span> <span class="nv">Δ</span> <span class="nv">Γ1</span> <span class="nv">Γ2</span> <span class="nv">t</span> <span class="nv">τ</span>,
    (Δ ; Γ1 ⊢ t : τ) -&gt;
    Permutation Γ1 Γ2 -&gt;
    (Δ ; Γ2 ⊢ t : τ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ</span> : kind_ctx) (<span class="nv">Γ1</span> : type_ctx)
  (<span class="nv">Γ2</span> : list (atom * typ LN)) (<span class="nv">t</span> : term LN)
  (<span class="nv">τ</span> : typ LN),
Δ; Γ1 ⊢ t : τ -&gt; Permutation Γ1 Γ2 -&gt; Δ; Γ2 ⊢ t : τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkab"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ</span> : kind_ctx) (<span class="nv">Γ1</span> : type_ctx)
  (<span class="nv">Γ2</span> : list (atom * typ LN)) (<span class="nv">t</span> : term LN)
  (<span class="nv">τ</span> : typ LN),
Δ; Γ1 ⊢ t : τ -&gt; Permutation Γ1 Γ2 -&gt; Δ; Γ2 ⊢ t : τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkac">introv j perm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ⊢ t : τ</span></span></span><br><span><var>perm</var><span class="hyp-type"><b>: </b><span>Permutation Γ1 Γ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ2 ⊢ t : τ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkad"><span class="nb">generalize dependent</span> Γ2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ⊢ t : τ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">Γ2</span> : list (atom * typ LN),
Permutation Γ1 Γ2 -&gt; Δ; Γ2 ⊢ t : τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkae"><span class="nb">induction</span> j; <span class="nb">intros</span> ? Hperm; <span class="kp">try</span> <span class="nb">eauto using</span> Judgment.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x, τ) ∈ Γ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hperm</var><span class="hyp-type"><b>: </b><span>Permutation Γ Γ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ2 ⊢ tm_var (Fr x) : τ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chkaf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
<span class="kr">forall</span> <span class="nv">Γ2</span> : list (atom * typ LN),
Permutation (Γ ++ x ~ τ1) Γ2 -&gt;
Δ; Γ2 ⊢ open term ktrm (tm_var (Fr x)) t : τ2</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hperm</var><span class="hyp-type"><b>: </b><span>Permutation Γ Γ2</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chkaf"><hr></label><div class="goal-conclusion">Δ; Γ2 ⊢ tm_abs τ1 t : ty_ar τ1 τ2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkb0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x, τ) ∈ Γ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hperm</var><span class="hyp-type"><b>: </b><span>Permutation Γ Γ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ2 ⊢ tm_var (Fr x) : τ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkb1"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x, τ) ∈ Γ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hperm</var><span class="hyp-type"><b>: </b><span>Permutation Γ Γ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_kind_ctx Δ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chkb2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x, τ) ∈ Γ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hperm</var><span class="hyp-type"><b>: </b><span>Permutation Γ Γ2</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chkb2"><hr></label><div class="goal-conclusion">ok_type_ctx Δ Γ2</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chkb3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x, τ) ∈ Γ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hperm</var><span class="hyp-type"><b>: </b><span>Permutation Γ Γ2</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chkb3"><hr></label><div class="goal-conclusion">(x, τ) ∈ Γ2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkb4">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x, τ) ∈ Γ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hperm</var><span class="hyp-type"><b>: </b><span>Permutation Γ Γ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_kind_ctx Δ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eauto using</span> ok_kind_ctx_perm.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkb5">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x, τ) ∈ Γ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hperm</var><span class="hyp-type"><b>: </b><span>Permutation Γ Γ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type_ctx Δ Γ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> ok_type_ctx_perm_gamma;
        <span class="nb">eauto using</span> Permutation_sym.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkb6">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x, τ) ∈ Γ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hperm</var><span class="hyp-type"><b>: </b><span>Permutation Γ Γ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x, τ) ∈ Γ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkb7"><span class="nb">symmetry in</span> Hperm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x, τ) ∈ Γ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hperm</var><span class="hyp-type"><b>: </b><span>Permutation Γ2 Γ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x, τ) ∈ Γ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">erewrite</span> List.permutation_spec; <span class="nb">eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkb8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
<span class="kr">forall</span> <span class="nv">Γ2</span> : list (atom * typ LN),
Permutation (Γ ++ x ~ τ1) Γ2 -&gt;
Δ; Γ2 ⊢ open term ktrm (tm_var (Fr x)) t : τ2</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hperm</var><span class="hyp-type"><b>: </b><span>Permutation Γ Γ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ2 ⊢ tm_abs τ1 t : ty_ar τ1 τ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">econstructor</span>; <span class="nb">eauto using</span> Permutation_app_tail.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkb9"><span class="kn">Corollary</span> <span class="nf">j_type_ctx_perm_iff</span> : <span class="kr">forall</span> <span class="nv">Δ</span> <span class="nv">Γ1</span> <span class="nv">Γ2</span> <span class="nv">t</span> <span class="nv">τ</span>,
    Permutation Γ1 Γ2 -&gt;
    (Δ ; Γ1 ⊢ t : τ) &lt;-&gt;
    (Δ ; Γ2 ⊢ t : τ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ</span> : kind_ctx) (<span class="nv">Γ1</span> <span class="nv">Γ2</span> : list (atom * typ LN))
  (<span class="nv">t</span> : term LN) (<span class="nv">τ</span> : typ LN),
Permutation Γ1 Γ2 -&gt; Δ; Γ1 ⊢ t : τ &lt;-&gt; Δ; Γ2 ⊢ t : τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkba"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ</span> : kind_ctx) (<span class="nv">Γ1</span> <span class="nv">Γ2</span> : list (atom * typ LN))
  (<span class="nv">t</span> : term LN) (<span class="nv">τ</span> : typ LN),
Permutation Γ1 Γ2 -&gt; Δ; Γ1 ⊢ t : τ &lt;-&gt; Δ; Γ2 ⊢ t : τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkbb">introv Hperm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ1, Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Hperm</var><span class="hyp-type"><b>: </b><span>Permutation Γ1 Γ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ1 ⊢ t : τ &lt;-&gt; Δ; Γ2 ⊢ t : τ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkbc"><span class="nb">assert</span> (Permutation Γ2 Γ1) <span class="bp">by</span> <span class="bp">now</span> <span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ1, Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Hperm</var><span class="hyp-type"><b>: </b><span>Permutation Γ1 Γ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Permutation Γ2 Γ1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ1 ⊢ t : τ &lt;-&gt; Δ; Γ2 ⊢ t : τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">split</span>; <span class="nb">eauto using</span> j_type_ctx_perm.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkbd"><span class="kn">Corollary</span> <span class="nf">j_type_ctx_perm1</span> : <span class="kr">forall</span> <span class="nv">Δ</span> <span class="nv">Γ1</span> <span class="nv">Γ2</span> <span class="nv">x</span> <span class="nv">τ2</span> <span class="nv">t</span> <span class="nv">τ1</span>,
    (Δ ; (Γ1 ++ x ~ τ2) ++ Γ2 ⊢ t : τ1) &lt;-&gt;
    (Δ ; (Γ1 ++ Γ2) ++ x ~ τ2 ⊢ t : τ1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ</span> : kind_ctx) (<span class="nv">Γ1</span> <span class="nv">Γ2</span> : list (atom * typ LN)) 
  <span class="nv">x</span> (<span class="nv">τ2</span> : typ LN) (<span class="nv">t</span> : term LN) (<span class="nv">τ1</span> : typ LN),
Δ; (Γ1 ++ x ~ τ2) ++ Γ2 ⊢ t : τ1 &lt;-&gt;
Δ; (Γ1 ++ Γ2) ++ x ~ τ2 ⊢ t : τ1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkbe"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ</span> : kind_ctx) (<span class="nv">Γ1</span> <span class="nv">Γ2</span> : list (atom * typ LN)) 
  <span class="nv">x</span> (<span class="nv">τ2</span> : typ LN) (<span class="nv">t</span> : term LN) (<span class="nv">τ1</span> : typ LN),
Δ; (Γ1 ++ x ~ τ2) ++ Γ2 ⊢ t : τ1 &lt;-&gt;
Δ; (Γ1 ++ Γ2) ++ x ~ τ2 ⊢ t : τ1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkbf"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ1, Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; (Γ1 ++ x ~ τ2) ++ Γ2 ⊢ t : τ1 &lt;-&gt;
Δ; (Γ1 ++ Γ2) ++ x ~ τ2 ⊢ t : τ1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkc0"><span class="nb">apply</span> j_type_ctx_perm_iff.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ1, Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Permutation ((Γ1 ++ x ~ τ2) ++ Γ2)
  ((Γ1 ++ Γ2) ++ x ~ τ2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkc1">simpl_alist.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ1, Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Permutation (Γ1 ++ x ~ τ2 ++ Γ2) (Γ1 ++ Γ2 ++ x ~ τ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Permutation_app; <span class="nb">auto using</span> Permutation_app_comm.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Weakening *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkc2"><span class="kn">Theorem</span> <span class="nf">j_type_ctx_weak</span> : <span class="kr">forall</span> <span class="nv">Δ</span> <span class="nv">Γ1</span> <span class="nv">Γ2</span> <span class="nv">t</span> <span class="nv">τ</span>,
    ok_type_ctx Δ Γ2 -&gt;
    disjoint Γ1 Γ2 -&gt;
    (Δ ; Γ1 ⊢ t : τ) -&gt;
    (Δ ; Γ1 ++ Γ2 ⊢ t : τ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ</span> : kind_ctx) (<span class="nv">Γ1</span> : alist (typ LN))
  (<span class="nv">Γ2</span> : type_ctx) (<span class="nv">t</span> : term LN) (<span class="nv">τ</span> : typ LN),
ok_type_ctx Δ Γ2 -&gt;
disjoint Γ1 Γ2 -&gt; Δ; Γ1 ⊢ t : τ -&gt; Δ; Γ1 ++ Γ2 ⊢ t : τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkc3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ</span> : kind_ctx) (<span class="nv">Γ1</span> : alist (typ LN))
  (<span class="nv">Γ2</span> : type_ctx) (<span class="nv">t</span> : term LN) (<span class="nv">τ</span> : typ LN),
ok_type_ctx Δ Γ2 -&gt;
disjoint Γ1 Γ2 -&gt; Δ; Γ1 ⊢ t : τ -&gt; Δ; Γ1 ++ Γ2 ⊢ t : τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkc4">introv ok disj j.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>alist (typ LN)</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Γ1 Γ2</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ⊢ t : τ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ1 ++ Γ2 ⊢ t : τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* save knowledge that Δ is uniq for [j_inst] case *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkc5"><span class="nb">pose proof</span> (okΔ := j); <span class="nb">apply</span> j_kind_ctx_wf <span class="kr">in</span> okΔ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>alist (typ LN)</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Γ1 Γ2</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ⊢ t : τ</span></span></span><br><span><var>okΔ</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ1 ++ Γ2 ⊢ t : τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkc6"><span class="nb">induction</span> j.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Γ Γ2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x, τ) ∈ Γ</span></span></span><br><span><var>okΔ</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ ++ Γ2 ⊢ tm_var (Fr x) : τ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chkc7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Γ Γ2</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
ok_type_ctx Δ Γ2 -&gt;
disjoint (Γ ++ x ~ τ1) Γ2 -&gt;
ok_kind_ctx Δ -&gt;
Δ; (Γ ++ x ~ τ1) ++ Γ2
⊢ open term ktrm (tm_var (Fr x)) t : τ2</span></span></span><br><span><var>okΔ</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chkc7"><hr></label><div class="goal-conclusion">Δ; Γ ++ Γ2 ⊢ tm_abs τ1 t : ty_ar τ1 τ2</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chkc8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Γ Γ2</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t2 : τ1</span></span></span><br><span><var>okΔ</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2 -&gt;
disjoint Γ Γ2 -&gt;
ok_kind_ctx Δ -&gt; Δ; Γ ++ Γ2 ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2 -&gt;
disjoint Γ Γ2 -&gt;
ok_kind_ctx Δ -&gt; Δ; Γ ++ Γ2 ⊢ t2 : τ1</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chkc8"><hr></label><div class="goal-conclusion">Δ; Γ ++ Γ2 ⊢ tm_app t1 t2 : τ2</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chkc9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Γ Γ2</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
ok_type_ctx (Δ ++ x ~ tt) Γ2 -&gt;
disjoint Γ Γ2 -&gt;
ok_kind_ctx (Δ ++ x ~ tt) -&gt;
Δ ++ x ~ tt; Γ ++ Γ2
⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>okΔ</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chkc9"><hr></label><div class="goal-conclusion">Δ; Γ ++ Γ2 ⊢ tm_tab t : ty_univ τ</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chkca" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Γ Γ2</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>okΔ</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2 -&gt;
disjoint Γ Γ2 -&gt;
ok_kind_ctx Δ -&gt; Δ; Γ ++ Γ2 ⊢ t : ty_univ τ2</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chkca"><hr></label><div class="goal-conclusion">Δ; Γ ++ Γ2 ⊢ tm_tap t τ1 : open typ ktyp τ1 τ2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkcb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Γ Γ2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x, τ) ∈ Γ</span></span></span><br><span><var>okΔ</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ ++ Γ2 ⊢ tm_var (Fr x) : τ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkcc"><span class="nb">apply</span> j_var.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Γ Γ2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x, τ) ∈ Γ</span></span></span><br><span><var>okΔ</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_kind_ctx Δ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chkcd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Γ Γ2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x, τ) ∈ Γ</span></span></span><br><span><var>okΔ</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chkcd"><hr></label><div class="goal-conclusion">ok_type_ctx Δ (Γ ++ Γ2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chkce" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Γ Γ2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x, τ) ∈ Γ</span></span></span><br><span><var>okΔ</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chkce"><hr></label><div class="goal-conclusion">(x, τ) ∈ (Γ ++ Γ2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkcf">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Γ Γ2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x, τ) ∈ Γ</span></span></span><br><span><var>okΔ</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_kind_ctx Δ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkd0">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Γ Γ2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x, τ) ∈ Γ</span></span></span><br><span><var>okΔ</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type_ctx Δ (Γ ++ Γ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> ok_type_ctx_app.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkd1">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Γ Γ2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x, τ) ∈ Γ</span></span></span><br><span><var>okΔ</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x, τ) ∈ (Γ ++ Γ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkd2"><span class="nb">autorewrite with</span> tea_list.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Γ Γ2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x, τ) ∈ Γ</span></span></span><br><span><var>okΔ</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x, τ) ∈ Γ \/ (x, τ) ∈ Γ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkd3">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Γ Γ2</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
ok_type_ctx Δ Γ2 -&gt;
disjoint (Γ ++ x ~ τ1) Γ2 -&gt;
ok_kind_ctx Δ -&gt;
Δ; (Γ ++ x ~ τ1) ++ Γ2
⊢ open term ktrm (tm_var (Fr x)) t : τ2</span></span></span><br><span><var>okΔ</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ ++ Γ2 ⊢ tm_abs τ1 t : ty_ar τ1 τ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkd4"><span class="nb">apply</span> j_abs <span class="kr">with</span> (L := L ∪ domset Γ2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Γ Γ2</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
ok_type_ctx Δ Γ2 -&gt;
disjoint (Γ ++ x ~ τ1) Γ2 -&gt;
ok_kind_ctx Δ -&gt;
Δ; (Γ ++ x ~ τ1) ++ Γ2
⊢ open term ktrm (tm_var (Fr x)) t : τ2</span></span></span><br><span><var>okΔ</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` (L ∪ domset Γ2) -&gt;
Δ; (Γ ++ Γ2) ++ x ~ τ1
⊢ open term ktrm (tm_var (Fr x)) t : τ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkd5">+  <span class="c">(* todo need better automation here *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Γ Γ2</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
ok_type_ctx Δ Γ2 -&gt;
disjoint (Γ ++ x ~ τ1) Γ2 -&gt;
ok_kind_ctx Δ -&gt;
Δ; (Γ ++ x ~ τ1) ++ Γ2
⊢ open term ktrm (tm_var (Fr x)) t : τ2</span></span></span><br><span><var>okΔ</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` (L ∪ domset Γ2) -&gt;
Δ; (Γ ++ Γ2) ++ x ~ τ1
⊢ open term ktrm (tm_var (Fr x)) t : τ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkd6"><span class="nb">rename</span> H0 <span class="nb">into</span> IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Γ Γ2</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
ok_type_ctx Δ Γ2 -&gt;
disjoint (Γ ++ x ~ τ1) Γ2 -&gt;
ok_kind_ctx Δ -&gt;
Δ; (Γ ++ x ~ τ1) ++ Γ2
⊢ open term ktrm (tm_var (Fr x)) t : τ2</span></span></span><br><span><var>okΔ</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` (L ∪ domset Γ2) -&gt;
Δ; (Γ ++ Γ2) ++ x ~ τ1
⊢ open term ktrm (tm_var (Fr x)) t : τ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkd7">intros_cof IH; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Γ Γ2</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2 -&gt;
disjoint (Γ ++ e ~ τ1) Γ2 -&gt;
ok_kind_ctx Δ -&gt;
Δ; (Γ ++ e ~ τ1) ++ Γ2
⊢ open term ktrm (tm_var (Fr e)) t : τ2</span></span></span><br><span><var>okΔ</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ domset Γ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; (Γ ++ Γ2) ++ e ~ τ1
⊢ open term ktrm (tm_var (Fr e)) t : τ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkd8"><span class="nb">rewrite</span> &lt;- j_type_ctx_perm1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Γ Γ2</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2 -&gt;
disjoint (Γ ++ e ~ τ1) Γ2 -&gt;
ok_kind_ctx Δ -&gt;
Δ; (Γ ++ e ~ τ1) ++ Γ2
⊢ open term ktrm (tm_var (Fr e)) t : τ2</span></span></span><br><span><var>okΔ</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ domset Γ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; (Γ ++ e ~ τ1) ++ Γ2
⊢ open term ktrm (tm_var (Fr e)) t : τ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkd9"><span class="nb">apply</span> IH; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Γ Γ2</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2 -&gt;
disjoint (Γ ++ e ~ τ1) Γ2 -&gt;
ok_kind_ctx Δ -&gt;
Δ; (Γ ++ e ~ τ1) ++ Γ2
⊢ open term ktrm (tm_var (Fr e)) t : τ2</span></span></span><br><span><var>okΔ</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ domset Γ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">disjoint (Γ ++ e ~ τ1) Γ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkda"><span class="nb">autorewrite with</span> tea_rw_disj.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Γ Γ2</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2 -&gt;
disjoint (Γ ++ e ~ τ1) Γ2 -&gt;
ok_kind_ctx Δ -&gt;
Δ; (Γ ++ e ~ τ1) ++ Γ2
⊢ open term ktrm (tm_var (Fr e)) t : τ2</span></span></span><br><span><var>okΔ</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ domset Γ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">disjoint Γ Γ2 /\ e `notin` domset Γ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intuition</span> fsetdec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkdb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Γ Γ2</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t2 : τ1</span></span></span><br><span><var>okΔ</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2 -&gt;
disjoint Γ Γ2 -&gt;
ok_kind_ctx Δ -&gt; Δ; Γ ++ Γ2 ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2 -&gt;
disjoint Γ Γ2 -&gt;
ok_kind_ctx Δ -&gt; Δ; Γ ++ Γ2 ⊢ t2 : τ1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ ++ Γ2 ⊢ tm_app t1 t2 : τ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> j_app <span class="kr">with</span> (τ1 := τ1); <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkdc">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Γ Γ2</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
ok_type_ctx (Δ ++ x ~ tt) Γ2 -&gt;
disjoint Γ Γ2 -&gt;
ok_kind_ctx (Δ ++ x ~ tt) -&gt;
Δ ++ x ~ tt; Γ ++ Γ2
⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>okΔ</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ ++ Γ2 ⊢ tm_tab t : ty_univ τ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkdd"><span class="nb">apply</span> j_univ <span class="kr">with</span> (L := L ∪ domset Δ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Γ Γ2</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
ok_type_ctx (Δ ++ x ~ tt) Γ2 -&gt;
disjoint Γ Γ2 -&gt;
ok_kind_ctx (Δ ++ x ~ tt) -&gt;
Δ ++ x ~ tt; Γ ++ Γ2
⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>okΔ</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` (L ∪ domset Δ) -&gt;
Δ ++ x ~ tt; Γ ++ Γ2 ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkde">intros_cof H0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Γ Γ2</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx (Δ ++ e ~ tt) Γ2 -&gt;
disjoint Γ Γ2 -&gt;
ok_kind_ctx (Δ ++ e ~ tt) -&gt;
Δ ++ e ~ tt; Γ ++ Γ2
⊢ open term ktyp (ty_v (Fr e)) t
: open typ ktyp (ty_v (Fr e)) τ</span></span></span><br><span><var>okΔ</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ domset Δ)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ ++ e ~ tt; Γ ++ Γ2 ⊢ open term ktyp (ty_v (Fr e)) t
: open typ ktyp (ty_v (Fr e)) τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkdf"><span class="nb">apply</span> H0; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Γ Γ2</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx (Δ ++ e ~ tt) Γ2 -&gt;
disjoint Γ Γ2 -&gt;
ok_kind_ctx (Δ ++ e ~ tt) -&gt;
Δ ++ e ~ tt; Γ ++ Γ2
⊢ open term ktyp (ty_v (Fr e)) t
: open typ ktyp (ty_v (Fr e)) τ</span></span></span><br><span><var>okΔ</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ domset Δ)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type_ctx (Δ ++ e ~ tt) Γ2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chke0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Γ Γ2</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx (Δ ++ e ~ tt) Γ2 -&gt;
disjoint Γ Γ2 -&gt;
ok_kind_ctx (Δ ++ e ~ tt) -&gt;
Δ ++ e ~ tt; Γ ++ Γ2
⊢ open term ktyp (ty_v (Fr e)) t
: open typ ktyp (ty_v (Fr e)) τ</span></span></span><br><span><var>okΔ</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ domset Δ)</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chke0"><hr></label><div class="goal-conclusion">ok_kind_ctx (Δ ++ e ~ tt)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chke1">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Γ Γ2</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx (Δ ++ e ~ tt) Γ2 -&gt;
disjoint Γ Γ2 -&gt;
ok_kind_ctx (Δ ++ e ~ tt) -&gt;
Δ ++ e ~ tt; Γ ++ Γ2
⊢ open term ktyp (ty_v (Fr e)) t
: open typ ktyp (ty_v (Fr e)) τ</span></span></span><br><span><var>okΔ</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ domset Δ)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type_ctx (Δ ++ e ~ tt) Γ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto using</span> ok_type_ctx_weak_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chke2">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Γ Γ2</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx (Δ ++ e ~ tt) Γ2 -&gt;
disjoint Γ Γ2 -&gt;
ok_kind_ctx (Δ ++ e ~ tt) -&gt;
Δ ++ e ~ tt; Γ ++ Γ2
⊢ open term ktyp (ty_v (Fr e)) t
: open typ ktyp (ty_v (Fr e)) τ</span></span></span><br><span><var>okΔ</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ domset Δ)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_kind_ctx (Δ ++ e ~ tt)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chke3"><span class="nb">rewrite</span> ok_kind_ctx_app.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Γ Γ2</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx (Δ ++ e ~ tt) Γ2 -&gt;
disjoint Γ Γ2 -&gt;
ok_kind_ctx (Δ ++ e ~ tt) -&gt;
Δ ++ e ~ tt; Γ ++ Γ2
⊢ open term ktyp (ty_v (Fr e)) t
: open typ ktyp (ty_v (Fr e)) τ</span></span></span><br><span><var>okΔ</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ domset Δ)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_kind_ctx Δ /\
ok_kind_ctx (e ~ tt) /\ disjoint Δ (e ~ tt)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chke4"><span class="nb">autorewrite with</span> tea_rw_disj.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Γ Γ2</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx (Δ ++ e ~ tt) Γ2 -&gt;
disjoint Γ Γ2 -&gt;
ok_kind_ctx (Δ ++ e ~ tt) -&gt;
Δ ++ e ~ tt; Γ ++ Γ2
⊢ open term ktyp (ty_v (Fr e)) t
: open typ ktyp (ty_v (Fr e)) τ</span></span></span><br><span><var>okΔ</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ domset Δ)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_kind_ctx Δ /\
ok_kind_ctx (e ~ tt) /\ e `notin` domset Δ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">splits; <span class="nb">intuition</span> (<span class="nb">auto using</span> ok_kind_ctx_one; fsetdec).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chke5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Γ Γ2</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>okΔ</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2 -&gt;
disjoint Γ Γ2 -&gt;
ok_kind_ctx Δ -&gt; Δ; Γ ++ Γ2 ⊢ t : ty_univ τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ ++ Γ2 ⊢ tm_tap t τ1 : open typ ktyp τ1 τ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chke6"><span class="nb">apply</span> j_inst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Γ Γ2</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>okΔ</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2 -&gt;
disjoint Γ Γ2 -&gt;
ok_kind_ctx Δ -&gt; Δ; Γ ++ Γ2 ⊢ t : ty_univ τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type Δ τ1</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chke7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Γ Γ2</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>okΔ</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2 -&gt;
disjoint Γ Γ2 -&gt;
ok_kind_ctx Δ -&gt; Δ; Γ ++ Γ2 ⊢ t : ty_univ τ2</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chke7"><hr></label><div class="goal-conclusion">Δ; Γ ++ Γ2 ⊢ t : ty_univ τ2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chke8">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Γ Γ2</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>okΔ</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2 -&gt;
disjoint Γ Γ2 -&gt;
ok_kind_ctx Δ -&gt; Δ; Γ ++ Γ2 ⊢ t : ty_univ τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type Δ τ1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chke9">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>ok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>disj</var><span class="hyp-type"><b>: </b><span>disjoint Γ Γ2</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>okΔ</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ2 -&gt;
disjoint Γ Γ2 -&gt;
ok_kind_ctx Δ -&gt; Δ; Γ ++ Γ2 ⊢ t : ty_univ τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ ++ Γ2 ⊢ t : ty_univ τ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IHj; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Substitution *)</span>
<span class="sd">(******************************************************************************)</span>

<span class="sd">(** ** Properties in τ of &lt;&lt;(Δ ; Γ ⊢ t : τ&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>

<span class="sd">(** *** &lt;&lt;τ&gt;&gt; is always locally closed *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkea"><span class="kn">Lemma</span> <span class="nf">j_lc_type</span> : <span class="kr">forall</span> <span class="nv">Δ</span> <span class="nv">Γ</span> <span class="nv">t</span> <span class="nv">τ</span>,
    (Δ ; Γ ⊢ t : τ) -&gt;
    LC typ ktyp τ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ</span> : kind_ctx) (<span class="nv">Γ</span> : type_ctx) (<span class="nv">t</span> : term LN)
  (<span class="nv">τ</span> : typ LN), Δ; Γ ⊢ t : τ -&gt; LC typ ktyp τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkeb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ</span> : kind_ctx) (<span class="nv">Γ</span> : type_ctx) (<span class="nv">t</span> : term LN)
  (<span class="nv">τ</span> : typ LN), Δ; Γ ⊢ t : τ -&gt; LC typ ktyp τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkec">introv j.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : τ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC typ ktyp τ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chked"><span class="nb">induction</span> j.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x, τ) ∈ Γ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC typ ktyp τ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chkee" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt; LC typ ktyp τ2</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chkee"><hr></label><div class="goal-conclusion">LC typ ktyp (ty_ar τ1 τ2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chkef" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t2 : τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span>LC typ ktyp (ty_ar τ1 τ2)</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span>LC typ ktyp τ1</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chkef"><hr></label><div class="goal-conclusion">LC typ ktyp τ2</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chkf0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
LC typ ktyp (open typ ktyp (ty_v (Fr x)) τ)</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chkf0"><hr></label><div class="goal-conclusion">LC typ ktyp (ty_univ τ)</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chkf1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>LC typ ktyp (ty_univ τ2)</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chkf1"><hr></label><div class="goal-conclusion">LC typ ktyp (open typ ktyp τ1 τ2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkf2">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x, τ) ∈ Γ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC typ ktyp τ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> ok_type_ctx_binds; <span class="nb">eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkf3" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkf3">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt; LC typ ktyp τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC typ ktyp (ty_ar τ1 τ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkf4">cc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>LC typ ktyp τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC typ ktyp (ty_ar τ1 τ2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkf5" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkf5">simplify_LC.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>LC typ ktyp τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC typ ktyp τ1 /\ LC typ ktyp τ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkf6"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>LC typ ktyp τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC typ ktyp τ1</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chkf7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>LC typ ktyp τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chkf7"><hr></label><div class="goal-conclusion">LC typ ktyp τ2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkf8">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>LC typ ktyp τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC typ ktyp τ1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkf9"><span class="nb">eapply</span> j_type_ctx2 <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>LC typ ktyp τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC typ ktyp τ1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> ok_type_lc; <span class="nb">eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkfa" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkfa">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>LC typ ktyp τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC typ ktyp τ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkfb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t2 : τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span>LC typ ktyp (ty_ar τ1 τ2)</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span>LC typ ktyp τ1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC typ ktyp τ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">replace</span> (LC (ix := I2) typ ktyp (ty_ar τ1 τ2))
      <span class="kr">with</span> (LC typ ktyp τ1 /\ LC typ ktyp τ2) <span class="kr">in</span> IHj1 <span class="bp">by</span> (<span class="bp">now</span> simplify_LC).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkfc">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
LC typ ktyp (open typ ktyp (ty_v (Fr x)) τ)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC typ ktyp (ty_univ τ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkfd">cc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ ++ e0 ~ tt; Γ ⊢ open term ktyp (ty_v (Fr e0)) t
: open typ ktyp (ty_v (Fr e0)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>LC typ ktyp (open typ ktyp (ty_v (Fr e)) τ)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC typ ktyp (ty_univ τ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkfe">simplify_LC.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ ++ e0 ~ tt; Γ ⊢ open term ktyp (ty_v (Fr e0)) t
: open typ ktyp (ty_v (Fr e0)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>LC typ ktyp (open typ ktyp (ty_v (Fr e)) τ)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LCn typ ktyp <span class="mi">1</span> τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> (open_lc_gap_eq_var typ); <span class="nb">eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chkff" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chkff">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>LC typ ktyp (ty_univ τ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC typ ktyp (open typ ktyp τ1 τ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk100"><span class="nb">rewrite</span> &lt;- (open_lc_gap_eq_iff_1 typ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>LC typ ktyp (ty_univ τ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LCn typ ktyp <span class="mi">1</span> τ2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk101" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>LC typ ktyp (ty_univ τ2)</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk101"><hr></label><div class="goal-conclusion">LC (SystemF ktyp) ktyp τ1</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk102">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>LC typ ktyp (ty_univ τ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LCn typ ktyp <span class="mi">1</span> τ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk103" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk103"><span class="nb">replace</span> (LC (ix := I2) typ ktyp (ty_univ τ2))
        <span class="kr">with</span> (LCn typ ktyp <span class="mi">1</span> τ2) <span class="kr">in</span> IHj
          <span class="bp">by</span> (<span class="bp">now</span> simplify_LC).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>LCn typ ktyp <span class="mi">1</span> τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LCn typ ktyp <span class="mi">1</span> τ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk104">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>LC typ ktyp (ty_univ τ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC (SystemF ktyp) ktyp τ1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk105" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk105"><span class="nb">eapply</span> ok_type_lc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>LC typ ktyp (ty_univ τ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type <span class="nl">?Δ</span> τ1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">eassumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** &lt;&lt;τ&gt;&gt; is always well-formed *)</span>
<span class="sd">(******************************************************************************)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk106" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk106"><span class="kn">Lemma</span> <span class="nf">ok_type_rw_ty_ar</span>: <span class="kr">forall</span> <span class="nv">Δ</span> <span class="nv">τ1</span> <span class="nv">τ2</span>,
    ok_type Δ (ty_ar τ1 τ2) =
      (ok_type Δ τ1 /\ ok_type Δ τ2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ</span> : kind_ctx) (<span class="nv">τ1</span> <span class="nv">τ2</span> : typ LN),
ok_type Δ (ty_ar τ1 τ2) =
(ok_type Δ τ1 /\ ok_type Δ τ2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk107" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk107"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ</span> : kind_ctx) (<span class="nv">τ1</span> <span class="nv">τ2</span> : typ LN),
ok_type Δ (ty_ar τ1 τ2) =
(ok_type Δ τ1 /\ ok_type Δ τ2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk108" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk108"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type Δ (ty_ar τ1 τ2) =
(ok_type Δ τ1 /\ ok_type Δ τ2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk109" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk109"><span class="nb">unfold</span> ok_type, scoped.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(FV typ ktyp (ty_ar τ1 τ2) ⊆ domset Δ /\
 LC typ ktyp (ty_ar τ1 τ2)) =
((FV typ ktyp τ1 ⊆ domset Δ /\ LC typ ktyp τ1) /\
 FV typ ktyp τ2 ⊆ domset Δ /\ LC typ ktyp τ2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk10a" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk10a"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((FV typ ktyp τ1 ⊆ domset Δ /\ LC typ ktyp τ1) /\
 FV typ ktyp τ2 ⊆ domset Δ /\ LC typ ktyp τ2) =
(FV typ ktyp (ty_ar τ1 τ2) ⊆ domset Δ /\
 LC typ ktyp (ty_ar τ1 τ2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk10b" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk10b">simplify_FV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((FV typ ktyp τ1 ⊆ domset Δ /\ LC typ ktyp τ1) /\
 FV typ ktyp τ2 ⊆ domset Δ /\ LC typ ktyp τ2) =
(atoms (free typ ktyp τ1 ++ free typ ktyp τ2)
 ⊆ domset Δ /\ LC typ ktyp (ty_ar τ1 τ2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk10c">simplify_LC.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((FV typ ktyp τ1 ⊆ domset Δ /\ LC typ ktyp τ1) /\
 FV typ ktyp τ2 ⊆ domset Δ /\ LC typ ktyp τ2) =
(atoms (free typ ktyp τ1 ++ free typ ktyp τ2)
 ⊆ domset Δ /\ LC typ ktyp τ1 /\ LC typ ktyp τ2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">propext;
    <span class="nb">rewrite</span> atoms_app;
    <span class="nb">intuition</span> fsetdec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk10d" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk10d"><span class="kn">Lemma</span> <span class="nf">ok_type_rw_ty_univ</span>: <span class="kr">forall</span> <span class="nv">Δ</span> <span class="nv">τ</span>,
    ok_type Δ (ty_univ τ) =
      (scoped typ ktyp (ty_univ τ) (domset Δ) /\ LCn typ ktyp <span class="mi">1</span> τ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ</span> : kind_ctx) (<span class="nv">τ</span> : typ LN),
ok_type Δ (ty_univ τ) =
(scoped typ ktyp (ty_univ τ) (domset Δ) /\
 LCn typ ktyp <span class="mi">1</span> τ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk10e" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk10e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ</span> : kind_ctx) (<span class="nv">τ</span> : typ LN),
ok_type Δ (ty_univ τ) =
(scoped typ ktyp (ty_univ τ) (domset Δ) /\
 LCn typ ktyp <span class="mi">1</span> τ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk10f" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk10f"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type Δ (ty_univ τ) =
(scoped typ ktyp (ty_univ τ) (domset Δ) /\
 LCn typ ktyp <span class="mi">1</span> τ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk110" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk110"><span class="nb">unfold</span> ok_type, scoped.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(FV typ ktyp (ty_univ τ) ⊆ domset Δ /\
 LC typ ktyp (ty_univ τ)) =
(FV typ ktyp (ty_univ τ) ⊆ domset Δ /\
 LCn typ ktyp <span class="mi">1</span> τ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk111">simplify_FV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(FV typ ktyp τ ⊆ domset Δ /\ LC typ ktyp (ty_univ τ)) =
(FV typ ktyp τ ⊆ domset Δ /\ LCn typ ktyp <span class="mi">1</span> τ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk112" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk112">simplify_LC.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(FV typ ktyp τ ⊆ domset Δ /\ LCn typ ktyp <span class="mi">1</span> τ) =
(FV typ ktyp τ ⊆ domset Δ /\ LCn typ ktyp <span class="mi">1</span> τ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk113" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk113"><span class="kn">Lemma</span> <span class="nf">j_ok_type</span> : <span class="kr">forall</span> <span class="nv">Δ</span> <span class="nv">Γ</span> <span class="nv">t</span> <span class="nv">τ</span>,
    (Δ ; Γ ⊢ t : τ) -&gt;
    ok_type Δ τ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ</span> : kind_ctx) (<span class="nv">Γ</span> : type_ctx) (<span class="nv">t</span> : term LN)
  (<span class="nv">τ</span> : typ LN), Δ; Γ ⊢ t : τ -&gt; ok_type Δ τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk114" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk114"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ</span> : kind_ctx) (<span class="nv">Γ</span> : type_ctx) (<span class="nv">t</span> : term LN)
  (<span class="nv">τ</span> : typ LN), Δ; Γ ⊢ t : τ -&gt; ok_type Δ τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk115" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk115">introv j.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : τ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type Δ τ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk116" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk116"><span class="nb">induction</span> j.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x, τ) ∈ Γ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type Δ τ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk117" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt; ok_type Δ τ2</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk117"><hr></label><div class="goal-conclusion">ok_type Δ (ty_ar τ1 τ2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk118" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t2 : τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span>ok_type Δ (ty_ar τ1 τ2)</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk118"><hr></label><div class="goal-conclusion">ok_type Δ τ2</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk119" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
ok_type (Δ ++ x ~ tt)
  (open typ ktyp (ty_v (Fr x)) τ)</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk119"><hr></label><div class="goal-conclusion">ok_type Δ (ty_univ τ)</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk11a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>ok_type Δ (ty_univ τ2)</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk11a"><hr></label><div class="goal-conclusion">ok_type Δ (open typ ktyp τ1 τ2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk11b" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk11b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x, τ) ∈ Γ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type Δ τ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eauto using</span> ok_type_ctx_binds.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk11c" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk11c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt; ok_type Δ τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type Δ (ty_ar τ1 τ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk11d" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk11d">cc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type Δ (ty_ar τ1 τ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk11e" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk11e"><span class="nb">rewrite</span> ok_type_rw_ty_ar.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type Δ τ1 /\ ok_type Δ τ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk11f" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk11f"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type Δ τ1</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk120" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk120"><hr></label><div class="goal-conclusion">ok_type Δ τ2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk121" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk121">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type Δ τ1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> j_type_ctx2; <span class="nb">eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk122" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk122">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type Δ τ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk123" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk123">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t2 : τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span>ok_type Δ (ty_ar τ1 τ2)</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type Δ τ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> ok_type_rw_ty_ar <span class="kr">in</span> IHj1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk124" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk124">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
ok_type (Δ ++ x ~ tt)
  (open typ ktyp (ty_v (Fr x)) τ)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type Δ (ty_univ τ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk125" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk125"><span class="nb">rewrite</span> ok_type_rw_ty_univ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
ok_type (Δ ++ x ~ tt)
  (open typ ktyp (ty_v (Fr x)) τ)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scoped typ ktyp (ty_univ τ) (domset Δ) /\
LCn typ ktyp <span class="mi">1</span> τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk126" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk126"><span class="nb">rename</span> H0 <span class="nb">into</span> IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
ok_type (Δ ++ x ~ tt)
  (open typ ktyp (ty_v (Fr x)) τ)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scoped typ ktyp (ty_univ τ) (domset Δ) /\
LCn typ ktyp <span class="mi">1</span> τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk127" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk127">pick <span class="kp">fresh</span> e <span class="kr">for</span> (L ∪ FV typ ktyp τ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
ok_type (Δ ++ x ~ tt)
  (open typ ktyp (ty_v (Fr x)) τ)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ FV typ ktyp τ)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scoped typ ktyp (ty_univ τ) (domset Δ) /\
LCn typ ktyp <span class="mi">1</span> τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk128" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk128">specialize_cof IH e.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ok_type (Δ ++ e ~ tt)
  (open typ ktyp (ty_v (Fr e)) τ)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ FV typ ktyp τ)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scoped typ ktyp (ty_univ τ) (domset Δ) /\
LCn typ ktyp <span class="mi">1</span> τ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk129" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk129"><span class="nb">destruct</span> IH <span class="kr">as</span> [IHsc IHlc].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IHsc</var><span class="hyp-type"><b>: </b><span>scoped typ ktyp (open typ ktyp (ty_v (Fr e)) τ)
  (domset (Δ ++ e ~ tt))</span></span></span><br><span><var>IHlc</var><span class="hyp-type"><b>: </b><span>LC typ ktyp (open typ ktyp (ty_v (Fr e)) τ)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ FV typ ktyp τ)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scoped typ ktyp (ty_univ τ) (domset Δ) /\
LCn typ ktyp <span class="mi">1</span> τ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk12a" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk12a"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IHsc</var><span class="hyp-type"><b>: </b><span>scoped typ ktyp (open typ ktyp (ty_v (Fr e)) τ)
  (domset (Δ ++ e ~ tt))</span></span></span><br><span><var>IHlc</var><span class="hyp-type"><b>: </b><span>LC typ ktyp (open typ ktyp (ty_v (Fr e)) τ)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ FV typ ktyp τ)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scoped typ ktyp (ty_univ τ) (domset Δ)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk12b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IHsc</var><span class="hyp-type"><b>: </b><span>scoped typ ktyp (open typ ktyp (ty_v (Fr e)) τ)
  (domset (Δ ++ e ~ tt))</span></span></span><br><span><var>IHlc</var><span class="hyp-type"><b>: </b><span>LC typ ktyp (open typ ktyp (ty_v (Fr e)) τ)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ FV typ ktyp τ)</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk12b"><hr></label><div class="goal-conclusion">LCn typ ktyp <span class="mi">1</span> τ</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk12c" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk12c">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IHsc</var><span class="hyp-type"><b>: </b><span>scoped typ ktyp (open typ ktyp (ty_v (Fr e)) τ)
  (domset (Δ ++ e ~ tt))</span></span></span><br><span><var>IHlc</var><span class="hyp-type"><b>: </b><span>LC typ ktyp (open typ ktyp (ty_v (Fr e)) τ)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ FV typ ktyp τ)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scoped typ ktyp (ty_univ τ) (domset Δ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk12d" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk12d"><span class="nb">unfold</span> ok_type, scoped <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IHsc</var><span class="hyp-type"><b>: </b><span>FV typ ktyp (open typ ktyp (ty_v (Fr e)) τ)
⊆ domset (Δ ++ e ~ tt)</span></span></span><br><span><var>IHlc</var><span class="hyp-type"><b>: </b><span>LC typ ktyp (open typ ktyp (ty_v (Fr e)) τ)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ FV typ ktyp τ)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV typ ktyp (ty_univ τ) ⊆ domset Δ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk12e" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk12e"><span class="nb">enough</span> (<span class="nb">cut</span>: FV typ ktyp τ ⊆ domset (Δ ++ e ~ tt)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IHsc</var><span class="hyp-type"><b>: </b><span>FV typ ktyp (open typ ktyp (ty_v (Fr e)) τ)
⊆ domset (Δ ++ e ~ tt)</span></span></span><br><span><var>IHlc</var><span class="hyp-type"><b>: </b><span>LC typ ktyp (open typ ktyp (ty_v (Fr e)) τ)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ FV typ ktyp τ)</span></span></span><br><span><var>cut</var><span class="hyp-type"><b>: </b><span>FV typ ktyp τ ⊆ domset (Δ ++ e ~ tt)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV typ ktyp (ty_univ τ) ⊆ domset Δ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk12f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IHsc</var><span class="hyp-type"><b>: </b><span>FV typ ktyp (open typ ktyp (ty_v (Fr e)) τ)
⊆ domset (Δ ++ e ~ tt)</span></span></span><br><span><var>IHlc</var><span class="hyp-type"><b>: </b><span>LC typ ktyp (open typ ktyp (ty_v (Fr e)) τ)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ FV typ ktyp τ)</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk12f"><hr></label><div class="goal-conclusion">FV typ ktyp τ ⊆ domset (Δ ++ e ~ tt)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk130" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk130">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IHsc</var><span class="hyp-type"><b>: </b><span>FV typ ktyp (open typ ktyp (ty_v (Fr e)) τ)
⊆ domset (Δ ++ e ~ tt)</span></span></span><br><span><var>IHlc</var><span class="hyp-type"><b>: </b><span>LC typ ktyp (open typ ktyp (ty_v (Fr e)) τ)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ FV typ ktyp τ)</span></span></span><br><span><var>cut</var><span class="hyp-type"><b>: </b><span>FV typ ktyp τ ⊆ domset (Δ ++ e ~ tt)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV typ ktyp (ty_univ τ) ⊆ domset Δ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk131" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk131"><span class="nb">autorewrite with</span> tea_rw_dom <span class="kr">in</span> <span class="nb">cut</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IHsc</var><span class="hyp-type"><b>: </b><span>FV typ ktyp (open typ ktyp (ty_v (Fr e)) τ)
⊆ domset (Δ ++ e ~ tt)</span></span></span><br><span><var>IHlc</var><span class="hyp-type"><b>: </b><span>LC typ ktyp (open typ ktyp (ty_v (Fr e)) τ)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ FV typ ktyp τ)</span></span></span><br><span><var>cut</var><span class="hyp-type"><b>: </b><span>FV typ ktyp τ ⊆ domset Δ ∪ {{e}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV typ ktyp (ty_univ τ) ⊆ domset Δ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk132" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk132">simplify_FV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IHsc</var><span class="hyp-type"><b>: </b><span>FV typ ktyp (open typ ktyp (ty_v (Fr e)) τ)
⊆ domset (Δ ++ e ~ tt)</span></span></span><br><span><var>IHlc</var><span class="hyp-type"><b>: </b><span>LC typ ktyp (open typ ktyp (ty_v (Fr e)) τ)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ FV typ ktyp τ)</span></span></span><br><span><var>cut</var><span class="hyp-type"><b>: </b><span>FV typ ktyp τ ⊆ domset Δ ∪ {{e}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV typ ktyp τ ⊆ domset Δ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input">fsetdec.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk133" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk133">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IHsc</var><span class="hyp-type"><b>: </b><span>FV typ ktyp (open typ ktyp (ty_v (Fr e)) τ)
⊆ domset (Δ ++ e ~ tt)</span></span></span><br><span><var>IHlc</var><span class="hyp-type"><b>: </b><span>LC typ ktyp (open typ ktyp (ty_v (Fr e)) τ)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ FV typ ktyp τ)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV typ ktyp τ ⊆ domset (Δ ++ e ~ tt)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> FV_open_lower; <span class="nb">eauto</span>; <span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk134" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk134">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IHsc</var><span class="hyp-type"><b>: </b><span>scoped typ ktyp (open typ ktyp (ty_v (Fr e)) τ)
  (domset (Δ ++ e ~ tt))</span></span></span><br><span><var>IHlc</var><span class="hyp-type"><b>: </b><span>LC typ ktyp (open typ ktyp (ty_v (Fr e)) τ)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ FV typ ktyp τ)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LCn typ ktyp <span class="mi">1</span> τ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk135" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk135"><span class="nb">rewrite</span> (open_lc_gap_eq_iff typ); <span class="nb">eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IHsc</var><span class="hyp-type"><b>: </b><span>scoped typ ktyp (open typ ktyp (ty_v (Fr e)) τ)
  (domset (Δ ++ e ~ tt))</span></span></span><br><span><var>IHlc</var><span class="hyp-type"><b>: </b><span>LC typ ktyp (open typ ktyp (ty_v (Fr e)) τ)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ FV typ ktyp τ)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC (SystemF ktyp) ktyp (ty_v (Fr e))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> simplify_LC.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk136" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk136">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>ok_type Δ (ty_univ τ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type Δ (open typ ktyp τ1 τ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk137" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk137"><span class="nb">unfold</span> ok_type <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>scoped typ ktyp τ1 (domset Δ) /\ LC typ ktyp τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>scoped typ ktyp (ty_univ τ2) (domset Δ) /\
LC typ ktyp (ty_univ τ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scoped typ ktyp (open typ ktyp τ1 τ2) (domset Δ) /\
LC typ ktyp (open typ ktyp τ1 τ2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk138" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk138"><span class="nb">unfold</span> scoped <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>FV typ ktyp τ1 ⊆ domset Δ /\ LC typ ktyp τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>FV typ ktyp (ty_univ τ2) ⊆ domset Δ /\
LC typ ktyp (ty_univ τ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV typ ktyp (open typ ktyp τ1 τ2) ⊆ domset Δ /\
LC typ ktyp (open typ ktyp τ1 τ2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk139" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk139"><span class="nb">destruct</span> IHj <span class="kr">as</span> [IHj_FV IHj_LC].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>FV typ ktyp τ1 ⊆ domset Δ /\ LC typ ktyp τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj_FV</var><span class="hyp-type"><b>: </b><span>FV typ ktyp (ty_univ τ2) ⊆ domset Δ</span></span></span><br><span><var>IHj_LC</var><span class="hyp-type"><b>: </b><span>LC typ ktyp (ty_univ τ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV typ ktyp (open typ ktyp τ1 τ2) ⊆ domset Δ /\
LC typ ktyp (open typ ktyp τ1 τ2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk13a" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk13a"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>FV typ ktyp τ1 ⊆ domset Δ /\ LC typ ktyp τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj_FV</var><span class="hyp-type"><b>: </b><span>FV typ ktyp (ty_univ τ2) ⊆ domset Δ</span></span></span><br><span><var>IHj_LC</var><span class="hyp-type"><b>: </b><span>LC typ ktyp (ty_univ τ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV typ ktyp (open typ ktyp τ1 τ2) ⊆ domset Δ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk13b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>FV typ ktyp τ1 ⊆ domset Δ /\ LC typ ktyp τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj_FV</var><span class="hyp-type"><b>: </b><span>FV typ ktyp (ty_univ τ2) ⊆ domset Δ</span></span></span><br><span><var>IHj_LC</var><span class="hyp-type"><b>: </b><span>LC typ ktyp (ty_univ τ2)</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk13b"><hr></label><div class="goal-conclusion">LC typ ktyp (open typ ktyp τ1 τ2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk13c" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk13c">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>FV typ ktyp τ1 ⊆ domset Δ /\ LC typ ktyp τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj_FV</var><span class="hyp-type"><b>: </b><span>FV typ ktyp (ty_univ τ2) ⊆ domset Δ</span></span></span><br><span><var>IHj_LC</var><span class="hyp-type"><b>: </b><span>LC typ ktyp (ty_univ τ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV typ ktyp (open typ ktyp τ1 τ2) ⊆ domset Δ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk13d" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk13d"><span class="nb">transitivity</span> (FV typ ktyp τ1 ∪ FV typ ktyp τ2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>FV typ ktyp τ1 ⊆ domset Δ /\ LC typ ktyp τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj_FV</var><span class="hyp-type"><b>: </b><span>FV typ ktyp (ty_univ τ2) ⊆ domset Δ</span></span></span><br><span><var>IHj_LC</var><span class="hyp-type"><b>: </b><span>LC typ ktyp (ty_univ τ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV typ ktyp (open typ ktyp τ1 τ2)
⊆ FV typ ktyp τ1 ∪ FV typ ktyp τ2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk13e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>FV typ ktyp τ1 ⊆ domset Δ /\ LC typ ktyp τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj_FV</var><span class="hyp-type"><b>: </b><span>FV typ ktyp (ty_univ τ2) ⊆ domset Δ</span></span></span><br><span><var>IHj_LC</var><span class="hyp-type"><b>: </b><span>LC typ ktyp (ty_univ τ2)</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk13e"><hr></label><div class="goal-conclusion">FV typ ktyp τ1 ∪ FV typ ktyp τ2 ⊆ domset Δ</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk13f" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk13f">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>FV typ ktyp τ1 ⊆ domset Δ /\ LC typ ktyp τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj_FV</var><span class="hyp-type"><b>: </b><span>FV typ ktyp (ty_univ τ2) ⊆ domset Δ</span></span></span><br><span><var>IHj_LC</var><span class="hyp-type"><b>: </b><span>LC typ ktyp (ty_univ τ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV typ ktyp (open typ ktyp τ1 τ2)
⊆ FV typ ktyp τ1 ∪ FV typ ktyp τ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk140" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk140"><span class="nb">rewrite</span> (FV_open_upper_eq typ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>FV typ ktyp τ1 ⊆ domset Δ /\ LC typ ktyp τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj_FV</var><span class="hyp-type"><b>: </b><span>FV typ ktyp (ty_univ τ2) ⊆ domset Δ</span></span></span><br><span><var>IHj_LC</var><span class="hyp-type"><b>: </b><span>LC typ ktyp (ty_univ τ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV typ ktyp τ2 ∪ FV (SystemF ktyp) ktyp τ1
⊆ FV typ ktyp τ1 ∪ FV typ ktyp τ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input">fsetdec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk141" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk141">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>FV typ ktyp τ1 ⊆ domset Δ /\ LC typ ktyp τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj_FV</var><span class="hyp-type"><b>: </b><span>FV typ ktyp (ty_univ τ2) ⊆ domset Δ</span></span></span><br><span><var>IHj_LC</var><span class="hyp-type"><b>: </b><span>LC typ ktyp (ty_univ τ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV typ ktyp τ1 ∪ FV typ ktyp τ2 ⊆ domset Δ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk142" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk142"><span class="nb">replace</span> (FV (ix := I2) typ ktyp (ty_univ τ2))
          <span class="kr">with</span> (FV typ ktyp τ2) <span class="kr">in</span> IHj_FV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>FV typ ktyp τ1 ⊆ domset Δ /\ LC typ ktyp τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj_FV</var><span class="hyp-type"><b>: </b><span>FV typ ktyp τ2 ⊆ domset Δ</span></span></span><br><span><var>IHj_LC</var><span class="hyp-type"><b>: </b><span>LC typ ktyp (ty_univ τ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV typ ktyp τ1 ∪ FV typ ktyp τ2 ⊆ domset Δ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk143" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>FV typ ktyp τ1 ⊆ domset Δ /\ LC typ ktyp τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj_FV</var><span class="hyp-type"><b>: </b><span>FV typ ktyp (ty_univ τ2) ⊆ domset Δ</span></span></span><br><span><var>IHj_LC</var><span class="hyp-type"><b>: </b><span>LC typ ktyp (ty_univ τ2)</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk143"><hr></label><div class="goal-conclusion">FV typ ktyp τ2 = FV typ ktyp (ty_univ τ2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk144" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk144"><span class="nb">intuition</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>FV typ ktyp τ1 ⊆ domset Δ /\ LC typ ktyp τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj_FV</var><span class="hyp-type"><b>: </b><span>FV typ ktyp (ty_univ τ2) ⊆ domset Δ</span></span></span><br><span><var>IHj_LC</var><span class="hyp-type"><b>: </b><span>LC typ ktyp (ty_univ τ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV typ ktyp τ2 = FV typ ktyp (ty_univ τ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> simplify_FV.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk145" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk145">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>FV typ ktyp τ1 ⊆ domset Δ /\ LC typ ktyp τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj_FV</var><span class="hyp-type"><b>: </b><span>FV typ ktyp (ty_univ τ2) ⊆ domset Δ</span></span></span><br><span><var>IHj_LC</var><span class="hyp-type"><b>: </b><span>LC typ ktyp (ty_univ τ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC typ ktyp (open typ ktyp τ1 τ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk146" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk146"><span class="nb">replace</span> (LC (ix := I2) typ ktyp (ty_univ τ2))
        <span class="kr">with</span> (LCn typ ktyp <span class="mi">1</span> τ2) <span class="kr">in</span> IHj_LC.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>FV typ ktyp τ1 ⊆ domset Δ /\ LC typ ktyp τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj_FV</var><span class="hyp-type"><b>: </b><span>FV typ ktyp (ty_univ τ2) ⊆ domset Δ</span></span></span><br><span><var>IHj_LC</var><span class="hyp-type"><b>: </b><span>LCn typ ktyp <span class="mi">1</span> τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC typ ktyp (open typ ktyp τ1 τ2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk147" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>FV typ ktyp τ1 ⊆ domset Δ /\ LC typ ktyp τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj_FV</var><span class="hyp-type"><b>: </b><span>FV typ ktyp (ty_univ τ2) ⊆ domset Δ</span></span></span><br><span><var>IHj_LC</var><span class="hyp-type"><b>: </b><span>LC typ ktyp (ty_univ τ2)</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk147"><hr></label><div class="goal-conclusion">LCn typ ktyp <span class="mi">1</span> τ2 = LC typ ktyp (ty_univ τ2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk148" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk148"><span class="nb">rewrite</span> &lt;- (open_lc_gap_eq_iff_1 typ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>FV typ ktyp τ1 ⊆ domset Δ /\ LC typ ktyp τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj_FV</var><span class="hyp-type"><b>: </b><span>FV typ ktyp (ty_univ τ2) ⊆ domset Δ</span></span></span><br><span><var>IHj_LC</var><span class="hyp-type"><b>: </b><span>LCn typ ktyp <span class="mi">1</span> τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LCn typ ktyp <span class="mi">1</span> τ2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk149" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>FV typ ktyp τ1 ⊆ domset Δ /\ LC typ ktyp τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj_FV</var><span class="hyp-type"><b>: </b><span>FV typ ktyp (ty_univ τ2) ⊆ domset Δ</span></span></span><br><span><var>IHj_LC</var><span class="hyp-type"><b>: </b><span>LCn typ ktyp <span class="mi">1</span> τ2</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk149"><hr></label><div class="goal-conclusion">LC (SystemF ktyp) ktyp τ1</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk14a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>FV typ ktyp τ1 ⊆ domset Δ /\ LC typ ktyp τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj_FV</var><span class="hyp-type"><b>: </b><span>FV typ ktyp (ty_univ τ2) ⊆ domset Δ</span></span></span><br><span><var>IHj_LC</var><span class="hyp-type"><b>: </b><span>LC typ ktyp (ty_univ τ2)</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk14a"><hr></label><div class="goal-conclusion">LCn typ ktyp <span class="mi">1</span> τ2 = LC typ ktyp (ty_univ τ2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk14b" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk14b">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>FV typ ktyp τ1 ⊆ domset Δ /\ LC typ ktyp τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj_FV</var><span class="hyp-type"><b>: </b><span>FV typ ktyp (ty_univ τ2) ⊆ domset Δ</span></span></span><br><span><var>IHj_LC</var><span class="hyp-type"><b>: </b><span>LCn typ ktyp <span class="mi">1</span> τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LCn typ ktyp <span class="mi">1</span> τ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk14c" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk14c">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>FV typ ktyp τ1 ⊆ domset Δ /\ LC typ ktyp τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj_FV</var><span class="hyp-type"><b>: </b><span>FV typ ktyp (ty_univ τ2) ⊆ domset Δ</span></span></span><br><span><var>IHj_LC</var><span class="hyp-type"><b>: </b><span>LCn typ ktyp <span class="mi">1</span> τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC (SystemF ktyp) ktyp τ1</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk14d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>FV typ ktyp τ1 ⊆ domset Δ /\ LC typ ktyp τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj_FV</var><span class="hyp-type"><b>: </b><span>FV typ ktyp (ty_univ τ2) ⊆ domset Δ</span></span></span><br><span><var>IHj_LC</var><span class="hyp-type"><b>: </b><span>LC typ ktyp (ty_univ τ2)</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk14d"><hr></label><div class="goal-conclusion">LCn typ ktyp <span class="mi">1</span> τ2 = LC typ ktyp (ty_univ τ2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk14e" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk14e">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>FV typ ktyp τ1 ⊆ domset Δ /\ LC typ ktyp τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj_FV</var><span class="hyp-type"><b>: </b><span>FV typ ktyp (ty_univ τ2) ⊆ domset Δ</span></span></span><br><span><var>IHj_LC</var><span class="hyp-type"><b>: </b><span>LCn typ ktyp <span class="mi">1</span> τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC (SystemF ktyp) ktyp τ1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">tauto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk14f" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk14f">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>FV typ ktyp τ1 ⊆ domset Δ /\ LC typ ktyp τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj_FV</var><span class="hyp-type"><b>: </b><span>FV typ ktyp (ty_univ τ2) ⊆ domset Δ</span></span></span><br><span><var>IHj_LC</var><span class="hyp-type"><b>: </b><span>LC typ ktyp (ty_univ τ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LCn typ ktyp <span class="mi">1</span> τ2 = LC typ ktyp (ty_univ τ2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk150" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk150">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>FV typ ktyp τ1 ⊆ domset Δ /\ LC typ ktyp τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj_FV</var><span class="hyp-type"><b>: </b><span>FV typ ktyp (ty_univ τ2) ⊆ domset Δ</span></span></span><br><span><var>IHj_LC</var><span class="hyp-type"><b>: </b><span>LC typ ktyp (ty_univ τ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LCn typ ktyp <span class="mi">1</span> τ2 = LC typ ktyp (ty_univ τ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> simplify_LC.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Properties in t of &lt;&lt;(Δ ; Γ ⊢ t : τ&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>

<span class="sd">(** *** &lt;&lt;t&gt;&gt; is always locally closed w.r.t. term variables *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk151" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk151"><span class="kn">Lemma</span> <span class="nf">j_lc_KTerm_term</span> : <span class="kr">forall</span> <span class="nv">Δ</span> <span class="nv">Γ</span> <span class="nv">t</span> <span class="nv">τ</span>,
    (Δ ; Γ ⊢ t : τ) -&gt;
    LC term ktrm t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ</span> : kind_ctx) (<span class="nv">Γ</span> : type_ctx) (<span class="nv">t</span> : term LN)
  (<span class="nv">τ</span> : typ LN), Δ; Γ ⊢ t : τ -&gt; LC term ktrm t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk152" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk152"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ</span> : kind_ctx) (<span class="nv">Γ</span> : type_ctx) (<span class="nv">t</span> : term LN)
  (<span class="nv">τ</span> : typ LN), Δ; Γ ⊢ t : τ -&gt; LC term ktrm t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk153" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk153">introv j.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : τ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC term ktrm t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk154" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk154"><span class="nb">induction</span> j; <span class="kp">try</span> <span class="nb">rename</span> H0 <span class="nb">into</span> IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x, τ) ∈ Γ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC term ktrm (tm_var (Fr x))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk155" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
LC term ktrm (open term ktrm (tm_var (Fr x)) t)</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk155"><hr></label><div class="goal-conclusion">LC term ktrm (tm_abs τ1 t)</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk156" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t2 : τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span>LC term ktrm t1</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span>LC term ktrm t2</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk156"><hr></label><div class="goal-conclusion">LC term ktrm (tm_app t1 t2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk157" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
LC term ktrm (open term ktyp (ty_v (Fr x)) t)</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk157"><hr></label><div class="goal-conclusion">LC term ktrm (tm_tab t)</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk158" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>LC term ktrm t</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk158"><hr></label><div class="goal-conclusion">LC term ktrm (tm_tap t τ1)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk159" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk159">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x, τ) ∈ Γ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC term ktrm (tm_var (Fr x))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> simplify_LC.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk15a" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk15a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
LC term ktrm (open term ktrm (tm_var (Fr x)) t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC term ktrm (tm_abs τ1 t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk15b" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk15b">cc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>LC term ktrm (open term ktrm (tm_var (Fr e)) t)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC term ktrm (tm_abs τ1 t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk15c" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk15c">simplify_LC.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>LC term ktrm (open term ktrm (tm_var (Fr e)) t)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC typ ktrm τ1 /\ LCn term ktrm <span class="mi">1</span> t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk15d" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk15d"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>LC term ktrm (open term ktrm (tm_var (Fr e)) t)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC typ ktrm τ1</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk15e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>LC term ktrm (open term ktrm (tm_var (Fr e)) t)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk15e"><hr></label><div class="goal-conclusion">LCn term ktrm <span class="mi">1</span> t</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk15f" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk15f">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>LC term ktrm (open term ktrm (tm_var (Fr e)) t)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC typ ktrm τ1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> LC_typ_trm.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk160" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk160">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>LC term ktrm (open term ktrm (tm_var (Fr e)) t)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LCn term ktrm <span class="mi">1</span> t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk161" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk161"><span class="nb">rewrite</span> (open_lc_gap_eq_iff_1 term).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>LC term ktrm (open term ktrm (tm_var (Fr e)) t)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC term ktrm (open term ktrm <span class="nl">?Goal3</span> t)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk162" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>LC term ktrm (open term ktrm (tm_var (Fr e)) t)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk162"><hr></label><div class="goal-conclusion">LC (SystemF ktrm) ktrm <span class="nl">?Goal3</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk163" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk163">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>LC term ktrm (open term ktrm (tm_var (Fr e)) t)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC term ktrm (open term ktrm <span class="nl">?Goal3</span> t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">eassumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk164" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk164">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>LC term ktrm (open term ktrm (tm_var (Fr e)) t)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC (SystemF ktrm) ktrm (tm_var (Fr e))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> simplify_LC.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk165" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk165">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t2 : τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span>LC term ktrm t1</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span>LC term ktrm t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC term ktrm (tm_app t1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> simplify_LC.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk166" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk166">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
LC term ktrm (open term ktyp (ty_v (Fr x)) t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC term ktrm (tm_tab t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk167" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk167">cc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ ++ e0 ~ tt; Γ ⊢ open term ktyp (ty_v (Fr e0)) t
: open typ ktyp (ty_v (Fr e0)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>LC term ktrm (open term ktyp (ty_v (Fr e)) t)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC term ktrm (tm_tab t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk168" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk168">simplify_LC.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ ++ e0 ~ tt; Γ ⊢ open term ktyp (ty_v (Fr e0)) t
: open typ ktyp (ty_v (Fr e0)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>LC term ktrm (open term ktyp (ty_v (Fr e)) t)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC term ktrm t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk169" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk169"><span class="nb">rewrite</span> (open_lc_gap_neq_var term).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ ++ e0 ~ tt; Γ ⊢ open term ktyp (ty_v (Fr e0)) t
: open typ ktyp (ty_v (Fr e0)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>LC term ktrm (open term ktyp (ty_v (Fr e)) t)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC term ktrm
  (open term <span class="nl">?Goal1</span> (mret SystemF <span class="nl">?Goal1</span> (Fr <span class="nl">?Goal2</span>))
     t)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk16a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ ++ e0 ~ tt; Γ ⊢ open term ktyp (ty_v (Fr e0)) t
: open typ ktyp (ty_v (Fr e0)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>LC term ktrm (open term ktyp (ty_v (Fr e)) t)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk16a"><hr></label><div class="goal-conclusion">ktrm &lt;&gt; <span class="nl">?Goal1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk16b" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk16b">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ ++ e0 ~ tt; Γ ⊢ open term ktyp (ty_v (Fr e0)) t
: open typ ktyp (ty_v (Fr e0)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>LC term ktrm (open term ktyp (ty_v (Fr e)) t)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC term ktrm
  (open term <span class="nl">?Goal1</span> (mret SystemF <span class="nl">?Goal1</span> (Fr <span class="nl">?Goal2</span>))
     t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> IH.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk16c" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk16c">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ ++ e0 ~ tt; Γ ⊢ open term ktyp (ty_v (Fr e0)) t
: open typ ktyp (ty_v (Fr e0)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>LC term ktrm (open term ktyp (ty_v (Fr e)) t)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ktrm &lt;&gt; ktyp</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">discriminate</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk16d" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk16d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>LC term ktrm t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC term ktrm (tm_tap t τ1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk16e" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk16e">simplify_LC.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>LC term ktrm t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC term ktrm t /\ LC typ ktrm τ1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk16f" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk16f"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>LC term ktrm t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC term ktrm t</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk170" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>LC term ktrm t</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk170"><hr></label><div class="goal-conclusion">LC typ ktrm τ1</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk171" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk171">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>LC term ktrm t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC term ktrm t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk172" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk172">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>LC term ktrm t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC typ ktrm τ1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> LC_typ_trm.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** &lt;&lt;t&gt;&gt; is always locally closed w.r.t. type variables *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk173" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk173"><span class="kn">Lemma</span> <span class="nf">j_lc_ktyp_term</span> : <span class="kr">forall</span> <span class="nv">Δ</span> <span class="nv">Γ</span> <span class="nv">t</span> <span class="nv">τ</span>,
    (Δ ; Γ ⊢ t : τ) -&gt;
    LC term ktyp t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ</span> : kind_ctx) (<span class="nv">Γ</span> : type_ctx) (<span class="nv">t</span> : term LN)
  (<span class="nv">τ</span> : typ LN), Δ; Γ ⊢ t : τ -&gt; LC term ktyp t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk174" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk174"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ</span> : kind_ctx) (<span class="nv">Γ</span> : type_ctx) (<span class="nv">t</span> : term LN)
  (<span class="nv">τ</span> : typ LN), Δ; Γ ⊢ t : τ -&gt; LC term ktyp t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk175" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk175">introv j.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : τ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC term ktyp t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk176" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk176"><span class="nb">induction</span> j.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x, τ) ∈ Γ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC term ktyp (tm_var (Fr x))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk177" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
LC term ktyp (open term ktrm (tm_var (Fr x)) t)</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk177"><hr></label><div class="goal-conclusion">LC term ktyp (tm_abs τ1 t)</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk178" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t2 : τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span>LC term ktyp t1</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span>LC term ktyp t2</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk178"><hr></label><div class="goal-conclusion">LC term ktyp (tm_app t1 t2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk179" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
LC term ktyp (open term ktyp (ty_v (Fr x)) t)</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk179"><hr></label><div class="goal-conclusion">LC term ktyp (tm_tab t)</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk17a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>LC term ktyp t</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk17a"><hr></label><div class="goal-conclusion">LC term ktyp (tm_tap t τ1)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk17b" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk17b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x, τ) ∈ Γ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC term ktyp (tm_var (Fr x))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> simplify_LC.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk17c" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk17c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
LC term ktyp (open term ktrm (tm_var (Fr x)) t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC term ktyp (tm_abs τ1 t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk17d" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk17d">cc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>LC term ktyp (open term ktrm (tm_var (Fr e)) t)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC term ktyp (tm_abs τ1 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk17e" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk17e"><span class="nb">rename</span> H0 <span class="nb">into</span> IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>LC term ktyp (open term ktrm (tm_var (Fr e)) t)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC term ktyp (tm_abs τ1 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk17f" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk17f">simplify_LC.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>LC term ktyp (open term ktrm (tm_var (Fr e)) t)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC typ ktyp τ1 /\ LC term ktyp t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk180" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk180"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>LC term ktyp (open term ktrm (tm_var (Fr e)) t)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC typ ktyp τ1</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk181" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>LC term ktyp (open term ktrm (tm_var (Fr e)) t)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk181"><hr></label><div class="goal-conclusion">LC term ktyp t</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk182" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk182">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>LC term ktyp (open term ktrm (tm_var (Fr e)) t)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC typ ktyp τ1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk183" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk183"><span class="nb">apply</span> j_type_ctx2 <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>LC term ktyp (open term ktrm (tm_var (Fr e)) t)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC typ ktyp τ1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk184" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk184"><span class="nb">eapply</span> ok_type_lc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>LC term ktyp (open term ktrm (tm_var (Fr e)) t)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type <span class="nl">?Δ</span> τ1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">eassumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk185" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk185">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>LC term ktyp (open term ktrm (tm_var (Fr e)) t)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC term ktyp t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk186" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk186"><span class="nb">change</span> (tm_var (Fr e)) <span class="kr">with</span> (mret SystemF ktrm (Fr e)) <span class="kr">in</span> IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>LC term ktyp
  (open term ktrm (mret SystemF ktrm (Fr e)) t)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC term ktyp t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk187" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk187"><span class="nb">rewrite</span> &lt;- (open_lc_gap_neq_var term) <span class="kr">in</span> IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>LC term ktyp t</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC term ktyp t</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk188" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>LC term ktyp
  (open term ktrm (mret SystemF ktrm (Fr e)) t)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk188"><hr></label><div class="goal-conclusion">ktyp &lt;&gt; ktrm</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk189" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk189">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>LC term ktyp t</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC term ktyp t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk18a" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk18a">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>LC term ktyp
  (open term ktrm (mret SystemF ktrm (Fr e)) t)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ktyp &lt;&gt; ktrm</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">discriminate</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk18b" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk18b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t2 : τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span>LC term ktyp t1</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span>LC term ktyp t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC term ktyp (tm_app t1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> simplify_LC.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk18c" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk18c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
LC term ktyp (open term ktyp (ty_v (Fr x)) t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC term ktyp (tm_tab t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk18d" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk18d"><span class="nb">rename</span> H0 <span class="nb">into</span> IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
LC term ktyp (open term ktyp (ty_v (Fr x)) t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC term ktyp (tm_tab t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk18e" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk18e">cc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ ++ e0 ~ tt; Γ ⊢ open term ktyp (ty_v (Fr e0)) t
: open typ ktyp (ty_v (Fr e0)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>LC term ktyp (open term ktyp (ty_v (Fr e)) t)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC term ktyp (tm_tab t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk18f" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk18f">simplify_LC.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ ++ e0 ~ tt; Γ ⊢ open term ktyp (ty_v (Fr e0)) t
: open typ ktyp (ty_v (Fr e0)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>LC term ktyp (open term ktyp (ty_v (Fr e)) t)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LCn term ktyp <span class="mi">1</span> t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk190" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk190"><span class="nb">rewrite</span> (open_lc_gap_eq_var term).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ ++ e0 ~ tt; Γ ⊢ open term ktyp (ty_v (Fr e0)) t
: open typ ktyp (ty_v (Fr e0)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>LC term ktyp (open term ktyp (ty_v (Fr e)) t)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LCn term ktyp (<span class="mi">1</span> - <span class="mi">1</span>)
  (open term ktyp (mret SystemF ktyp (Fr <span class="nl">?Goal1</span>)) t)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk191" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ ++ e0 ~ tt; Γ ⊢ open term ktyp (ty_v (Fr e0)) t
: open typ ktyp (ty_v (Fr e0)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>LC term ktyp (open term ktyp (ty_v (Fr e)) t)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk191"><hr></label><div class="goal-conclusion"><span class="mi">1</span> &gt; <span class="mi">0</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk192" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk192">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ ++ e0 ~ tt; Γ ⊢ open term ktyp (ty_v (Fr e0)) t
: open typ ktyp (ty_v (Fr e0)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>LC term ktyp (open term ktyp (ty_v (Fr e)) t)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LCn term ktyp (<span class="mi">1</span> - <span class="mi">1</span>)
  (open term ktyp (mret SystemF ktyp (Fr <span class="nl">?Goal1</span>)) t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> IH.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk193" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk193">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ ++ e0 ~ tt; Γ ⊢ open term ktyp (ty_v (Fr e0)) t
: open typ ktyp (ty_v (Fr e0)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>LC term ktyp (open term ktyp (ty_v (Fr e)) t)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> &gt; <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk194" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk194">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>LC term ktyp t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC term ktyp (tm_tap t τ1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk195" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk195">simplify_LC; <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>LC term ktyp t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC term ktyp t</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk196" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>LC term ktyp t</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk196"><hr></label><div class="goal-conclusion">LC typ ktyp τ1</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk197" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk197">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>LC term ktyp t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC term ktyp t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk198" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk198">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>LC term ktyp t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC typ ktyp τ1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">inversion</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** &lt;&lt;t&gt;&gt; is always well-scoped w.r.t. type variables *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk199" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk199"><span class="kn">Lemma</span> <span class="nf">j_sc_ktyp_term</span> : <span class="kr">forall</span> <span class="nv">Δ</span> <span class="nv">Γ</span> <span class="nv">t</span> <span class="nv">τ</span>,
    (Δ ; Γ ⊢ t : τ) -&gt;
    scoped term ktyp t (domset Δ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ</span> : kind_ctx) (<span class="nv">Γ</span> : type_ctx) (<span class="nv">t</span> : term LN)
  (<span class="nv">τ</span> : typ LN),
Δ; Γ ⊢ t : τ -&gt; scoped term ktyp t (domset Δ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk19a" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk19a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ</span> : kind_ctx) (<span class="nv">Γ</span> : type_ctx) (<span class="nv">t</span> : term LN)
  (<span class="nv">τ</span> : typ LN),
Δ; Γ ⊢ t : τ -&gt; scoped term ktyp t (domset Δ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk19b" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk19b">introv j.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : τ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scoped term ktyp t (domset Δ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk19c" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk19c"><span class="nb">induction</span> j; <span class="kp">try</span> <span class="nb">rename</span> H0 <span class="nb">into</span> IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x, τ) ∈ Γ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scoped term ktyp (tm_var (Fr x)) (domset Δ)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk19d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
scoped term ktyp
  (open term ktrm (tm_var (Fr x)) t) (domset Δ)</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk19d"><hr></label><div class="goal-conclusion">scoped term ktyp (tm_abs τ1 t) (domset Δ)</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk19e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t2 : τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span>scoped term ktyp t1 (domset Δ)</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span>scoped term ktyp t2 (domset Δ)</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk19e"><hr></label><div class="goal-conclusion">scoped term ktyp (tm_app t1 t2) (domset Δ)</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk19f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
scoped term ktyp (open term ktyp (ty_v (Fr x)) t)
  (domset (Δ ++ x ~ tt))</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk19f"><hr></label><div class="goal-conclusion">scoped term ktyp (tm_tab t) (domset Δ)</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk1a0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>scoped term ktyp t (domset Δ)</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk1a0"><hr></label><div class="goal-conclusion">scoped term ktyp (tm_tap t τ1) (domset Δ)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1a1" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1a1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x, τ) ∈ Γ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scoped term ktyp (tm_var (Fr x)) (domset Δ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1a2" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1a2"><span class="nb">unfold</span> scoped.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x, τ) ∈ Γ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term ktyp (tm_var (Fr x)) ⊆ domset Δ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">fsetdec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1a3" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1a3">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
scoped term ktyp
  (open term ktrm (tm_var (Fr x)) t) 
  (domset Δ)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scoped term ktyp (tm_abs τ1 t) (domset Δ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1a4" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1a4"><span class="nb">unfold</span> scoped.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
scoped term ktyp
  (open term ktrm (tm_var (Fr x)) t) 
  (domset Δ)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term ktyp (tm_abs τ1 t) ⊆ domset Δ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1a5" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1a5">cc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>scoped term ktyp
  (open term ktrm (tm_var (Fr e)) t) 
  (domset Δ)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term ktyp (tm_abs τ1 t) ⊆ domset Δ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1a6" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1a6">simplify_FV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>scoped term ktyp
  (open term ktrm (tm_var (Fr e)) t) 
  (domset Δ)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV typ ktyp τ1 ∪ FV term ktyp t ⊆ domset Δ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1a7" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1a7"><span class="nb">assert</span> (FV typ ktyp τ1 ⊆ domset Δ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>scoped term ktyp
  (open term ktrm (tm_var (Fr e)) t) 
  (domset Δ)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV typ ktyp τ1 ⊆ domset Δ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk1a8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>scoped term ktyp
  (open term ktrm (tm_var (Fr e)) t) 
  (domset Δ)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>FV typ ktyp τ1 ⊆ domset Δ</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk1a8"><hr></label><div class="goal-conclusion">FV typ ktyp τ1 ∪ FV term ktyp t ⊆ domset Δ</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1a9" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1a9">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>scoped term ktyp
  (open term ktrm (tm_var (Fr e)) t) 
  (domset Δ)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV typ ktyp τ1 ⊆ domset Δ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1aa" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1aa"><span class="nb">eapply</span> j_type_ctx2 <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>scoped term ktyp
  (open term ktrm (tm_var (Fr e)) t) 
  (domset Δ)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV typ ktyp τ1 ⊆ domset Δ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> H.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1ab" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1ab">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>scoped term ktyp
  (open term ktrm (tm_var (Fr e)) t) 
  (domset Δ)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>FV typ ktyp τ1 ⊆ domset Δ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV typ ktyp τ1 ∪ FV term ktyp t ⊆ domset Δ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1ac" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1ac"><span class="nb">unfold</span> scoped <span class="kr">in</span> IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>FV term ktyp (open term ktrm (tm_var (Fr e)) t)
⊆ domset Δ</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>FV typ ktyp τ1 ⊆ domset Δ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV typ ktyp τ1 ∪ FV term ktyp t ⊆ domset Δ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1ad" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1ad"><span class="nb">rewrite</span> &lt;- (FV_open_lower term) <span class="kr">in</span> IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ e0 ~ τ1
⊢ open term ktrm (tm_var (Fr e0)) t : τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>FV term ktyp t ⊆ domset Δ</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>FV typ ktyp τ1 ⊆ domset Δ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV typ ktyp τ1 ∪ FV term ktyp t ⊆ domset Δ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">fsetdec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1ae" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1ae">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t2 : τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span>scoped term ktyp t1 (domset Δ)</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span>scoped term ktyp t2 (domset Δ)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scoped term ktyp (tm_app t1 t2) (domset Δ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1af" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1af"><span class="nb">unfold</span> scoped <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t2 : τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span>FV term ktyp t1 ⊆ domset Δ</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span>FV term ktyp t2 ⊆ domset Δ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term ktyp (tm_app t1 t2) ⊆ domset Δ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1b0" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1b0">simplify_FV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t2 : τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span>FV term ktyp t1 ⊆ domset Δ</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span>FV term ktyp t2 ⊆ domset Δ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term ktyp t1 ∪ FV term ktyp t2 ⊆ domset Δ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">fsetdec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1b1" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1b1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
scoped term ktyp (open term ktyp (ty_v (Fr x)) t)
  (domset (Δ ++ x ~ tt))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scoped term ktyp (tm_tab t) (domset Δ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1b2" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1b2"><span class="nb">unfold</span> scoped.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
scoped term ktyp (open term ktyp (ty_v (Fr x)) t)
  (domset (Δ ++ x ~ tt))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term ktyp (tm_tab t) ⊆ domset Δ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1b3" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1b3">simplify_FV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
scoped term ktyp (open term ktyp (ty_v (Fr x)) t)
  (domset (Δ ++ x ~ tt))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term ktyp t ⊆ domset Δ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1b4" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1b4">pick <span class="kp">fresh</span> x <span class="kr">for</span> (L ∪ FV term ktyp t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
scoped term ktyp (open term ktyp (ty_v (Fr x)) t)
  (domset (Δ ++ x ~ tt))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>x `notin` (L ∪ FV term ktyp t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term ktyp t ⊆ domset Δ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1b5" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1b5">specialize_cof IH x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>scoped term ktyp (open term ktyp (ty_v (Fr x)) t)
  (domset (Δ ++ x ~ tt))</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>x `notin` (L ∪ FV term ktyp t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term ktyp t ⊆ domset Δ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1b6" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1b6"><span class="nb">unfold</span> scoped <span class="kr">in</span> IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>FV term ktyp (open term ktyp (ty_v (Fr x)) t)
⊆ domset (Δ ++ x ~ tt)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>x `notin` (L ∪ FV term ktyp t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term ktyp t ⊆ domset Δ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1b7" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1b7"><span class="nb">rewrite</span> &lt;- (FV_open_lower term) <span class="kr">in</span> IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>FV term ktyp t ⊆ domset (Δ ++ x ~ tt)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>x `notin` (L ∪ FV term ktyp t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term ktyp t ⊆ domset Δ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1b8" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1b8"><span class="nb">eapply</span> (scoped_stren_r term).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>FV term ktyp t ⊆ domset (Δ ++ x ~ tt)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>x `notin` (L ∪ FV term ktyp t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scoped term ktyp t (domset (Δ ++ <span class="nl">?x</span> ~ <span class="nl">?x&#39;</span>))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk1b9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>FV term ktyp t ⊆ domset (Δ ++ x ~ tt)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>x `notin` (L ∪ FV term ktyp t)</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk1b9"><hr></label><div class="goal-conclusion"><span class="nl">?x</span> `notin` FV term ktyp t</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1ba" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1ba">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>FV term ktyp t ⊆ domset (Δ ++ x ~ tt)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>x `notin` (L ∪ FV term ktyp t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scoped term ktyp t (domset (Δ ++ <span class="nl">?x</span> ~ <span class="nl">?x&#39;</span>))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1bb" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1bb">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>FV term ktyp t ⊆ domset (Δ ++ x ~ tt)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>x `notin` (L ∪ FV term ktyp t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x `notin` FV term ktyp t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">fsetdec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1bc" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1bc">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>scoped term ktyp t (domset Δ)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scoped term ktyp (tm_tap t τ1) (domset Δ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1bd" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1bd"><span class="nb">unfold</span> scoped <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>FV term ktyp t ⊆ domset Δ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term ktyp (tm_tap t τ1) ⊆ domset Δ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1be" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1be">simplify_FV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>FV term ktyp t ⊆ domset Δ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term ktyp t ∪ FV typ ktyp τ1 ⊆ domset Δ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1bf" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1bf"><span class="nb">assert</span> (FV typ ktyp τ1 ⊆ domset Δ) <span class="bp">by</span> <span class="nb">apply</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>FV term ktyp t ⊆ domset Δ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>FV typ ktyp τ1 ⊆ domset Δ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term ktyp t ∪ FV typ ktyp τ1 ⊆ domset Δ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">fsetdec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** &lt;&lt;t&gt;&gt; is always well-scoped w.r.t. term variables *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1c0" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1c0"><span class="kn">Lemma</span> <span class="nf">j_sc_KTerm_term</span> : <span class="kr">forall</span> <span class="nv">Δ</span> <span class="nv">Γ</span> <span class="nv">t</span> <span class="nv">τ</span>,
    (Δ ; Γ ⊢ t : τ) -&gt;
    scoped term ktrm t (domset Γ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ</span> : kind_ctx) (<span class="nv">Γ</span> : type_ctx) (<span class="nv">t</span> : term LN)
  (<span class="nv">τ</span> : typ LN),
Δ; Γ ⊢ t : τ -&gt; scoped term ktrm t (domset Γ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1c1" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1c1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ</span> : kind_ctx) (<span class="nv">Γ</span> : type_ctx) (<span class="nv">t</span> : term LN)
  (<span class="nv">τ</span> : typ LN),
Δ; Γ ⊢ t : τ -&gt; scoped term ktrm t (domset Γ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1c2" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1c2">introv j.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : τ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scoped term ktrm t (domset Γ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1c3" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1c3"><span class="nb">induction</span> j; <span class="kp">try</span> <span class="nb">rename</span> H0 <span class="nb">into</span> IH; <span class="nb">unfold</span> scoped <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x, τ) ∈ Γ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term ktrm (tm_var (Fr x)) ⊆ domset Γ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk1c4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
FV term ktrm (open term ktrm (tm_var (Fr x)) t)
⊆ domset (Γ ++ x ~ τ1)</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk1c4"><hr></label><div class="goal-conclusion">FV term ktrm (tm_abs τ1 t) ⊆ domset Γ</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk1c5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t2 : τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span>FV term ktrm t1 ⊆ domset Γ</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span>FV term ktrm t2 ⊆ domset Γ</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk1c5"><hr></label><div class="goal-conclusion">FV term ktrm (tm_app t1 t2) ⊆ domset Γ</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk1c6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
FV term ktrm (open term ktyp (ty_v (Fr x)) t)
⊆ domset Γ</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk1c6"><hr></label><div class="goal-conclusion">FV term ktrm (tm_tab t) ⊆ domset Γ</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk1c7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>FV term ktrm t ⊆ domset Γ</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk1c7"><hr></label><div class="goal-conclusion">FV term ktrm (tm_tap t τ1) ⊆ domset Γ</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1c8" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1c8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x, τ) ∈ Γ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term ktrm (tm_var (Fr x)) ⊆ domset Γ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1c9" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1c9"><span class="nb">rename</span> H1 <span class="nb">into</span> Hin.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>(x, τ) ∈ Γ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term ktrm (tm_var (Fr x)) ⊆ domset Γ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1ca" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1ca">simplify_FV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>(x, τ) ∈ Γ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{{x}} ⊆ domset Γ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1cb" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1cb"><span class="nb">apply</span> in_in_domset <span class="kr">in</span> Hin.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ Γ</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>x `<span class="kr">in</span>` domset Γ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{{x}} ⊆ domset Γ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">fsetdec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1cc" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1cc">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
FV term ktrm (open term ktrm (tm_var (Fr x)) t)
⊆ domset (Γ ++ x ~ τ1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term ktrm (tm_abs τ1 t) ⊆ domset Γ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1cd" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1cd">simplify_FV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
FV term ktrm (open term ktrm (tm_var (Fr x)) t)
⊆ domset (Γ ++ x ~ τ1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV typ ktrm τ1 ∪ FV term ktrm t ⊆ domset Γ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1ce" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1ce"><span class="nb">assert</span> (FV term ktrm t ⊆ domset Γ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
FV term ktrm (open term ktrm (tm_var (Fr x)) t)
⊆ domset (Γ ++ x ~ τ1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term ktrm t ⊆ domset Γ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk1cf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
FV term ktrm (open term ktrm (tm_var (Fr x)) t)
⊆ domset (Γ ++ x ~ τ1)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>FV term ktrm t ⊆ domset Γ</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk1cf"><hr></label><div class="goal-conclusion">FV typ ktrm τ1 ∪ FV term ktrm t ⊆ domset Γ</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1d0" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1d0">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
FV term ktrm (open term ktrm (tm_var (Fr x)) t)
⊆ domset (Γ ++ x ~ τ1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term ktrm t ⊆ domset Γ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1d1" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1d1">pick <span class="kp">fresh</span> x <span class="kr">for</span> (L ∪ FV term ktrm t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
FV term ktrm (open term ktrm (tm_var (Fr x)) t)
⊆ domset (Γ ++ x ~ τ1)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>x `notin` (L ∪ FV term ktrm t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term ktrm t ⊆ domset Γ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1d2" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1d2">specialize_cof IH x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>FV term ktrm (open term ktrm (tm_var (Fr x)) t)
⊆ domset (Γ ++ x ~ τ1)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>x `notin` (L ∪ FV term ktrm t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term ktrm t ⊆ domset Γ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1d3" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1d3"><span class="nb">rewrite</span> &lt;- (FV_open_lower term) <span class="kr">in</span> IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>FV term ktrm t ⊆ domset (Γ ++ x ~ τ1)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>x `notin` (L ∪ FV term ktrm t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term ktrm t ⊆ domset Γ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1d4" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1d4"><span class="nb">eapply</span> (scoped_stren_r term).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>FV term ktrm t ⊆ domset (Γ ++ x ~ τ1)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>x `notin` (L ∪ FV term ktrm t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scoped term ktrm t (domset (Γ ++ <span class="nl">?x</span> ~ <span class="nl">?x&#39;</span>))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk1d5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>FV term ktrm t ⊆ domset (Γ ++ x ~ τ1)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>x `notin` (L ∪ FV term ktrm t)</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk1d5"><hr></label><div class="goal-conclusion"><span class="nl">?x</span> `notin` FV term ktrm t</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1d6" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1d6">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>FV term ktrm t ⊆ domset (Γ ++ x ~ τ1)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>x `notin` (L ∪ FV term ktrm t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scoped term ktrm t (domset (Γ ++ <span class="nl">?x</span> ~ <span class="nl">?x&#39;</span>))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1d7" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1d7">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>FV term ktrm t ⊆ domset (Γ ++ x ~ τ1)</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>x `notin` (L ∪ FV term ktrm t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x `notin` FV term ktrm t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">fsetdec.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1d8" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1d8">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
FV term ktrm (open term ktrm (tm_var (Fr x)) t)
⊆ domset (Γ ++ x ~ τ1)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>FV term ktrm t ⊆ domset Γ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV typ ktrm τ1 ∪ FV term ktrm t ⊆ domset Γ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1d9" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1d9"><span class="nb">rewrite</span> FV_trm_type_empty.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ; Γ ++ x ~ τ1 ⊢ open term ktrm (tm_var (Fr x)) t
: τ2</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
FV term ktrm (open term ktrm (tm_var (Fr x)) t)
⊆ domset (Γ ++ x ~ τ1)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>FV term ktrm t ⊆ domset Γ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">∅ ∪ FV term ktrm t ⊆ domset Γ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">fsetdec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1da" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1da">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t2 : τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span>FV term ktrm t1 ⊆ domset Γ</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span>FV term ktrm t2 ⊆ domset Γ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term ktrm (tm_app t1 t2) ⊆ domset Γ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1db" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1db">simplify_FV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t2 : τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span>FV term ktrm t1 ⊆ domset Γ</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span>FV term ktrm t2 ⊆ domset Γ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term ktrm t1 ∪ FV term ktrm t2 ⊆ domset Γ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">fsetdec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1dc" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1dc">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
FV term ktrm (open term ktyp (ty_v (Fr x)) t)
⊆ domset Γ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term ktrm (tm_tab t) ⊆ domset Γ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1dd" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1dd">simplify_FV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
Δ ++ x ~ tt; Γ ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
FV term ktrm (open term ktyp (ty_v (Fr x)) t)
⊆ domset Γ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term ktrm t ⊆ domset Γ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1de" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1de">cc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ ++ e0 ~ tt; Γ ⊢ open term ktyp (ty_v (Fr e0)) t
: open typ ktyp (ty_v (Fr e0)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>FV term ktrm (open term ktyp (ty_v (Fr e)) t)
⊆ domset Γ</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term ktrm t ⊆ domset Γ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1df" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1df"><span class="nb">etransitivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ ++ e0 ~ tt; Γ ⊢ open term ktyp (ty_v (Fr e0)) t
: open typ ktyp (ty_v (Fr e0)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>FV term ktrm (open term ktyp (ty_v (Fr e)) t)
⊆ domset Γ</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term ktrm t ⊆ <span class="nl">?y</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk1e0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ ++ e0 ~ tt; Γ ⊢ open term ktyp (ty_v (Fr e0)) t
: open typ ktyp (ty_v (Fr e0)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>FV term ktrm (open term ktyp (ty_v (Fr e)) t)
⊆ domset Γ</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk1e0"><hr></label><div class="goal-conclusion"><span class="nl">?y</span> ⊆ domset Γ</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1e1" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1e1"><span class="nb">pose</span> (lemma := FV_open_lower term t (ktyp : K) (ktrm : K)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ ++ e0 ~ tt; Γ ⊢ open term ktyp (ty_v (Fr e0)) t
: open typ ktyp (ty_v (Fr e0)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>FV term ktrm (open term ktyp (ty_v (Fr e)) t)
⊆ domset Γ</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br><span><var>lemma</var><span><span class="hyp-body"><b>:= </b><span>FV_open_lower term t (ktyp : K) (ktrm : K)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">u</span> : SystemF (ktyp : K) LN,
FV term (ktrm : K) t
⊆ FV term (ktrm : K)
    (open term (ktyp : K) u t)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term ktrm t ⊆ <span class="nl">?y</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk1e2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ ++ e0 ~ tt; Γ ⊢ open term ktyp (ty_v (Fr e0)) t
: open typ ktyp (ty_v (Fr e0)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>FV term ktrm (open term ktyp (ty_v (Fr e)) t)
⊆ domset Γ</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk1e2"><hr></label><div class="goal-conclusion"><span class="nl">?y</span> ⊆ domset Γ</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1e3" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1e3"><span class="nb">apply</span> lemma.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ ++ e0 ~ tt; Γ ⊢ open term ktyp (ty_v (Fr e0)) t
: open typ ktyp (ty_v (Fr e0)) τ</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>FV term ktrm (open term ktyp (ty_v (Fr e)) t)
⊆ domset Γ</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` L</span></span></span><br><span><var>Hfresh0</var><span class="hyp-type"><b>: </b><span>e0 `notin` (L ∪ {{e}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term ktrm (open term ktyp <span class="nl">?u</span> t) ⊆ domset Γ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1e4" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1e4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>FV term ktrm t ⊆ domset Γ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term ktrm (tm_tap t τ1) ⊆ domset Γ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1e5" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1e5">simplify_FV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>FV term ktrm t ⊆ domset Γ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term ktrm t ∪ FV typ ktrm τ1 ⊆ domset Γ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1e6" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1e6"><span class="nb">enough</span> (FV typ ktrm τ1 ⊆ domset Γ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>FV term ktrm t ⊆ domset Γ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>FV typ ktrm τ1 ⊆ domset Γ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term ktrm t ∪ FV typ ktrm τ1 ⊆ domset Γ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk1e7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>FV term ktrm t ⊆ domset Γ</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk1e7"><hr></label><div class="goal-conclusion">FV typ ktrm τ1 ⊆ domset Γ</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1e8" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1e8">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>FV term ktrm t ⊆ domset Γ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>FV typ ktrm τ1 ⊆ domset Γ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term ktrm t ∪ FV typ ktrm τ1 ⊆ domset Γ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">fsetdec.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1e9" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1e9">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>FV term ktrm t ⊆ domset Γ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV typ ktrm τ1 ⊆ domset Γ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1ea" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1ea"><span class="nb">inversion</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>FV term ktrm t ⊆ domset Γ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>scoped typ ktyp τ1 (domset Δ)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>LC typ ktyp τ1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV typ ktrm τ1 ⊆ domset Γ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1eb" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1eb"><span class="nb">unfold</span> scoped <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>FV term ktrm t ⊆ domset Γ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>FV typ ktyp τ1 ⊆ domset Δ</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>LC typ ktyp τ1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV typ ktrm τ1 ⊆ domset Γ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1ec" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1ec"><span class="nb">rewrite</span> FV_trm_type_empty.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>FV term ktrm t ⊆ domset Γ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>FV typ ktyp τ1 ⊆ domset Δ</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>LC typ ktyp τ1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">∅ ⊆ domset Γ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">fsetdec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** &lt;&lt;t&gt;&gt; is always well-formed *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1ed" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1ed"><span class="kn">Lemma</span> <span class="nf">j_ok_term</span> : <span class="kr">forall</span> <span class="nv">Δ</span> <span class="nv">Γ</span> <span class="nv">t</span> <span class="nv">τ</span>,
    (Δ ; Γ ⊢ t : τ) -&gt;
    ok_term Δ Γ t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ</span> : kind_ctx) (<span class="nv">Γ</span> : type_ctx) (<span class="nv">t</span> : term LN)
  (<span class="nv">τ</span> : typ LN), Δ; Γ ⊢ t : τ -&gt; ok_term Δ Γ t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1ee" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1ee"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ</span> : kind_ctx) (<span class="nv">Γ</span> : type_ctx) (<span class="nv">t</span> : term LN)
  (<span class="nv">τ</span> : typ LN), Δ; Γ ⊢ t : τ -&gt; ok_term Δ Γ t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1ef" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1ef"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : τ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_term Δ Γ t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1f0" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1f0"><span class="nb">unfold</span> ok_term.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>type_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : τ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scoped term ktyp t (domset Δ) /\
scoped term ktrm t (domset Γ) /\
LC term ktrm t /\ LC term ktyp t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intuition</span> (<span class="nb">eauto using</span> j_sc_KTerm_term, j_sc_ktyp_term, j_lc_KTerm_term, j_lc_ktyp_term).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Substitution *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1f1" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1f1"><span class="kn">Theorem</span> <span class="nf">j_type_ctx_subst</span> : <span class="kr">forall</span> <span class="nv">Δ</span> <span class="nv">Γ1</span> <span class="nv">Γ2</span> <span class="nv">x</span> <span class="nv">τ2</span> <span class="nv">t</span> <span class="nv">u</span> <span class="nv">τ1</span>,
    (Δ ; Γ1 ++ x ~ τ2 ++ Γ2 ⊢ t : τ1) -&gt;
    (Δ ; Γ1 ++ Γ2 ⊢ u : τ2) -&gt;
    (Δ ; Γ1 ++ Γ2 ⊢ <span class="nb">subst</span> term ktrm x u t : τ1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ</span> : kind_ctx) (<span class="nv">Γ1</span> <span class="nv">Γ2</span> : list (atom * typ LN)) 
  <span class="nv">x</span> (<span class="nv">τ2</span> : typ LN) (<span class="nv">t</span> <span class="nv">u</span> : term LN) (<span class="nv">τ1</span> : typ LN),
Δ; Γ1 ++ x ~ τ2 ++ Γ2 ⊢ t : τ1 -&gt;
Δ; Γ1 ++ Γ2 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ2 ⊢ <span class="nb">subst</span> term ktrm x u t : τ1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1f2" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1f2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ</span> : kind_ctx) (<span class="nv">Γ1</span> <span class="nv">Γ2</span> : list (atom * typ LN)) 
  <span class="nv">x</span> (<span class="nv">τ2</span> : typ LN) (<span class="nv">t</span> <span class="nv">u</span> : term LN) (<span class="nv">τ1</span> : typ LN),
Δ; Γ1 ++ x ~ τ2 ++ Γ2 ⊢ t : τ1 -&gt;
Δ; Γ1 ++ Γ2 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ2 ⊢ <span class="nb">subst</span> term ktrm x u t : τ1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1f3" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1f3">introv jt ju.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ1, Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t, u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>jt</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ x ~ τ2 ++ Γ2 ⊢ t : τ1</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ1 ++ Γ2 ⊢ <span class="nb">subst</span> term ktrm x u t : τ1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1f4" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1f4"><span class="nb">remember</span> (Γ1 ++ x ~ τ2 ++ Γ2) <span class="kr">as</span> Γ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ1, Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t, u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>HeqΓ</var><span class="hyp-type"><b>: </b><span>Γ = Γ1 ++ x ~ τ2 ++ Γ2</span></span></span><br><span><var>jt</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : τ1</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ1 ++ Γ2 ⊢ <span class="nb">subst</span> term ktrm x u t : τ1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1f5" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1f5"><span class="nb">generalize dependent</span> Γ2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t, u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>jt</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ t : τ1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">Γ2</span> : list (atom * typ LN),
Γ = Γ1 ++ x ~ τ2 ++ Γ2 -&gt;
Δ; Γ1 ++ Γ2 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ2 ⊢ <span class="nb">subst</span> term ktrm x u t : τ1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1f6" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1f6"><span class="nb">induction</span> jt; <span class="nb">intros</span>; <span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ1 ++ Γ2 ⊢ <span class="nb">subst</span> term ktrm x u (tm_var (Fr x0)) : τ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk1f7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
<span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
(Γ1 ++ x ~ τ2 ++ Γ2) ++ x0 ~ τ1 =
Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3
⊢ <span class="nb">subst</span> term ktrm x u
    (open term ktrm (tm_var (Fr x0)) t) : τ0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ; (Γ1 ++ x ~ τ2 ++ Γ2) ++ x0 ~ τ1
⊢ open term ktrm (tm_var (Fr x0)) t : τ0</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk1f7"><hr></label><div class="goal-conclusion">Δ; Γ1 ++ Γ2 ⊢ <span class="nb">subst</span> term ktrm x u (tm_abs τ1 t)
: ty_ar τ1 τ0</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk1f8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>IHjt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3 ⊢ <span class="nb">subst</span> term ktrm x u t2 : τ1</span></span></span><br><span><var>IHjt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3 ⊢ <span class="nb">subst</span> term ktrm x u t1
: ty_ar τ1 τ0</span></span></span><br><span><var>jt2</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ x ~ τ2 ++ Γ2 ⊢ t2 : τ1</span></span></span><br><span><var>jt1</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ x ~ τ2 ++ Γ2 ⊢ t1 : ty_ar τ1 τ0</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk1f8"><hr></label><div class="goal-conclusion">Δ; Γ1 ++ Γ2 ⊢ <span class="nb">subst</span> term ktrm x u (tm_app t1 t2) : τ0</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk1f9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
<span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ ++ x0 ~ tt; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ ++ x0 ~ tt; Γ1 ++ Γ3
⊢ <span class="nb">subst</span> term ktrm x u
    (open term ktyp (ty_v (Fr x0)) t)
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ ++ x0 ~ tt; Γ1 ++ x ~ τ2 ++ Γ2
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk1f9"><hr></label><div class="goal-conclusion">Δ; Γ1 ++ Γ2 ⊢ <span class="nb">subst</span> term ktrm x u (tm_tab t)
: ty_univ τ</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk1fa" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>IHjt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3 ⊢ <span class="nb">subst</span> term ktrm x u t
: ty_univ τ0</span></span></span><br><span><var>jt</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ x ~ τ2 ++ Γ2 ⊢ t : ty_univ τ0</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk1fa"><hr></label><div class="goal-conclusion">Δ; Γ1 ++ Γ2 ⊢ <span class="nb">subst</span> term ktrm x u (tm_tap t τ1)
: open typ ktyp τ1 τ0</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1fb" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1fb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ1 ++ Γ2 ⊢ <span class="nb">subst</span> term ktrm x u (tm_var (Fr x0)) : τ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1fc" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1fc"><span class="nb">rename</span> H0 <span class="nb">into</span> Hok.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ1 ++ Γ2 ⊢ <span class="nb">subst</span> term ktrm x u (tm_var (Fr x0)) : τ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1fd" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1fd"><span class="nb">rename</span> H1 <span class="nb">into</span> Hvar.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hvar</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ1 ++ Γ2 ⊢ <span class="nb">subst</span> term ktrm x u (tm_var (Fr x0)) : τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk1fe" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk1fe"><span class="nb">compare</span> values x <span class="kn">and</span> x0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ (Γ1 ++ x0 ~ τ2 ++ Γ2)</span></span></span><br><span><var>Hvar</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ (Γ1 ++ x0 ~ τ2 ++ Γ2)</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>DESTR_EQs</var><span class="hyp-type"><b>: </b><span>x0 = x0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ1 ++ Γ2 ⊢ <span class="nb">subst</span> term ktrm x0 u (tm_var (Fr x0))
: τ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk1ff" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hvar</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; x0</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>x0 &lt;&gt; x</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk1ff"><hr></label><div class="goal-conclusion">Δ; Γ1 ++ Γ2 ⊢ <span class="nb">subst</span> term ktrm x u (tm_var (Fr x0)) : τ</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk200" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk200">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ (Γ1 ++ x0 ~ τ2 ++ Γ2)</span></span></span><br><span><var>Hvar</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ (Γ1 ++ x0 ~ τ2 ++ Γ2)</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>DESTR_EQs</var><span class="hyp-type"><b>: </b><span>x0 = x0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ1 ++ Γ2 ⊢ <span class="nb">subst</span> term ktrm x0 u (tm_var (Fr x0))
: τ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk201" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk201"><span class="nb">replace</span> (<span class="nb">subst</span> (ix := I2) term ktrm x0 u (tm_var (Fr x0))) <span class="kr">with</span> u.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ (Γ1 ++ x0 ~ τ2 ++ Γ2)</span></span></span><br><span><var>Hvar</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ (Γ1 ++ x0 ~ τ2 ++ Γ2)</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>DESTR_EQs</var><span class="hyp-type"><b>: </b><span>x0 = x0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ1 ++ Γ2 ⊢ u : τ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk202" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ (Γ1 ++ x0 ~ τ2 ++ Γ2)</span></span></span><br><span><var>Hvar</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ (Γ1 ++ x0 ~ τ2 ++ Γ2)</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>DESTR_EQs</var><span class="hyp-type"><b>: </b><span>x0 = x0</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk202"><hr></label><div class="goal-conclusion">u = <span class="nb">subst</span> term ktrm x0 u (tm_var (Fr x0))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk203" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk203"><span class="mi">2</span>:{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ (Γ1 ++ x0 ~ τ2 ++ Γ2)</span></span></span><br><span><var>Hvar</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ (Γ1 ++ x0 ~ τ2 ++ Γ2)</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>DESTR_EQs</var><span class="hyp-type"><b>: </b><span>x0 = x0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">u = <span class="nb">subst</span> term ktrm x0 u (tm_var (Fr x0))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk204" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk204">simplify_subst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ (Γ1 ++ x0 ~ τ2 ++ Γ2)</span></span></span><br><span><var>Hvar</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ (Γ1 ++ x0 ~ τ2 ++ Γ2)</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>DESTR_EQs</var><span class="hyp-type"><b>: </b><span>x0 = x0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">u = btg ktrm (subst_loc ktrm x0 u) ktrm (Fr x0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk205" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk205"><span class="nb">rewrite</span> btg_eq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ (Γ1 ++ x0 ~ τ2 ++ Γ2)</span></span></span><br><span><var>Hvar</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ (Γ1 ++ x0 ~ τ2 ++ Γ2)</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>DESTR_EQs</var><span class="hyp-type"><b>: </b><span>x0 = x0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">u = subst_loc ktrm x0 u (Fr x0)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk206" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk206"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ (Γ1 ++ x0 ~ τ2 ++ Γ2)</span></span></span><br><span><var>Hvar</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ (Γ1 ++ x0 ~ τ2 ++ Γ2)</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>DESTR_EQs</var><span class="hyp-type"><b>: </b><span>x0 = x0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">u = (<span class="kr">if</span> x0 == x0 <span class="kr">then</span> u <span class="kr">else</span> tm_var (Fr x0))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">destruct_eq_args x0 x0.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk207" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk207">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ (Γ1 ++ x0 ~ τ2 ++ Γ2)</span></span></span><br><span><var>Hvar</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ (Γ1 ++ x0 ~ τ2 ++ Γ2)</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>DESTR_EQs</var><span class="hyp-type"><b>: </b><span>x0 = x0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ1 ++ Γ2 ⊢ u : τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk208" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk208"><span class="nb">enough</span> (τ = τ2) <span class="bp">by</span> <span class="bp">congruence</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ (Γ1 ++ x0 ~ τ2 ++ Γ2)</span></span></span><br><span><var>Hvar</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ (Γ1 ++ x0 ~ τ2 ++ Γ2)</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>DESTR_EQs</var><span class="hyp-type"><b>: </b><span>x0 = x0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">τ = τ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk209" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk209"><span class="nb">eapply</span> binds_mid_eq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ (Γ1 ++ x0 ~ τ2 ++ Γ2)</span></span></span><br><span><var>Hvar</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ (Γ1 ++ x0 ~ τ2 ++ Γ2)</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>DESTR_EQs</var><span class="hyp-type"><b>: </b><span>x0 = x0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?x</span>, τ) ∈ (<span class="nl">?Γ1</span> ++ <span class="nl">?x</span> ~ τ2 ++ <span class="nl">?Γ2</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk20a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ (Γ1 ++ x0 ~ τ2 ++ Γ2)</span></span></span><br><span><var>Hvar</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ (Γ1 ++ x0 ~ τ2 ++ Γ2)</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>DESTR_EQs</var><span class="hyp-type"><b>: </b><span>x0 = x0</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk20a"><hr></label><div class="goal-conclusion">uniq (<span class="nl">?Γ1</span> ++ <span class="nl">?x</span> ~ τ2 ++ <span class="nl">?Γ2</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk20b" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk20b"><span class="nb">apply</span> Hvar.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ (Γ1 ++ x0 ~ τ2 ++ Γ2)</span></span></span><br><span><var>Hvar</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ (Γ1 ++ x0 ~ τ2 ++ Γ2)</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>DESTR_EQs</var><span class="hyp-type"><b>: </b><span>x0 = x0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">uniq (Γ1 ++ x0 ~ τ2 ++ Γ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Hok.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk20c" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk20c">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hvar</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; x0</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>x0 &lt;&gt; x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ1 ++ Γ2 ⊢ <span class="nb">subst</span> term ktrm x u (tm_var (Fr x0)) : τ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk20d" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk20d"><span class="nb">replace</span> (<span class="nb">subst</span> (ix := I2) term ktrm x u (tm_var (Fr x0)))
        <span class="kr">with</span> (tm_var (Fr x0)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hvar</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; x0</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>x0 &lt;&gt; x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ1 ++ Γ2 ⊢ tm_var (Fr x0) : τ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk20e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hvar</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; x0</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>x0 &lt;&gt; x</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk20e"><hr></label><div class="goal-conclusion">tm_var (Fr x0) = <span class="nb">subst</span> term ktrm x u (tm_var (Fr x0))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk20f" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk20f"><span class="mi">2</span>:{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hvar</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; x0</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>x0 &lt;&gt; x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tm_var (Fr x0) = <span class="nb">subst</span> term ktrm x u (tm_var (Fr x0))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk210" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk210">simplify_subst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hvar</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; x0</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>x0 &lt;&gt; x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tm_var (Fr x0) =
btg ktrm (subst_loc ktrm x u) ktrm (Fr x0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk211" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk211"><span class="nb">rewrite</span> btg_eq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hvar</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; x0</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>x0 &lt;&gt; x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tm_var (Fr x0) = subst_loc ktrm x u (Fr x0)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk212" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk212"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hvar</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; x0</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>x0 &lt;&gt; x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tm_var (Fr x0) =
(<span class="kr">if</span> x == x0 <span class="kr">then</span> u <span class="kr">else</span> tm_var (Fr x0))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">destruct_eq_args x x0.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk213" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk213">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hvar</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; x0</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>x0 &lt;&gt; x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ1 ++ Γ2 ⊢ tm_var (Fr x0) : τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk214" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk214"><span class="nb">apply</span> j_var.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hvar</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; x0</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>x0 &lt;&gt; x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_kind_ctx Δ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk215" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hvar</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; x0</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>x0 &lt;&gt; x</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk215"><hr></label><div class="goal-conclusion">ok_type_ctx Δ (Γ1 ++ Γ2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk216" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hvar</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; x0</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>x0 &lt;&gt; x</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk216"><hr></label><div class="goal-conclusion">(x0, τ) ∈ (Γ1 ++ Γ2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk217" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk217">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hvar</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; x0</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>x0 &lt;&gt; x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_kind_ctx Δ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk218" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk218">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hvar</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; x0</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>x0 &lt;&gt; x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type_ctx Δ (Γ1 ++ Γ2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk219" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hvar</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; x0</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>x0 &lt;&gt; x</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk219"><hr></label><div class="goal-conclusion">(x0, τ) ∈ (Γ1 ++ Γ2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk21a" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk21a">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hvar</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; x0</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>x0 &lt;&gt; x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type_ctx Δ (Γ1 ++ Γ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eauto with</span> sysf_ctx.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk21b" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk21b">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hvar</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; x0</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>x0 &lt;&gt; x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x0, τ) ∈ (Γ1 ++ Γ2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk21c" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk21c">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx Δ</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>Hvar</var><span class="hyp-type"><b>: </b><span>(x0, τ) ∈ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>Hok</var><span class="hyp-type"><b>: </b><span>ok_type_ctx Δ (Γ1 ++ x ~ τ2 ++ Γ2)</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; x0</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>x0 &lt;&gt; x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x0, τ) ∈ (Γ1 ++ Γ2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eauto using</span> binds_remove_mid.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk21d" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk21d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
<span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
(Γ1 ++ x ~ τ2 ++ Γ2) ++ x0 ~ τ1 =
Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3
⊢ <span class="nb">subst</span> term ktrm x u
    (open term ktrm (tm_var (Fr x0)) t) : τ0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ; (Γ1 ++ x ~ τ2 ++ Γ2) ++ x0 ~ τ1
⊢ open term ktrm (tm_var (Fr x0)) t : τ0</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ1 ++ Γ2 ⊢ <span class="nb">subst</span> term ktrm x u (tm_abs τ1 t)
: ty_ar τ1 τ0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk21e" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk21e"><span class="nb">rename</span> H0 <span class="nb">into</span> IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
<span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
(Γ1 ++ x ~ τ2 ++ Γ2) ++ x0 ~ τ1 =
Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3
⊢ <span class="nb">subst</span> term ktrm x u
    (open term ktrm (tm_var (Fr x0)) t) : τ0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ; (Γ1 ++ x ~ τ2 ++ Γ2) ++ x0 ~ τ1
⊢ open term ktrm (tm_var (Fr x0)) t : τ0</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ1 ++ Γ2 ⊢ <span class="nb">subst</span> term ktrm x u (tm_abs τ1 t)
: ty_ar τ1 τ0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk21f" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk21f">simplify_subst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
<span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
(Γ1 ++ x ~ τ2 ++ Γ2) ++ x0 ~ τ1 =
Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3
⊢ <span class="nb">subst</span> term ktrm x u
    (open term ktrm (tm_var (Fr x0)) t) : τ0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ; (Γ1 ++ x ~ τ2 ++ Γ2) ++ x0 ~ τ1
⊢ open term ktrm (tm_var (Fr x0)) t : τ0</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ1 ++ Γ2
⊢ tm_abs (<span class="nb">subst</span> typ ktrm x u τ1)
    (<span class="nb">subst</span> term ktrm x u t) : 
ty_ar τ1 τ0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk220" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk220"><span class="nb">rewrite</span> subst_in_type_id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
<span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
(Γ1 ++ x ~ τ2 ++ Γ2) ++ x0 ~ τ1 =
Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3
⊢ <span class="nb">subst</span> term ktrm x u
    (open term ktrm (tm_var (Fr x0)) t) : τ0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ; (Γ1 ++ x ~ τ2 ++ Γ2) ++ x0 ~ τ1
⊢ open term ktrm (tm_var (Fr x0)) t : τ0</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ1 ++ Γ2 ⊢ tm_abs τ1 (<span class="nb">subst</span> term ktrm x u t)
: ty_ar τ1 τ0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk221" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk221"><span class="nb">apply</span> j_abs <span class="kr">with</span> (L := L ∪ {{ x }} ∪ domset Γ1 ∪ domset Γ2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
<span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
(Γ1 ++ x ~ τ2 ++ Γ2) ++ x0 ~ τ1 =
Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3
⊢ <span class="nb">subst</span> term ktrm x u
    (open term ktrm (tm_var (Fr x0)) t) : τ0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ; (Γ1 ++ x ~ τ2 ++ Γ2) ++ x0 ~ τ1
⊢ open term ktrm (tm_var (Fr x0)) t : τ0</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` (L ∪ {{x}} ∪ domset Γ1 ∪ domset Γ2) -&gt;
Δ; (Γ1 ++ Γ2) ++ x0 ~ τ1
⊢ open term ktrm (tm_var (Fr x0))
    (<span class="nb">subst</span> term ktrm x u t) : τ0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk222" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk222">intros_cof IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
(Γ1 ++ x ~ τ2 ++ Γ2) ++ e ~ τ1 =
Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3
⊢ <span class="nb">subst</span> term ktrm x u
    (open term ktrm (tm_var (Fr e)) t) : τ0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ; (Γ1 ++ x ~ τ2 ++ Γ2) ++ x0 ~ τ1
⊢ open term ktrm (tm_var (Fr x0)) t : τ0</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}} ∪ domset Γ1 ∪ domset Γ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; (Γ1 ++ Γ2) ++ e ~ τ1
⊢ open term ktrm (tm_var (Fr e))
    (<span class="nb">subst</span> term ktrm x u t) : τ0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk223" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk223"><span class="nb">rewrite</span> (subst_open_eq term) <span class="kr">in</span> IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
(Γ1 ++ x ~ τ2 ++ Γ2) ++ e ~ τ1 =
Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3
⊢ open term ktrm
    (<span class="nb">subst</span> (SystemF ktrm) ktrm x u
       (tm_var (Fr e))) (<span class="nb">subst</span> term ktrm x u t)
: τ0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ; (Γ1 ++ x ~ τ2 ++ Γ2) ++ x0 ~ τ1
⊢ open term ktrm (tm_var (Fr x0)) t : τ0</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}} ∪ domset Γ1 ∪ domset Γ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; (Γ1 ++ Γ2) ++ e ~ τ1
⊢ open term ktrm (tm_var (Fr e))
    (<span class="nb">subst</span> term ktrm x u t) : τ0</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk224" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
(Γ1 ++ x ~ τ2 ++ Γ2) ++ e ~ τ1 =
Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3
⊢ <span class="nb">subst</span> term ktrm x u
    (open term ktrm (tm_var (Fr e)) t) : τ0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ; (Γ1 ++ x ~ τ2 ++ Γ2) ++ x0 ~ τ1
⊢ open term ktrm (tm_var (Fr x0)) t : τ0</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}} ∪ domset Γ1 ∪ domset Γ2)</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk224"><hr></label><div class="goal-conclusion">LC (SystemF ktrm) ktrm u</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk225" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk225"><span class="mi">2</span>:{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
(Γ1 ++ x ~ τ2 ++ Γ2) ++ e ~ τ1 =
Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3
⊢ <span class="nb">subst</span> term ktrm x u
    (open term ktrm (tm_var (Fr e)) t) : τ0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ; (Γ1 ++ x ~ τ2 ++ Γ2) ++ x0 ~ τ1
⊢ open term ktrm (tm_var (Fr x0)) t : τ0</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}} ∪ domset Γ1 ∪ domset Γ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC (SystemF ktrm) ktrm u</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> j_lc_KTerm_term; <span class="nb">eauto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk226" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk226">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
(Γ1 ++ x ~ τ2 ++ Γ2) ++ e ~ τ1 =
Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3
⊢ open term ktrm
    (<span class="nb">subst</span> (SystemF ktrm) ktrm x u
       (tm_var (Fr e))) (<span class="nb">subst</span> term ktrm x u t)
: τ0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ; (Γ1 ++ x ~ τ2 ++ Γ2) ++ x0 ~ τ1
⊢ open term ktrm (tm_var (Fr x0)) t : τ0</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}} ∪ domset Γ1 ∪ domset Γ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; (Γ1 ++ Γ2) ++ e ~ τ1
⊢ open term ktrm (tm_var (Fr e))
    (<span class="nb">subst</span> term ktrm x u t) : τ0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk227" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk227"><span class="nb">rewrite</span> (subst_fresh term) <span class="kr">in</span> IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
(Γ1 ++ x ~ τ2 ++ Γ2) ++ e ~ τ1 =
Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3
⊢ open term ktrm (tm_var (Fr e))
    (<span class="nb">subst</span> term ktrm x u t) : τ0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ; (Γ1 ++ x ~ τ2 ++ Γ2) ++ x0 ~ τ1
⊢ open term ktrm (tm_var (Fr x0)) t : τ0</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}} ∪ domset Γ1 ∪ domset Γ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; (Γ1 ++ Γ2) ++ e ~ τ1
⊢ open term ktrm (tm_var (Fr e))
    (<span class="nb">subst</span> term ktrm x u t) : τ0</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk228" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
(Γ1 ++ x ~ τ2 ++ Γ2) ++ e ~ τ1 =
Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3
⊢ open term ktrm
    (<span class="nb">subst</span> (SystemF ktrm) ktrm x u
       (tm_var (Fr e))) (<span class="nb">subst</span> term ktrm x u t)
: τ0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ; (Γ1 ++ x ~ τ2 ++ Γ2) ++ x0 ~ τ1
⊢ open term ktrm (tm_var (Fr x0)) t : τ0</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}} ∪ domset Γ1 ∪ domset Γ2)</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk228"><hr></label><div class="goal-conclusion">~ x ∈ free term ktrm (tm_var (Fr e))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk229" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk229"><span class="mi">2</span>:{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
(Γ1 ++ x ~ τ2 ++ Γ2) ++ e ~ τ1 =
Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3
⊢ open term ktrm
    (<span class="nb">subst</span> (SystemF ktrm) ktrm x u
       (tm_var (Fr e))) (<span class="nb">subst</span> term ktrm x u t)
: τ0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ; (Γ1 ++ x ~ τ2 ++ Γ2) ++ x0 ~ τ1
⊢ open term ktrm (tm_var (Fr x0)) t : τ0</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}} ∪ domset Γ1 ∪ domset Γ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ x ∈ free term ktrm (tm_var (Fr e))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk22a" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk22a"><span class="nb">change</span> (free (ix := I2) term ktrm (tm_var (Fr e))) <span class="kr">with</span> [ e ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
(Γ1 ++ x ~ τ2 ++ Γ2) ++ e ~ τ1 =
Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3
⊢ open term ktrm
    (<span class="nb">subst</span> (SystemF ktrm) ktrm x u
       (tm_var (Fr e))) (<span class="nb">subst</span> term ktrm x u t)
: τ0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ; (Γ1 ++ x ~ τ2 ++ Γ2) ++ x0 ~ τ1
⊢ open term ktrm (tm_var (Fr x0)) t : τ0</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}} ∪ domset Γ1 ∪ domset Γ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ x ∈ [e]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk22b" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk22b"><span class="nb">autorewrite with</span> tea_list.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
(Γ1 ++ x ~ τ2 ++ Γ2) ++ e ~ τ1 =
Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3
⊢ open term ktrm
    (<span class="nb">subst</span> (SystemF ktrm) ktrm x u
       (tm_var (Fr e))) (<span class="nb">subst</span> term ktrm x u t)
: τ0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ; (Γ1 ++ x ~ τ2 ++ Γ2) ++ x0 ~ τ1
⊢ open term ktrm (tm_var (Fr x0)) t : τ0</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}} ∪ domset Γ1 ∪ domset Γ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x &lt;&gt; e</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">fsetdec.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk22c" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk22c">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
(Γ1 ++ x ~ τ2 ++ Γ2) ++ e ~ τ1 =
Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3
⊢ open term ktrm (tm_var (Fr e))
    (<span class="nb">subst</span> term ktrm x u t) : τ0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ; (Γ1 ++ x ~ τ2 ++ Γ2) ++ x0 ~ τ1
⊢ open term ktrm (tm_var (Fr x0)) t : τ0</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}} ∪ domset Γ1 ∪ domset Γ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; (Γ1 ++ Γ2) ++ e ~ τ1
⊢ open term ktrm (tm_var (Fr e))
    (<span class="nb">subst</span> term ktrm x u t) : τ0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk22d" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk22d">simpl_alist <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 ++ e ~ τ1 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3
⊢ open term ktrm (tm_var (Fr e))
    (<span class="nb">subst</span> term ktrm x u t) : τ0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ; (Γ1 ++ x ~ τ2 ++ Γ2) ++ x0 ~ τ1
⊢ open term ktrm (tm_var (Fr x0)) t : τ0</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}} ∪ domset Γ1 ∪ domset Γ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ1 ++ Γ2 ++ e ~ τ1
⊢ open term ktrm (tm_var (Fr e))
    (<span class="nb">subst</span> term ktrm x u t) : τ0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk22e" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk22e"><span class="nb">apply</span> IH; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 ++ e ~ τ1 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3
⊢ open term ktrm (tm_var (Fr e))
    (<span class="nb">subst</span> term ktrm x u t) : τ0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ; (Γ1 ++ x ~ τ2 ++ Γ2) ++ x0 ~ τ1
⊢ open term ktrm (tm_var (Fr x0)) t : τ0</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}} ∪ domset Γ1 ∪ domset Γ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ1 ++ Γ2 ++ e ~ τ1 ⊢ u : τ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk22f" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk22f">change_alist ((Γ1 ++ Γ2) ++ e ~ τ1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 ++ e ~ τ1 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3
⊢ open term ktrm (tm_var (Fr e))
    (<span class="nb">subst</span> term ktrm x u t) : τ0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ; (Γ1 ++ x ~ τ2 ++ Γ2) ++ x0 ~ τ1
⊢ open term ktrm (tm_var (Fr x0)) t : τ0</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}} ∪ domset Γ1 ∪ domset Γ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; (Γ1 ++ Γ2) ++ e ~ τ1 ⊢ u : τ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk230" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk230"><span class="nb">apply</span> j_type_ctx_weak.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 ++ e ~ τ1 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3
⊢ open term ktrm (tm_var (Fr e))
    (<span class="nb">subst</span> term ktrm x u t) : τ0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ; (Γ1 ++ x ~ τ2 ++ Γ2) ++ x0 ~ τ1
⊢ open term ktrm (tm_var (Fr x0)) t : τ0</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}} ∪ domset Γ1 ∪ domset Γ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type_ctx Δ (e ~ τ1)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk231" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 ++ e ~ τ1 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3
⊢ open term ktrm (tm_var (Fr e))
    (<span class="nb">subst</span> term ktrm x u t) : τ0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ; (Γ1 ++ x ~ τ2 ++ Γ2) ++ x0 ~ τ1
⊢ open term ktrm (tm_var (Fr x0)) t : τ0</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}} ∪ domset Γ1 ∪ domset Γ2)</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk231"><hr></label><div class="goal-conclusion">disjoint (Γ1 ++ Γ2) (e ~ τ1)</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk232" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 ++ e ~ τ1 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3
⊢ open term ktrm (tm_var (Fr e))
    (<span class="nb">subst</span> term ktrm x u t) : τ0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ; (Γ1 ++ x ~ τ2 ++ Γ2) ++ x0 ~ τ1
⊢ open term ktrm (tm_var (Fr x0)) t : τ0</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}} ∪ domset Γ1 ∪ domset Γ2)</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk232"><hr></label><div class="goal-conclusion">Δ; Γ1 ++ Γ2 ⊢ u : τ2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk233" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk233">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 ++ e ~ τ1 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3
⊢ open term ktrm (tm_var (Fr e))
    (<span class="nb">subst</span> term ktrm x u t) : τ0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ; (Γ1 ++ x ~ τ2 ++ Γ2) ++ x0 ~ τ1
⊢ open term ktrm (tm_var (Fr x0)) t : τ0</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}} ∪ domset Γ1 ∪ domset Γ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type_ctx Δ (e ~ τ1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk234" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk234"><span class="nb">apply</span> ok_type_ctx_one.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 ++ e ~ τ1 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3
⊢ open term ktrm (tm_var (Fr e))
    (<span class="nb">subst</span> term ktrm x u t) : τ0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ; (Γ1 ++ x ~ τ2 ++ Γ2) ++ x0 ~ τ1
⊢ open term ktrm (tm_var (Fr x0)) t : τ0</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}} ∪ domset Γ1 ∪ domset Γ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type Δ τ1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk235" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk235">specialize_cof H e.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 ++ e ~ τ1 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3
⊢ open term ktrm (tm_var (Fr e))
    (<span class="nb">subst</span> term ktrm x u t) : τ0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Δ; (Γ1 ++ x ~ τ2 ++ Γ2) ++ e ~ τ1
⊢ open term ktrm (tm_var (Fr e)) t : τ0</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}} ∪ domset Γ1 ∪ domset Γ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type Δ τ1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> j_type_ctx2; <span class="bp">eassumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk236" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk236">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 ++ e ~ τ1 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3
⊢ open term ktrm (tm_var (Fr e))
    (<span class="nb">subst</span> term ktrm x u t) : τ0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ; (Γ1 ++ x ~ τ2 ++ Γ2) ++ x0 ~ τ1
⊢ open term ktrm (tm_var (Fr x0)) t : τ0</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}} ∪ domset Γ1 ∪ domset Γ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">disjoint (Γ1 ++ Γ2) (e ~ τ1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk237" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk237"><span class="nb">autorewrite with</span> tea_rw_disj <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 ++ e ~ τ1 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3
⊢ open term ktrm (tm_var (Fr e))
    (<span class="nb">subst</span> term ktrm x u t) : τ0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ; (Γ1 ++ x ~ τ2 ++ Γ2) ++ x0 ~ τ1
⊢ open term ktrm (tm_var (Fr x0)) t : τ0</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}} ∪ domset Γ1 ∪ domset Γ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">e `notin` domset Γ1 /\ e `notin` domset Γ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intuition</span> fsetdec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk238" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk238">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 ++ e ~ τ1 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3
⊢ open term ktrm (tm_var (Fr e))
    (<span class="nb">subst</span> term ktrm x u t) : τ0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ; (Γ1 ++ x ~ τ2 ++ Γ2) ++ x0 ~ τ1
⊢ open term ktrm (tm_var (Fr x0)) t : τ0</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ {{x}} ∪ domset Γ1 ∪ domset Γ2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ1 ++ Γ2 ⊢ u : τ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk239" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk239">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>IHjt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3 ⊢ <span class="nb">subst</span> term ktrm x u t2 : τ1</span></span></span><br><span><var>IHjt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3 ⊢ <span class="nb">subst</span> term ktrm x u t1
: ty_ar τ1 τ0</span></span></span><br><span><var>jt2</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ x ~ τ2 ++ Γ2 ⊢ t2 : τ1</span></span></span><br><span><var>jt1</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ x ~ τ2 ++ Γ2 ⊢ t1 : ty_ar τ1 τ0</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ1 ++ Γ2 ⊢ <span class="nb">subst</span> term ktrm x u (tm_app t1 t2) : τ0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk23a" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk23a">simplify_subst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>IHjt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3 ⊢ <span class="nb">subst</span> term ktrm x u t2 : τ1</span></span></span><br><span><var>IHjt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3 ⊢ <span class="nb">subst</span> term ktrm x u t1
: ty_ar τ1 τ0</span></span></span><br><span><var>jt2</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ x ~ τ2 ++ Γ2 ⊢ t2 : τ1</span></span></span><br><span><var>jt1</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ x ~ τ2 ++ Γ2 ⊢ t1 : ty_ar τ1 τ0</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ1 ++ Γ2
⊢ tm_app (<span class="nb">subst</span> term ktrm x u t1)
    (<span class="nb">subst</span> term ktrm x u t2) : τ0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eauto using</span> j_app.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk23b" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk23b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
<span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ ++ x0 ~ tt; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ ++ x0 ~ tt; Γ1 ++ Γ3
⊢ <span class="nb">subst</span> term ktrm x u
    (open term ktyp (ty_v (Fr x0)) t)
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ ++ x0 ~ tt; Γ1 ++ x ~ τ2 ++ Γ2
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ1 ++ Γ2 ⊢ <span class="nb">subst</span> term ktrm x u (tm_tab t)
: ty_univ τ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk23c" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk23c"><span class="nb">rename</span> H0 <span class="nb">into</span> IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
<span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ ++ x0 ~ tt; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ ++ x0 ~ tt; Γ1 ++ Γ3
⊢ <span class="nb">subst</span> term ktrm x u
    (open term ktyp (ty_v (Fr x0)) t)
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ ++ x0 ~ tt; Γ1 ++ x ~ τ2 ++ Γ2
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ1 ++ Γ2 ⊢ <span class="nb">subst</span> term ktrm x u (tm_tab t)
: ty_univ τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk23d" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk23d">simplify_subst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
<span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ ++ x0 ~ tt; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ ++ x0 ~ tt; Γ1 ++ Γ3
⊢ <span class="nb">subst</span> term ktrm x u
    (open term ktyp (ty_v (Fr x0)) t)
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ ++ x0 ~ tt; Γ1 ++ x ~ τ2 ++ Γ2
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ1 ++ Γ2 ⊢ tm_tab (<span class="nb">subst</span> term ktrm x u t)
: ty_univ τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk23e" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk23e"><span class="nb">apply</span> j_univ <span class="kr">with</span> (L := L ∪ domset Δ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
<span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ ++ x0 ~ tt; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ ++ x0 ~ tt; Γ1 ++ Γ3
⊢ <span class="nb">subst</span> term ktrm x u
    (open term ktyp (ty_v (Fr x0)) t)
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ ++ x0 ~ tt; Γ1 ++ x ~ τ2 ++ Γ2
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` (L ∪ domset Δ) -&gt;
Δ ++ x0 ~ tt; Γ1 ++ Γ2
⊢ open term ktyp (ty_v (Fr x0))
    (<span class="nb">subst</span> term ktrm x u t)
: open typ ktyp (ty_v (Fr x0)) τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk23f" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk23f">intros_cof IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ ++ e ~ tt; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ ++ e ~ tt; Γ1 ++ Γ3
⊢ <span class="nb">subst</span> term ktrm x u
    (open term ktyp (ty_v (Fr e)) t)
: open typ ktyp (ty_v (Fr e)) τ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ ++ x0 ~ tt; Γ1 ++ x ~ τ2 ++ Γ2
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ domset Δ)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ ++ e ~ tt; Γ1 ++ Γ2
⊢ open term ktyp (ty_v (Fr e)) (<span class="nb">subst</span> term ktrm x u t)
: open typ ktyp (ty_v (Fr e)) τ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk240" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk240"><span class="nb">rewrite</span> (subst_open_neq term) <span class="kr">in</span> IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ ++ e ~ tt; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ ++ e ~ tt; Γ1 ++ Γ3
⊢ open term ktyp
    (<span class="nb">subst</span> (SystemF ktyp) ktrm x u (ty_v (Fr e)))
    (<span class="nb">subst</span> term ktrm x u t)
: open typ ktyp (ty_v (Fr e)) τ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ ++ x0 ~ tt; Γ1 ++ x ~ τ2 ++ Γ2
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ domset Δ)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ ++ e ~ tt; Γ1 ++ Γ2
⊢ open term ktyp (ty_v (Fr e)) (<span class="nb">subst</span> term ktrm x u t)
: open typ ktyp (ty_v (Fr e)) τ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk241" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ ++ e ~ tt; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ ++ e ~ tt; Γ1 ++ Γ3
⊢ <span class="nb">subst</span> term ktrm x u
    (open term ktyp (ty_v (Fr e)) t)
: open typ ktyp (ty_v (Fr e)) τ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ ++ x0 ~ tt; Γ1 ++ x ~ τ2 ++ Γ2
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ domset Δ)</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk241"><hr></label><div class="goal-conclusion">ktyp &lt;&gt; ktrm</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk242" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ ++ e ~ tt; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ ++ e ~ tt; Γ1 ++ Γ3
⊢ <span class="nb">subst</span> term ktrm x u
    (open term ktyp (ty_v (Fr e)) t)
: open typ ktyp (ty_v (Fr e)) τ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ ++ x0 ~ tt; Γ1 ++ x ~ τ2 ++ Γ2
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ domset Δ)</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk242"><hr></label><div class="goal-conclusion">LC (SystemF ktrm) ktyp u</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk243" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk243"><span class="mi">2</span>:{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ ++ e ~ tt; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ ++ e ~ tt; Γ1 ++ Γ3
⊢ <span class="nb">subst</span> term ktrm x u
    (open term ktyp (ty_v (Fr e)) t)
: open typ ktyp (ty_v (Fr e)) τ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ ++ x0 ~ tt; Γ1 ++ x ~ τ2 ++ Γ2
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ domset Δ)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ktyp &lt;&gt; ktrm</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">discriminate</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk244" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk244">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ ++ e ~ tt; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ ++ e ~ tt; Γ1 ++ Γ3
⊢ open term ktyp
    (<span class="nb">subst</span> (SystemF ktyp) ktrm x u (ty_v (Fr e)))
    (<span class="nb">subst</span> term ktrm x u t)
: open typ ktyp (ty_v (Fr e)) τ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ ++ x0 ~ tt; Γ1 ++ x ~ τ2 ++ Γ2
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ domset Δ)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ ++ e ~ tt; Γ1 ++ Γ2
⊢ open term ktyp (ty_v (Fr e)) (<span class="nb">subst</span> term ktrm x u t)
: open typ ktyp (ty_v (Fr e)) τ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk245" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ ++ e ~ tt; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ ++ e ~ tt; Γ1 ++ Γ3
⊢ <span class="nb">subst</span> term ktrm x u
    (open term ktyp (ty_v (Fr e)) t)
: open typ ktyp (ty_v (Fr e)) τ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ ++ x0 ~ tt; Γ1 ++ x ~ τ2 ++ Γ2
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ domset Δ)</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk245"><hr></label><div class="goal-conclusion">LC (SystemF ktrm) ktyp u</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk246" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk246"><span class="mi">2</span>:{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ ++ e ~ tt; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ ++ e ~ tt; Γ1 ++ Γ3
⊢ <span class="nb">subst</span> term ktrm x u
    (open term ktyp (ty_v (Fr e)) t)
: open typ ktyp (ty_v (Fr e)) τ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ ++ x0 ~ tt; Γ1 ++ x ~ τ2 ++ Γ2
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ domset Δ)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC (SystemF ktrm) ktyp u</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> j_ok_term; <span class="bp">eassumption</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk247" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk247">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ ++ e ~ tt; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ ++ e ~ tt; Γ1 ++ Γ3
⊢ open term ktyp
    (<span class="nb">subst</span> (SystemF ktyp) ktrm x u (ty_v (Fr e)))
    (<span class="nb">subst</span> term ktrm x u t)
: open typ ktyp (ty_v (Fr e)) τ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ ++ x0 ~ tt; Γ1 ++ x ~ τ2 ++ Γ2
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ domset Δ)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ ++ e ~ tt; Γ1 ++ Γ2
⊢ open term ktyp (ty_v (Fr e)) (<span class="nb">subst</span> term ktrm x u t)
: open typ ktyp (ty_v (Fr e)) τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk248" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk248"><span class="nb">apply</span> IH; [<span class="bp">reflexivity</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ ++ e ~ tt; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ ++ e ~ tt; Γ1 ++ Γ3
⊢ open term ktyp
    (<span class="nb">subst</span> (SystemF ktyp) ktrm x u (ty_v (Fr e)))
    (<span class="nb">subst</span> term ktrm x u t)
: open typ ktyp (ty_v (Fr e)) τ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ ++ x0 ~ tt; Γ1 ++ x ~ τ2 ++ Γ2
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ domset Δ)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ ++ e ~ tt; Γ1 ++ Γ2 ⊢ u : τ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk249" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk249"><span class="nb">eapply</span> j_kind_ctx_weak.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ ++ e ~ tt; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ ++ e ~ tt; Γ1 ++ Γ3
⊢ open term ktyp
    (<span class="nb">subst</span> (SystemF ktyp) ktrm x u (ty_v (Fr e)))
    (<span class="nb">subst</span> term ktrm x u t)
: open typ ktyp (ty_v (Fr e)) τ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ ++ x0 ~ tt; Γ1 ++ x ~ τ2 ++ Γ2
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ domset Δ)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_kind_ctx (e ~ tt)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk24a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ ++ e ~ tt; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ ++ e ~ tt; Γ1 ++ Γ3
⊢ open term ktyp
    (<span class="nb">subst</span> (SystemF ktyp) ktrm x u (ty_v (Fr e)))
    (<span class="nb">subst</span> term ktrm x u t)
: open typ ktyp (ty_v (Fr e)) τ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ ++ x0 ~ tt; Γ1 ++ x ~ τ2 ++ Γ2
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ domset Δ)</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk24a"><hr></label><div class="goal-conclusion">disjoint Δ (e ~ tt)</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk24b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ ++ e ~ tt; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ ++ e ~ tt; Γ1 ++ Γ3
⊢ open term ktyp
    (<span class="nb">subst</span> (SystemF ktyp) ktrm x u (ty_v (Fr e)))
    (<span class="nb">subst</span> term ktrm x u t)
: open typ ktyp (ty_v (Fr e)) τ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ ++ x0 ~ tt; Γ1 ++ x ~ τ2 ++ Γ2
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ domset Δ)</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk24b"><hr></label><div class="goal-conclusion">Δ; Γ1 ++ Γ2 ⊢ u : τ2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk24c" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk24c">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ ++ e ~ tt; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ ++ e ~ tt; Γ1 ++ Γ3
⊢ open term ktyp
    (<span class="nb">subst</span> (SystemF ktyp) ktrm x u (ty_v (Fr e)))
    (<span class="nb">subst</span> term ktrm x u t)
: open typ ktyp (ty_v (Fr e)) τ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ ++ x0 ~ tt; Γ1 ++ x ~ τ2 ++ Γ2
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ domset Δ)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_kind_ctx (e ~ tt)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ok_kind_ctx_one.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk24d" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk24d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ ++ e ~ tt; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ ++ e ~ tt; Γ1 ++ Γ3
⊢ open term ktyp
    (<span class="nb">subst</span> (SystemF ktyp) ktrm x u (ty_v (Fr e)))
    (<span class="nb">subst</span> term ktrm x u t)
: open typ ktyp (ty_v (Fr e)) τ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ ++ x0 ~ tt; Γ1 ++ x ~ τ2 ++ Γ2
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ domset Δ)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">disjoint Δ (e ~ tt)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk24e" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk24e"><span class="nb">autorewrite with</span> tea_rw_disj.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ ++ e ~ tt; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ ++ e ~ tt; Γ1 ++ Γ3
⊢ open term ktyp
    (<span class="nb">subst</span> (SystemF ktyp) ktrm x u (ty_v (Fr e)))
    (<span class="nb">subst</span> term ktrm x u t)
: open typ ktyp (ty_v (Fr e)) τ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ ++ x0 ~ tt; Γ1 ++ x ~ τ2 ++ Γ2
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ domset Δ)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">e `notin` domset Δ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">fsetdec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk24f" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk24f">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>AtomSet.elt</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ ++ e ~ tt; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ ++ e ~ tt; Γ1 ++ Γ3
⊢ open term ktyp
    (<span class="nb">subst</span> (SystemF ktyp) ktrm x u (ty_v (Fr e)))
    (<span class="nb">subst</span> term ktrm x u t)
: open typ ktyp (ty_v (Fr e)) τ</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : AtomSet.elt,
x0 `notin` L -&gt;
Δ ++ x0 ~ tt; Γ1 ++ x ~ τ2 ++ Γ2
⊢ open term ktyp (ty_v (Fr x0)) t
: open typ ktyp (ty_v (Fr x0)) τ</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br><span><var>Notin</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ domset Δ)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ1 ++ Γ2 ⊢ u : τ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk250" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk250">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>IHjt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3 ⊢ <span class="nb">subst</span> term ktrm x u t
: ty_univ τ0</span></span></span><br><span><var>jt</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ x ~ τ2 ++ Γ2 ⊢ t : ty_univ τ0</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ1 ++ Γ2 ⊢ <span class="nb">subst</span> term ktrm x u (tm_tap t τ1)
: open typ ktyp τ1 τ0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk251" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk251">simplify_subst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>IHjt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3 ⊢ <span class="nb">subst</span> term ktrm x u t
: ty_univ τ0</span></span></span><br><span><var>jt</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ x ~ τ2 ++ Γ2 ⊢ t : ty_univ τ0</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ1 ++ Γ2
⊢ tm_tap (<span class="nb">subst</span> term ktrm x u t)
    (<span class="nb">subst</span> typ ktrm x u τ1) : 
open typ ktyp τ1 τ0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk252" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk252"><span class="nb">rewrite</span> subst_in_type_id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>IHjt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3 ⊢ <span class="nb">subst</span> term ktrm x u t
: ty_univ τ0</span></span></span><br><span><var>jt</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ x ~ τ2 ++ Γ2 ⊢ t : ty_univ τ0</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ1 ++ Γ2 ⊢ tm_tap (<span class="nb">subst</span> term ktrm x u t) τ1
: open typ ktyp τ1 τ0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk253" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk253"><span class="nb">apply</span> j_inst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>IHjt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3 ⊢ <span class="nb">subst</span> term ktrm x u t
: ty_univ τ0</span></span></span><br><span><var>jt</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ x ~ τ2 ++ Γ2 ⊢ t : ty_univ τ0</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type Δ τ1</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk254" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>IHjt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3 ⊢ <span class="nb">subst</span> term ktrm x u t
: ty_univ τ0</span></span></span><br><span><var>jt</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ x ~ τ2 ++ Γ2 ⊢ t : ty_univ τ0</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk254"><hr></label><div class="goal-conclusion">Δ; Γ1 ++ Γ2 ⊢ <span class="nb">subst</span> term ktrm x u t : ty_univ τ0</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk255" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk255">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>IHjt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3 ⊢ <span class="nb">subst</span> term ktrm x u t
: ty_univ τ0</span></span></span><br><span><var>jt</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ x ~ τ2 ++ Γ2 ⊢ t : ty_univ τ0</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type Δ τ1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk256" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk256">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ1</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ0</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type Δ τ1</span></span></span><br><span><var>Γ2</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>IHjt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Γ3</span> : list (atom * typ LN),
Γ1 ++ x ~ τ2 ++ Γ2 = Γ1 ++ x ~ τ2 ++ Γ3 -&gt;
Δ; Γ1 ++ Γ3 ⊢ u : τ2 -&gt;
Δ; Γ1 ++ Γ3 ⊢ <span class="nb">subst</span> term ktrm x u t
: ty_univ τ0</span></span></span><br><span><var>jt</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ x ~ τ2 ++ Γ2 ⊢ t : ty_univ τ0</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ1 ++ Γ2 ⊢ u : τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ1 ++ Γ2 ⊢ <span class="nb">subst</span> term ktrm x u t : ty_univ τ0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk257" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk257"><span class="kn">Corollary</span> <span class="nf">j_type_ctx_subst1</span> : <span class="kr">forall</span> <span class="nv">Δ</span> <span class="nv">Γ</span> <span class="nv">x</span> <span class="nv">τ2</span> <span class="nv">t</span> <span class="nv">u</span> <span class="nv">τ1</span>,
    (Δ ; Γ ++ x ~ τ2 ⊢ t : τ1) -&gt;
    (Δ ; Γ ⊢ u : τ2) -&gt;
    (Δ ; Γ ⊢ <span class="nb">subst</span> term ktrm x u t : τ1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ</span> : kind_ctx) (<span class="nv">Γ</span> : list (atom * typ LN)) <span class="nv">x</span>
  (<span class="nv">τ2</span> : typ LN) (<span class="nv">t</span> <span class="nv">u</span> : term LN) (<span class="nv">τ1</span> : typ LN),
Δ; Γ ++ x ~ τ2 ⊢ t : τ1 -&gt;
Δ; Γ ⊢ u : τ2 -&gt; Δ; Γ ⊢ <span class="nb">subst</span> term ktrm x u t : τ1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk258" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk258"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Δ</span> : kind_ctx) (<span class="nv">Γ</span> : list (atom * typ LN)) <span class="nv">x</span>
  (<span class="nv">τ2</span> : typ LN) (<span class="nv">t</span> <span class="nv">u</span> : term LN) (<span class="nv">τ1</span> : typ LN),
Δ; Γ ++ x ~ τ2 ⊢ t : τ1 -&gt;
Δ; Γ ⊢ u : τ2 -&gt; Δ; Γ ⊢ <span class="nb">subst</span> term ktrm x u t : τ1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk259" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk259">introv jt ju.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t, u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>jt</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ x ~ τ2 ⊢ t : τ1</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ u : τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ ⊢ <span class="nb">subst</span> term ktrm x u t : τ1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk25a" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk25a">change_alist (Γ ++ x ~ τ2 ++ []) <span class="kr">in</span> jt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t, u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>jt</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ x ~ τ2 ++ [] ⊢ t : τ1</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ ⊢ u : τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ ⊢ <span class="nb">subst</span> term ktrm x u t : τ1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk25b" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk25b">change_alist (Γ ++ []) <span class="kr">in</span> ju.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t, u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>jt</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ x ~ τ2 ++ [] ⊢ t : τ1</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ [] ⊢ u : τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ ⊢ <span class="nb">subst</span> term ktrm x u t : τ1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk25c" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk25c">change_alist (Γ ++ []).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Δ</var><span class="hyp-type"><b>: </b><span>kind_ctx</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t, u</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>jt</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ x ~ τ2 ++ [] ⊢ t : τ1</span></span></span><br><span><var>ju</var><span class="hyp-type"><b>: </b><span>Δ; Γ ++ [] ⊢ u : τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Δ; Γ ++ [] ⊢ <span class="nb">subst</span> term ktrm x u t : τ1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eauto using</span> j_type_ctx_subst.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Progress and preservation *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk25d" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk25d"><span class="kn">Theorem</span> <span class="nf">preservation_theorem</span> : preservation.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">preservation</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk25e" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk25e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">preservation</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk25f" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk25f">introv j.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t, t'</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t : τ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nb">red</span> t t&#39; -&gt; []; [] ⊢ t&#39; : τ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk260" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk260"><span class="nb">generalize dependent</span> t&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t : τ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> t t&#39; -&gt; []; [] ⊢ t&#39; : τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk261" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk261"><span class="nb">remember</span> (@nil (atom * unit)) <span class="kr">as</span> Delta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Delta</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>HeqDelta</var><span class="hyp-type"><b>: </b><span>Delta = []</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Delta; [] ⊢ t : τ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> t t&#39; -&gt; Delta; [] ⊢ t&#39; : τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk262" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk262"><span class="nb">remember</span> (@nil (atom * typ LN)) <span class="kr">as</span> Gamma.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Delta</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>HeqDelta</var><span class="hyp-type"><b>: </b><span>Delta = []</span></span></span><br><span><var>Gamma</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>HeqGamma</var><span class="hyp-type"><b>: </b><span>Gamma = []</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Delta; Gamma ⊢ t : τ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> t t&#39; -&gt; Delta; Gamma ⊢ t&#39; : τ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk263" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk263"><span class="nb">induction</span> j; <span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx [] []</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx []</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x, τ) ∈ []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> (tm_var (Fr x)) t&#39; -&gt; []; [] ⊢ t&#39; : τ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk264" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
[]; [] ++ x ~ τ1
⊢ open term ktrm (tm_var (Fr x)) t : τ2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
[] = [] -&gt;
[] ++ x ~ τ1 = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> (open term ktrm (tm_var (Fr x)) t) t&#39; -&gt;
[]; [] ++ x ~ τ1 ⊢ t&#39; : τ2</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk264"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> (tm_abs τ1 t) t&#39; -&gt; []; [] ⊢ t&#39; : ty_ar τ1 τ2</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk265" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t2 : τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> t1 t&#39; -&gt; []; [] ⊢ t&#39; : ty_ar τ1 τ2</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> t2 t&#39; -&gt; []; [] ⊢ t&#39; : τ1</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk265"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> (tm_app t1 t2) t&#39; -&gt; []; [] ⊢ t&#39; : τ2</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk266" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
[] ++ x ~ tt; [] ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
[] ++ x ~ tt = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> (open term ktyp (ty_v (Fr x)) t) t&#39; -&gt;
[] ++ x ~ tt; [] ⊢ t&#39;
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk266"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> (tm_tab t) t&#39; -&gt; []; [] ⊢ t&#39; : ty_univ τ</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk267" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> t t&#39; -&gt; []; [] ⊢ t&#39; : ty_univ τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type [] τ1</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk267"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> (tm_tap t τ1) t&#39; -&gt;
[]; [] ⊢ t&#39; : open typ ktyp τ1 τ2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk268" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk268">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx [] []</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx []</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x, τ) ∈ []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> (tm_var (Fr x)) t&#39; -&gt; []; [] ⊢ t&#39; : τ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">inversion</span> <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk269" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk269">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
[]; [] ++ x ~ τ1
⊢ open term ktrm (tm_var (Fr x)) t : τ2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
[] = [] -&gt;
[] ++ x ~ τ1 = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> (open term ktrm (tm_var (Fr x)) t) t&#39; -&gt;
[]; [] ++ x ~ τ1 ⊢ t&#39; : τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> (tm_abs τ1 t) t&#39; -&gt; []; [] ⊢ t&#39; : ty_ar τ1 τ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">inversion</span> <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk26a" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk26a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t2 : τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> t1 t&#39; -&gt; []; [] ⊢ t&#39; : ty_ar τ1 τ2</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> t2 t&#39; -&gt; []; [] ⊢ t&#39; : τ1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> (tm_app t1 t2) t&#39; -&gt; []; [] ⊢ t&#39; : τ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk26b" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk26b"><span class="nb">inversion</span> <span class="mi">1</span>; <span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t2 : τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> t1 t&#39; -&gt; []; [] ⊢ t&#39; : ty_ar τ1 τ2</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> t2 t&#39; -&gt; []; [] ⊢ t&#39; : τ1</span></span></span><br><span><var>t1'</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="nb">red</span> (tm_app t1 t2) (tm_app t1&#39; t2)</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="nb">red</span> t1 t1&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[]; [] ⊢ tm_app t1&#39; t2 : τ2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk26c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t2 : τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> t1 t&#39; -&gt; []; [] ⊢ t&#39; : ty_ar τ1 τ2</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> t2 t&#39; -&gt; []; [] ⊢ t&#39; : τ1</span></span></span><br><span><var>t2'</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="nb">red</span> (tm_app t1 t2) (tm_app t1 t2&#39;)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>value t1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span><span class="nb">red</span> t2 t2&#39;</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk26c"><hr></label><div class="goal-conclusion">[]; [] ⊢ tm_app t1 t2&#39; : τ2</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk26d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2, T</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ tm_abs T t0 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t2 : τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> (tm_abs T t0) t&#39; -&gt;
[]; [] ⊢ t&#39; : ty_ar τ1 τ2</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> t2 t&#39; -&gt; []; [] ⊢ t&#39; : τ1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="nb">red</span> (tm_app (tm_abs T t0) t2)
  (open term ktrm t2 t0)</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>value t2</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk26d"><hr></label><div class="goal-conclusion">[]; [] ⊢ open term ktrm t2 t0 : τ2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk26e" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk26e">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t2 : τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> t1 t&#39; -&gt; []; [] ⊢ t&#39; : ty_ar τ1 τ2</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> t2 t&#39; -&gt; []; [] ⊢ t&#39; : τ1</span></span></span><br><span><var>t1'</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="nb">red</span> (tm_app t1 t2) (tm_app t1&#39; t2)</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="nb">red</span> t1 t1&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[]; [] ⊢ tm_app t1&#39; t2 : τ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eauto using</span> Judgment.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk26f" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk26f">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t2 : τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> t1 t&#39; -&gt; []; [] ⊢ t&#39; : ty_ar τ1 τ2</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> t2 t&#39; -&gt; []; [] ⊢ t&#39; : τ1</span></span></span><br><span><var>t2'</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="nb">red</span> (tm_app t1 t2) (tm_app t1 t2&#39;)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>value t1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span><span class="nb">red</span> t2 t2&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[]; [] ⊢ tm_app t1 t2&#39; : τ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eauto using</span> Judgment.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk270" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk270">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2, T</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ tm_abs T t0 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t2 : τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> (tm_abs T t0) t&#39; -&gt;
[]; [] ⊢ t&#39; : ty_ar τ1 τ2</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> t2 t&#39; -&gt; []; [] ⊢ t&#39; : τ1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="nb">red</span> (tm_app (tm_abs T t0) t2)
  (open term ktrm t2 t0)</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>value t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[]; [] ⊢ open term ktrm t2 t0 : τ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk271" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk271">inverts j1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t2 : τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> (tm_abs τ1 t0) t&#39; -&gt;
[]; [] ⊢ t&#39; : ty_ar τ1 τ2</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> t2 t&#39; -&gt; []; [] ⊢ t&#39; : τ1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="nb">red</span> (tm_app (tm_abs τ1 t0) t2)
  (open term ktrm t2 t0)</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>value t2</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
[]; [] ++ x ~ τ1
⊢ open term ktrm (tm_var (Fr x)) t0 : τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[]; [] ⊢ open term ktrm t2 t0 : τ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk272" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk272"><span class="nb">rename</span> H4 <span class="nb">into</span> hyp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t2 : τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> (tm_abs τ1 t0) t&#39; -&gt;
[]; [] ⊢ t&#39; : ty_ar τ1 τ2</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> t2 t&#39; -&gt; []; [] ⊢ t&#39; : τ1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="nb">red</span> (tm_app (tm_abs τ1 t0) t2)
  (open term ktrm t2 t0)</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>value t2</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
[]; [] ++ x ~ τ1
⊢ open term ktrm (tm_var (Fr x)) t0 : τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[]; [] ⊢ open term ktrm t2 t0 : τ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk273" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk273">pick <span class="kp">fresh</span> e <span class="kr">for</span> (L ∪ FV term ktrm t0).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t2 : τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> (tm_abs τ1 t0) t&#39; -&gt;
[]; [] ⊢ t&#39; : ty_ar τ1 τ2</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> t2 t&#39; -&gt; []; [] ⊢ t&#39; : τ1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="nb">red</span> (tm_app (tm_abs τ1 t0) t2)
  (open term ktrm t2 t0)</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>value t2</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
[]; [] ++ x ~ τ1
⊢ open term ktrm (tm_var (Fr x)) t0 : τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ FV term ktrm t0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[]; [] ⊢ open term ktrm t2 t0 : τ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk274" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk274"><span class="nb">rewrite</span> (open_spec_eq term) <span class="kr">with</span> (x := e); [| fsetdec].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t2 : τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> (tm_abs τ1 t0) t&#39; -&gt;
[]; [] ⊢ t&#39; : ty_ar τ1 τ2</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> t2 t&#39; -&gt; []; [] ⊢ t&#39; : τ1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="nb">red</span> (tm_app (tm_abs τ1 t0) t2)
  (open term ktrm t2 t0)</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>value t2</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
[]; [] ++ x ~ τ1
⊢ open term ktrm (tm_var (Fr x)) t0 : τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ FV term ktrm t0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[]; []
⊢ <span class="nb">subst</span> term ktrm e t2
    (open term ktrm (mret SystemF ktrm (Fr e)) t0)
: τ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk275" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk275"><span class="nb">eapply</span> j_type_ctx_subst1; <span class="nb">eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t2 : τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> (tm_abs τ1 t0) t&#39; -&gt;
[]; [] ⊢ t&#39; : ty_ar τ1 τ2</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> t2 t&#39; -&gt; []; [] ⊢ t&#39; : τ1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="nb">red</span> (tm_app (tm_abs τ1 t0) t2)
  (open term ktrm t2 t0)</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>value t2</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
[]; [] ++ x ~ τ1
⊢ open term ktrm (tm_var (Fr x)) t0 : τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ FV term ktrm t0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[]; [] ++ e ~ τ1
⊢ open term ktrm (mret SystemF ktrm (Fr e)) t0 : τ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk276" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk276"><span class="nb">apply</span> hyp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t2 : τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> (tm_abs τ1 t0) t&#39; -&gt;
[]; [] ⊢ t&#39; : ty_ar τ1 τ2</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> t2 t&#39; -&gt; []; [] ⊢ t&#39; : τ1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="nb">red</span> (tm_app (tm_abs τ1 t0) t2)
  (open term ktrm t2 t0)</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>value t2</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
[]; [] ++ x ~ τ1
⊢ open term ktrm (tm_var (Fr x)) t0 : τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e `notin` (L ∪ FV term ktrm t0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">e `notin` L</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">fsetdec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk277" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk277">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
[] ++ x ~ tt; [] ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
[] ++ x ~ tt = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> (open term ktyp (ty_v (Fr x)) t) t&#39; -&gt;
[] ++ x ~ tt; [] ⊢ t&#39;
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> (tm_tab t) t&#39; -&gt; []; [] ⊢ t&#39; : ty_univ τ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">inversion</span> <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk278" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk278">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> t t&#39; -&gt; []; [] ⊢ t&#39; : ty_univ τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type [] τ1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> (tm_tap t τ1) t&#39; -&gt;
[]; [] ⊢ t&#39; : open typ ktyp τ1 τ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk279" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk279"><span class="nb">inversion</span> <span class="mi">1</span>; <span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> t t&#39; -&gt; []; [] ⊢ t&#39; : ty_univ τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type [] τ1</span></span></span><br><span><var>t'0</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="nb">red</span> (tm_tap t τ1) (tm_tap t&#39;0 τ1)</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span><span class="nb">red</span> t t&#39;0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[]; [] ⊢ tm_tap t&#39;0 τ1 : open typ ktyp τ1 τ2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk27a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> (tm_tab t0) t&#39; -&gt; []; [] ⊢ t&#39; : ty_univ τ2</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ tm_tab t0 : ty_univ τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type [] τ1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="nb">red</span> (tm_tap (tm_tab t0) τ1)
  (open term ktyp τ1 t0)</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk27a"><hr></label><div class="goal-conclusion">[]; [] ⊢ open term ktyp τ1 t0 : open typ ktyp τ1 τ2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk27b" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk27b">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> t t&#39; -&gt; []; [] ⊢ t&#39; : ty_univ τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type [] τ1</span></span></span><br><span><var>t'0</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="nb">red</span> (tm_tap t τ1) (tm_tap t&#39;0 τ1)</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span><span class="nb">red</span> t t&#39;0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[]; [] ⊢ tm_tap t&#39;0 τ1 : open typ ktyp τ1 τ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eauto using</span> Judgment.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk27c" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk27c">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> (tm_tab t0) t&#39; -&gt; []; [] ⊢ t&#39; : ty_univ τ2</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ tm_tab t0 : ty_univ τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type [] τ1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="nb">red</span> (tm_tap (tm_tab t0) τ1)
  (open term ktyp τ1 t0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[]; [] ⊢ open term ktyp τ1 t0 : open typ ktyp τ1 τ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk27d" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk27d">inverts j.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> (tm_tab t0) t&#39; -&gt; []; [] ⊢ t&#39; : ty_univ τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type [] τ1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="nb">red</span> (tm_tap (tm_tab t0) τ1)
  (open term ktyp τ1 t0)</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
[] ++ x ~ tt; []
⊢ open term ktyp (ty_v (Fr x)) t0
: open typ ktyp (ty_v (Fr x)) τ2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[]; [] ⊢ open term ktyp τ1 t0 : open typ ktyp τ1 τ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk27e" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk27e">pick <span class="kp">fresh</span> e <span class="kr">for</span> (L ∪ FV term ktyp t0 ∪ FV typ ktyp τ2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> (tm_tab t0) t&#39; -&gt; []; [] ⊢ t&#39; : ty_univ τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type [] τ1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="nb">red</span> (tm_tap (tm_tab t0) τ1)
  (open term ktyp τ1 t0)</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
[] ++ x ~ tt; []
⊢ open term ktyp (ty_v (Fr x)) t0
: open typ ktyp (ty_v (Fr x)) τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e
`notin` (L
         ∪ (FV term ktyp t0 ∪ FV typ ktyp τ2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[]; [] ⊢ open term ktyp τ1 t0 : open typ ktyp τ1 τ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk27f" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk27f"><span class="nb">rewrite</span> (open_spec_eq term) <span class="kr">with</span> (x := e); [|fsetdec].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> (tm_tab t0) t&#39; -&gt; []; [] ⊢ t&#39; : ty_univ τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type [] τ1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="nb">red</span> (tm_tap (tm_tab t0) τ1)
  (open term ktyp τ1 t0)</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
[] ++ x ~ tt; []
⊢ open term ktyp (ty_v (Fr x)) t0
: open typ ktyp (ty_v (Fr x)) τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e
`notin` (L
         ∪ (FV term ktyp t0 ∪ FV typ ktyp τ2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[]; []
⊢ <span class="nb">subst</span> term ktyp e τ1
    (open term ktyp (mret SystemF ktyp (Fr e)) t0)
: open typ ktyp τ1 τ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk280" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk280"><span class="nb">rewrite</span> (open_spec_eq typ) <span class="kr">with</span> (x := e); [|fsetdec].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> (tm_tab t0) t&#39; -&gt; []; [] ⊢ t&#39; : ty_univ τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type [] τ1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="nb">red</span> (tm_tap (tm_tab t0) τ1)
  (open term ktyp τ1 t0)</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
[] ++ x ~ tt; []
⊢ open term ktyp (ty_v (Fr x)) t0
: open typ ktyp (ty_v (Fr x)) τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e
`notin` (L
         ∪ (FV term ktyp t0 ∪ FV typ ktyp τ2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[]; []
⊢ <span class="nb">subst</span> term ktyp e τ1
    (open term ktyp (mret SystemF ktyp (Fr e)) t0)
: <span class="nb">subst</span> typ ktyp e τ1
    (open typ ktyp (mret SystemF ktyp (Fr e)) τ2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk281" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk281"><span class="nb">change</span> (@nil (atom * typ LN))
        <span class="kr">with</span> (envmap (<span class="nb">subst</span> typ ktyp e τ1) []).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> (tm_tab t0) t&#39; -&gt; []; [] ⊢ t&#39; : ty_univ τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type [] τ1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="nb">red</span> (tm_tap (tm_tab t0) τ1)
  (open term ktyp τ1 t0)</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
[] ++ x ~ tt; []
⊢ open term ktyp (ty_v (Fr x)) t0
: open typ ktyp (ty_v (Fr x)) τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e
`notin` (L
         ∪ (FV term ktyp t0 ∪ FV typ ktyp τ2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[]; envmap (<span class="nb">subst</span> typ ktyp e τ1) []
⊢ <span class="nb">subst</span> term ktyp e τ1
    (open term ktyp (mret SystemF ktyp (Fr e)) t0)
: <span class="nb">subst</span> typ ktyp e τ1
    (open typ ktyp (mret SystemF ktyp (Fr e)) τ2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk282" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk282"><span class="nb">eapply</span> j_kind_ctx_subst1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> (tm_tab t0) t&#39; -&gt; []; [] ⊢ t&#39; : ty_univ τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type [] τ1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="nb">red</span> (tm_tap (tm_tab t0) τ1)
  (open term ktyp τ1 t0)</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
[] ++ x ~ tt; []
⊢ open term ktyp (ty_v (Fr x)) t0
: open typ ktyp (ty_v (Fr x)) τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e
`notin` (L
         ∪ (FV term ktyp t0 ∪ FV typ ktyp τ2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type [] τ1</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk283" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> (tm_tab t0) t&#39; -&gt; []; [] ⊢ t&#39; : ty_univ τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type [] τ1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="nb">red</span> (tm_tap (tm_tab t0) τ1)
  (open term ktyp τ1 t0)</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
[] ++ x ~ tt; []
⊢ open term ktyp (ty_v (Fr x)) t0
: open typ ktyp (ty_v (Fr x)) τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e
`notin` (L
         ∪ (FV term ktyp t0 ∪ FV typ ktyp τ2))</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk283"><hr></label><div class="goal-conclusion">[] ++ e ~ tt; []
⊢ open term ktyp (mret SystemF ktyp (Fr e)) t0
: open typ ktyp (mret SystemF ktyp (Fr e)) τ2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk284" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk284">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> (tm_tab t0) t&#39; -&gt; []; [] ⊢ t&#39; : ty_univ τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type [] τ1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="nb">red</span> (tm_tap (tm_tab t0) τ1)
  (open term ktyp τ1 t0)</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
[] ++ x ~ tt; []
⊢ open term ktyp (ty_v (Fr x)) t0
: open typ ktyp (ty_v (Fr x)) τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e
`notin` (L
         ∪ (FV term ktyp t0 ∪ FV typ ktyp τ2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ok_type [] τ1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk285" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk285">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> (tm_tab t0) t&#39; -&gt; []; [] ⊢ t&#39; : ty_univ τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type [] τ1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="nb">red</span> (tm_tap (tm_tab t0) τ1)
  (open term ktyp τ1 t0)</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
[] ++ x ~ tt; []
⊢ open term ktyp (ty_v (Fr x)) t0
: open typ ktyp (ty_v (Fr x)) τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e
`notin` (L
         ∪ (FV term ktyp t0 ∪ FV typ ktyp τ2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[] ++ e ~ tt; []
⊢ open term ktyp (mret SystemF ktyp (Fr e)) t0
: open typ ktyp (mret SystemF ktyp (Fr e)) τ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk286" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk286">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> (tm_tab t0) t&#39; -&gt; []; [] ⊢ t&#39; : ty_univ τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type [] τ1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="nb">red</span> (tm_tap (tm_tab t0) τ1)
  (open term ktyp τ1 t0)</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
[] ++ x ~ tt; []
⊢ open term ktyp (ty_v (Fr x)) t0
: open typ ktyp (ty_v (Fr x)) τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e
`notin` (L
         ∪ (FV term ktyp t0 ∪ FV typ ktyp τ2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[] ++ e ~ tt; []
⊢ open term ktyp (mret SystemF ktyp (Fr e)) t0
: open typ ktyp (mret SystemF ktyp (Fr e)) τ2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk287" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk287"><span class="nb">apply</span> H5.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
<span class="kr">forall</span> <span class="nv">t&#39;</span> : term LN,
<span class="nb">red</span> (tm_tab t0) t&#39; -&gt; []; [] ⊢ t&#39; : ty_univ τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type [] τ1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="nb">red</span> (tm_tap (tm_tab t0) τ1)
  (open term ktyp τ1 t0)</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
[] ++ x ~ tt; []
⊢ open term ktyp (ty_v (Fr x)) t0
: open typ ktyp (ty_v (Fr x)) τ2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>e
`notin` (L
         ∪ (FV term ktyp t0 ∪ FV typ ktyp τ2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">e `notin` L</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">fsetdec.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk288" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk288"><span class="kn">Theorem</span> <span class="nf">progress_theorem</span> : <span class="kp">progress</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kp">progress</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk289" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk289"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kp">progress</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk28a" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk28a">introv j.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t : τ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">value t \/ (<span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> t t&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk28b" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk28b"><span class="nb">remember</span> (@nil (atom * unit)) <span class="kr">as</span> Delta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Delta</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>HeqDelta</var><span class="hyp-type"><b>: </b><span>Delta = []</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Delta; [] ⊢ t : τ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">value t \/ (<span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> t t&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk28c" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk28c"><span class="nb">remember</span> (@nil (atom * typ LN)) <span class="kr">as</span> Gamma.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>Delta</var><span class="hyp-type"><b>: </b><span>list (atom * unit)</span></span></span><br><span><var>HeqDelta</var><span class="hyp-type"><b>: </b><span>Delta = []</span></span></span><br><span><var>Gamma</var><span class="hyp-type"><b>: </b><span>list (atom * typ LN)</span></span></span><br><span><var>HeqGamma</var><span class="hyp-type"><b>: </b><span>Gamma = []</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Delta; Gamma ⊢ t : τ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">value t \/ (<span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> t t&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk28d" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk28d"><span class="nb">induction</span> j; <span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx [] []</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx []</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x, τ) ∈ []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">value (tm_var (Fr x)) \/
(<span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_var (Fr x)) t&#39;)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk28e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
[]; [] ++ x ~ τ1
⊢ open term ktrm (tm_var (Fr x)) t : τ2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
[] = [] -&gt;
[] ++ x ~ τ1 = [] -&gt;
value (open term ktrm (tm_var (Fr x)) t) \/
(<span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN,
   <span class="nb">red</span> (open term ktrm (tm_var (Fr x)) t) t&#39;)</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk28e"><hr></label><div class="goal-conclusion">value (tm_abs τ1 t) \/
(<span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_abs τ1 t) t&#39;)</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk28f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t2 : τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
value t1 \/ (<span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> t1 t&#39;)</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
value t2 \/ (<span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> t2 t&#39;)</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk28f"><hr></label><div class="goal-conclusion">value (tm_app t1 t2) \/
(<span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_app t1 t2) t&#39;)</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk290" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
[] ++ x ~ tt; [] ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
[] ++ x ~ tt = [] -&gt;
[] = [] -&gt;
value (open term ktyp (ty_v (Fr x)) t) \/
(<span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN,
   <span class="nb">red</span> (open term ktyp (ty_v (Fr x)) t) t&#39;)</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk290"><hr></label><div class="goal-conclusion">value (tm_tab t) \/
(<span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_tab t) t&#39;)</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk291" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
value t \/ (<span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> t t&#39;)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type [] τ1</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk291"><hr></label><div class="goal-conclusion">value (tm_tap t τ1) \/
(<span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_tap t τ1) t&#39;)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk292" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk292">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ok_type_ctx [] []</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_kind_ctx []</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(x, τ) ∈ []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">value (tm_var (Fr x)) \/
(<span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_var (Fr x)) t&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">inversion</span> H1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk293" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk293">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
[]; [] ++ x ~ τ1
⊢ open term ktrm (tm_var (Fr x)) t : τ2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
[] = [] -&gt;
[] ++ x ~ τ1 = [] -&gt;
value (open term ktrm (tm_var (Fr x)) t) \/
(<span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN,
   <span class="nb">red</span> (open term ktrm (tm_var (Fr x)) t) t&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">value (tm_abs τ1 t) \/
(<span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_abs τ1 t) t&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">left</span>; <span class="nb">auto using</span> value.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk294" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk294">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t2 : τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
value t1 \/ (<span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> t1 t&#39;)</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
value t2 \/ (<span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> t2 t&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">value (tm_app t1 t2) \/
(<span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_app t1 t2) t&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk295" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk295"><span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t2 : τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
value t1 \/ (<span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> t1 t&#39;)</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
value t2 \/ (<span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> t2 t&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_app t1 t2) t&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk296" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk296"><span class="nb">specialize</span> (IHj1 <span class="kp">ltac</span>:(<span class="nb">trivial</span>) <span class="kp">ltac</span>:(<span class="nb">trivial</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t2 : τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span>value t1 \/ (<span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> t1 t&#39;)</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
value t2 \/ (<span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> t2 t&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_app t1 t2) t&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk297" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk297"><span class="nb">specialize</span> (IHj2 <span class="kp">ltac</span>:(<span class="nb">trivial</span>) <span class="kp">ltac</span>:(<span class="nb">trivial</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t2 : τ1</span></span></span><br><span><var>IHj1</var><span class="hyp-type"><b>: </b><span>value t1 \/ (<span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> t1 t&#39;)</span></span></span><br><span><var>IHj2</var><span class="hyp-type"><b>: </b><span>value t2 \/ (<span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> t2 t&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_app t1 t2) t&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk298" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk298"><span class="nb">intuition</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t2 : τ1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>value t1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>value t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_app t1 t2) t&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk299" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t2 : τ1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>value t1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> t2 t&#39;</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk299"><hr></label><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_app t1 t2) t&#39;</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk29a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t2 : τ1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> t1 t&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>value t2</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk29a"><hr></label><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_app t1 t2) t&#39;</div></blockquote><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk29b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t2 : τ1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> t1 t&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> t2 t&#39;</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk29b"><hr></label><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_app t1 t2) t&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk29c" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk29c">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t2 : τ1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>value t1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>value t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_app t1 t2) t&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk29d" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk29d">inverts H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2, T</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ tm_abs T t : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t2 : τ1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>value t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_app (tm_abs T t) t2) t&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk29e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ tm_tab t : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t2 : τ1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>value t2</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk29e"><hr></label><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_app (tm_tab t) t2) t&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk29f" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk29f">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2, T</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ tm_abs T t : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t2 : τ1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>value t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_app (tm_abs T t) t2) t&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eauto using</span> <span class="nb">red</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk2a0" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk2a0">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ tm_tab t : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t2 : τ1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>value t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_app (tm_tab t) t2) t&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk2a1" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk2a1">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ tm_tab t : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t2 : τ1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>value t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_app (tm_tab t) t2) t&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk2a2" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk2a2">false.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ tm_tab t : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t2 : τ1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>value t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">inverts j1.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk2a3" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk2a3">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t2 : τ1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>value t1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> t2 t&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_app t1 t2) t&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk2a4" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk2a4">inverts H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2, T</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ tm_abs T t : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t2 : τ1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> t2 t&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_app (tm_abs T t) t2) t&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk2a5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ tm_tab t : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t2 : τ1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> t2 t&#39;</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk2a5"><hr></label><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_app (tm_tab t) t2) t&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk2a6" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk2a6">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2, T</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ tm_abs T t : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t2 : τ1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> t2 t&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_app (tm_abs T t) t2) t&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk2a7" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk2a7">destruct_all_existentials.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2, T</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ tm_abs T t : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t2 : τ1</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="nb">red</span> t2 x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_app (tm_abs T t) t2) t&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eauto using</span> <span class="nb">red</span>, value.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk2a8" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk2a8">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ tm_tab t : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t2 : τ1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> t2 t&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_app (tm_tab t) t2) t&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk2a9" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk2a9">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ tm_tab t : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t2 : τ1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> t2 t&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_app (tm_tab t) t2) t&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">inverts j1.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk2aa" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk2aa">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t2 : τ1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> t1 t&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>value t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_app t1 t2) t&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk2ab" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk2ab">destruct_all_existentials.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t2 : τ1</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="nb">red</span> t1 x</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>value t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_app t1 t2) t&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eauto using</span> <span class="nb">red</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk2ac" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk2ac">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t2 : τ1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> t1 t&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> t2 t&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_app t1 t2) t&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk2ad" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk2ad">destruct_all_existentials.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j1</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t1 : ty_ar τ1 τ2</span></span></span><br><span><var>j2</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t2 : τ1</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="nb">red</span> t1 x0</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="nb">red</span> t2 x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_app t1 t2) t&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eauto using</span> <span class="nb">red</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk2ae" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk2ae">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>L</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>τ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
[] ++ x ~ tt; [] ⊢ open term ktyp (ty_v (Fr x)) t
: open typ ktyp (ty_v (Fr x)) τ</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : AtomSet.elt,
x `notin` L -&gt;
[] ++ x ~ tt = [] -&gt;
[] = [] -&gt;
value (open term ktyp (ty_v (Fr x)) t) \/
(<span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN,
   <span class="nb">red</span> (open term ktyp (ty_v (Fr x)) t) t&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">value (tm_tab t) \/
(<span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_tab t) t&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">left</span>; <span class="nb">auto using</span> value.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk2af" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk2af">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
value t \/ (<span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> t t&#39;)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type [] τ1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">value (tm_tap t τ1) \/
(<span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_tap t τ1) t&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk2b0" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk2b0"><span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>[] = [] -&gt;
[] = [] -&gt;
value t \/ (<span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> t t&#39;)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type [] τ1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_tap t τ1) t&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk2b1" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk2b1"><span class="nb">specialize</span> (IHj <span class="kp">ltac</span>:(<span class="nb">trivial</span>) <span class="kp">ltac</span>:(<span class="nb">trivial</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t : ty_univ τ2</span></span></span><br><span><var>IHj</var><span class="hyp-type"><b>: </b><span>value t \/ (<span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> t t&#39;)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type [] τ1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_tap t τ1) t&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk2b2" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk2b2"><span class="nb">intuition</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t : ty_univ τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type [] τ1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>value t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_tap t τ1) t&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk2b3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t : ty_univ τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type [] τ1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> t t&#39;</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk2b3"><hr></label><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_tap t τ1) t&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk2b4" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk2b4">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t : ty_univ τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type [] τ1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>value t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_tap t τ1) t&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk2b5" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk2b5">inverts H0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>τ1, τ2, T</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ tm_abs T t0 : ty_univ τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type [] τ1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_tap (tm_abs T t0) τ1) t&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="typesoundness-v-chk2b6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ tm_tab t0 : ty_univ τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type [] τ1</span></span></span><br></div><label class="goal-separator" for="typesoundness-v-chk2b6"><hr></label><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_tap (tm_tab t0) τ1) t&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk2b7" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk2b7">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>τ1, τ2, T</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ tm_abs T t0 : ty_univ τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type [] τ1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_tap (tm_abs T t0) τ1) t&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">inverts j.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk2b8" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk2b8">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ tm_tab t0 : ty_univ τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type [] τ1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_tap (tm_tab t0) τ1) t&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk2b9" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk2b9">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ tm_tab t0 : ty_univ τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type [] τ1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_tap (tm_tab t0) τ1) t&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eauto using</span> <span class="nb">red</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk2ba" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk2ba">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t : ty_univ τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type [] τ1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> t t&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_tap t τ1) t&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk2bb" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk2bb">destruct_all_existentials.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>τ1, τ2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>[]; [] ⊢ t : ty_univ τ2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ok_type [] τ1</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="nb">red</span> t x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t&#39;</span> : term LN, <span class="nb">red</span> (tm_tap t τ1) t&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eauto using</span> <span class="nb">red</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk2bc" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk2bc"><span class="kn">Print Assumptions</span> progress_theorem.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Axioms</span>:
base_typ : <span class="kt">Type</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(* Axioms:</span>
<span class="c">base_typ : Type</span>
<span class="c">*)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="typesoundness-v-chk2bd" style="display: none" type="checkbox"><label class="alectryon-input" for="typesoundness-v-chk2bd"><span class="kn">Print Assumptions</span> preservation_theorem.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Axioms</span>:
propositional_extensionality
  : <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>, P &lt;-&gt; Q -&gt; P = Q
functional_extensionality_dep
  : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>)
      (<span class="nv">f</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">x</span> : A, B x),
    (<span class="kr">forall</span> <span class="nv">x</span> : A, f x = g x) -&gt; f = g
Eqdep.Eq_rect_eq.eq_rect_eq
  : <span class="kr">forall</span> (<span class="nv">U</span> : <span class="kt">Type</span>) (<span class="nv">p</span> : U) (<span class="nv">Q</span> : U -&gt; <span class="kt">Type</span>)
      (<span class="nv">x</span> : Q p) (<span class="nv">h</span> : p = p), x = rew [Q] h <span class="kr">in</span> x
base_typ : <span class="kt">Type</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(*</span>
<span class="c">Axioms:</span>
<span class="c">propositional_extensionality : forall P Q : Prop, P &lt;-&gt; Q -&gt; P = Q</span>
<span class="c">functional_extensionality_dep</span>
<span class="c">  : forall (A : Type) (B : A -&gt; Type) (f g : forall x : A, B x),</span>
<span class="c">    (forall x : A, f x = g x) -&gt; f = g</span>
<span class="c">Eqdep.Eq_rect_eq.eq_rect_eq</span>
<span class="c">  : forall (U : Type) (p : U) (Q : U -&gt; Type) (x : Q p) (h : p = p),</span>
<span class="c">    x = rew [Q] h in x</span>
<span class="c">base_typ : Type</span>
<span class="c">*)</span></span></pre>
</div>
</div></body>
</html>
