<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<title>SystemF_LN.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.16.0+0.16.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Tealeaves <span class="kn">Require Export</span>
  Examples.SystemF.Syntax
  Simplification.Tests.Support
  Simplification.MBinddt
  Simplification.Tests.SystemF_Binddt
  Simplification.Tests.SystemF_Targeted
  Classes.Multisorted.Theory.Foldmap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Generalizable Variables</span> <span class="nf">G</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Arguments</span> mbinddt {ix} {W}%type_scope {T} U%function_scope
  {MBind} {F}%function_scope {H H0 H1 A B} _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Generalizable Variables</span> <span class="nf">A</span> B C F W T U K.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">local_lemmas_needed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    (<span class="nv">U</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
      `{MultiDecoratedTraversablePreModule (list K) T U
          (mn_op := Monoid_op_list)
          (mn_unit := Monoid_unit_list)}
      `{! MultiDecoratedTraversableMonad (list K) T
          (mn_op := Monoid_op_list)
          (mn_unit := Monoid_unit_list)}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk0"><span class="kn">Lemma</span> <span class="nf">subst_to_kbind</span> : <span class="kr">forall</span> (<span class="nv">k</span>: K) (<span class="nv">x</span>: atom) (<span class="nv">u</span>: T k LN),
      <span class="nb">subst</span> U k x u = kbind U k (subst_loc k x u).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">k</span> : K) (<span class="nv">x</span> : atom) (<span class="nv">u</span> : T k LN),
<span class="nb">subst</span> U k x u = kbind U k (subst_loc k x u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">k</span> : K) (<span class="nv">x</span> : atom) (<span class="nv">u</span> : T k LN),
<span class="nb">subst</span> U k x u = kbind U k (subst_loc k x u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk2"><span class="kn">Lemma</span> <span class="nf">open_to_kbindd</span> : <span class="kr">forall</span> (<span class="nv">k</span>: K) (<span class="nv">u</span>: T k LN),
      open U k u = kbindd U k (open_loc k u).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">k</span> : K) (<span class="nv">u</span> : T k LN),
open U k u = kbindd U k (open_loc k u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">k</span> : K) (<span class="nv">u</span> : T k LN),
open U k u = kbindd U k (open_loc k u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk4"><span class="kn">Lemma</span> <span class="nf">free_to_foldMapk</span> : <span class="kr">forall</span> (<span class="nv">k</span>: K),
      free U (T := T) k = foldMapk U k free_loc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">k</span> : K, free U k = foldMapk U k free_loc</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">k</span> : K, free U k = foldMapk U k free_loc</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk6"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free U k = foldMapk U k free_loc</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk7"><span class="nb">unfold</span> free.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bind free_loc ‚óã toklist U k = foldMapk U k free_loc</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk8">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>U LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bind free_loc (toklist U k t) =
foldMapk U k free_loc t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk9"><span class="nb">unfold</span> toklist, compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>U LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bind free_loc (map extract (toklistd U k t)) =
foldMapk U k free_loc t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chka"><span class="nb">unfold</span> foldMapk.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>U LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bind free_loc (map extract (toklistd U k t)) =
foldMapm U (tgt_def k free_loc (const ∆µ)) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkb"><span class="nb">rewrite</span> foldMapm_to_foldMapmd.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>U LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bind free_loc (map extract (toklistd U k t)) =
foldMapmd U
  (tgt_def k free_loc (const ∆µ) ‚óª allK extract) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkc"><span class="nb">rewrite</span> (foldMapmd_through_tolist U).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>U LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bind free_loc (map extract (toklistd U k t)) =
(foldMap_list
   (<span class="kr">fun</span> &#39;(w, (k0, a)) =&gt;
    (tgt_def k free_loc (const ∆µ) ‚óª allK extract) k0
      (w, a)) ‚àò tolistmd U) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkd"><span class="nb">unfold</span> toklistd.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>U LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bind free_loc
  (map extract ((filterk k ‚àò tolistmd U) t)) =
(foldMap_list
   (<span class="kr">fun</span> &#39;(w, (k0, a)) =&gt;
    (tgt_def k free_loc (const ∆µ) ‚óª allK extract) k0
      (w, a)) ‚àò tolistmd U) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chke"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>U LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bind free_loc (map extract (filterk k (tolistmd U t))) =
foldMap_list
  (<span class="kr">fun</span> &#39;(w, (k0, a)) =&gt;
   (tgt_def k free_loc (const ∆µ) ‚óª allK extract) k0
     (w, a)) (tolistmd U t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkf"><span class="nb">induction</span> (tolistmd U t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>U LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bind free_loc (map extract (filterk k [])) =
foldMap_list
  (<span class="kr">fun</span> &#39;(w, (k0, a)) =&gt;
   (tgt_def k free_loc (const ∆µ) ‚óª allK extract) k0
     (w, a)) []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="systemf-ln-v-chk10" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>U LN</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list K * (K * LN)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (list K * (K * LN))</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>bind free_loc (map extract (filterk k l)) =
foldMap_list
  (<span class="kr">fun</span> &#39;(w, (k0, a)) =&gt;
   (tgt_def k free_loc (const ∆µ) ‚óª allK extract)
     k0 (w, a)) l</span></span></span><br></div><label class="goal-separator" for="systemf-ln-v-chk10"><hr></label><div class="goal-conclusion">bind free_loc (map extract (filterk k (a :: l))) =
foldMap_list
  (<span class="kr">fun</span> &#39;(w, (k0, a)) =&gt;
   (tgt_def k free_loc (const ∆µ) ‚óª allK extract) k0
     (w, a)) 
  (a :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk11">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>U LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bind free_loc (map extract (filterk k [])) =
foldMap_list
  (<span class="kr">fun</span> &#39;(w, (k0, a)) =&gt;
   (tgt_def k free_loc (const ∆µ) ‚óª allK extract) k0
     (w, a)) []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk12">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>U LN</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list K * (K * LN)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (list K * (K * LN))</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>bind free_loc (map extract (filterk k l)) =
foldMap_list
  (<span class="kr">fun</span> &#39;(w, (k0, a)) =&gt;
   (tgt_def k free_loc (const ∆µ) ‚óª allK extract)
     k0 (w, a)) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bind free_loc (map extract (filterk k (a :: l))) =
foldMap_list
  (<span class="kr">fun</span> &#39;(w, (k0, a)) =&gt;
   (tgt_def k free_loc (const ∆µ) ‚óª allK extract) k0
     (w, a)) (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk13"><span class="nb">destruct</span> a <span class="kr">as</span> [w [j l&#39;]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>U LN</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list K</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (list K * (K * LN))</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>bind free_loc (map extract (filterk k l)) =
foldMap_list
  (<span class="kr">fun</span> &#39;(w, (k0, a)) =&gt;
   (tgt_def k free_loc (const ∆µ) ‚óª allK extract)
     k0 (w, a)) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bind free_loc
  (map extract (filterk k ((w, (j, l&#39;)) :: l))) =
foldMap_list
  (<span class="kr">fun</span> &#39;(w, (k0, a)) =&gt;
   (tgt_def k free_loc (const ∆µ) ‚óª allK extract) k0
     (w, a)) ((w, (j, l&#39;)) :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk14"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>U LN</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list K</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (list K * (K * LN))</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>bind free_loc (map extract (filterk k l)) =
foldMap_list
  (<span class="kr">fun</span> &#39;(w, (k0, a)) =&gt;
   (tgt_def k free_loc (const ∆µ) ‚óª allK extract)
     k0 (w, a)) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bind free_loc
  (map extract
     (<span class="kr">if</span> k == j
      <span class="kr">then</span> (w, l&#39;) :: filterk k l
      <span class="kr">else</span> filterk k l)) =
(tgt_def k free_loc (const ∆µ) ‚óª allK extract) j
  (w, l&#39;)
‚óè <span class="nb">fold</span> (list atom)
    (map
       (<span class="kr">fun</span> &#39;(w, (k0, a)) =&gt;
        (tgt_def k free_loc (const ∆µ) ‚óª allK extract)
          k0 (w, a)) l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk15"><span class="nb">unfold</span> tgt_def.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>U LN</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list K</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (list K * (K * LN))</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>bind free_loc (map extract (filterk k l)) =
foldMap_list
  (<span class="kr">fun</span> &#39;(w, (k0, a)) =&gt;
   (tgt_def k free_loc (const ∆µ) ‚óª allK extract)
     k0 (w, a)) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bind free_loc
  (map extract
     (<span class="kr">if</span> k == j
      <span class="kr">then</span> (w, l&#39;) :: filterk k l
      <span class="kr">else</span> filterk k l)) =
((<span class="kr">fun</span> <span class="nv">j</span> : K =&gt; <span class="kr">if</span> k == j <span class="kr">then</span> free_loc <span class="kr">else</span> const ∆µ)
 ‚óª allK extract) j (w, l&#39;)
‚óè <span class="nb">fold</span> (list atom)
    (map
       (<span class="kr">fun</span> &#39;(w, (k0, a)) =&gt;
        ((<span class="kr">fun</span> <span class="nv">j</span> : K =&gt;
          <span class="kr">if</span> k == j <span class="kr">then</span> free_loc <span class="kr">else</span> const ∆µ)
         ‚óª allK extract) k0 (w, a)) l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk16">unfold_ops @Monoid_op_list.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>U LN</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list K</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (list K * (K * LN))</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>bind free_loc (map extract (filterk k l)) =
foldMap_list
  (<span class="kr">fun</span> &#39;(w, (k0, a)) =&gt;
   (tgt_def k free_loc (const ∆µ) ‚óª allK extract)
     k0 (w, a)) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bind free_loc
  (map extract
     (<span class="kr">if</span> k == j
      <span class="kr">then</span> (w, l&#39;) :: filterk k l
      <span class="kr">else</span> filterk k l)) =
((<span class="kr">fun</span> <span class="nv">j</span> : K =&gt; <span class="kr">if</span> k == j <span class="kr">then</span> free_loc <span class="kr">else</span> const ∆µ)
 ‚óª allK extract) j (w, l&#39;) ++
<span class="nb">fold</span> (list atom)
  (map
     (<span class="kr">fun</span> &#39;(w, (k0, a)) =&gt;
      ((<span class="kr">fun</span> <span class="nv">j</span> : K =&gt;
        <span class="kr">if</span> k == j <span class="kr">then</span> free_loc <span class="kr">else</span> const ∆µ)
       ‚óª allK extract) k0 (w, a)) l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk17"><span class="nb">unfold</span> vec_compose, compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>U LN</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list K</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (list K * (K * LN))</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>bind free_loc (map extract (filterk k l)) =
foldMap_list
  (<span class="kr">fun</span> &#39;(w, (k0, a)) =&gt;
   (tgt_def k free_loc (const ∆µ) ‚óª allK extract)
     k0 (w, a)) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bind free_loc
  (map extract
     (<span class="kr">if</span> k == j
      <span class="kr">then</span> (w, l&#39;) :: filterk k l
      <span class="kr">else</span> filterk k l)) =
(<span class="kr">if</span> k == j <span class="kr">then</span> free_loc <span class="kr">else</span> const ∆µ)
  (allK extract j (w, l&#39;)) ++
<span class="nb">fold</span> (list atom)
  (map
     (<span class="kr">fun</span> &#39;(w, (k0, a)) =&gt;
      (<span class="kr">if</span> k == k0 <span class="kr">then</span> free_loc <span class="kr">else</span> const ∆µ)
        (allK extract k0 (w, a))) l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk18"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>U LN</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list K</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (list K * (K * LN))</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>bind free_loc (map extract (filterk k l)) =
foldMap_list
  (<span class="kr">fun</span> &#39;(w, (k0, a)) =&gt;
   (tgt_def k free_loc (const ∆µ) ‚óª allK extract)
     k0 (w, a)) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bind free_loc
  (map extract
     (<span class="kr">if</span> k == j
      <span class="kr">then</span> (w, l&#39;) :: filterk k l
      <span class="kr">else</span> filterk k l)) =
(<span class="kr">if</span> k == j <span class="kr">then</span> free_loc <span class="kr">else</span> const ∆µ) l&#39; ++
<span class="nb">fold</span> (list atom)
  (map
     (<span class="kr">fun</span> &#39;(_, (k0, a)) =&gt;
      (<span class="kr">if</span> k == k0 <span class="kr">then</span> free_loc <span class="kr">else</span> const ∆µ) a) l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk19">destruct_eq_args k j.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>U LN</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list K</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (list K * (K * LN))</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>bind free_loc (map extract (filterk j l)) =
foldMap_list
  (<span class="kr">fun</span> &#39;(w, (k, a)) =&gt;
   (tgt_def j free_loc (const ∆µ) ‚óª allK extract)
     k (w, a)) l</span></span></span><br><span><var>DESTR_EQs</var><span class="hyp-type"><b>: </b><span>j = j</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bind free_loc (map extract ((w, l&#39;) :: filterk j l)) =
free_loc l&#39; ++
<span class="nb">fold</span> (list atom)
  (map
     (<span class="kr">fun</span> &#39;(_, (k, a)) =&gt;
      (<span class="kr">if</span> j == k <span class="kr">then</span> free_loc <span class="kr">else</span> const ∆µ) a) l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk1a"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>U LN</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list K</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (list K * (K * LN))</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>bind free_loc (map extract (filterk j l)) =
foldMap_list
  (<span class="kr">fun</span> &#39;(w, (k, a)) =&gt;
   (tgt_def j free_loc (const ∆µ) ‚óª allK extract)
     k (w, a)) l</span></span></span><br><span><var>DESTR_EQs</var><span class="hyp-type"><b>: </b><span>j = j</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_loc l&#39;
‚óè bind free_loc (map extract (filterk j l)) =
free_loc l&#39; ++
<span class="nb">fold</span> (list atom)
  (map
     (<span class="kr">fun</span> &#39;(_, (k, a)) =&gt;
      (<span class="kr">if</span> j == k <span class="kr">then</span> free_loc <span class="kr">else</span> const ∆µ) a) l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk1b"><span class="nb">rewrite</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>U LN</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list K</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (list K * (K * LN))</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>bind free_loc (map extract (filterk j l)) =
foldMap_list
  (<span class="kr">fun</span> &#39;(w, (k, a)) =&gt;
   (tgt_def j free_loc (const ∆µ) ‚óª allK extract)
     k (w, a)) l</span></span></span><br><span><var>DESTR_EQs</var><span class="hyp-type"><b>: </b><span>j = j</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free_loc l&#39;
‚óè foldMap_list
    (<span class="kr">fun</span> &#39;(w, (k, a)) =&gt;
     (tgt_def j free_loc (const ∆µ) ‚óª allK extract) k
       (w, a)) l =
free_loc l&#39; ++
<span class="nb">fold</span> (list atom)
  (map
     (<span class="kr">fun</span> &#39;(_, (k, a)) =&gt;
      (<span class="kr">if</span> j == k <span class="kr">then</span> free_loc <span class="kr">else</span> const ∆µ) a) l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">fequal.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk1c"><span class="kn">Lemma</span> <span class="nf">FV_to_free</span> : <span class="kr">forall</span> (<span class="nv">k</span>: K) (<span class="nv">t</span>: U LN),
      FV U k t = atoms (free U (T := T) k t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">k</span> : K) (<span class="nv">t</span> : U LN),
FV U k t = atoms (free U k t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk1d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">k</span> : K) (<span class="nv">t</span> : U LN),
FV U k t = atoms (free U k t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk1e"><span class="kn">Lemma</span> <span class="nf">LCn_to_Forallkd</span>:
    <span class="kr">forall</span> (<span class="nv">n</span>: nat) (<span class="nv">t</span>: U LN) <span class="nv">k</span>,
      LCn U k n t = Forallkd U k (lc_loc k n) t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">t</span> : U LN) (<span class="nv">k</span> : K),
LCn U k n t = Forallkd U k (lc_loc k n) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk1f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">t</span> : U LN) (<span class="nv">k</span> : K),
LCn U k n t = Forallkd U k (lc_loc k n) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk20"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>U LN</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LCn U k n t = Forallkd U k (lc_loc k n) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk21"><span class="nb">apply</span> propositional_extensionality.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>U LN</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LCn U k n t &lt;-&gt; Forallkd U k (lc_loc k n) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk22"><span class="nb">rewrite</span> &lt;- (Forallkd_spec U (lc_loc k n)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>U LN</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LCn U k n t &lt;-&gt;
(<span class="kr">forall</span> (<span class="nv">w</span> : list K) (<span class="nv">a</span> : LN),
 (w, (k, a)) ‚ààmd t -&gt; lc_loc k n (w, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk23"><span class="kn">Lemma</span> <span class="nf">LC_to_Forallkd</span>:
    <span class="kr">forall</span> (<span class="nv">n</span>: nat) (<span class="nv">t</span>: U LN) <span class="nv">k</span>,
      LC U k t = Forallkd U k (lc_loc k <span class="mi">0</span>) t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nat -&gt;
<span class="kr">forall</span> (<span class="nv">t</span> : U LN) (<span class="nv">k</span> : K),
LC U k t = Forallkd U k (lc_loc k <span class="mi">0</span>) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk24"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nat -&gt;
<span class="kr">forall</span> (<span class="nv">t</span> : U LN) (<span class="nv">k</span> : K),
LC U k t = Forallkd U k (lc_loc k <span class="mi">0</span>) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk25"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>U LN</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC U k t = Forallkd U k (lc_loc k <span class="mi">0</span>) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk26"><span class="nb">apply</span> propositional_extensionality.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>U LN</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC U k t &lt;-&gt; Forallkd U k (lc_loc k <span class="mi">0</span>) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk27"><span class="nb">rewrite</span> &lt;- (Forallkd_spec U (lc_loc k <span class="mi">0</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>U LN</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LC U k t &lt;-&gt;
(<span class="kr">forall</span> (<span class="nv">w</span> : list K) (<span class="nv">a</span> : LN),
 (w, (k, a)) ‚ààmd t -&gt; lc_loc k <span class="mi">0</span> (w, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk28"><span class="kn">Lemma</span> <span class="nf">lc_loc_preincr_eq</span> :
    <span class="kr">forall</span> <span class="nv">k</span> <span class="nv">n</span> <span class="nv">j</span>,
      k = j -&gt;
      (lc_loc k n ‚¶ø [j]) =
        lc_loc k (S n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">k</span> : K) (<span class="nv">n</span> : nat) (<span class="nv">j</span> : K),
k = j -&gt; lc_loc k n ‚¶ø [j] = lc_loc k (S n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk29"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">k</span> : K) (<span class="nv">n</span> : nat) (<span class="nv">j</span> : K),
k = j -&gt; lc_loc k n ‚¶ø [j] = lc_loc k (S n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk2a"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>k = j</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lc_loc k n ‚¶ø [j] = lc_loc k (S n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk2b"><span class="nb">unfold</span> preincr, compose, incr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>k = j</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">a</span> : list K * LN =&gt;
 lc_loc k n (<span class="kr">let</span> &#39;(w1, a0) := a <span class="kr">in</span> ([j] ‚óè w1, a0))) =
lc_loc k (S n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk2c">ext [w l].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>k = j</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list K</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lc_loc k n ([j] ‚óè w, l) = lc_loc k (S n) (w, l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk2d"><span class="nb">unfold</span> lc_loc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>k = j</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list K</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> l <span class="kr">with</span>
| Fr _ =&gt; <span class="kt">True</span>
| Bd n0 =&gt; n0 &lt; countk k ([j] ‚óè w) + n
<span class="kr">end</span> =
<span class="kr">match</span> l <span class="kr">with</span>
| Fr _ =&gt; <span class="kt">True</span>
| Bd n0 =&gt; n0 &lt; countk k w + S n
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk2e"><span class="nb">destruct</span> l <span class="kr">as</span> [x | m].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>k = j</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list K</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span> = <span class="kt">True</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="systemf-ln-v-chk2f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>k = j</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list K</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="systemf-ln-v-chk2f"><hr></label><div class="goal-conclusion">(m &lt; countk k ([j] ‚óè w) + n) = (m &lt; countk k w + S n)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk30">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>k = j</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list K</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span> = <span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk31">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>k = j</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list K</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(m &lt; countk k ([j] ‚óè w) + n) = (m &lt; countk k w + S n)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk32"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>k = j</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list K</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(m &lt; (<span class="kr">if</span> k == j <span class="kr">then</span> <span class="mi">1</span> <span class="kr">else</span> <span class="mi">0</span>) + countk k w + n) =
(m &lt; countk k w + S n)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk33">destruct_eq_args k j.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list K</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>DESTR_EQs, DESTR_EQ</var><span class="hyp-type"><b>: </b><span>j = j</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(m &lt; <span class="mi">1</span> + countk j w + n) = (m &lt; countk j w + S n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">propext; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk34"><span class="kn">Lemma</span> <span class="nf">lc_loc_preincr_neq</span> :
    <span class="kr">forall</span> <span class="nv">k</span> <span class="nv">n</span> <span class="nv">j</span>,
      k &lt;&gt; j -&gt;
      (lc_loc k n ‚¶ø [j]) =
        lc_loc k n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">k</span> : K) (<span class="nv">n</span> : nat) (<span class="nv">j</span> : K),
k &lt;&gt; j -&gt; lc_loc k n ‚¶ø [j] = lc_loc k n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk35"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">k</span> : K) (<span class="nv">n</span> : nat) (<span class="nv">j</span> : K),
k &lt;&gt; j -&gt; lc_loc k n ‚¶ø [j] = lc_loc k n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk36"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>k &lt;&gt; j</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lc_loc k n ‚¶ø [j] = lc_loc k n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk37"><span class="nb">unfold</span> preincr, compose, incr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>k &lt;&gt; j</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">a</span> : list K * LN =&gt;
 lc_loc k n (<span class="kr">let</span> &#39;(w1, a0) := a <span class="kr">in</span> ([j] ‚óè w1, a0))) =
lc_loc k n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk38">ext [w l].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>k &lt;&gt; j</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list K</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lc_loc k n ([j] ‚óè w, l) = lc_loc k n (w, l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk39"><span class="nb">unfold</span> lc_loc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>k &lt;&gt; j</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list K</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> l <span class="kr">with</span>
| Fr _ =&gt; <span class="kt">True</span>
| Bd n0 =&gt; n0 &lt; countk k ([j] ‚óè w) + n
<span class="kr">end</span> =
<span class="kr">match</span> l <span class="kr">with</span>
| Fr _ =&gt; <span class="kt">True</span>
| Bd n0 =&gt; n0 &lt; countk k w + n
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk3a"><span class="nb">destruct</span> l <span class="kr">as</span> [x | m].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>k &lt;&gt; j</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list K</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span> = <span class="kt">True</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="systemf-ln-v-chk3b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>k &lt;&gt; j</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list K</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="systemf-ln-v-chk3b"><hr></label><div class="goal-conclusion">(m &lt; countk k ([j] ‚óè w) + n) = (m &lt; countk k w + n)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk3c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>k &lt;&gt; j</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list K</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span> = <span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk3d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>k &lt;&gt; j</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list K</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(m &lt; countk k ([j] ‚óè w) + n) = (m &lt; countk k w + n)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk3e"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind (list K) T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind (list K) T (T k)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule (list K) T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  (list K) T</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>k &lt;&gt; j</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list K</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(m &lt; (<span class="kr">if</span> k == j <span class="kr">then</span> <span class="mi">1</span> <span class="kr">else</span> <span class="mi">0</span>) + countk k w + n) =
(m &lt; countk k w + n)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">destruct_eq_args k j.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">local_lemmas_needed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Create HintDb</span> lc_loc_db.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Hint Rewrite</span> lc_loc_preincr_eq: lc_loc_db.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Hint Rewrite</span> lc_loc_preincr_neq: lc_loc_db.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(*</span>
<span class="c">Ltac handle_lc_loc :=</span>
<span class="c">  autorewrite* with lc_loc_db using (auto; try discriminate).</span>
<span class="c"> *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">handle_lc_loc</span> :=
  <span class="kr">match goal with</span>
  | |- <span class="kp">context</span>[lc_loc (ix := <span class="nl">?ix</span>)] =&gt;
      <span class="kp">first</span> [ <span class="nb">rewrite</span> (lc_loc_preincr_eq (ix := ix)) <span class="bp">by</span> <span class="nb">auto</span>
            | <span class="nb">rewrite</span> (lc_loc_preincr_neq (ix := ix)) <span class="bp">by</span>
              (<span class="kp">solve</span> [<span class="nb">auto</span> || <span class="bp">discriminate</span>])
        ]
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_open_pre_refold_hook</span> :=
  <span class="kp">idtac</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_open_post_refold_hook</span> :=
  <span class="kp">idtac</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_open</span> :=
  <span class="nb">rewrite</span> <span class="nl">?open_to_kbindd</span>;
  simplify_kbindd;
  simplify_open_pre_refold_hook;
  <span class="nb">rewrite</span> &lt;- <span class="nl">?open_to_kbindd</span>;
  simplify_open_post_refold_hook.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** &lt;&lt;open&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">rw_open</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    (<span class="nv">A</span> : <span class="kt">Type</span>)
      (<span class="nv">k</span> : K2)
      (<span class="nv">x</span>: atom)
      (<span class="nv">u</span>: SystemF k LN).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">tactic_being_tested</span> ::= simplify_open.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk3f"><span class="kn">Lemma</span> <span class="nf">open_type_rw1</span> : <span class="kr">forall</span> <span class="nv">c</span>,
      open typ k u (ty_c c) = ty_c c.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : base_typ, open typ k u (ty_c c) = ty_c c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk40"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : base_typ, open typ k u (ty_c c) = ty_c c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(*</span>
<span class="c">  Lemma open_type_rw2_neq : forall (a : A),</span>
<span class="c">      k &lt;&gt; ktyp -&gt;</span>
<span class="c">      open typ k f (ty_v a) = ty_v a.</span>
<span class="c">  Proof.</span>
<span class="c">    intros.</span>
<span class="c">    simplify_open.</span>
<span class="c">    rewrite btgd_neq; auto.</span>
<span class="c">  Qed.*)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk41"><span class="kn">Lemma</span> <span class="nf">open_type_rw3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : typ LN),
      open typ k u (ty_ar t1 t2) =
        ty_ar (open typ k u t1) (open typ k u t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : typ LN,
open typ k u (ty_ar t1 t2) =
ty_ar (open typ k u t1) (open typ k u t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk42"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : typ LN,
open typ k u (ty_ar t1 t2) =
ty_ar (open typ k u t1) (open typ k u t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk43"><span class="kn">Lemma</span> <span class="nf">open_type_rw4</span> : <span class="kr">forall</span> (<span class="nv">body</span> : typ LN),
      open typ k u (ty_univ body) =
        ty_univ (kbindd typ k (open_loc k u ‚¶ø [ktyp]) body).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ LN,
open typ k u (ty_univ body) =
ty_univ (kbindd typ k (open_loc k u ‚¶ø [ktyp]) body)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk44"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ LN,
open typ k u (ty_univ body) =
ty_univ (kbindd typ k (open_loc k u ‚¶ø [ktyp]) body)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk45"><span class="kn">Lemma</span> <span class="nf">open_term_rw1_neq</span> : <span class="kr">forall</span> (<span class="nv">a</span> : LN),
      k &lt;&gt; ktrm -&gt;
      open term k u (tm_var a) = tm_var a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : LN,
k &lt;&gt; ktrm -&gt; open term k u (tm_var a) = tm_var a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk46"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : LN,
k &lt;&gt; ktrm -&gt; open term k u (tm_var a) = tm_var a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk47"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>k &lt;&gt; ktrm</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">open term k u (tm_var a) = tm_var a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk48"><span class="nb">unfold</span> open.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>k &lt;&gt; ktrm</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">kbindd term k (open_loc k u) (tm_var a) = tm_var a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk49">simplify_kbindd.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>k &lt;&gt; ktrm</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">btgd k (open_loc k u) ktrm ([], a) = tm_var a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk4a">normalize_K.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>LN</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>k &lt;&gt; ktrm</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">btgd k (open_loc k u) ktrm ([], a) = tm_var a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk4b"><span class="kn">Lemma</span> <span class="nf">open_term_rw2</span> : <span class="kr">forall</span> (<span class="nv">œÑ</span> : typ LN) (<span class="nv">t</span> : term LN),
      open term k u (tm_abs œÑ t) =
        tm_abs (open typ k u œÑ) (kbindd term k (open_loc k u ‚¶ø [ktrm]) t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ LN) (<span class="nv">t</span> : term LN),
open term k u (tm_abs œÑ t) =
tm_abs (open typ k u œÑ)
  (kbindd term k (open_loc k u ‚¶ø [ktrm]) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk4c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ LN) (<span class="nv">t</span> : term LN),
open term k u (tm_abs œÑ t) =
tm_abs (open typ k u œÑ)
  (kbindd term k (open_loc k u ‚¶ø [ktrm]) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk4d"><span class="kn">Lemma</span> <span class="nf">open_term_rw3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term LN),
      open term k u (tm_app t1 t2) =
        tm_app (open term k u t1) (open term k u t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term LN,
open term k u (tm_app t1 t2) =
tm_app (open term k u t1) (open term k u t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk4e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term LN,
open term k u (tm_app t1 t2) =
tm_app (open term k u t1) (open term k u t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk4f"><span class="kn">Lemma</span> <span class="nf">open_term_rw4</span> : <span class="kr">forall</span> (<span class="nv">t</span> : term LN),
      open term k u (tm_tab t) =
        tm_tab (kbindd term k (open_loc k u ‚¶ø [ktyp]) t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term LN,
open term k u (tm_tab t) =
tm_tab (kbindd term k (open_loc k u ‚¶ø [ktyp]) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk50"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term LN,
open term k u (tm_tab t) =
tm_tab (kbindd term k (open_loc k u ‚¶ø [ktyp]) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk51"><span class="kn">Lemma</span> <span class="nf">open_term_rw5</span> : <span class="kr">forall</span> (<span class="nv">t</span>: term LN) (<span class="nv">œÑ</span> : typ LN),
      open term k u (tm_tap t œÑ) =
        tm_tap (open term k u t) (open typ k u œÑ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term LN) (<span class="nv">œÑ</span> : typ LN),
open term k u (tm_tap t œÑ) =
tm_tap (open term k u t) (open typ k u œÑ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk52"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term LN) (<span class="nv">œÑ</span> : typ LN),
open term k u (tm_tap t œÑ) =
tm_tap (open term k u t) (open typ k u œÑ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">rw_open</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_LCn_pre_refold_hook</span> :=
  <span class="kp">repeat</span> handle_lc_loc.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_LCn_post_refold_hook</span> :=
  <span class="kp">idtac</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_LCn</span> :=
  <span class="kr">match goal with</span>
  | |- <span class="kp">context</span>[LCn (T := <span class="nl">?T</span>) (ix := <span class="nl">?ix</span>)
                <span class="nl">?U</span> <span class="nl">?k</span> <span class="nl">?n</span> <span class="nl">?t</span>] =&gt;
      <span class="nb">rewrite</span> ?(LCn_to_Forallkd _<span class="c">(*U*)</span> (ix := ix));
      simplify_Forallkd;
      simplify_LCn_pre_refold_hook;
      <span class="nb">rewrite</span> &lt;- ?(LCn_to_Forallkd _ (ix := ix));
      simplify_LCn_post_refold_hook
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** &lt;&lt;LCn&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">rw_LCn</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    (<span class="nv">A</span> : <span class="kt">Type</span>)
      (<span class="nv">k</span> : K2)
      (<span class="nv">n</span>: nat)
      (<span class="nv">x</span>: atom)
      (<span class="nv">u</span>: SystemF k LN).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">tactic_being_tested</span> ::= simplify_LCn.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk53"><span class="kn">Lemma</span> <span class="nf">LCn_type_rw1</span> : <span class="kr">forall</span> <span class="nv">c</span>,
      LCn typ k n (ty_c c) = <span class="kt">True</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : base_typ, LCn typ k n (ty_c c) = <span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk54"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : base_typ, LCn typ k n (ty_c c) = <span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(*</span>
<span class="c">  Lemma LCn_type_rw2_neq : forall (a : A),</span>
<span class="c">      k &lt;&gt; ktyp -&gt;</span>
<span class="c">      LC typ k f (ty_v a) = ty_v a.</span>
<span class="c">  Proof.</span>
<span class="c">    intros.</span>
<span class="c">    simplify_LC.</span>
<span class="c">    rewrite btgd_neq; auto.</span>
<span class="c">  Qed.*)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk55"><span class="kn">Lemma</span> <span class="nf">LCn_type_rw3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : typ LN),
      LCn typ k n (ty_ar t1 t2) =
        (LCn typ k n t1 /\ LCn typ k n t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : typ LN,
LCn typ k n (ty_ar t1 t2) =
(LCn typ k n t1 /\ LCn typ k n t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk56"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : typ LN,
LCn typ k n (ty_ar t1 t2) =
(LCn typ k n t1 /\ LCn typ k n t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk57"><span class="kn">Lemma</span> <span class="nf">LCn_type_rw4_eq</span> : <span class="kr">forall</span> (<span class="nv">body</span> : typ LN),
      k = ktyp -&gt;
      LCn typ k n (ty_univ body) =
        LCn typ k (S n) body.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ LN,
k = ktyp -&gt;
LCn typ k n (ty_univ body) = LCn typ k (S n) body</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk58"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ LN,
k = ktyp -&gt;
LCn typ k n (ty_univ body) = LCn typ k (S n) body</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk59"><span class="kn">Lemma</span> <span class="nf">LCn_type_rw4_neq</span> : <span class="kr">forall</span> (<span class="nv">body</span> : typ LN),
      k &lt;&gt; ktyp -&gt;
      LCn typ k n (ty_univ body) =
        LCn typ k n body.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ LN,
k &lt;&gt; ktyp -&gt;
LCn typ k n (ty_univ body) = LCn typ k n body</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk5a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ LN,
k &lt;&gt; ktyp -&gt;
LCn typ k n (ty_univ body) = LCn typ k n body</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(*</span>
<span class="c">  Lemma LCn_term_rw1_neq : forall (a : LN),</span>
<span class="c">      k &lt;&gt; ktrm -&gt;</span>
<span class="c">      LC term (tm_var a) = tm_var a.</span>
<span class="c">  Proof.</span>
<span class="c">    intros.</span>
<span class="c">    unfold LC.</span>
<span class="c">    simplify_kbindd.</span>
<span class="c">    normalize_K.</span>
<span class="c">  Abort.</span>
<span class="c">  *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk5b"><span class="kn">Lemma</span> <span class="nf">LCn_term_rw2_eq</span> : <span class="kr">forall</span> (<span class="nv">œÑ</span> : typ LN) (<span class="nv">t</span> : term LN),
      k = ktrm -&gt;
      LCn term k n (tm_abs œÑ t) =
        (LCn typ k n œÑ /\ LCn term k (S n) t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ LN) (<span class="nv">t</span> : term LN),
k = ktrm -&gt;
LCn term k n (tm_abs œÑ t) =
(LCn typ k n œÑ /\ LCn term k (S n) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk5c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ LN) (<span class="nv">t</span> : term LN),
k = ktrm -&gt;
LCn term k n (tm_abs œÑ t) =
(LCn typ k n œÑ /\ LCn term k (S n) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk5d"><span class="kn">Lemma</span> <span class="nf">LCn_term_rw2_neq</span> : <span class="kr">forall</span> (<span class="nv">œÑ</span> : typ LN) (<span class="nv">t</span> : term LN),
      k &lt;&gt; ktrm -&gt;
      LCn term k n (tm_abs œÑ t) =
        (LCn typ k n œÑ /\ LCn term k n t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ LN) (<span class="nv">t</span> : term LN),
k &lt;&gt; ktrm -&gt;
LCn term k n (tm_abs œÑ t) =
(LCn typ k n œÑ /\ LCn term k n t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk5e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ LN) (<span class="nv">t</span> : term LN),
k &lt;&gt; ktrm -&gt;
LCn term k n (tm_abs œÑ t) =
(LCn typ k n œÑ /\ LCn term k n t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk5f"><span class="kn">Lemma</span> <span class="nf">LCn_term_rw3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term LN),
      LCn term k n (tm_app t1 t2) =
        (LCn term k n t1 /\ LCn term k n t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term LN,
LCn term k n (tm_app t1 t2) =
(LCn term k n t1 /\ LCn term k n t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk60"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term LN,
LCn term k n (tm_app t1 t2) =
(LCn term k n t1 /\ LCn term k n t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk61"><span class="kn">Lemma</span> <span class="nf">LCn_term_rw4_neq</span> : <span class="kr">forall</span> (<span class="nv">t</span> : term LN),
      k &lt;&gt; ktyp -&gt;
      LCn term k n (tm_tab t) =
        LCn term k n t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term LN,
k &lt;&gt; ktyp -&gt; LCn term k n (tm_tab t) = LCn term k n t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk62"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term LN,
k &lt;&gt; ktyp -&gt; LCn term k n (tm_tab t) = LCn term k n t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk63"><span class="kn">Lemma</span> <span class="nf">LCn_term_rw4_eq</span> : <span class="kr">forall</span> (<span class="nv">t</span> : term LN),
      k = ktyp -&gt;
      LCn term k n (tm_tab t) =
        LCn term k (S n) t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term LN,
k = ktyp -&gt;
LCn term k n (tm_tab t) = LCn term k (S n) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk64"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term LN,
k = ktyp -&gt;
LCn term k n (tm_tab t) = LCn term k (S n) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk65"><span class="kn">Lemma</span> <span class="nf">LCn_term_rw5</span> : <span class="kr">forall</span> (<span class="nv">t</span>: term LN) (<span class="nv">œÑ</span> : typ LN),
      LCn term k n (tm_tap t œÑ) =
        (LCn term k n t /\ LCn typ k n œÑ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term LN) (<span class="nv">œÑ</span> : typ LN),
LCn term k n (tm_tap t œÑ) =
(LCn term k n t /\ LCn typ k n œÑ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk66"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term LN) (<span class="nv">œÑ</span> : typ LN),
LCn term k n (tm_tap t œÑ) =
(LCn term k n t /\ LCn typ k n œÑ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">rw_LCn</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_LC_pre_refold_hook</span> :=
  <span class="kp">idtac</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_LC_post_refold_hook</span> :=
  <span class="kp">idtac</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_LC</span> :=
  <span class="kr">match goal with</span>
  | |- <span class="kp">context</span>[LC (T := <span class="nl">?T</span>) (ix := <span class="nl">?ix</span>)
                <span class="nl">?U</span> <span class="nl">?k</span> <span class="nl">?t</span>] =&gt;
      <span class="nb">unfold</span> LC;
      simplify_LCn;
      <span class="kp">repeat</span> (<span class="nb">change</span> (LCn <span class="nl">?U</span> <span class="nl">?k</span> <span class="mi">0</span>) <span class="kr">with</span> (LC U k))
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** &lt;&lt;LC&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">rw_LC</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    (<span class="nv">A</span> : <span class="kt">Type</span>)
      (<span class="nv">k</span> : K2)
      (<span class="nv">n</span>: nat)
      (<span class="nv">x</span>: atom)
      (<span class="nv">u</span>: SystemF k LN).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">tactic_being_tested</span> ::= simplify_LC.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk67"><span class="kn">Lemma</span> <span class="nf">LC_type_rw1</span> : <span class="kr">forall</span> <span class="nv">c</span>,
      LC typ k (ty_c c) = <span class="kt">True</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : base_typ, LC typ k (ty_c c) = <span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk68"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : base_typ, LC typ k (ty_c c) = <span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk69"><span class="kn">Lemma</span> <span class="nf">LC_type_rw3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : typ LN),
      LC typ k (ty_ar t1 t2) =
        (LC typ k t1 /\ LC typ k t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : typ LN,
LC typ k (ty_ar t1 t2) = (LC typ k t1 /\ LC typ k t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk6a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : typ LN,
LC typ k (ty_ar t1 t2) = (LC typ k t1 /\ LC typ k t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk6b"><span class="kn">Lemma</span> <span class="nf">LC_type_rw4_eq</span> : <span class="kr">forall</span> (<span class="nv">body</span> : typ LN),
      k = ktyp -&gt;
      LC typ k (ty_univ body) =
        LCn typ k <span class="mi">1</span> body.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ LN,
k = ktyp -&gt; LC typ k (ty_univ body) = LCn typ k <span class="mi">1</span> body</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk6c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ LN,
k = ktyp -&gt; LC typ k (ty_univ body) = LCn typ k <span class="mi">1</span> body</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk6d"><span class="kn">Lemma</span> <span class="nf">LC_type_rw4_neq</span> : <span class="kr">forall</span> (<span class="nv">body</span> : typ LN),
      k &lt;&gt; ktyp -&gt;
      LC typ k (ty_univ body) =
        LC typ k body.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ LN,
k &lt;&gt; ktyp -&gt; LC typ k (ty_univ body) = LC typ k body</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk6e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ LN,
k &lt;&gt; ktyp -&gt; LC typ k (ty_univ body) = LC typ k body</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk6f"><span class="kn">Lemma</span> <span class="nf">LC_term_rw2_eq</span> : <span class="kr">forall</span> (<span class="nv">œÑ</span> : typ LN) (<span class="nv">t</span> : term LN),
      k = ktrm -&gt;
      LC term k (tm_abs œÑ t) =
        (LC typ k œÑ /\ LCn term k <span class="mi">1</span> t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ LN) (<span class="nv">t</span> : term LN),
k = ktrm -&gt;
LC term k (tm_abs œÑ t) =
(LC typ k œÑ /\ LCn term k <span class="mi">1</span> t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk70"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ LN) (<span class="nv">t</span> : term LN),
k = ktrm -&gt;
LC term k (tm_abs œÑ t) =
(LC typ k œÑ /\ LCn term k <span class="mi">1</span> t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk71"><span class="kn">Lemma</span> <span class="nf">LC_term_rw2_neq</span> : <span class="kr">forall</span> (<span class="nv">œÑ</span> : typ LN) (<span class="nv">t</span> : term LN),
      k &lt;&gt; ktrm -&gt;
      LC term k (tm_abs œÑ t) =
        (LC typ k œÑ /\ LC term k t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ LN) (<span class="nv">t</span> : term LN),
k &lt;&gt; ktrm -&gt;
LC term k (tm_abs œÑ t) = (LC typ k œÑ /\ LC term k t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk72"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ LN) (<span class="nv">t</span> : term LN),
k &lt;&gt; ktrm -&gt;
LC term k (tm_abs œÑ t) = (LC typ k œÑ /\ LC term k t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk73"><span class="kn">Lemma</span> <span class="nf">LC_term_rw3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term LN),
      LC term k (tm_app t1 t2) =
        (LC term k t1 /\ LC term k t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term LN,
LC term k (tm_app t1 t2) =
(LC term k t1 /\ LC term k t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk74"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term LN,
LC term k (tm_app t1 t2) =
(LC term k t1 /\ LC term k t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk75"><span class="kn">Lemma</span> <span class="nf">LC_term_rw4_neq</span> : <span class="kr">forall</span> (<span class="nv">t</span> : term LN),
      k &lt;&gt; ktyp -&gt;
      LC term k (tm_tab t) =
        LC term k t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term LN,
k &lt;&gt; ktyp -&gt; LC term k (tm_tab t) = LC term k t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk76"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term LN,
k &lt;&gt; ktyp -&gt; LC term k (tm_tab t) = LC term k t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk77"><span class="kn">Lemma</span> <span class="nf">LC_term_rw4_eq</span> : <span class="kr">forall</span> (<span class="nv">t</span> : term LN),
      k = ktyp -&gt;
      LC term k (tm_tab t) =
        LCn term k <span class="mi">1</span> t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term LN,
k = ktyp -&gt; LC term k (tm_tab t) = LCn term k <span class="mi">1</span> t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk78"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term LN,
k = ktyp -&gt; LC term k (tm_tab t) = LCn term k <span class="mi">1</span> t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk79"><span class="kn">Lemma</span> <span class="nf">LC_term_rw5</span> : <span class="kr">forall</span> (<span class="nv">t</span>: term LN) (<span class="nv">œÑ</span> : typ LN),
      LC term k (tm_tap t œÑ) =
        (LC term k t /\ LC typ k œÑ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term LN) (<span class="nv">œÑ</span> : typ LN),
LC term k (tm_tap t œÑ) = (LC term k t /\ LC typ k œÑ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk7a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term LN) (<span class="nv">œÑ</span> : typ LN),
LC term k (tm_tap t œÑ) = (LC term k t /\ LC typ k œÑ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">rw_LC</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_subst_pre_refold_hook</span> :=
  <span class="kp">idtac</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_subst_post_refold_hook</span> :=
  <span class="kp">idtac</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_subst</span> :=
  <span class="kr">match goal with</span>
  | |- <span class="kp">context</span>[<span class="nb">subst</span> (T := <span class="nl">?T</span>) (ix := <span class="nl">?ix</span>)
                <span class="nl">?U</span> <span class="nl">?k</span> <span class="nl">?t</span>] =&gt;
      <span class="nb">rewrite</span> ?(subst_to_kbind);
      simplify_kbind;
      <span class="nb">rewrite</span> &lt;- ?(subst_to_kbind)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** &lt;&lt;subst&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">rw_subst</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    (<span class="nv">A</span> : <span class="kt">Type</span>)
      (<span class="nv">k</span> : K2)
      (<span class="nv">n</span>: nat)
      (<span class="nv">x</span>: atom)
      (<span class="nv">u</span>: SystemF k LN).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">tactic_being_tested</span> ::= simplify_subst.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk7b"><span class="kn">Lemma</span> <span class="nf">subst_type_rw1</span> : <span class="kr">forall</span> <span class="nv">c</span>,
      <span class="nb">subst</span> typ k x u (ty_c c) = ty_c c.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : base_typ, <span class="nb">subst</span> typ k x u (ty_c c) = ty_c c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk7c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : base_typ, <span class="nb">subst</span> typ k x u (ty_c c) = ty_c c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk7d"><span class="kn">Lemma</span> <span class="nf">subst_type_rw3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : typ LN),
      <span class="nb">subst</span> typ k x u (ty_ar t1 t2) =
        ty_ar (<span class="nb">subst</span> typ k x u t1) (<span class="nb">subst</span> typ k x u t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : typ LN,
<span class="nb">subst</span> typ k x u (ty_ar t1 t2) =
ty_ar (<span class="nb">subst</span> typ k x u t1) (<span class="nb">subst</span> typ k x u t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk7e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : typ LN,
<span class="nb">subst</span> typ k x u (ty_ar t1 t2) =
ty_ar (<span class="nb">subst</span> typ k x u t1) (<span class="nb">subst</span> typ k x u t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk7f"><span class="kn">Lemma</span> <span class="nf">subst_type_rw4</span> : <span class="kr">forall</span> (<span class="nv">body</span> : typ LN),
      <span class="nb">subst</span> typ k x u (ty_univ body) =
        ty_univ (<span class="nb">subst</span> typ k x u body).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ LN,
<span class="nb">subst</span> typ k x u (ty_univ body) =
ty_univ (<span class="nb">subst</span> typ k x u body)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk80"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ LN,
<span class="nb">subst</span> typ k x u (ty_univ body) =
ty_univ (<span class="nb">subst</span> typ k x u body)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk81"><span class="kn">Lemma</span> <span class="nf">subst_term_rw2_eq</span> : <span class="kr">forall</span> (<span class="nv">œÑ</span> : typ LN) (<span class="nv">t</span> : term LN),
      <span class="nb">subst</span> term k x u (tm_abs œÑ t) =
        tm_abs (<span class="nb">subst</span> typ k x u œÑ) (<span class="nb">subst</span> term k x u t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ LN) (<span class="nv">t</span> : term LN),
<span class="nb">subst</span> term k x u (tm_abs œÑ t) =
tm_abs (<span class="nb">subst</span> typ k x u œÑ) (<span class="nb">subst</span> term k x u t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk82"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ LN) (<span class="nv">t</span> : term LN),
<span class="nb">subst</span> term k x u (tm_abs œÑ t) =
tm_abs (<span class="nb">subst</span> typ k x u œÑ) (<span class="nb">subst</span> term k x u t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk83"><span class="kn">Lemma</span> <span class="nf">subst_term_rw2</span> : <span class="kr">forall</span> (<span class="nv">œÑ</span> : typ LN) (<span class="nv">t</span> : term LN),
      <span class="nb">subst</span> term k x u (tm_abs œÑ t) =
        tm_abs (<span class="nb">subst</span> typ k x u œÑ) (<span class="nb">subst</span> term k x u t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ LN) (<span class="nv">t</span> : term LN),
<span class="nb">subst</span> term k x u (tm_abs œÑ t) =
tm_abs (<span class="nb">subst</span> typ k x u œÑ) (<span class="nb">subst</span> term k x u t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk84"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ LN) (<span class="nv">t</span> : term LN),
<span class="nb">subst</span> term k x u (tm_abs œÑ t) =
tm_abs (<span class="nb">subst</span> typ k x u œÑ) (<span class="nb">subst</span> term k x u t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk85"><span class="kn">Lemma</span> <span class="nf">subst_term_rw3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term LN),
      <span class="nb">subst</span> term k x u (tm_app t1 t2) =
        tm_app (<span class="nb">subst</span> term k x u t1) (<span class="nb">subst</span> term k x u t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term LN,
<span class="nb">subst</span> term k x u (tm_app t1 t2) =
tm_app (<span class="nb">subst</span> term k x u t1) (<span class="nb">subst</span> term k x u t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk86"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term LN,
<span class="nb">subst</span> term k x u (tm_app t1 t2) =
tm_app (<span class="nb">subst</span> term k x u t1) (<span class="nb">subst</span> term k x u t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk87"><span class="kn">Lemma</span> <span class="nf">subst_term_rw4</span> : <span class="kr">forall</span> (<span class="nv">t</span> : term LN),
      <span class="nb">subst</span> term k x u (tm_tab t) =
        tm_tab (<span class="nb">subst</span> term k x u t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term LN,
<span class="nb">subst</span> term k x u (tm_tab t) =
tm_tab (<span class="nb">subst</span> term k x u t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk88"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term LN,
<span class="nb">subst</span> term k x u (tm_tab t) =
tm_tab (<span class="nb">subst</span> term k x u t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk89"><span class="kn">Lemma</span> <span class="nf">subst_term_rw5</span> : <span class="kr">forall</span> (<span class="nv">t</span>: term LN) (<span class="nv">œÑ</span> : typ LN),
      <span class="nb">subst</span> term k x u (tm_tap t œÑ) =
        tm_tap (<span class="nb">subst</span> term k x u t) (<span class="nb">subst</span> typ k x u œÑ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term LN) (<span class="nv">œÑ</span> : typ LN),
<span class="nb">subst</span> term k x u (tm_tap t œÑ) =
tm_tap (<span class="nb">subst</span> term k x u t) (<span class="nb">subst</span> typ k x u œÑ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk8a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term LN) (<span class="nv">œÑ</span> : typ LN),
<span class="nb">subst</span> term k x u (tm_tap t œÑ) =
tm_tap (<span class="nb">subst</span> term k x u t) (<span class="nb">subst</span> typ k x u œÑ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">rw_subst</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_free_pre_refold_hook</span> :=
  <span class="kp">idtac</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_free_post_refold_hook</span> :=
  unfold_ops @Monoid_op_list;
  unfold_ops @Monoid_unit_list.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">handle_free_at_leaf</span> :=
  (<span class="kr">match goal with</span>
   | |- <span class="kp">context</span>[EqDec_eq_of_EqDec <span class="nl">?Keq</span> <span class="nl">?k1</span> <span class="nl">?k2</span>] =&gt;
       <span class="nb">destruct</span> (EqDec_eq_of_EqDec Keq k1 k2);
       <span class="kp">try</span> <span class="bp">easy</span>
   <span class="kr">end</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_free</span> :=
  <span class="kr">match goal with</span>
  | |- <span class="kp">context</span>[free (T := <span class="nl">?T</span>) (ix := <span class="nl">?ix</span>)
                <span class="nl">?U</span> <span class="nl">?k</span> <span class="nl">?t</span>] =&gt;
      <span class="nb">rewrite</span> ?(free_to_foldMapk _ (ix := ix));
      simplify_foldMapk;
      simplify_free_pre_refold_hook;
      <span class="nb">rewrite</span> &lt;- ?(free_to_foldMapk _ (ix := ix));
      simplify_free_post_refold_hook;
      <span class="kp">try</span> <span class="kp">solve</span> [handle_free_at_leaf]
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** &lt;&lt;free&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">rw_free</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    (<span class="nv">A</span> : <span class="kt">Type</span>)
      (<span class="nv">k</span> : K2)
      (<span class="nv">n</span>: nat)
      (<span class="nv">x</span>: atom)
      (<span class="nv">u</span>: SystemF k LN).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">tactic_being_tested</span> ::= simplify_free.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk8b"><span class="kn">Lemma</span> <span class="nf">free_type_rw1</span> : <span class="kr">forall</span> <span class="nv">c</span>,
      free typ k (ty_c c) = nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : base_typ, free typ k (ty_c c) = []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk8c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : base_typ, free typ k (ty_c c) = []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk8d"><span class="kn">Lemma</span> <span class="nf">free_type_rw2_atom_eq</span> : <span class="kr">forall</span> (<span class="nv">x</span>: atom),
      k = ktyp -&gt;
      free typ k (ty_v (Fr x)) = [ x ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : atom,
k = ktyp -&gt; free typ k (ty_v (Fr x)) = [x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk8e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : atom,
k = ktyp -&gt; free typ k (ty_v (Fr x)) = [x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk8f"><span class="kn">Lemma</span> <span class="nf">free_type_rw2_atom</span> : <span class="kr">forall</span> (<span class="nv">x</span>: atom),
      k &lt;&gt; ktyp -&gt;
      free typ k (ty_v (Fr x)) = [ ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : atom,
k &lt;&gt; ktyp -&gt; free typ k (ty_v (Fr x)) = []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk90"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : atom,
k &lt;&gt; ktyp -&gt; free typ k (ty_v (Fr x)) = []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk91"><span class="kn">Lemma</span> <span class="nf">free_type_rw2_bound</span> : <span class="kr">forall</span> <span class="nv">n</span>,
      free typ k (ty_v (Bd n)) = [ ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat, free typ k (ty_v (Bd n)) = []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk92"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat, free typ k (ty_v (Bd n)) = []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk93"><span class="kn">Lemma</span> <span class="nf">free_type_rw3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : typ LN),
      free typ k (ty_ar t1 t2) =
        free typ k t1 ++ free typ k t2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : typ LN,
free typ k (ty_ar t1 t2) =
free typ k t1 ++ free typ k t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk94"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : typ LN,
free typ k (ty_ar t1 t2) =
free typ k t1 ++ free typ k t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk95"><span class="kn">Lemma</span> <span class="nf">free_type_rw4</span> : <span class="kr">forall</span> (<span class="nv">body</span> : typ LN),
      free typ k (ty_univ body) =
        free typ k body.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ LN,
free typ k (ty_univ body) = free typ k body</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk96"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ LN,
free typ k (ty_univ body) = free typ k body</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk97"><span class="kn">Lemma</span> <span class="nf">free_term_rw2_eq</span> : <span class="kr">forall</span> (<span class="nv">œÑ</span> : typ LN) (<span class="nv">t</span> : term LN),
      free term k (tm_abs œÑ t) =
        free typ k œÑ ++ free term k t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ LN) (<span class="nv">t</span> : term LN),
free term k (tm_abs œÑ t) =
free typ k œÑ ++ free term k t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk98"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ LN) (<span class="nv">t</span> : term LN),
free term k (tm_abs œÑ t) =
free typ k œÑ ++ free term k t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk99"><span class="kn">Lemma</span> <span class="nf">free_term_rw2</span> : <span class="kr">forall</span> (<span class="nv">œÑ</span> : typ LN) (<span class="nv">t</span> : term LN),
      free term k (tm_abs œÑ t) =
        free typ k œÑ ++ free term k t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ LN) (<span class="nv">t</span> : term LN),
free term k (tm_abs œÑ t) =
free typ k œÑ ++ free term k t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk9a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ LN) (<span class="nv">t</span> : term LN),
free term k (tm_abs œÑ t) =
free typ k œÑ ++ free term k t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk9b"><span class="kn">Lemma</span> <span class="nf">free_term_rw3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term LN),
      free term k (tm_app t1 t2) =
        free term k t1 ++ free term k t2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term LN,
free term k (tm_app t1 t2) =
free term k t1 ++ free term k t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk9c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term LN,
free term k (tm_app t1 t2) =
free term k t1 ++ free term k t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk9d"><span class="kn">Lemma</span> <span class="nf">free_term_rw4</span> : <span class="kr">forall</span> (<span class="nv">t</span> : term LN),
      free term k (tm_tab t) =
        free term k t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term LN,
free term k (tm_tab t) = free term k t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk9e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term LN,
free term k (tm_tab t) = free term k t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chk9f"><span class="kn">Lemma</span> <span class="nf">free_term_rw5</span> : <span class="kr">forall</span> (<span class="nv">t</span>: term LN) (<span class="nv">œÑ</span> : typ LN),
      free term k (tm_tap t œÑ) =
        free term k t ++ free typ k œÑ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term LN) (<span class="nv">œÑ</span> : typ LN),
free term k (tm_tap t œÑ) =
free term k t ++ free typ k œÑ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chka0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term LN) (<span class="nv">œÑ</span> : typ LN),
free term k (tm_tap t œÑ) =
free term k t ++ free typ k œÑ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">rw_free</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">assert_identical_with_atoms</span> :=
    <span class="kr">match goal with</span>
    | |- <span class="nl">?x</span> [=] <span class="nl">?x</span> =&gt;
        ltac_trace <span class="s2">&quot;Both sides identical:&quot;</span>;
        print_goal
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">test_simplification_with_atoms</span> :=
  <span class="nb">intros</span>;
  tactic_being_tested;
  <span class="kp">try</span> normalize_K;
  <span class="bp">now</span> assert_identical_with_atoms.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_FV_pre_refold_hook</span> :=
  <span class="nb">autorewrite with</span> tea_rw_atoms.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_FV_post_refold_hook</span> :=
  <span class="kp">idtac</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_FV</span> :=
  <span class="kr">match goal with</span>
  | |- <span class="kp">context</span>[FV (T := <span class="nl">?T</span>) (ix := <span class="nl">?ix</span>)
                <span class="nl">?U</span> <span class="nl">?k</span> <span class="nl">?t</span>] =&gt;
      <span class="nb">rewrite</span> ?(FV_to_free _ (ix := ix));
      simplify_free;
      simplify_FV_pre_refold_hook;
      <span class="nb">rewrite</span> &lt;- ?(FV_to_free _ (ix := ix));
      simplify_FV_post_refold_hook
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** &lt;&lt;FV&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">rw_FV</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    (<span class="nv">A</span> : <span class="kt">Type</span>)
      (<span class="nv">k</span> : K2)
      (<span class="nv">n</span>: nat)
      (<span class="nv">x</span>: atom)
      (<span class="nv">u</span>: SystemF k LN).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">tactic_being_tested</span> ::= simplify_FV.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Open Scope</span> set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chka1"><span class="kn">Lemma</span> <span class="nf">FV_type_rw1</span> : <span class="kr">forall</span> <span class="nv">c</span>,
      FV typ k (ty_c c) [=] ‚àÖ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : base_typ, FV typ k (ty_c c) [=] ‚àÖ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chka2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : base_typ, FV typ k (ty_c c) [=] ‚àÖ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification_with_atoms.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chka3"><span class="kn">Lemma</span> <span class="nf">FV_type_rw2_atom</span> : <span class="kr">forall</span> (<span class="nv">x</span>: atom),
      k = ktyp -&gt;
      FV typ k (ty_v (Fr x)) [=] {{ x }}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : atom,
k = ktyp -&gt; FV typ k (ty_v (Fr x)) [=] {{x}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chka4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : atom,
k = ktyp -&gt; FV typ k (ty_v (Fr x)) [=] {{x}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification_with_atoms.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chka5"><span class="kn">Lemma</span> <span class="nf">FV_type_rw3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : typ LN),
      FV typ k (ty_ar t1 t2) [=]
        FV typ k t1 ‚à™ FV typ k t2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : typ LN,
FV typ k (ty_ar t1 t2) [=] FV typ k t1 ‚à™ FV typ k t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chka6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : typ LN,
FV typ k (ty_ar t1 t2) [=] FV typ k t1 ‚à™ FV typ k t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification_with_atoms.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chka7"><span class="kn">Lemma</span> <span class="nf">FV_type_rw4</span> : <span class="kr">forall</span> (<span class="nv">body</span> : typ LN),
      FV typ k (ty_univ body) [=]
        FV typ k body.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ LN,
FV typ k (ty_univ body) [=] FV typ k body</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chka8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ LN,
FV typ k (ty_univ body) [=] FV typ k body</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification_with_atoms.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chka9"><span class="kn">Lemma</span> <span class="nf">FV_term_rw2_eq</span> : <span class="kr">forall</span> (<span class="nv">œÑ</span> : typ LN) (<span class="nv">t</span> : term LN),
      FV term k (tm_abs œÑ t) [=]
        FV typ k œÑ ‚à™ FV term k t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ LN) (<span class="nv">t</span> : term LN),
FV term k (tm_abs œÑ t) [=] FV typ k œÑ ‚à™ FV term k t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkaa"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ LN) (<span class="nv">t</span> : term LN),
FV term k (tm_abs œÑ t) [=] FV typ k œÑ ‚à™ FV term k t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification_with_atoms.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkab"><span class="kn">Lemma</span> <span class="nf">FV_term_rw2</span> : <span class="kr">forall</span> (<span class="nv">œÑ</span> : typ LN) (<span class="nv">t</span> : term LN),
      FV term k (tm_abs œÑ t) [=]
        FV typ k œÑ ‚à™ FV term k t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ LN) (<span class="nv">t</span> : term LN),
FV term k (tm_abs œÑ t) [=] FV typ k œÑ ‚à™ FV term k t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkac"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ LN) (<span class="nv">t</span> : term LN),
FV term k (tm_abs œÑ t) [=] FV typ k œÑ ‚à™ FV term k t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification_with_atoms.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkad"><span class="kn">Lemma</span> <span class="nf">FV_term_rw3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term LN),
      FV term k (tm_app t1 t2) [=]
        FV term k t1 ‚à™ FV term k t2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term LN,
FV term k (tm_app t1 t2)
[=] FV term k t1 ‚à™ FV term k t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkae"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term LN,
FV term k (tm_app t1 t2)
[=] FV term k t1 ‚à™ FV term k t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification_with_atoms.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkaf"><span class="kn">Lemma</span> <span class="nf">FV_term_rw4</span> : <span class="kr">forall</span> (<span class="nv">t</span> : term LN),
      FV term k (tm_tab t) [=]
        FV term k t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term LN,
FV term k (tm_tab t) [=] FV term k t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkb0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term LN,
FV term k (tm_tab t) [=] FV term k t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification_with_atoms.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkb1"><span class="kn">Lemma</span> <span class="nf">FV_term_rw5</span> : <span class="kr">forall</span> (<span class="nv">t</span>: term LN) (<span class="nv">œÑ</span> : typ LN),
      FV term k (tm_tap t œÑ) [=]
        FV term k t ‚à™ FV typ k œÑ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term LN) (<span class="nv">œÑ</span> : typ LN),
FV term k (tm_tap t œÑ) [=] FV term k t ‚à™ FV typ k œÑ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkb2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term LN) (<span class="nv">œÑ</span> : typ LN),
FV term k (tm_tap t œÑ) [=] FV term k t ‚à™ FV typ k œÑ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification_with_atoms.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">rw_FV</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_scoped_pre_refold_hook</span> :=
  <span class="kp">idtac</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_scoped_post_refold_hook</span> :=
  <span class="kp">idtac</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_scoped</span> :=
  <span class="kr">match goal with</span>
  | |- <span class="kp">context</span>[scoped (T := <span class="nl">?T</span>) (ix := <span class="nl">?ix</span>)
                <span class="nl">?U</span> <span class="nl">?k</span> <span class="nl">?n</span> <span class="nl">?t</span>] =&gt;
      <span class="kp">idtac</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(*</span>
<span class="c">      rewrite ?(scoped_to_Forallkd _(*U*) (ix := ix));</span>
<span class="c">      simplify_Forallkd;</span>
<span class="c">      simplify_scoped_pre_refold_hook;</span>
<span class="c">      rewrite &lt;- ?(scoped_to_Forallkd _ (ix := ix));</span>
<span class="c">      simplify_scoped_post_refold_hook</span>
<span class="c">*)</span>

<span class="sd">(** ** &lt;&lt;scoped&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">rw_scoped</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    (<span class="nv">A</span> : <span class="kt">Type</span>)
      (<span class="nv">k</span> : K2)
      (<span class="nv">Œì</span> : AtomSet.t)
      (<span class="nv">u</span>: SystemF k LN).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">tactic_being_tested</span> ::= simplify_scoped.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkb3"><span class="kn">Lemma</span> <span class="nf">scoped_type_rw1</span> : <span class="kr">forall</span> <span class="nv">c</span>,
      scoped typ k (ty_c c) Œì &lt;-&gt; <span class="kt">True</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : base_typ, scoped typ k (ty_c c) Œì &lt;-&gt; <span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkb4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : base_typ, scoped typ k (ty_c c) Œì &lt;-&gt; <span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkb5"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scoped typ k (ty_c c) Œì &lt;-&gt; <span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkb6"><span class="nb">unfold</span> scoped.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV typ k (ty_c c) ‚äÜ Œì &lt;-&gt; <span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkb7">simplify_FV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">‚àÖ%<span class="nb">set</span> ‚äÜ Œì &lt;-&gt; <span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">split</span>; fsetdec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(*</span>
<span class="c">  Lemma scoped_type_rw2_neq : forall (a : A),</span>
<span class="c">      k &lt;&gt; ktyp -&gt;</span>
<span class="c">      LC typ k f (ty_v a) = ty_v a.</span>
<span class="c">  Proof.</span>
<span class="c">    intros.</span>
<span class="c">    simplify_LC.</span>
<span class="c">    rewrite btgd_neq; auto.</span>
<span class="c">  Qed.*)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkb8"><span class="kn">Lemma</span> <span class="nf">scoped_type_rw3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : typ LN),
      scoped typ k (ty_ar t1 t2) Œì &lt;-&gt;
        (scoped typ k t1 Œì /\ scoped typ k t2 Œì).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : typ LN,
scoped typ k (ty_ar t1 t2) Œì &lt;-&gt;
scoped typ k t1 Œì /\ scoped typ k t2 Œì</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkb9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : typ LN,
scoped typ k (ty_ar t1 t2) Œì &lt;-&gt;
scoped typ k t1 Œì /\ scoped typ k t2 Œì</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkba"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scoped typ k (ty_ar t1 t2) Œì &lt;-&gt;
scoped typ k t1 Œì /\ scoped typ k t2 Œì</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkbb"><span class="nb">unfold</span> scoped.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV typ k (ty_ar t1 t2) ‚äÜ Œì &lt;-&gt;
FV typ k t1 ‚äÜ Œì /\ FV typ k t2 ‚äÜ Œì</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkbc">simplify_FV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(FV typ k t1 ‚à™ FV typ k t2)%<span class="nb">set</span> ‚äÜ Œì &lt;-&gt;
FV typ k t1 ‚äÜ Œì /\ FV typ k t2 ‚äÜ Œì</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intuition</span> fsetdec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkbd"><span class="kn">Lemma</span> <span class="nf">scoped_type_rw4_eq</span> : <span class="kr">forall</span> (<span class="nv">body</span> : typ LN),
      scoped typ k (ty_univ body) Œì &lt;-&gt;
        scoped typ k body Œì.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ LN,
scoped typ k (ty_univ body) Œì &lt;-&gt; scoped typ k body Œì</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkbe"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ LN,
scoped typ k (ty_univ body) Œì &lt;-&gt; scoped typ k body Œì</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkbf"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scoped typ k (ty_univ body) Œì &lt;-&gt; scoped typ k body Œì</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkc0"><span class="nb">unfold</span> scoped.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV typ k (ty_univ body) ‚äÜ Œì &lt;-&gt; FV typ k body ‚äÜ Œì</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkc1">simplify_FV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV typ k body ‚äÜ Œì &lt;-&gt; FV typ k body ‚äÜ Œì</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intuition</span> fsetdec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkc2"><span class="kn">Lemma</span> <span class="nf">scoped_type_rw4_neq</span> : <span class="kr">forall</span> (<span class="nv">body</span> : typ LN),
      scoped typ k (ty_univ body) =
        scoped typ k body.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ LN,
scoped typ k (ty_univ body) = scoped typ k body</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkc3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ LN,
scoped typ k (ty_univ body) = scoped typ k body</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkc4"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scoped typ k (ty_univ body) = scoped typ k body</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkc5"><span class="nb">unfold</span> scoped.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">Œ≥</span> : AtomSet.t =&gt; FV typ k (ty_univ body) ‚äÜ Œ≥) =
(<span class="kr">fun</span> <span class="nv">Œ≥</span> : AtomSet.t =&gt; FV typ k body ‚äÜ Œ≥)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkc6">simplify_FV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">Œ≥</span> : AtomSet.t =&gt; FV typ k body ‚äÜ Œ≥) =
(<span class="kr">fun</span> <span class="nv">Œ≥</span> : AtomSet.t =&gt; FV typ k body ‚äÜ Œ≥)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">conclude.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Open Scope</span> set_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkc7"><span class="kn">Lemma</span> <span class="nf">scoped_term_rw1_eq</span> : <span class="kr">forall</span> (<span class="nv">x</span> : atom),
      k = ktrm -&gt;
      scoped term k (tm_var (Fr x)) Œì = ({{x}} ‚äÜ Œì).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : atom,
k = ktrm -&gt;
scoped term k (tm_var (Fr x)) Œì = ({{x}} ‚äÜ Œì)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkc8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : atom,
k = ktrm -&gt;
scoped term k (tm_var (Fr x)) Œì = ({{x}} ‚äÜ Œì)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkc9"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>k = ktrm</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scoped term k (tm_var (Fr x)) Œì = ({{x}} ‚äÜ Œì)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkca"><span class="nb">unfold</span> scoped.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>k = ktrm</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(FV term k (tm_var (Fr x)) ‚äÜ Œì) = ({{x}} ‚äÜ Œì)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">simplify_FV.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkcb"><span class="kn">Lemma</span> <span class="nf">scoped_term_rw1_neq</span> : <span class="kr">forall</span> (<span class="nv">x</span> : atom),
      k &lt;&gt; ktrm -&gt;
      scoped term k (tm_var (Fr x)) Œì = <span class="kt">True</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : atom,
k &lt;&gt; ktrm -&gt; scoped term k (tm_var (Fr x)) Œì = <span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkcc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : atom,
k &lt;&gt; ktrm -&gt; scoped term k (tm_var (Fr x)) Œì = <span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkcd"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>k &lt;&gt; ktrm</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scoped term k (tm_var (Fr x)) Œì = <span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkce"><span class="nb">unfold</span> scoped.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>k &lt;&gt; ktrm</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(FV term k (tm_var (Fr x)) ‚äÜ Œì) = <span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">propext; simplify_FV.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkcf"><span class="kn">Lemma</span> <span class="nf">scoped_term_rw2</span>: <span class="kr">forall</span> (<span class="nv">œÑ</span> : typ LN) (<span class="nv">t</span> : term LN),
      scoped term k (tm_abs œÑ t) Œì &lt;-&gt;
        (scoped typ k œÑ Œì /\ scoped term k t Œì).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ LN) (<span class="nv">t</span> : term LN),
scoped term k (tm_abs œÑ t) Œì &lt;-&gt;
scoped typ k œÑ Œì /\ scoped term k t Œì</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkd0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ LN) (<span class="nv">t</span> : term LN),
scoped term k (tm_abs œÑ t) Œì &lt;-&gt;
scoped typ k œÑ Œì /\ scoped term k t Œì</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkd1"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br><span><var>œÑ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scoped term k (tm_abs œÑ t) Œì &lt;-&gt;
scoped typ k œÑ Œì /\ scoped term k t Œì</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkd2"><span class="nb">unfold</span> scoped.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br><span><var>œÑ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term k (tm_abs œÑ t) ‚äÜ Œì &lt;-&gt;
FV typ k œÑ ‚äÜ Œì /\ FV term k t ‚äÜ Œì</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkd3">simplify_FV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br><span><var>œÑ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV typ k œÑ ‚à™ FV term k t ‚äÜ Œì &lt;-&gt;
FV typ k œÑ ‚äÜ Œì /\ FV term k t ‚äÜ Œì</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intuition</span> fsetdec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkd4"><span class="kn">Lemma</span> <span class="nf">scoped_term_rw3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term LN),
      scoped term k (tm_app t1 t2) Œì &lt;-&gt;
        (scoped term k t1 Œì /\ scoped term k t2 Œì).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term LN,
scoped term k (tm_app t1 t2) Œì &lt;-&gt;
scoped term k t1 Œì /\ scoped term k t2 Œì</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkd5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term LN,
scoped term k (tm_app t1 t2) Œì &lt;-&gt;
scoped term k t1 Œì /\ scoped term k t2 Œì</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkd6"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scoped term k (tm_app t1 t2) Œì &lt;-&gt;
scoped term k t1 Œì /\ scoped term k t2 Œì</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkd7"><span class="nb">unfold</span> scoped.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term k (tm_app t1 t2) ‚äÜ Œì &lt;-&gt;
FV term k t1 ‚äÜ Œì /\ FV term k t2 ‚äÜ Œì</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkd8">simplify_FV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term k t1 ‚à™ FV term k t2 ‚äÜ Œì &lt;-&gt;
FV term k t1 ‚äÜ Œì /\ FV term k t2 ‚äÜ Œì</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intuition</span> fsetdec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkd9"><span class="kn">Lemma</span> <span class="nf">scoped_term_rw4_neq</span> : <span class="kr">forall</span> (<span class="nv">t</span> : term LN),
      scoped term k (tm_tab t) Œì &lt;-&gt;
        scoped term k t Œì.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term LN,
scoped term k (tm_tab t) Œì &lt;-&gt; scoped term k t Œì</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkda"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term LN,
scoped term k (tm_tab t) Œì &lt;-&gt; scoped term k t Œì</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkdb"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scoped term k (tm_tab t) Œì &lt;-&gt; scoped term k t Œì</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkdc"><span class="nb">unfold</span> scoped.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term k (tm_tab t) ‚äÜ Œì &lt;-&gt; FV term k t ‚äÜ Œì</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkdd">simplify_FV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term k t ‚äÜ Œì &lt;-&gt; FV term k t ‚äÜ Œì</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intuition</span> fsetdec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkde"><span class="kn">Lemma</span> <span class="nf">scoped_term_rw4_eq</span> : <span class="kr">forall</span> (<span class="nv">t</span> : term LN),
      scoped term k (tm_tab t) Œì &lt;-&gt;
        scoped term k t Œì.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term LN,
scoped term k (tm_tab t) Œì &lt;-&gt; scoped term k t Œì</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chkdf"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term LN,
scoped term k (tm_tab t) Œì &lt;-&gt; scoped term k t Œì</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chke0"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scoped term k (tm_tab t) Œì &lt;-&gt; scoped term k t Œì</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chke1"><span class="nb">unfold</span> scoped.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term k (tm_tab t) ‚äÜ Œì &lt;-&gt; FV term k t ‚äÜ Œì</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chke2">simplify_FV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term k t ‚äÜ Œì &lt;-&gt; FV term k t ‚äÜ Œì</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intuition</span> fsetdec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chke3"><span class="kn">Lemma</span> <span class="nf">scoped_term_rw5</span> : <span class="kr">forall</span> (<span class="nv">t</span>: term LN) (<span class="nv">œÑ</span> : typ LN),
      scoped term k (tm_tap t œÑ) Œì &lt;-&gt;
        (scoped term k t Œì /\ scoped typ k œÑ Œì).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term LN) (<span class="nv">œÑ</span> : typ LN),
scoped term k (tm_tap t œÑ) Œì &lt;-&gt;
scoped term k t Œì /\ scoped typ k œÑ Œì</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chke4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term LN) (<span class="nv">œÑ</span> : typ LN),
scoped term k (tm_tap t œÑ) Œì &lt;-&gt;
scoped term k t Œì /\ scoped typ k œÑ Œì</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chke5"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>œÑ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scoped term k (tm_tap t œÑ) Œì &lt;-&gt;
scoped term k t Œì /\ scoped typ k œÑ Œì</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chke6"><span class="nb">unfold</span> scoped.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>œÑ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term k (tm_tap t œÑ) ‚äÜ Œì &lt;-&gt;
FV term k t ‚äÜ Œì /\ FV typ k œÑ ‚äÜ Œì</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-ln-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-ln-v-chke7">simplify_FV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>Œì</var><span class="hyp-type"><b>: </b><span>AtomSet.t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>SystemF k LN</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term LN</span></span></span><br><span><var>œÑ</var><span class="hyp-type"><b>: </b><span>typ LN</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FV term k t ‚à™ FV typ k œÑ ‚äÜ Œì &lt;-&gt;
FV term k t ‚äÜ Œì /\ FV typ k œÑ ‚äÜ Œì</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intuition</span> fsetdec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">rw_scoped</span>.</span></span></pre>
</div>
</div></body>
</html>
