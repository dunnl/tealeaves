<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<title>Formalizing STLC with Tealeaves</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.16.0+0.16.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="formalizing-stlc-with-tealeaves">
<h1 class="title">Formalizing STLC with Tealeaves</h1>
<h2 class="subtitle" id="algebraic-presentation">Algebraic presentation</h2>

<p>This file gives a tutorial on proving the decorated traversable monad
laws the for the syntax of the simply-typed lambda calculus (STLC).</p>
<div class="contents topic" id="table-of-contents">
<p class="topic-title"><a class="reference internal" href="#top">Table of Contents</a></p>
<ul class="simple">
<li><a class="reference internal" href="#imports-and-setup" id="toc-entry-1">Imports and setup</a></li>
<li><a class="reference internal" href="#language-definition" id="toc-entry-2">Language Definition</a></li>
<li><a class="reference internal" href="#functor-instances" id="toc-entry-3">Functor instances</a><ul>
<li><a class="reference internal" href="#plain-functor-instance" id="toc-entry-4">Plain Functor instance</a></li>
<li><a class="reference internal" href="#decorated-functor-instance" id="toc-entry-5">Decorated Functor instance</a></li>
<li><a class="reference internal" href="#traversable-functor-instance" id="toc-entry-6">Traversable Functor instance</a></li>
<li><a class="reference internal" href="#decorated-traversable-functor-instance" id="toc-entry-7">Decorated-Traversable Functor instance</a></li>
</ul>
</li>
<li><a class="reference internal" href="#monad-instances" id="toc-entry-8">Monad instances</a><ul>
<li><a class="reference internal" href="#plain-monad-instance" id="toc-entry-9">Plain Monad instance</a></li>
<li><a class="reference internal" href="#decorated-monad-instance" id="toc-entry-10">Decorated Monad instance</a></li>
<li><a class="reference internal" href="#traversable-monad-instance" id="toc-entry-11">Traversable Monad instance</a></li>
<li><a class="reference internal" href="#decorated-traversable-monad-instance" id="toc-entry-12">Decorated-Traversable Monad instance</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="imports-and-setup">
<h1><a class="toc-backref" href="#toc-entry-1">Imports and setup</a></h1>
<p>Since we are using the algebraic typeclass hierarchy, we import modules under
the namespaces <tt class="docutils literal">Classes.Algebraic</tt> and <tt class="docutils literal">Theory.Algebraic.</tt></p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Tealeaves <span class="kn">Require Export</span>
  Classes.Categorical.DecoratedTraversableMonad
  Classes.Monoid
  Misc.NaturalNumbers.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Categorical.TraversableFunctor.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> List.ListNotations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Strength.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Monoid.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Generalizable All Variables</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Set Implicit Arguments</span>.</span></span></pre></div>
<div class="section" id="language-definition">
<h1><a class="toc-backref" href="#toc-entry-2">Language Definition</a></h1>
<p>The first step with Tealeaves is to define the syntax of the
language. We take a type <tt class="docutils literal">base_typ</tt> of types we consider primitive
(a/k/a atomic). The set of simple types is built up by forming arrows
between types, starting with base types. The syntax of STLC is defined
with three constructors as usual.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Parameter</span> <span class="nv">base_typ</span> : <span class="kt">Type</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">typ</span> :=
| base : base_typ -&gt; typ
| arr : typ -&gt; typ -&gt; typ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">base</span> : base_typ &gt;-&gt; typ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* we give more informative names to [Lam]&#39;s arguments</span>
<span class="c"> than Coq would infer otherwise *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">term</span> (<span class="nv">A</span> : <span class="kt">Type</span>) :=
| Var : A -&gt; term A
| Lam : <span class="kr">forall</span> (<span class="nv">X</span> : typ) (<span class="nv">t</span> : term A), term A
| Ap : term A -&gt; term A -&gt; term A.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">Notations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;Œª&#39; X ‚ãÖ body&quot;</span> :=
    (Lam X body) (<span class="kn">at level</span> <span class="mi">45</span>) : tealeaves_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;[ t1 ] [ t2 ]&quot;</span> :=
    (Ap t1 t2) (<span class="kn">at level</span> <span class="mi">40</span>) : tealeaves_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;A ‚üπ B&quot;</span> :=
    (arr A B) (<span class="kn">at level</span> <span class="mi">40</span>) : tealeaves_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Notations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Notations.</span></span></pre><p>For convenience, we define an extremely rudimentary Ltac tactic that
will solve the most trivial inductive steps automatically. Namely,
they will attempt to solve a goal in one step by rewriting with the
hypotheses in context (up to two times), then calling <tt class="docutils literal">reflexivity</tt>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">basic</span> t :=
  <span class="nb">induction</span> t;
  [ <span class="bp">reflexivity</span> |
    <span class="nb">simpl</span>; <span class="kr">match goal with</span> H : _ |- _ =&gt; <span class="nb">rewrite</span> H <span class="kr">end</span>; <span class="bp">reflexivity</span> |
    <span class="nb">simpl</span>; <span class="kp">do</span> <span class="mi">2</span> <span class="kr">match goal with</span> H : _ |- _ =&gt; <span class="nb">rewrite</span> H <span class="kr">end</span>; <span class="bp">reflexivity</span> ].</span></span></pre></div>
<div class="section" id="functor-instances">
<h1><a class="toc-backref" href="#toc-entry-3">Functor instances</a></h1>
<div class="section" id="plain-functor-instance">
<h2><a class="toc-backref" href="#toc-entry-4">Plain Functor instance</a></h2>
<p>Note that our datatype <tt class="docutils literal">term</tt> is parameterized by a single type
variable. The first thing we must show is that <tt class="docutils literal">term</tt> is actually
<em>functor</em> in this type argument.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">map_term</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">t</span> : term A) : term B :=
  <span class="kr">match</span> t <span class="kr">with</span>
  | Var a =&gt; Var (f a)
  | Lam X t =&gt; Lam X (map_term f t)
  | Ap t1 t2 =&gt; Ap (map_term f t1) (map_term f t2)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Map_term</span> : Map term := @map_term.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk0"><span class="kn">Theorem</span> <span class="nf">map_id</span> : <span class="kr">forall</span> <span class="nv">A</span>, map id = @id (term A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, map id = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, map id = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk2"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map id = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk3">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map id t = id t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk4"><span class="nb">unfold</span> transparent tcs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map_term id t = id t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">basic t.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk5"><span class="kn">Theorem</span> <span class="nf">map_map</span> : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : B -&gt; C),
    map g ‚àò map f = map (g ‚àò f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : B -&gt; C),
map g ‚àò map f = map (g ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : B -&gt; C),
map g ‚àò map f = map (g ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk7"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map g ‚àò map f = map (g ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk8">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map g ‚àò map f) t = map (g ‚àò f) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk9"><span class="nb">unfold</span> transparent tcs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map_term g ‚àò map_term f) t = map_term (g ‚àò f) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chka"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map_term g (map_term f t) = map_term (g ‚óã f) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">basic t.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Functor_term</span> : Functor term :=
  {| fun_map_id := @map_id;
     fun_map_map := @map_map;
  |}.</span></span></pre><div class="section" id="rewriting-rules-for-map">
<h3>Rewriting rules for <tt class="docutils literal">map</tt></h3>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">map_term_rewrite</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{f : A -&gt; B}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkb"><span class="kn">Lemma</span> <span class="nf">map_term_ap</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term A),
      map f (@Ap A t1 t2) = @Ap B (map f t1) (map f t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term A,
map f ([t1][t2]) = [map f t1][map f t2]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term A,
map f ([t1][t2]) = [map f t1][map f t2]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">map_term_rewrite</span>.</span></span></pre></div>
</div>
<div class="section" id="decorated-functor-instance">
<h2><a class="toc-backref" href="#toc-entry-5">Decorated Functor instance</a></h2>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">dec_term</span> {<span class="nv">A</span>} (<span class="nv">t</span> : term A) : term (nat * A) :=
  <span class="kr">match</span> t <span class="kr">with</span>
  | Var a =&gt; Var (∆µ, a)
  | Lam œÑ t =&gt; Lam œÑ (shift term (<span class="mi">1</span>, dec_term t))
  | Ap t1 t2 =&gt; Ap (dec_term t1) (dec_term t2)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Decorate_term</span> : Decorate nat term := @dec_term.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkd"><span class="kn">Theorem</span> <span class="nf">dec_natural</span> : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> (<span class="nv">f</span> : A -&gt; B),
    map (F := term) (map f) ‚àò dec term = dec term ‚àò map (F := term) f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
map (map f) ‚àò dec term = dec term ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chke"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
map (map f) ‚àò dec term = dec term ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkf"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map f) ‚àò dec term = dec term ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk10"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map f) ‚óã dec term = dec term ‚óã map f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk11">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map f) (dec term t) = dec term (map f t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk12"><span class="nb">induction</span> t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map f) (dec term (Var a)) =
dec term (map f (Var a))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chk13" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>map (map f) (dec term t) = dec term (map f t)</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chk13"><hr></label><div class="goal-conclusion">map (map f) (dec term (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t)) =
dec term (map f (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t))</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chk14" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map (map f) (dec term t1) = dec term (map f t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map (map f) (dec term t2) = dec term (map f t2)</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chk14"><hr></label><div class="goal-conclusion">map (map f) (dec term ([t1][t2])) =
dec term (map f ([t1][t2]))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk15">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map f) (dec term (Var a)) =
dec term (map f (Var a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">cbn</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk16">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>map (map f) (dec term t) = dec term (map f t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map f) (dec term (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t)) =
dec term (map f (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk17"><span class="nb">cbn</span> -[shift].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>map (map f) (dec term t) = dec term (map f t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ map (map f) (shift term (<span class="mi">1</span>, dec term t)) =
<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ shift term (<span class="mi">1</span>, dec term (map f t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk18">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>map (map f) (dec term t) = dec term (map f t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map f) (shift term (<span class="mi">1</span>, dec term t)) =
shift term (<span class="mi">1</span>, dec term (map f t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> dec_helper_1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk19">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map (map f) (dec term t1) = dec term (map f t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map (map f) (dec term t2) = dec term (map f t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map f) (dec term ([t1][t2])) =
dec term (map f ([t1][t2]))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk1a"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map (map f) (dec term t1) = dec term (map f t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map (map f) (dec term t2) = dec term (map f t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[map (map f) (dec term t1)][map (map f) (dec term t2)] =
[dec term (map f t1)][dec term (map f t2)]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> fequal.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk1b">#[export] <span class="kn">Instance</span>: Natural (@dec nat term _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural (@dec nat term Decorate_term)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk1c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural (@dec nat term Decorate_term)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk1d"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor term</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor (term ‚óã prod nat)</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
map f ‚àò dec term = dec term ‚àò map f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk1e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor term</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk1f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor (term ‚óã prod nat)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Functor_compose;
      <span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk20">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
map f ‚àò dec term = dec term ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> dec_natural.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk21"><span class="kn">Theorem</span> <span class="nf">dec_extract</span> : <span class="kr">forall</span> <span class="nv">A</span>,
    map (F := term) (extract) ‚àò dec term = @id (term A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, map extract ‚àò dec term = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk22"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, map extract ‚àò dec term = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk23"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map extract ‚àò dec term = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk24"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map extract ‚óã dec term = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk25">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map extract (dec term t) = id t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk26"><span class="nb">induction</span> t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map extract (dec term (Var a)) = id (Var a)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chk27" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>map extract (dec term t) = id t</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chk27"><hr></label><div class="goal-conclusion">map extract (dec term (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t)) = id (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t)</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chk28" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map extract (dec term t1) = id t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map extract (dec term t2) = id t2</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chk28"><hr></label><div class="goal-conclusion">map extract (dec term ([t1][t2])) = id ([t1][t2])</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk29">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map extract (dec term (Var a)) = id (Var a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk2a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>map extract (dec term t) = id t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map extract (dec term (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t)) = id (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk2b"><span class="nb">cbn</span> -[shift].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>map extract (dec term t) = id t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ map extract (shift term (<span class="mi">1</span>, dec term t)) =
id (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> dec_helper_2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk2c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map extract (dec term t1) = id t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map extract (dec term t2) = id t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map extract (dec term ([t1][t2])) = id ([t1][t2])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk2d"><span class="nb">unfold</span> id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map extract (dec term t1) = id t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map extract (dec term t2) = id t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map extract (dec term ([t1][t2])) = [t1][t2]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk2e"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map extract (dec term t1) = id t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map extract (dec term t2) = id t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[map extract (dec term t1)][map extract (dec term t2)] =
[t1][t2]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> fequal.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk2f"><span class="kn">Theorem</span> <span class="nf">dec_dec</span> : <span class="kr">forall</span> <span class="nv">A</span>,
    dec term ‚àò dec term = map (F := term) (cojoin) ‚àò dec term (A := A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
dec term ‚àò dec term = map cojoin ‚àò dec term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk30"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
dec term ‚àò dec term = map cojoin ‚àò dec term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk31"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec term ‚àò dec term = map cojoin ‚àò dec term</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk32"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec term ‚óã dec term = map cojoin ‚óã dec term</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk33">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec term (dec term t) = map cojoin (dec term t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk34"><span class="nb">induction</span> t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec term (dec term (Var a)) =
map cojoin (dec term (Var a))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chk35" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dec term (dec term t) = map cojoin (dec term t)</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chk35"><hr></label><div class="goal-conclusion">dec term (dec term (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t)) =
map cojoin (dec term (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t))</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chk36" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dec term (dec term t1) =
map cojoin (dec term t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dec term (dec term t2) =
map cojoin (dec term t2)</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chk36"><hr></label><div class="goal-conclusion">dec term (dec term ([t1][t2])) =
map cojoin (dec term ([t1][t2]))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk37">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec term (dec term (Var a)) =
map cojoin (dec term (Var a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk38">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dec term (dec term t) = map cojoin (dec term t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec term (dec term (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t)) =
map cojoin (dec term (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk39"><span class="nb">cbn</span> -[shift].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dec term (dec term t) = map cojoin (dec term t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">Œª</span> <span class="nv">X</span>
‚ãÖ shift term
    (<span class="mi">1</span>, dec term (shift term (<span class="mi">1</span>, dec term t))) =
<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ map cojoin (shift term (<span class="mi">1</span>, dec term t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk3a">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dec term (dec term t) = map cojoin (dec term t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">shift term (<span class="mi">1</span>, dec term (shift term (<span class="mi">1</span>, dec term t))) =
map cojoin (shift term (<span class="mi">1</span>, dec term t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> dec_helper_3.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk3b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dec term (dec term t1) =
map cojoin (dec term t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dec term (dec term t2) =
map cojoin (dec term t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec term (dec term ([t1][t2])) =
map cojoin (dec term ([t1][t2]))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk3c"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dec term (dec term t1) =
map cojoin (dec term t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dec term (dec term t2) =
map cojoin (dec term t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[dec term (dec term t1)][dec term (dec term t2)] =
[map cojoin (dec term t1)][map cojoin (dec term t2)]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">fequal; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk3d">#[export] <span class="kn">Instance</span> <span class="nf">DecoratedFunctor_term</span> : DecoratedFunctor nat term.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">DecoratedFunctor nat term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk3e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">DecoratedFunctor nat term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk3f"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor term</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural (@dec nat term Decorate_term)</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
dec term ‚àò dec term = map cojoin ‚àò dec term</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, map extract ‚àò dec term = id</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk40">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor term</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk41">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural (@dec nat term Decorate_term)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk42">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
dec term ‚àò dec term = map cojoin ‚àò dec term</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> dec_dec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk43">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, map extract ‚àò dec term = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> dec_extract.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="section" id="rewriting-rules-for-dec">
<h3>Rewriting rules for <tt class="docutils literal">dec</tt></h3>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">dec_term_rewrite</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{f : A -&gt; B}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk44"><span class="kn">Lemma</span> <span class="nf">dec_term1</span> : <span class="kr">forall</span> (<span class="nv">x</span> : A),
      dec term (Var x) = Var (<span class="mi">0</span>, x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A, dec term (Var x) = Var (<span class="mi">0</span>, x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk45"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A, dec term (Var x) = Var (<span class="mi">0</span>, x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk46"><span class="kn">Lemma</span> <span class="nf">dec_term21</span> : <span class="kr">forall</span> (<span class="nv">X</span> : typ) (<span class="nv">t</span> : term A),
      dec term (Lam X t) = shift term (<span class="mi">1</span>, Lam X (dec term t)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : typ) (<span class="nv">t</span> : term A),
dec term (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t) = shift term (<span class="mi">1</span>, <span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ dec term t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk47"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : typ) (<span class="nv">t</span> : term A),
dec term (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t) = shift term (<span class="mi">1</span>, <span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ dec term t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk48"><span class="kn">Lemma</span> <span class="nf">dec_term22</span> : <span class="kr">forall</span> (<span class="nv">X</span> : typ) (<span class="nv">t</span> : term A),
      dec term (Lam X t) = Lam X (shift term (<span class="mi">1</span>, dec term t)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : typ) (<span class="nv">t</span> : term A),
dec term (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t) = <span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ shift term (<span class="mi">1</span>, dec term t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk49"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : typ) (<span class="nv">t</span> : term A),
dec term (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t) = <span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ shift term (<span class="mi">1</span>, dec term t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk4a"><span class="kn">Lemma</span> <span class="nf">dec_term3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term A),
      dec term (Ap t1 t2) = Ap (dec term t1) (dec term t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term A,
dec term ([t1][t2]) = [dec term t1][dec term t2]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk4b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term A,
dec term ([t1][t2]) = [dec term t1][dec term t2]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">dec_term_rewrite</span>.</span></span></pre></div>
</div>
<div class="section" id="traversable-functor-instance">
<h2><a class="toc-backref" href="#toc-entry-6">Traversable Functor instance</a></h2>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Applicative.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">dist_term</span> `{Map F} `{Pure F} `{Mult F} {A : <span class="kt">Type</span>}
         (t : term (F A)) : F (term A) :=
  <span class="kr">match</span> t <span class="kr">with</span>
  | Var a =&gt; map (@Var A) a
  | Lam X t =&gt; map (Lam X) (dist_term t)
  | Ap t1 t2 =&gt; (pure (@Ap A))
                 &lt;‚ãÜ&gt; dist_term t1
                 &lt;‚ãÜ&gt; dist_term t2
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span>: ApplicativeDist term := @dist_term.</span></span></pre><div class="section" id="rewriting-rules-for-dist">
<h3>Rewriting rules for <tt class="docutils literal">dist</tt></h3>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">term_dist_rewrite</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{Applicative G}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> (<span class="nv">A</span> : <span class="kt">Type</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk4c"><span class="kn">Lemma</span> <span class="nf">dist_term_var_1</span> : <span class="kr">forall</span> (<span class="nv">x</span> : G A),
    dist term G (@Var (G A) x) = pure (@Var A) &lt;‚ãÜ&gt; x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G A,
Œ¥ term G (Var x) = pure (Var (A:=A)) &lt;‚ãÜ&gt; x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk4d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G A,
Œ¥ term G (Var x) = pure (Var (A:=A)) &lt;‚ãÜ&gt; x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk4e"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G (Var x) = pure (Var (A:=A)) &lt;‚ãÜ&gt; x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk4f"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Var (A:=A)) x = pure (Var (A:=A)) &lt;‚ãÜ&gt; x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> map_to_ap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk50"><span class="kn">Lemma</span> <span class="nf">dist_term_var_2</span> : <span class="kr">forall</span> (<span class="nv">x</span> : G A),
    dist term G (@Var (G A) x) = map (@Var A) x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G A, Œ¥ term G (Var x) = map (Var (A:=A)) x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk51"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G A, Œ¥ term G (Var x) = map (Var (A:=A)) x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk52"><span class="kn">Lemma</span> <span class="nf">dist_term_lam_1</span> : <span class="kr">forall</span> (<span class="nv">X</span> : typ) (<span class="nv">t</span> : term (G A)),
      dist term G (Lam X t) = pure (Lam X) &lt;‚ãÜ&gt; (dist term G t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : typ) (<span class="nv">t</span> : term (G A)),
Œ¥ term G (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t) = pure (Lam X) &lt;‚ãÜ&gt; Œ¥ term G t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk53"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : typ) (<span class="nv">t</span> : term (G A)),
Œ¥ term G (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t) = pure (Lam X) &lt;‚ãÜ&gt; Œ¥ term G t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk54"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t) = pure (Lam X) &lt;‚ãÜ&gt; Œ¥ term G t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk55"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Lam X) (Œ¥ term G t) = pure (Lam X) &lt;‚ãÜ&gt; Œ¥ term G t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> map_to_ap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk56"><span class="kn">Lemma</span> <span class="nf">dist_term_lam_2</span> : <span class="kr">forall</span> (<span class="nv">X</span> : typ) (<span class="nv">t</span> : term (G A)),
      dist term G (Lam X t) = map (Lam X) (dist term G t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : typ) (<span class="nv">t</span> : term (G A)),
Œ¥ term G (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t) = map (Lam X) (Œ¥ term G t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk57"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> : typ) (<span class="nv">t</span> : term (G A)),
Œ¥ term G (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t) = map (Lam X) (Œ¥ term G t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk58"><span class="kn">Lemma</span> <span class="nf">dist_term_ap_1</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term (G A)),
      dist term G (Ap t1 t2) =
      (pure (@Ap A))
        &lt;‚ãÜ&gt; dist term G t1
        &lt;‚ãÜ&gt; dist term G t2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term (G A),
Œ¥ term G ([t1][t2]) =
pure (Ap (A:=A)) &lt;‚ãÜ&gt; Œ¥ term G t1 &lt;‚ãÜ&gt; Œ¥ term G t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk59"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term (G A),
Œ¥ term G ([t1][t2]) =
pure (Ap (A:=A)) &lt;‚ãÜ&gt; Œ¥ term G t1 &lt;‚ãÜ&gt; Œ¥ term G t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk5a"><span class="kn">Lemma</span> <span class="nf">dist_term_ap_2</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term (G A)),
      dist term G (Ap t1 t2) =
      (map (@Ap A) (dist term G t1)
            &lt;‚ãÜ&gt; dist term G t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term (G A),
Œ¥ term G ([t1][t2]) =
map (Ap (A:=A)) (Œ¥ term G t1) &lt;‚ãÜ&gt; Œ¥ term G t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk5b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term (G A),
Œ¥ term G ([t1][t2]) =
map (Ap (A:=A)) (Œ¥ term G t1) &lt;‚ãÜ&gt; Œ¥ term G t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk5c"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G ([t1][t2]) =
map (Ap (A:=A)) (Œ¥ term G t1) &lt;‚ãÜ&gt; Œ¥ term G t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk5d"><span class="nb">rewrite</span> dist_term_ap_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (Ap (A:=A)) &lt;‚ãÜ&gt; Œ¥ term G t1 &lt;‚ãÜ&gt; Œ¥ term G t2 =
map (Ap (A:=A)) (Œ¥ term G t1) &lt;‚ãÜ&gt; Œ¥ term G t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> map_to_ap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">term_dist_rewrite</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">dist_term_properties</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{Applicative G}.</span></span></pre></div>
<div class="section" id="naturality-of-dist">
<h3>Naturality of <tt class="docutils literal">dist</tt></h3>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk5e"><span class="kn">Lemma</span> <span class="nf">dist_natural_term</span> : <span class="kr">forall</span> `(f : A -&gt; B),
      map (F := G ‚àò term) f ‚àò dist term G =
      dist term G ‚àò map (F := term ‚àò G) f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
map f ‚àò Œ¥ term G = Œ¥ term G ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk5f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
map f ‚àò Œ¥ term G = Œ¥ term G ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk60"><span class="nb">intros</span>; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f ‚àò Œ¥ term G = Œ¥ term G ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk61">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map f ‚àò Œ¥ term G) t = (Œ¥ term G ‚àò map f) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk62">unfold_ops @Map_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (map f) ‚àò Œ¥ term G) t =
(Œ¥ term G ‚àò map (map f)) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk63"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map f) (Œ¥ term G t) = Œ¥ term G (map (map f) t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk64"><span class="nb">induction</span> t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map f) (Œ¥ term G (Var a)) =
Œ¥ term G (map (map f) (Var a))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chk65" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>map (map f) (Œ¥ term G t) = Œ¥ term G (map (map f) t)</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chk65"><hr></label><div class="goal-conclusion">map (map f) (Œ¥ term G (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t)) =
Œ¥ term G (map (map f) (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t))</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chk66" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map (map f) (Œ¥ term G t1) =
Œ¥ term G (map (map f) t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map (map f) (Œ¥ term G t2) =
Œ¥ term G (map (map f) t2)</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chk66"><hr></label><div class="goal-conclusion">map (map f) (Œ¥ term G ([t1][t2])) =
Œ¥ term G (map (map f) ([t1][t2]))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk67">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map f) (Œ¥ term G (Var a)) =
Œ¥ term G (map (map f) (Var a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk68"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map f) (map (Var (A:=A)) a) =
map (Var (A:=B)) (map f a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk69">compose near a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (map f) ‚àò map (Var (A:=A))) a =
(map (Var (A:=B)) ‚àò map f) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> <span class="mi">2</span>(fun_map_map).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk6a">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>map (map f) (Œ¥ term G t) =
Œ¥ term G (map (map f) t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map f) (Œ¥ term G (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t)) =
Œ¥ term G (map (map f) (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk6b"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>map (map f) (Œ¥ term G t) =
Œ¥ term G (map (map f) t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map f) (map (Lam X) (Œ¥ term G t)) =
map (Lam X) (Œ¥ term G (map (map f) t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk6c"><span class="nb">rewrite</span> &lt;- IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>map (map f) (Œ¥ term G t) =
Œ¥ term G (map (map f) t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map f) (map (Lam X) (Œ¥ term G t)) =
map (Lam X) (map (map f) (Œ¥ term G t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk6d">compose near (dist term G t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>map (map f) (Œ¥ term G t) =
Œ¥ term G (map (map f) t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (map f) ‚àò map (Lam X)) (Œ¥ term G t) =
(map (Lam X) ‚àò map (map f)) (Œ¥ term G t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> <span class="mi">2</span>(fun_map_map).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk6e">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map (map f) (Œ¥ term G t1) =
Œ¥ term G (map (map f) t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map (map f) (Œ¥ term G t2) =
Œ¥ term G (map (map f) t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map f) (Œ¥ term G ([t1][t2])) =
Œ¥ term G (map (map f) ([t1][t2]))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk6f"><span class="nb">rewrite</span> (dist_term_ap_2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map (map f) (Œ¥ term G t1) =
Œ¥ term G (map (map f) t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map (map f) (Œ¥ term G t2) =
Œ¥ term G (map (map f) t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map f)
  (map (Ap (A:=A)) (Œ¥ term G t1) &lt;‚ãÜ&gt; Œ¥ term G t2) =
Œ¥ term G (map (map f) ([t1][t2]))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk70"><span class="nb">rewrite</span> (map_term_ap).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map (map f) (Œ¥ term G t1) =
Œ¥ term G (map (map f) t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map (map f) (Œ¥ term G t2) =
Œ¥ term G (map (map f) t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map f)
  (map (Ap (A:=A)) (Œ¥ term G t1) &lt;‚ãÜ&gt; Œ¥ term G t2) =
Œ¥ term G ([map (map f) t1][map (map f) t2])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk71"><span class="nb">rewrite</span> (dist_term_ap_2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map (map f) (Œ¥ term G t1) =
Œ¥ term G (map (map f) t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map (map f) (Œ¥ term G t2) =
Œ¥ term G (map (map f) t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map f)
  (map (Ap (A:=A)) (Œ¥ term G t1) &lt;‚ãÜ&gt; Œ¥ term G t2) =
map (Ap (A:=B)) (Œ¥ term G (map (map f) t1)) &lt;‚ãÜ&gt;
Œ¥ term G (map (map f) t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk72"><span class="nb">rewrite</span> &lt;- IHt1, &lt;- IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map (map f) (Œ¥ term G t1) =
Œ¥ term G (map (map f) t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map (map f) (Œ¥ term G t2) =
Œ¥ term G (map (map f) t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map f)
  (map (Ap (A:=A)) (Œ¥ term G t1) &lt;‚ãÜ&gt; Œ¥ term G t2) =
map (Ap (A:=B)) (map (map f) (Œ¥ term G t1)) &lt;‚ãÜ&gt;
map (map f) (Œ¥ term G t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk73"><span class="nb">rewrite</span> &lt;- ap_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map (map f) (Œ¥ term G t1) =
Œ¥ term G (map (map f) t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map (map f) (Œ¥ term G t2) =
Œ¥ term G (map (map f) t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map f)
  (map (Ap (A:=A)) (Œ¥ term G t1) &lt;‚ãÜ&gt; Œ¥ term G t2) =
map (precompose (map f))
  (map (Ap (A:=B)) (map (map f) (Œ¥ term G t1))) &lt;‚ãÜ&gt;
Œ¥ term G t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk74"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map (map f) (Œ¥ term G t1) =
Œ¥ term G (map (map f) t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map (map f) (Œ¥ term G t2) =
Œ¥ term G (map (map f) t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (map f)) (map (Ap (A:=A)) (Œ¥ term G t1)) &lt;‚ãÜ&gt;
Œ¥ term G t2 =
map (precompose (map f))
  (map (Ap (A:=B)) (map (map f) (Œ¥ term G t1))) &lt;‚ãÜ&gt;
Œ¥ term G t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk75">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map (map f) (Œ¥ term G t1) =
Œ¥ term G (map (map f) t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map (map f) (Œ¥ term G t2) =
Œ¥ term G (map (map f) t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (map f)) (map (Ap (A:=A)) (Œ¥ term G t1)) =
map (precompose (map f))
  (map (Ap (A:=B)) (map (map f) (Œ¥ term G t1)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk76">compose near (dist term G t1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map (map f) (Œ¥ term G t1) =
Œ¥ term G (map (map f) t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map (map f) (Œ¥ term G t2) =
Œ¥ term G (map (map f) t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (compose (map f)) ‚àò map (Ap (A:=A)))
  (Œ¥ term G t1) =
map (precompose (map f))
  ((map (Ap (A:=B)) ‚àò map (map f)) (Œ¥ term G t1))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk77"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map (map f) (Œ¥ term G t1) =
Œ¥ term G (map (map f) t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map (map f) (Œ¥ term G t2) =
Œ¥ term G (map (map f) t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (map f) ‚àò Ap (A:=A)) (Œ¥ term G t1) =
map (precompose (map f))
  ((map (Ap (A:=B)) ‚àò map (map f)) (Œ¥ term G t1))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk78"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map (map f) (Œ¥ term G t1) =
Œ¥ term G (map (map f) t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map (map f) (Œ¥ term G t2) =
Œ¥ term G (map (map f) t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (map f) ‚àò Ap (A:=A)) (Œ¥ term G t1) =
map (precompose (map f))
  (map (Ap (A:=B) ‚àò map f) (Œ¥ term G t1))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk79">compose near (dist term G t1) on <span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map (map f) (Œ¥ term G t1) =
Œ¥ term G (map (map f) t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map (map f) (Œ¥ term G t2) =
Œ¥ term G (map (map f) t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (map f) ‚àò Ap (A:=A)) (Œ¥ term G t1) =
(map (precompose (map f)) ‚àò map (Ap (A:=B) ‚àò map f))
  (Œ¥ term G t1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk7a"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map (map f) (Œ¥ term G t1) =
Œ¥ term G (map (map f) t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map (map f) (Œ¥ term G t2) =
Œ¥ term G (map (map f) t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (map f) ‚àò Ap (A:=A)) (Œ¥ term G t1) =
map (precompose (map f) ‚àò (Ap (A:=B) ‚àò map f))
  (Œ¥ term G t1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk7b">#[export] <span class="kn">Instance</span> <span class="nf">dist_Natural_term</span> :
      Natural (@dist term _ _ _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural
  (@dist term ApplicativeDist_instance_0 G H H0 H1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk7c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural
  (@dist term ApplicativeDist_instance_0 G H H0 H1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk7d"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural
  (@dist term ApplicativeDist_instance_0 G H H0 H1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk7e"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor (term ‚óã G)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chk7f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chk7f"><hr></label><div class="goal-conclusion">Functor (G ‚óã term)</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chk80" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chk80"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
map f ‚àò Œ¥ term G = Œ¥ term G ‚àò map f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk81">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor (term ‚óã G)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk82">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor (G ‚óã term)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk83">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
map f ‚àò Œ¥ term G = Œ¥ term G ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk84"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f ‚àò Œ¥ term G = Œ¥ term G ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> dist_natural_term.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></div>
<div class="section" id="traversal-laws">
<h3>Traversal laws</h3>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk85"><span class="kn">Lemma</span> <span class="nf">dist_unit_term</span> : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>),
      dist term (<span class="kr">fun</span> <span class="nv">A</span> =&gt; A) = @id (term A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, Œ¥ term (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0) = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk86"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, Œ¥ term (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0) = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk87"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk88">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) t = id t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk89"><span class="nb">induction</span> t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (Var a) = id (Var a)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chk8a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) t = id t</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chk8a"><hr></label><div class="goal-conclusion">Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t) = id (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t)</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chk8b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) t1 = id t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) t2 = id t2</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chk8b"><hr></label><div class="goal-conclusion">Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) ([t1][t2]) = id ([t1][t2])</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk8c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (Var a) = id (Var a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk8d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) t = id t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t) = id (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk8e"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) t = id t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Lam X) (Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) t) =
id (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk8f"><span class="nb">rewrite</span> IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) t = id t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Lam X) (id t) = id (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk90">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) t1 = id t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) t2 = id t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) ([t1][t2]) = id ([t1][t2])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk91"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) t1 = id t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) t2 = id t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (Ap (A:=A)) (Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) t1)
  (Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) t2) = id ([t1][t2])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk92"><span class="nb">rewrite</span> IHt1, IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) t1 = id t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) t2 = id t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (Ap (A:=A)) (id t1) (id t2) = id ([t1][t2])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Set Keyed Unification</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk93"><span class="kn">Lemma</span> <span class="nf">dist_linear_term</span> : <span class="kr">forall</span> `{Applicative G1} `{Applicative G2} (A : <span class="kt">Type</span>),
      dist term (G1 ‚àò G2) =
      map (F := G1) (dist term G2) ‚àò dist term G1 (A := G2 A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G1</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H3</span> : Map G1)
  (<span class="nv">H4</span> : Pure G1) (<span class="nv">H5</span> : Mult G1),
Applicative G1 -&gt;
<span class="kr">forall</span> (<span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H7</span> : Map G2)
  (<span class="nv">H8</span> : Pure G2) (<span class="nv">H9</span> : Mult G2),
Applicative G2 -&gt;
<span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
Œ¥ term (G1 ‚àò G2) = map (Œ¥ term G2) ‚àò Œ¥ term G1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk94"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G1</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H3</span> : Map G1)
  (<span class="nv">H4</span> : Pure G1) (<span class="nv">H5</span> : Mult G1),
Applicative G1 -&gt;
<span class="kr">forall</span> (<span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H7</span> : Map G2)
  (<span class="nv">H8</span> : Pure G2) (<span class="nv">H9</span> : Mult G2),
Applicative G2 -&gt;
<span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
Œ¥ term (G1 ‚àò G2) = map (Œ¥ term G2) ‚àò Œ¥ term G1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk95"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term (G1 ‚àò G2) = map (Œ¥ term G2) ‚àò Œ¥ term G1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk96"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term (G1 ‚óã G2) = map (Œ¥ term G2) ‚óã Œ¥ term G1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk97">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term (G1 ‚óã G2) t = map (Œ¥ term G2) (Œ¥ term G1 t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk98"><span class="nb">induction</span> t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G1 (G2 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term (G1 ‚óã G2) (Var a) =
map (Œ¥ term G2) (Œ¥ term G1 (Var a))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chk99" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t = map (Œ¥ term G2) (Œ¥ term G1 t)</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chk99"><hr></label><div class="goal-conclusion">Œ¥ term (G1 ‚óã G2) (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t) =
map (Œ¥ term G2) (Œ¥ term G1 (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t))</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chk9a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t1 =
map (Œ¥ term G2) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t2 =
map (Œ¥ term G2) (Œ¥ term G1 t2)</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chk9a"><hr></label><div class="goal-conclusion">Œ¥ term (G1 ‚óã G2) ([t1][t2]) =
map (Œ¥ term G2) (Œ¥ term G1 ([t1][t2]))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk9b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G1 (G2 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term (G1 ‚óã G2) (Var a) =
map (Œ¥ term G2) (Œ¥ term G1 (Var a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk9c"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G1 (G2 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Var (A:=A)) a =
map (Œ¥ term G2) (map (Var (A:=G2 A)) a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk9d">compose near a on <span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G1 (G2 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Var (A:=A)) a =
(map (Œ¥ term G2) ‚àò map (Var (A:=G2 A))) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> (fun_map_map).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk9e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t = map (Œ¥ term G2) (Œ¥ term G1 t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term (G1 ‚óã G2) (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t) =
map (Œ¥ term G2) (Œ¥ term G1 (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk9f"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t = map (Œ¥ term G2) (Œ¥ term G1 t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Lam X) (Œ¥ term (G1 ‚óã G2) t) =
map (Œ¥ term G2) (map (Lam X) (Œ¥ term G1 t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chka0"><span class="nb">rewrite</span> IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t = map (Œ¥ term G2) (Œ¥ term G1 t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Lam X) (map (Œ¥ term G2) (Œ¥ term G1 t)) =
map (Œ¥ term G2) (map (Lam X) (Œ¥ term G1 t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chka1">compose near (dist term G1 t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t = map (Œ¥ term G2) (Œ¥ term G1 t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (Lam X) ‚àò map (Œ¥ term G2)) (Œ¥ term G1 t) =
(map (Œ¥ term G2) ‚àò map (Lam X)) (Œ¥ term G1 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chka2"><span class="nb">change</span> (map (F := G1 ‚óã G2) (Lam X)) <span class="kr">with</span> (map (F := G1) (map (F := G2) (@Lam A X))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t = map (Œ¥ term G2) (Œ¥ term G1 t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (map (Lam X)) ‚àò map (Œ¥ term G2)) (Œ¥ term G1 t) =
(map (Œ¥ term G2) ‚àò map (Lam X)) (Œ¥ term G1 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chka3"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t = map (Œ¥ term G2) (Œ¥ term G1 t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map (Lam X) ‚àò Œ¥ term G2) (Œ¥ term G1 t) =
(map (Œ¥ term G2) ‚àò map (Lam X)) (Œ¥ term G1 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> (fun_map_map).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chka4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t1 =
map (Œ¥ term G2) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t2 =
map (Œ¥ term G2) (Œ¥ term G1 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term (G1 ‚óã G2) ([t1][t2]) =
map (Œ¥ term G2) (Œ¥ term G1 ([t1][t2]))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chka5"><span class="nb">rewrite</span> dist_term_ap_2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t1 =
map (Œ¥ term G2) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t2 =
map (Œ¥ term G2) (Œ¥ term G1 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term (G1 ‚óã G2) ([t1][t2]) =
map (Œ¥ term G2)
  (map (Ap (A:=G2 A)) (Œ¥ term G1 t1) &lt;‚ãÜ&gt; Œ¥ term G1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chka6"><span class="nb">rewrite</span> (dist_term_ap_2 (G := G1 ‚óã G2)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t1 =
map (Œ¥ term G2) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t2 =
map (Œ¥ term G2) (Œ¥ term G1 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Ap (A:=A)) (Œ¥ term (G1 ‚óã G2) t1) &lt;‚ãÜ&gt;
Œ¥ term (G1 ‚óã G2) t2 =
map (Œ¥ term G2)
  (map (Ap (A:=G2 A)) (Œ¥ term G1 t1) &lt;‚ãÜ&gt; Œ¥ term G1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chka7"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t1 =
map (Œ¥ term G2) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t2 =
map (Œ¥ term G2) (Œ¥ term G1 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Ap (A:=A)) (Œ¥ term (G1 ‚óã G2) t1) &lt;‚ãÜ&gt;
Œ¥ term (G1 ‚óã G2) t2 =
map (compose (Œ¥ term G2))
  (map (Ap (A:=G2 A)) (Œ¥ term G1 t1)) &lt;‚ãÜ&gt; Œ¥ term G1 t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chka8">compose near ((dist term G1 t1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t1 =
map (Œ¥ term G2) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t2 =
map (Œ¥ term G2) (Œ¥ term G1 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Ap (A:=A)) (Œ¥ term (G1 ‚óã G2) t1) &lt;‚ãÜ&gt;
Œ¥ term (G1 ‚óã G2) t2 =
(map (compose (Œ¥ term G2)) ‚àò map (Ap (A:=G2 A)))
  (Œ¥ term G1 t1) &lt;‚ãÜ&gt; Œ¥ term G1 t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chka9"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t1 =
map (Œ¥ term G2) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t2 =
map (Œ¥ term G2) (Œ¥ term G1 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Ap (A:=A)) (Œ¥ term (G1 ‚óã G2) t1) &lt;‚ãÜ&gt;
Œ¥ term (G1 ‚óã G2) t2 =
map (compose (Œ¥ term G2) ‚àò Ap (A:=G2 A))
  (Œ¥ term G1 t1) &lt;‚ãÜ&gt; Œ¥ term G1 t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkaa"><span class="nb">rewrite</span> (ap_compose2 G2 G1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t1 =
map (Œ¥ term G2) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t2 =
map (Œ¥ term G2) (Œ¥ term G1 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (ap G2) (map (Ap (A:=A)) (Œ¥ term (G1 ‚óã G2) t1)) &lt;‚ãÜ&gt;
Œ¥ term (G1 ‚óã G2) t2 =
map (compose (Œ¥ term G2) ‚àò Ap (A:=G2 A))
  (Œ¥ term G1 t1) &lt;‚ãÜ&gt; Œ¥ term G1 t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkab"><span class="nb">rewrite</span> IHt1, IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t1 =
map (Œ¥ term G2) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t2 =
map (Œ¥ term G2) (Œ¥ term G1 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (ap G2)
  (map (Ap (A:=A)) (map (Œ¥ term G2) (Œ¥ term G1 t1))) &lt;‚ãÜ&gt;
map (Œ¥ term G2) (Œ¥ term G1 t2) =
map (compose (Œ¥ term G2) ‚àò Ap (A:=G2 A))
  (Œ¥ term G1 t1) &lt;‚ãÜ&gt; Œ¥ term G1 t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkac"><span class="nb">rewrite</span> &lt;- ap_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t1 =
map (Œ¥ term G2) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t2 =
map (Œ¥ term G2) (Œ¥ term G1 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (precompose (Œ¥ term G2))
  (map (ap G2)
     (map (Ap (A:=A)) (map (Œ¥ term G2) (Œ¥ term G1 t1)))) &lt;‚ãÜ&gt;
Œ¥ term G1 t2 =
map (compose (Œ¥ term G2) ‚àò Ap (A:=G2 A))
  (Œ¥ term G1 t1) &lt;‚ãÜ&gt; Œ¥ term G1 t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkad">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t1 =
map (Œ¥ term G2) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t2 =
map (Œ¥ term G2) (Œ¥ term G1 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (precompose (Œ¥ term G2))
  (map (ap G2)
     (map (Ap (A:=A)) (map (Œ¥ term G2) (Œ¥ term G1 t1)))) =
map (compose (Œ¥ term G2) ‚àò Ap (A:=G2 A))
  (Œ¥ term G1 t1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkae"><span class="kp">repeat</span> (compose near (dist term G1 t1) on <span class="nb">left</span>;
              <span class="nb">rewrite</span> (fun_map_map (F := G1))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t1 =
map (Œ¥ term G2) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t2 =
map (Œ¥ term G2) (Œ¥ term G1 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (precompose (Œ¥ term G2)
   ‚àò (ap G2 ‚àò (map (Ap (A:=A)) ‚àò Œ¥ term G2)))
  (Œ¥ term G1 t1) =
map (compose (Œ¥ term G2) ‚àò Ap (A:=G2 A))
  (Œ¥ term G1 t1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkaf">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t1 =
map (Œ¥ term G2) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t2 =
map (Œ¥ term G2) (Œ¥ term G1 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">precompose (Œ¥ term G2)
‚àò (ap G2 ‚àò (map (Ap (A:=A)) ‚àò Œ¥ term G2)) =
compose (Œ¥ term G2) ‚àò Ap (A:=G2 A)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkb0">ext s1 s2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t1 =
map (Œ¥ term G2) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t2 =
map (Œ¥ term G2) (Œ¥ term G1 t2)</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>term (G2 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(precompose (Œ¥ term G2)
 ‚àò (ap G2 ‚àò (map (Ap (A:=A)) ‚àò Œ¥ term G2))) s1 s2 =
(compose (Œ¥ term G2) ‚àò Ap (A:=G2 A)) s1 s2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkb1"><span class="nb">unfold</span> compose; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t1 =
map (Œ¥ term G2) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t2 =
map (Œ¥ term G2) (Œ¥ term G1 t2)</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>term (G2 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">precompose (Œ¥ term G2)
  (ap G2 (map (Ap (A:=A)) (Œ¥ term G2 s1))) s2 =
pure (Ap (A:=A)) &lt;‚ãÜ&gt; Œ¥ term G2 s1 &lt;‚ãÜ&gt; Œ¥ term G2 s2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkb2"><span class="nb">unfold</span> precompose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 (G2 A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t1 =
map (Œ¥ term G2) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term (G1 ‚óã G2) t2 =
map (Œ¥ term G2) (Œ¥ term G1 t2)</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>term (G2 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Ap (A:=A)) (Œ¥ term G2 s1) &lt;‚ãÜ&gt; Œ¥ term G2 s2 =
pure (Ap (A:=A)) &lt;‚ãÜ&gt; Œ¥ term G2 s1 &lt;‚ãÜ&gt; Œ¥ term G2 s2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> (map_to_ap).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Unset Keyed Unification</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkb3"><span class="kn">Lemma</span> <span class="nf">dist_morph_term</span> : <span class="kr">forall</span> `{ApplicativeMorphism G1 G2 œï} A,
      dist term G2 ‚àò map (œï A) = œï (term A) ‚àò dist term G1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G1</span> <span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H3</span> : Map G1)
  (<span class="nv">H4</span> : Mult G1) (<span class="nv">H5</span> : Pure G1) (<span class="nv">H6</span> : Map G2)
  (<span class="nv">H7</span> : Mult G2) (<span class="nv">H8</span> : Pure G2)
  (<span class="nv">œï</span> : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A),
ApplicativeMorphism G1 G2 œï -&gt;
<span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
Œ¥ term G2 ‚àò map (œï A) = œï (term A) ‚àò Œ¥ term G1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkb4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G1</span> <span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H3</span> : Map G1)
  (<span class="nv">H4</span> : Mult G1) (<span class="nv">H5</span> : Pure G1) (<span class="nv">H6</span> : Map G2)
  (<span class="nv">H7</span> : Mult G2) (<span class="nv">H8</span> : Pure G2)
  (<span class="nv">œï</span> : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A),
ApplicativeMorphism G1 G2 œï -&gt;
<span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
Œ¥ term G2 ‚àò map (œï A) = œï (term A) ‚àò Œ¥ term G1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkb5"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G2 ‚àò map (œï A) = œï (term A) ‚àò Œ¥ term G1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkb6">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G1 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Œ¥ term G2 ‚àò map (œï A)) t = (œï (term A) ‚àò Œ¥ term G1) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkb7"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G1 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G2 (map (œï A) t) = œï (term A) (Œ¥ term G1 t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkb8"><span class="nb">induction</span> t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G1 A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G2 (map (œï A) (Var a)) =
œï (term A) (Œ¥ term G1 (Var a))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chkb9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G1 A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (map (œï A) t) = œï (term A) (Œ¥ term G1 t)</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chkb9"><hr></label><div class="goal-conclusion">Œ¥ term G2 (map (œï A) (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t)) =
œï (term A) (Œ¥ term G1 (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t))</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chkba" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (map (œï A) t1) =
œï (term A) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (map (œï A) t2) =
œï (term A) (Œ¥ term G1 t2)</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chkba"><hr></label><div class="goal-conclusion">Œ¥ term G2 (map (œï A) ([t1][t2])) =
œï (term A) (Œ¥ term G1 ([t1][t2]))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkbb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G1 A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G2 (map (œï A) (Var a)) =
œï (term A) (Œ¥ term G1 (Var a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkbc"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G1 A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Var (A:=A)) (œï A a) =
œï (term A) (map (Var (A:=A)) a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> &lt;- (appmor_natural).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkbd">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G1 A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (map (œï A) t) = œï (term A) (Œ¥ term G1 t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G2 (map (œï A) (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t)) =
œï (term A) (Œ¥ term G1 (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkbe"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G1 A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (map (œï A) t) = œï (term A) (Œ¥ term G1 t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Lam X) (Œ¥ term G2 (map (œï A) t)) =
œï (term A) (map (Lam X) (Œ¥ term G1 t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkbf"><span class="nb">rewrite</span> IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G1 A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (map (œï A) t) = œï (term A) (Œ¥ term G1 t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Lam X) (œï (term A) (Œ¥ term G1 t)) =
œï (term A) (map (Lam X) (Œ¥ term G1 t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> (appmor_natural).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkc0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (map (œï A) t1) =
œï (term A) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (map (œï A) t2) =
œï (term A) (Œ¥ term G1 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G2 (map (œï A) ([t1][t2])) =
œï (term A) (Œ¥ term G1 ([t1][t2]))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkc1"><span class="nb">rewrite</span> map_term_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (map (œï A) t1) =
œï (term A) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (map (œï A) t2) =
œï (term A) (Œ¥ term G1 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G2 ([map (œï A) t1][map (œï A) t2]) =
œï (term A) (Œ¥ term G1 ([t1][t2]))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkc2"><span class="nb">inversion</span> H9.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (map (œï A) t1) =
œï (term A) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (map (œï A) t2) =
œï (term A) (Œ¥ term G1 t2)</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (map f x) = map f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (pure a) = pure a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G2 ([map (œï A) t1][map (œï A) t2]) =
œï (term A) (Œ¥ term G1 ([t1][t2]))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkc3"><span class="nb">rewrite</span> dist_term_ap_2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (map (œï A) t1) =
œï (term A) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (map (œï A) t2) =
œï (term A) (Œ¥ term G1 t2)</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (map f x) = map f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (pure a) = pure a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Ap (A:=A)) (Œ¥ term G2 (map (œï A) t1)) &lt;‚ãÜ&gt;
Œ¥ term G2 (map (œï A) t2) =
œï (term A) (Œ¥ term G1 ([t1][t2]))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkc4"><span class="nb">rewrite</span> IHt1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (map (œï A) t1) =
œï (term A) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (map (œï A) t2) =
œï (term A) (Œ¥ term G1 t2)</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (map f x) = map f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (pure a) = pure a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Ap (A:=A)) (œï (term A) (Œ¥ term G1 t1)) &lt;‚ãÜ&gt;
Œ¥ term G2 (map (œï A) t2) =
œï (term A) (Œ¥ term G1 ([t1][t2]))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkc5"><span class="nb">rewrite</span> IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (map (œï A) t1) =
œï (term A) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (map (œï A) t2) =
œï (term A) (Œ¥ term G1 t2)</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (map f x) = map f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (pure a) = pure a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Ap (A:=A)) (œï (term A) (Œ¥ term G1 t1)) &lt;‚ãÜ&gt;
œï (term A) (Œ¥ term G1 t2) =
œï (term A) (Œ¥ term G1 ([t1][t2]))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkc6"><span class="nb">rewrite</span> dist_term_ap_2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (map (œï A) t1) =
œï (term A) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (map (œï A) t2) =
œï (term A) (Œ¥ term G1 t2)</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (map f x) = map f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (pure a) = pure a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Ap (A:=A)) (œï (term A) (Œ¥ term G1 t1)) &lt;‚ãÜ&gt;
œï (term A) (Œ¥ term G1 t2) =
œï (term A)
  (map (Ap (A:=A)) (Œ¥ term G1 t1) &lt;‚ãÜ&gt; Œ¥ term G1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkc7"><span class="nb">rewrite</span> (ap_morphism_1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (map (œï A) t1) =
œï (term A) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (map (œï A) t2) =
œï (term A) (Œ¥ term G1 t2)</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (map f x) = map f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (pure a) = pure a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Ap (A:=A)) (œï (term A) (Œ¥ term G1 t1)) &lt;‚ãÜ&gt;
œï (term A) (Œ¥ term G1 t2) =
œï (term A -&gt; term A) (map (Ap (A:=A)) (Œ¥ term G1 t1)) &lt;‚ãÜ&gt;
œï (term A) (Œ¥ term G1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkc8">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (map (œï A) t1) =
œï (term A) (Œ¥ term G1 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G2 (map (œï A) t2) =
œï (term A) (Œ¥ term G1 t2)</span></span></span><br><span><var>appmor_app_F</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_app_G</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : G1 A),
œï B (map f x) = map f (œï A x)</span></span></span><br><span><var>appmor_pure</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (pure a) = pure a</span></span></span><br><span><var>appmor_mult</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G1 A)
  (<span class="nv">y</span> : G1 B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Ap (A:=A)) (œï (term A) (Œ¥ term G1 t1)) =
œï (term A -&gt; term A) (map (Ap (A:=A)) (Œ¥ term G1 t1))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> &lt;- (appmor_natural).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">dist_term_properties</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">TraversableFunctor_term</span> : TraversableFunctor term :=
  {| dist_natural := @dist_Natural_term;
     dist_morph := @dist_morph_term;
     dist_linear := @dist_linear_term;
     dist_unit := @dist_unit_term;
  |}.</span></span></pre></div>
</div>
<div class="section" id="decorated-traversable-functor-instance">
<h2><a class="toc-backref" href="#toc-entry-7">Decorated-Traversable Functor instance</a></h2>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkc9"><span class="kn">Lemma</span> <span class="nf">dtfun_compat_term1</span> : <span class="kr">forall</span> `{Applicative G} (X : typ) {A},
    map (dec term ‚àò Lam X) ‚àò Œ¥ term G (A := A) =
    map (F := G) (curry (shift term) <span class="mi">1</span> ‚àò Lam X) ‚àò map (dec term) ‚àò Œ¥ term G.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Map G) (<span class="nv">H0</span> : Pure G)
  (<span class="nv">H1</span> : Mult G),
Applicative G -&gt;
<span class="kr">forall</span> (<span class="nv">X</span> : typ) (<span class="nv">A</span> : <span class="kt">Type</span>),
map (dec term ‚àò Lam X) ‚àò Œ¥ term G =
map (curry (shift term) <span class="mi">1</span> ‚àò Lam X) ‚àò map (dec term)
‚àò Œ¥ term G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkca"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Map G) (<span class="nv">H0</span> : Pure G)
  (<span class="nv">H1</span> : Mult G),
Applicative G -&gt;
<span class="kr">forall</span> (<span class="nv">X</span> : typ) (<span class="nv">A</span> : <span class="kt">Type</span>),
map (dec term ‚àò Lam X) ‚àò Œ¥ term G =
map (curry (shift term) <span class="mi">1</span> ‚àò Lam X) ‚àò map (dec term)
‚àò Œ¥ term G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkcb"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (dec term ‚àò Lam X) ‚àò Œ¥ term G =
map (curry (shift term) <span class="mi">1</span> ‚àò Lam X) ‚àò map (dec term)
‚àò Œ¥ term G</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkcc"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (dec term ‚àò Lam X) ‚àò Œ¥ term G =
map (curry (shift term) <span class="mi">1</span> ‚àò Lam X ‚àò dec term)
‚àò Œ¥ term G</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkcd"><span class="kn">Theorem</span> <span class="nf">dtfun_compat_term</span> :
        `(<span class="kr">forall</span> `{Applicative G} {A : <span class="kt">Type</span>},
             dist term G ‚àò map (strength) ‚àò dec term (A := G A) =
             map (F := G) (dec term) ‚àò dist term G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Map G) (<span class="nv">H0</span> : Pure G)
  (<span class="nv">H1</span> : Mult G),
Applicative G -&gt;
<span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
Œ¥ term G ‚àò map (œÉ) ‚àò dec term =
map (dec term) ‚àò Œ¥ term G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkce"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Map G) (<span class="nv">H0</span> : Pure G)
  (<span class="nv">H1</span> : Mult G),
Applicative G -&gt;
<span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
Œ¥ term G ‚àò map (œÉ) ‚àò dec term =
map (dec term) ‚àò Œ¥ term G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkcf"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G ‚àò map (œÉ) ‚àò dec term =
map (dec term) ‚àò Œ¥ term G</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkd0">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Œ¥ term G ‚àò map (œÉ) ‚àò dec term) t =
(map (dec term) ‚àò Œ¥ term G) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkd1"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G (map (œÉ) (dec term t)) =
map (dec term) (Œ¥ term G t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkd2"><span class="nb">induction</span> t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G (map (œÉ) (dec term (Var a))) =
map (dec term) (Œ¥ term G (Var a))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chkd3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t)) = map (dec term) (Œ¥ term G t)</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chkd3"><hr></label><div class="goal-conclusion">Œ¥ term G (map (œÉ) (dec term (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t))) =
map (dec term) (Œ¥ term G (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t))</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chkd4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t1)) =
map (dec term) (Œ¥ term G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t2)) =
map (dec term) (Œ¥ term G t2)</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chkd4"><hr></label><div class="goal-conclusion">Œ¥ term G (map (œÉ) (dec term ([t1][t2]))) =
map (dec term) (Œ¥ term G ([t1][t2]))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkd5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G (map (œÉ) (dec term (Var a))) =
map (dec term) (Œ¥ term G (Var a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkd6"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Var (A:=nat * A)) (map (pair ∆µ) a) =
map (dec term) (map (Var (A:=A)) a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkd7">compose near a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (Var (A:=nat * A)) ‚àò map (pair ∆µ)) a =
(map (dec term) ‚àò map (Var (A:=A))) a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> <span class="mi">2</span>(fun_map_map).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkd8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t)) =
map (dec term) (Œ¥ term G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G (map (œÉ) (dec term (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t))) =
map (dec term) (Œ¥ term G (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkd9"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t)) =
map (dec term) (Œ¥ term G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Lam X)
  (Œ¥ term G
     (map (œÉ)
        (map (uncurry incr)
           (map (pair <span class="mi">1</span>) (dec term t))))) =
map (dec term) (map (Lam X) (Œ¥ term G t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkda"><span class="kp">do</span> <span class="mi">2</span> (compose near (dec term t) on <span class="nb">left</span>;
               <span class="nb">rewrite</span> (fun_map_map)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t)) =
map (dec term) (Œ¥ term G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Lam X)
  (Œ¥ term G
     (map (œÉ ‚àò (uncurry incr ‚àò pair <span class="mi">1</span>)) (dec term t))) =
map (dec term) (map (Lam X) (Œ¥ term G t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkdb">reassociate &lt;-.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t)) =
map (dec term) (Œ¥ term G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Lam X)
  (Œ¥ term G
     (map (œÉ ‚àò uncurry incr ‚àò pair <span class="mi">1</span>) (dec term t))) =
map (dec term) (map (Lam X) (Œ¥ term G t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkdc"><span class="nb">rewrite</span> incr_spec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t)) =
map (dec term) (Œ¥ term G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Lam X)
  (Œ¥ term G (map (œÉ ‚àò join ‚àò pair <span class="mi">1</span>) (dec term t))) =
map (dec term) (map (Lam X) (Œ¥ term G t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkdd"><span class="nb">rewrite</span> (strength_shift1 (W := nat) G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t)) =
map (dec term) (Œ¥ term G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Lam X)
  (Œ¥ term G
     (map (map (join ‚àò pair <span class="mi">1</span>) ‚àò œÉ) (dec term t))) =
map (dec term) (map (Lam X) (Œ¥ term G t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkde"><span class="nb">rewrite</span> &lt;- (fun_map_map); <span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t)) =
map (dec term) (Œ¥ term G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Lam X)
  (Œ¥ term G
     (map (map (join ‚óã pair <span class="mi">1</span>)) (map (œÉ) (dec term t)))) =
map (dec term) (map (Lam X) (Œ¥ term G t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkdf"><span class="nb">change</span> (map (map <span class="nl">?f</span>)) <span class="kr">with</span> (map (F := term ‚àò G) f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t)) =
map (dec term) (Œ¥ term G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Lam X)
  (Œ¥ term G
     (map (join ‚óã pair <span class="mi">1</span>) (map (œÉ) (dec term t)))) =
map (dec term) (map (Lam X) (Œ¥ term G t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chke0">compose near ((map (œÉ (F := G)) (dec term t))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t)) =
map (dec term) (Œ¥ term G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Lam X)
  ((Œ¥ term G ‚àò map (join ‚óã pair <span class="mi">1</span>))
     (map (œÉ) (dec term t))) =
map (dec term) (map (Lam X) (Œ¥ term G t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chke1">unfold_compose_in_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t)) =
map (dec term) (Œ¥ term G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Lam X)
  ((Œ¥ term G ‚àò map (join ‚óã pair <span class="mi">1</span>))
     (map (œÉ) (dec term t))) =
map (dec term) (map (Lam X) (Œ¥ term G t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chke2"><span class="nb">rewrite</span> &lt;- (natural (œï := @dist term _ G _ _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t)) =
map (dec term) (Œ¥ term G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Lam X)
  ((map (join ‚óã pair <span class="mi">1</span>) ‚àò Œ¥ term G)
     (map (œÉ) (dec term t))) =
map (dec term) (map (Lam X) (Œ¥ term G t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chke3"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t)) =
map (dec term) (Œ¥ term G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Lam X)
  (map (join ‚óã pair <span class="mi">1</span>)
     (Œ¥ term G (map (œÉ) (dec term t)))) =
map (dec term) (map (Lam X) (Œ¥ term G t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chke4"><span class="nb">rewrite</span> IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t)) =
map (dec term) (Œ¥ term G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Lam X)
  (map (join ‚óã pair <span class="mi">1</span>) (map (dec term) (Œ¥ term G t))) =
map (dec term) (map (Lam X) (Œ¥ term G t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chke5">compose near (Œ¥ term G t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t)) =
map (dec term) (Œ¥ term G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Lam X)
  ((map (join ‚óã pair <span class="mi">1</span>) ‚àò map (dec term)) (Œ¥ term G t)) =
(map (dec term) ‚àò map (Lam X)) (Œ¥ term G t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chke6"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t)) =
map (dec term) (Œ¥ term G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Lam X)
  ((map (join ‚óã pair <span class="mi">1</span>) ‚àò map (dec term)) (Œ¥ term G t)) =
map (dec term ‚àò Lam X) (Œ¥ term G t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chke7">compose near (Œ¥ term G t) on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t)) =
map (dec term) (Œ¥ term G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (Lam X) ‚àò (map (join ‚óã pair <span class="mi">1</span>) ‚àò map (dec term)))
  (Œ¥ term G t) = map (dec term ‚àò Lam X) (Œ¥ term G t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chke8">unfold_ops @Map_compose; <span class="nb">rewrite</span> <span class="mi">2</span>(fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t)) =
map (dec term) (Œ¥ term G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Lam X ‚àò (map (join ‚óã pair <span class="mi">1</span>) ‚àò dec term))
  (Œ¥ term G t) = map (dec term ‚àò Lam X) (Œ¥ term G t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chke9">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t)) =
map (dec term) (Œ¥ term G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Lam X ‚àò (map (join ‚óã pair <span class="mi">1</span>) ‚àò dec term) =
dec term ‚àò Lam X</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkea">ext t&#39;; <span class="nb">unfold</span> compose; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t)) =
map (dec term) (Œ¥ term G t)</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ map (join ‚óã pair <span class="mi">1</span>) (dec term t&#39;) =
<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ map (uncurry incr) (map (pair <span class="mi">1</span>) (dec term t&#39;))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkeb">compose near (dec term t&#39;) on <span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t)) =
map (dec term) (Œ¥ term G t)</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ map (join ‚óã pair <span class="mi">1</span>) (dec term t&#39;) =
<span class="kr">Œª</span> <span class="nv">X</span>
‚ãÖ (map (uncurry incr) ‚àò map (pair <span class="mi">1</span>)) (dec term t&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkec"><span class="nb">rewrite</span> (fun_map_map (F := term)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t)) =
map (dec term) (Œ¥ term G t)</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ map (join ‚óã pair <span class="mi">1</span>) (dec term t&#39;) =
<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ map (uncurry incr ‚àò pair <span class="mi">1</span>) (dec term t&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> incr_spec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chked">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t1)) =
map (dec term) (Œ¥ term G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t2)) =
map (dec term) (Œ¥ term G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G (map (œÉ) (dec term ([t1][t2]))) =
map (dec term) (Œ¥ term G ([t1][t2]))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkee" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkee"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t1)) =
map (dec term) (Œ¥ term G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t2)) =
map (dec term) (Œ¥ term G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (Ap (A:=nat * A)) &lt;‚ãÜ&gt;
Œ¥ term G (map (œÉ) (dec term t1)) &lt;‚ãÜ&gt;
Œ¥ term G (map (œÉ) (dec term t2)) =
map (dec term)
  (pure (Ap (A:=A)) &lt;‚ãÜ&gt; Œ¥ term G t1 &lt;‚ãÜ&gt; Œ¥ term G t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkef"><span class="nb">rewrite</span> IHt1, IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t1)) =
map (dec term) (Œ¥ term G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t2)) =
map (dec term) (Œ¥ term G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (Ap (A:=nat * A)) &lt;‚ãÜ&gt;
map (dec term) (Œ¥ term G t1) &lt;‚ãÜ&gt;
map (dec term) (Œ¥ term G t2) =
map (dec term)
  (pure (Ap (A:=A)) &lt;‚ãÜ&gt; Œ¥ term G t1 &lt;‚ãÜ&gt; Œ¥ term G t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkf0"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t1)) =
map (dec term) (Œ¥ term G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t2)) =
map (dec term) (Œ¥ term G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (Ap (A:=nat * A)) &lt;‚ãÜ&gt;
map (dec term) (Œ¥ term G t1) &lt;‚ãÜ&gt;
map (dec term) (Œ¥ term G t2) =
map (compose (dec term))
  (pure (Ap (A:=A)) &lt;‚ãÜ&gt; Œ¥ term G t1) &lt;‚ãÜ&gt; 
Œ¥ term G t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkf1"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t1)) =
map (dec term) (Œ¥ term G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t2)) =
map (dec term) (Œ¥ term G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (Ap (A:=nat * A)) &lt;‚ãÜ&gt;
map (dec term) (Œ¥ term G t1) &lt;‚ãÜ&gt;
map (dec term) (Œ¥ term G t2) =
map (compose (compose (dec term))) (pure (Ap (A:=A))) &lt;‚ãÜ&gt;
Œ¥ term G t1 &lt;‚ãÜ&gt; Œ¥ term G t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkf2"><span class="nb">rewrite</span> pure_ap_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t1)) =
map (dec term) (Œ¥ term G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t2)) =
map (dec term) (Œ¥ term G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Ap (A:=nat * A) ‚àò dec term) (Œ¥ term G t1) &lt;‚ãÜ&gt;
map (dec term) (Œ¥ term G t2) =
map (compose (compose (dec term))) (pure (Ap (A:=A))) &lt;‚ãÜ&gt;
Œ¥ term G t1 &lt;‚ãÜ&gt; Œ¥ term G t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkf3" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkf3"><span class="nb">rewrite</span> &lt;- ap_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t1)) =
map (dec term) (Œ¥ term G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t2)) =
map (dec term) (Œ¥ term G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (precompose (dec term))
  (map (Ap (A:=nat * A) ‚àò dec term) (Œ¥ term G t1)) &lt;‚ãÜ&gt;
Œ¥ term G t2 =
map (compose (compose (dec term))) (pure (Ap (A:=A))) &lt;‚ãÜ&gt;
Œ¥ term G t1 &lt;‚ãÜ&gt; Œ¥ term G t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkf4"><span class="nb">rewrite</span> (app_pure_natural).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t1)) =
map (dec term) (Œ¥ term G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t2)) =
map (dec term) (Œ¥ term G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (precompose (dec term))
  (map (Ap (A:=nat * A) ‚àò dec term) (Œ¥ term G t1)) &lt;‚ãÜ&gt;
Œ¥ term G t2 =
pure (compose (dec term) ‚àò Ap (A:=A)) &lt;‚ãÜ&gt; Œ¥ term G t1 &lt;‚ãÜ&gt;
Œ¥ term G t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkf5" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkf5"><span class="nb">rewrite</span> &lt;- (map_to_ap).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t1)) =
map (dec term) (Œ¥ term G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t2)) =
map (dec term) (Œ¥ term G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (precompose (dec term))
  (map (Ap (A:=nat * A) ‚àò dec term) (Œ¥ term G t1)) &lt;‚ãÜ&gt;
Œ¥ term G t2 =
map (compose (dec term) ‚àò Ap (A:=A)) (Œ¥ term G t1) &lt;‚ãÜ&gt;
Œ¥ term G t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkf6">compose near (Œ¥ term G t1) on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t1)) =
map (dec term) (Œ¥ term G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t2)) =
map (dec term) (Œ¥ term G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (precompose (dec term))
 ‚àò map (Ap (A:=nat * A) ‚àò dec term)) 
  (Œ¥ term G t1) &lt;‚ãÜ&gt; Œ¥ term G t2 =
map (compose (dec term) ‚àò Ap (A:=A)) (Œ¥ term G t1) &lt;‚ãÜ&gt;
Œ¥ term G t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkf7" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkf7"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t1)) =
map (dec term) (Œ¥ term G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (map (œÉ) (dec term t2)) =
map (dec term) (Œ¥ term G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (precompose (dec term)
   ‚àò (Ap (A:=nat * A) ‚àò dec term)) 
  (Œ¥ term G t1) &lt;‚ãÜ&gt; Œ¥ term G t2 =
map (compose (dec term) ‚àò Ap (A:=A)) (Œ¥ term G t1) &lt;‚ãÜ&gt;
Œ¥ term G t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> : DecoratedTraversableFunctor nat term :=
  {| dtfun_compat := @dtfun_compat_term |}.</span></span></pre></div>
</div>
<div class="section" id="monad-instances">
<h1><a class="toc-backref" href="#toc-entry-8">Monad instances</a></h1>
<div class="section" id="plain-monad-instance">
<h2><a class="toc-backref" href="#toc-entry-9">Plain Monad instance</a></h2>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">join_term</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">t</span> : term (term A)) : term A :=
  <span class="kr">match</span> t <span class="kr">with</span>
  | Var t&#39; =&gt; t&#39;
  | Lam X t =&gt; Lam X (join_term t)
  | Ap t1 t2 =&gt; Ap (join_term t1) (join_term t2)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Ret_term</span> : Return term := @Var.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Join_term</span> : Join term := @join_term.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkf8"><span class="kn">Theorem</span> <span class="nf">ret_natural</span> : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> (<span class="nv">f</span> : A -&gt; B),
    map f ‚àò ret (T := term)  = ret ‚àò f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
map f ‚àò ret = ret ‚àò f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkf9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
map f ‚àò ret = ret ‚àò f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkfa" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkfa"><span class="kn">Theorem</span> <span class="nf">join_natural</span> : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> (<span class="nv">f</span> : A -&gt; B),
    map f ‚àò join = join (T := term) ‚àò map (map f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
map f ‚àò join = join ‚àò map (map f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkfb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
map f ‚àò join = join ‚àò map (map f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkfc"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f ‚àò join = join ‚àò map (map f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkfd">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>(term ‚àò term) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map f ‚àò join) t = (join ‚àò map (map f)) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkfe"><span class="nb">unfold</span> transparent tcs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>(term ‚àò term) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map_term f ‚àò join_term) t =
(join_term ‚àò map_term (map_term f)) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chkff" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chkff"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>(term ‚àò term) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map_term f (join_term t) =
join_term (map_term (map_term f) t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">basic t.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk100">#[export] <span class="kn">Instance</span>: Natural (@ret term _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural (@ret term Ret_term)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk101" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk101"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural (@ret term Ret_term)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk102"><span class="nb">constructor</span>; <span class="kp">try</span> <span class="nb">typeclasses eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
map f ‚àò ret = ret ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ret_natural.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk103" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk103">#[export] <span class="kn">Instance</span>: Natural (@join term _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural (@join term Join_term)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk104"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural (@join term Join_term)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk105" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk105"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor (term ‚àò term)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor term</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
map f ‚àò join = join ‚àò map f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk106" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk106">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor (term ‚àò term)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk107" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk107">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor term</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk108" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk108">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
map f ‚àò join = join ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> join_natural.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk109" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk109"><span class="kn">Theorem</span> <span class="nf">join_ret</span> : <span class="kr">forall</span> <span class="nv">A</span>,
    join ‚àò ret (T := term) = @id (term A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, join ‚àò ret = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk10a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk10a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, join ‚àò ret = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk10b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk10b"><span class="kn">Theorem</span> <span class="nf">join_map_ret</span> : <span class="kr">forall</span> <span class="nv">A</span>,
    join (T := term) ‚àò map (F := term) (ret (T := term)) = @id (term A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, join ‚àò map ret = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk10c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, join ‚àò map ret = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk10d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk10d"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join ‚àò map ret = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk10e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk10e"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join ‚óã map ret = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk10f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk10f"><span class="nb">unfold</span> transparent tcs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join_term ‚óã map_term (Var (A:=A)) = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk110" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk110">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join_term (map_term (Var (A:=A)) t) = id t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">basic t.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk111"><span class="kn">Theorem</span> <span class="nf">join_join</span> : <span class="kr">forall</span> <span class="nv">A</span>,
    join (T := term) ‚àò join (T := term) = join (A := A) ‚àò map (join (T := term)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, join ‚àò join = join ‚àò map join</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk112" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk112"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, join ‚àò join = join ‚àò map join</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk113" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk113"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join ‚àò join = join ‚àò map join</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk114" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk114"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join ‚óã join = join ‚óã map join</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk115" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk115"><span class="nb">unfold</span> transparent tcs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join_term ‚óã join_term = join_term ‚óã map_term join_term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk116" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk116">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (term (term A))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join_term (join_term t) =
join_term (map_term join_term t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">basic t.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Monad_term</span> : Monad term :=
  {| mon_join_ret := join_ret;
     mon_join_map_ret := join_map_ret;
     mon_join_join := join_join |}.</span></span></pre></div>
<div class="section" id="decorated-monad-instance">
<h2><a class="toc-backref" href="#toc-entry-10">Decorated Monad instance</a></h2>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk117" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk117"><span class="kn">Theorem</span> <span class="nf">dec_ret</span> : <span class="kr">forall</span> <span class="nv">A</span>,
    dec term ‚àò ret (A := A) = ret (T := term) ‚àò pair ∆µ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, dec term ‚àò ret = ret ‚àò pair ∆µ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk118" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk118"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, dec term ‚àò ret = ret ‚àò pair ∆µ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk119" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk119"><span class="kn">Theorem</span> <span class="nf">dec_join</span> : <span class="kr">forall</span> <span class="nv">A</span>,
    dec term ‚àò join (T := term) (A := A) =
    join (T := term) ‚àò map (F := term) (shift term) ‚àò dec term ‚àò map (F := term) (dec term).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
dec term ‚àò join =
join ‚àò map (shift term) ‚àò dec term ‚àò map (dec term)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk11a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk11a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
dec term ‚àò join =
join ‚àò map (shift term) ‚àò dec term ‚àò map (dec term)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk11b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk11b"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec term ‚àò join =
join ‚àò map (shift term) ‚àò dec term ‚àò map (dec term)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk11c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk11c"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec term ‚óã join =
(<span class="kr">fun</span> <span class="nv">a</span> : term (term A) =&gt;
 join (map (shift term) (dec term (map (dec term) a))))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk11d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk11d">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (term A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec term (join t) =
join (map (shift term) (dec term (map (dec term) t)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk11e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk11e"><span class="nb">induction</span> t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec term (join (Var a)) =
join
  (map (shift term)
     (dec term (map (dec term) (Var a))))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chk11f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (term A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dec term (join t) = join (map (shift term) (dec term (map (dec term) t)))</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chk11f"><hr></label><div class="goal-conclusion">dec term (join (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t)) =
join
  (map (shift term)
     (dec term (map (dec term) (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t))))</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chk120" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (term A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dec term (join t1) =
join
  (map (shift term)
     (dec term (map (dec term) t1)))</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dec term (join t2) =
join
  (map (shift term)
     (dec term (map (dec term) t2)))</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chk120"><hr></label><div class="goal-conclusion">dec term (join ([t1][t2])) =
join
  (map (shift term)
     (dec term (map (dec term) ([t1][t2]))))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk121" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk121">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec term (join (Var a)) =
join
  (map (shift term)
     (dec term (map (dec term) (Var a))))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk122" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk122"><span class="nb">cbn</span> -[shift].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec term a = shift term (∆µ, dec term a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> (shift_zero term).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk123" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk123">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (term A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dec term (join t) =
join
  (map (shift term)
     (dec term (map (dec term) t)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec term (join (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t)) =
join
  (map (shift term)
     (dec term (map (dec term) (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t))))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk124" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk124"><span class="nb">cbn</span> -[shift].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (term A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dec term (join t) =
join
  (map (shift term)
     (dec term (map (dec term) t)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ shift term (<span class="mi">1</span>, dec term (join t)) =
<span class="kr">Œª</span> <span class="nv">X</span>
‚ãÖ join
    (map (shift term)
       (shift term (<span class="mi">1</span>, dec term (map (dec term) t))))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk125" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk125">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (term A)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dec term (join t) =
join
  (map (shift term)
     (dec term (map (dec term) t)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">shift term (<span class="mi">1</span>, dec term (join t)) =
join
  (map (shift term)
     (shift term (<span class="mi">1</span>, dec term (map (dec term) t))))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> (dec_helper_4).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk126" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk126">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (term A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dec term (join t1) =
join
  (map (shift term)
     (dec term (map (dec term) t1)))</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dec term (join t2) =
join
  (map (shift term)
     (dec term (map (dec term) t2)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec term (join ([t1][t2])) =
join
  (map (shift term)
     (dec term (map (dec term) ([t1][t2]))))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk127" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk127"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (term A)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dec term (join t1) =
join
  (map (shift term)
     (dec term (map (dec term) t1)))</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dec term (join t2) =
join
  (map (shift term)
     (dec term (map (dec term) t2)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[dec term (join t1)][dec term (join t2)] =
[join
   (map (shift term) (dec term (map (dec term) t1)))]
[join
   (map (shift term) (dec term (map (dec term) t2)))]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">fequal; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk128" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk128">#[export] <span class="kn">Instance</span> <span class="nf">DecoratedMonad_term</span> : DecoratedMonad nat term.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">DecoratedMonad nat term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk129" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk129"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">DecoratedMonad nat term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk12a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk12a"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">DecoratedFunctor nat term</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Monad term</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Monoid nat</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, dec term ‚àò ret = ret ‚àò pair ∆µ</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
dec term ‚àò join =
join ‚àò map (shift term) ‚àò dec term ‚àò map (dec term)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk12b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk12b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">DecoratedFunctor nat term</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk12c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk12c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Monad term</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk12d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk12d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Monoid nat</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk12e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk12e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, dec term ‚àò ret = ret ‚àò pair ∆µ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> dec_ret.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk12f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk12f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
dec term ‚àò join =
join ‚àò map (shift term) ‚àò dec term ‚àò map (dec term)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> dec_join.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></div>
<div class="section" id="traversable-monad-instance">
<h2><a class="toc-backref" href="#toc-entry-11">Traversable Monad instance</a></h2>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk130" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk130"><span class="kn">Theorem</span> <span class="nf">trvmon_ret_term</span> `{Applicative G} :
  `(dist term G ‚àò ret (T := term) (A := G A) = map (ret (T := term))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, Œ¥ term G ‚àò ret = map ret</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk131" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk131"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, Œ¥ term G ‚àò ret = map ret</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk132" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk132"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G ‚àò ret = map ret</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk133" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk133">ext x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Œ¥ term G ‚àò ret) x = map ret x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Tealeaves <span class="kn">Require Import</span> Categories.TraversableFunctor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Set Keyed Unification</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk134" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk134"><span class="kn">Theorem</span> <span class="nf">trvmon_join_term</span> `{Applicative G} :
  `(dist term G ‚àò join (T := term) = map (join (T := term)) ‚àò dist (term ‚àò term) G (A := A)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
Œ¥ term G ‚àò join = map join ‚àò Œ¥ (term ‚àò term) G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk135" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk135"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
Œ¥ term G ‚àò join = map join ‚àò Œ¥ (term ‚àò term) G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk136" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk136"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G ‚àò join = map join ‚àò Œ¥ (term ‚àò term) G</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk137" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk137">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>(term ‚àò term) (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Œ¥ term G ‚àò join) t = (map join ‚àò Œ¥ (term ‚àò term) G) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk138" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk138"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>(term ‚àò term) (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G (join t) = map join (Œ¥ (term ‚óã term) G t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk139" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk139"><span class="nb">induction</span> t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G (join (Var a)) =
map join (Œ¥ (term ‚óã term) G (Var a))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chk13a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join t) = map join (Œ¥ (term ‚óã term) G t)</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chk13a"><hr></label><div class="goal-conclusion">Œ¥ term G (join (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t)) =
map join (Œ¥ (term ‚óã term) G (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t))</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chk13b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join t1) =
map join (Œ¥ (term ‚óã term) G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join t2) =
map join (Œ¥ (term ‚óã term) G t2)</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chk13b"><hr></label><div class="goal-conclusion">Œ¥ term G (join ([t1][t2])) =
map join (Œ¥ (term ‚óã term) G ([t1][t2]))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk13c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk13c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G (join (Var a)) =
map join (Œ¥ (term ‚óã term) G (Var a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk13d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk13d"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G a =
map join (map (Var (A:=term A)) (Œ¥ term G a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk13e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk13e">compose near (dist term G a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G a =
(map join ‚àò map (Var (A:=term A))) (Œ¥ term G a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk13f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk13f"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G a = map (join ‚àò Var (A:=term A)) (Œ¥ term G a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk140" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk140"><span class="nb">replace</span> (join ‚àò Var (A := term A)) <span class="kr">with</span> (@id (term A)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G a = map id (Œ¥ term G a)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntaxcategorical-v-chk141" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br></div><label class="goal-separator" for="syntaxcategorical-v-chk141"><hr></label><div class="goal-conclusion">id = join ‚àò Var (A:=term A)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk142" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk142"><span class="bp">now</span> <span class="nb">rewrite</span> (fun_map_id).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>term (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">id = join ‚àò Var (A:=term A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (join_ret).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk143" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk143">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join t) =
map join (Œ¥ (term ‚óã term) G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G (join (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t)) =
map join (Œ¥ (term ‚óã term) G (<span class="kr">Œª</span> <span class="nv">X</span> ‚ãÖ t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk144" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk144"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join t) =
map join (Œ¥ (term ‚óã term) G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Lam X) (Œ¥ term G (join t)) =
map join (map (Lam X) (Œ¥ term G (map (Œ¥ term G) t)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk145" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk145"><span class="nb">rewrite</span> IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join t) =
map join (Œ¥ (term ‚óã term) G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Lam X) (map join (Œ¥ (term ‚óã term) G t)) =
map join (map (Lam X) (Œ¥ term G (map (Œ¥ term G) t)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk146" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk146">unfold_ops @Dist_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join t) =
map join (Œ¥ (term ‚óã term) G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Lam X) (map join ((Œ¥ term G ‚àò map (Œ¥ term G)) t)) =
map join (map (Lam X) (Œ¥ term G (map (Œ¥ term G) t)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk147" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk147"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join t) =
map join (Œ¥ (term ‚óã term) G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Lam X) (map join (Œ¥ term G (map (Œ¥ term G) t))) =
map join (map (Lam X) (Œ¥ term G (map (Œ¥ term G) t)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk148" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk148">compose near (dist term G (map (dist term G) t)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join t) =
map join (Œ¥ (term ‚óã term) G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (Lam X) ‚àò map join) (Œ¥ term G (map (Œ¥ term G) t)) =
(map join ‚àò map (Lam X)) (Œ¥ term G (map (Œ¥ term G) t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk149" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk149"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join t) =
map join (Œ¥ (term ‚óã term) G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Lam X ‚àò join) (Œ¥ term G (map (Œ¥ term G) t)) =
(map join ‚àò map (Lam X)) (Œ¥ term G (map (Œ¥ term G) t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk14a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk14a"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>typ</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join t) =
map join (Œ¥ (term ‚óã term) G t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Lam X ‚àò join) (Œ¥ term G (map (Œ¥ term G) t)) =
map (join ‚àò Lam X) (Œ¥ term G (map (Œ¥ term G) t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk14b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk14b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join t1) =
map join (Œ¥ (term ‚óã term) G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join t2) =
map join (Œ¥ (term ‚óã term) G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œ¥ term G (join ([t1][t2])) =
map join (Œ¥ (term ‚óã term) G ([t1][t2]))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk14c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk14c"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join t1) =
map join (Œ¥ (term ‚óã term) G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join t2) =
map join (Œ¥ (term ‚óã term) G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (Ap (A:=A)) &lt;‚ãÜ&gt; Œ¥ term G (join t1) &lt;‚ãÜ&gt;
Œ¥ term G (join t2) =
map join
  (pure (Ap (A:=term A)) &lt;‚ãÜ&gt;
   Œ¥ term G (map (Œ¥ term G) t1) &lt;‚ãÜ&gt;
   Œ¥ term G (map (Œ¥ term G) t2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk14d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk14d"><span class="nb">rewrite</span> IHt1, IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join t1) =
map join (Œ¥ (term ‚óã term) G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join t2) =
map join (Œ¥ (term ‚óã term) G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (Ap (A:=A)) &lt;‚ãÜ&gt; map join (Œ¥ (term ‚óã term) G t1) &lt;‚ãÜ&gt;
map join (Œ¥ (term ‚óã term) G t2) =
map join
  (pure (Ap (A:=term A)) &lt;‚ãÜ&gt;
   Œ¥ term G (map (Œ¥ term G) t1) &lt;‚ãÜ&gt;
   Œ¥ term G (map (Œ¥ term G) t2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk14e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk14e">unfold_ops @Dist_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join t1) =
map join (Œ¥ (term ‚óã term) G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join t2) =
map join (Œ¥ (term ‚óã term) G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (Ap (A:=A)) &lt;‚ãÜ&gt;
map join ((Œ¥ term G ‚àò map (Œ¥ term G)) t1) &lt;‚ãÜ&gt;
map join ((Œ¥ term G ‚àò map (Œ¥ term G)) t2) =
map join
  (pure (Ap (A:=term A)) &lt;‚ãÜ&gt;
   Œ¥ term G (map (Œ¥ term G) t1) &lt;‚ãÜ&gt;
   Œ¥ term G (map (Œ¥ term G) t2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk14f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk14f"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join t1) =
map join (Œ¥ (term ‚óã term) G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join t2) =
map join (Œ¥ (term ‚óã term) G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (Ap (A:=A)) &lt;‚ãÜ&gt;
map join (Œ¥ term G (map (Œ¥ term G) t1)) &lt;‚ãÜ&gt;
map join (Œ¥ term G (map (Œ¥ term G) t2)) =
map join
  (pure (Ap (A:=term A)) &lt;‚ãÜ&gt;
   Œ¥ term G (map (Œ¥ term G) t1) &lt;‚ãÜ&gt;
   Œ¥ term G (map (Œ¥ term G) t2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk150" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk150"><span class="nb">rewrite</span> &lt;- map_to_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join t1) =
map join (Œ¥ (term ‚óã term) G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join t2) =
map join (Œ¥ (term ‚óã term) G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Ap (A:=A))
  (map join (Œ¥ term G (map (Œ¥ term G) t1))) &lt;‚ãÜ&gt;
map join (Œ¥ term G (map (Œ¥ term G) t2)) =
map join
  (pure (Ap (A:=term A)) &lt;‚ãÜ&gt;
   Œ¥ term G (map (Œ¥ term G) t1) &lt;‚ãÜ&gt;
   Œ¥ term G (map (Œ¥ term G) t2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk151" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk151"><span class="nb">rewrite</span> &lt;- map_to_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join t1) =
map join (Œ¥ (term ‚óã term) G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join t2) =
map join (Œ¥ (term ‚óã term) G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Ap (A:=A))
  (map join (Œ¥ term G (map (Œ¥ term G) t1))) &lt;‚ãÜ&gt;
map join (Œ¥ term G (map (Œ¥ term G) t2)) =
map join
  (map (Ap (A:=term A)) (Œ¥ term G (map (Œ¥ term G) t1)) &lt;‚ãÜ&gt;
   Œ¥ term G (map (Œ¥ term G) t2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk152" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk152"><span class="nb">rewrite</span> &lt;- ap_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join t1) =
map join (Œ¥ (term ‚óã term) G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join t2) =
map join (Œ¥ (term ‚óã term) G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (precompose join)
  (map (Ap (A:=A))
     (map join (Œ¥ term G (map (Œ¥ term G) t1)))) &lt;‚ãÜ&gt;
Œ¥ term G (map (Œ¥ term G) t2) =
map join
  (map (Ap (A:=term A)) (Œ¥ term G (map (Œ¥ term G) t1)) &lt;‚ãÜ&gt;
   Œ¥ term G (map (Œ¥ term G) t2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk153" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk153"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join t1) =
map join (Œ¥ (term ‚óã term) G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join t2) =
map join (Œ¥ (term ‚óã term) G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (precompose join)
  (map (Ap (A:=A))
     (map join (Œ¥ term G (map (Œ¥ term G) t1)))) &lt;‚ãÜ&gt;
Œ¥ term G (map (Œ¥ term G) t2) =
map (compose join)
  (map (Ap (A:=term A)) (Œ¥ term G (map (Œ¥ term G) t1))) &lt;‚ãÜ&gt;
Œ¥ term G (map (Œ¥ term G) t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk154" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk154">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join t1) =
map join (Œ¥ (term ‚óã term) G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join t2) =
map join (Œ¥ (term ‚óã term) G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (precompose join)
  (map (Ap (A:=A))
     (map join (Œ¥ term G (map (Œ¥ term G) t1)))) =
map (compose join)
  (map (Ap (A:=term A)) (Œ¥ term G (map (Œ¥ term G) t1)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk155" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk155">compose near ((dist term G (map (dist term G) t1))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join t1) =
map join (Œ¥ (term ‚óã term) G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join t2) =
map join (Œ¥ (term ‚óã term) G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (precompose join)
  ((map (Ap (A:=A)) ‚àò map join)
     (Œ¥ term G (map (Œ¥ term G) t1))) =
(map (compose join) ‚àò map (Ap (A:=term A)))
  (Œ¥ term G (map (Œ¥ term G) t1))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk156" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk156"><span class="kp">repeat</span> <span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join t1) =
map join (Œ¥ (term ‚óã term) G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join t2) =
map join (Œ¥ (term ‚óã term) G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (precompose join)
  (map (Ap (A:=A) ‚àò join)
     (Œ¥ term G (map (Œ¥ term G) t1))) =
map (compose join ‚àò Ap (A:=term A))
  (Œ¥ term G (map (Œ¥ term G) t1))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk157" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk157">compose near ((dist term G (map (dist term G) t1))) on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join t1) =
map join (Œ¥ (term ‚óã term) G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join t2) =
map join (Œ¥ (term ‚óã term) G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (precompose join) ‚àò map (Ap (A:=A) ‚àò join))
  (Œ¥ term G (map (Œ¥ term G) t1)) =
map (compose join ‚àò Ap (A:=term A))
  (Œ¥ term G (map (Œ¥ term G) t1))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntaxcategorical-v-chk158" style="display: none" type="checkbox"><label class="alectryon-input" for="syntaxcategorical-v-chk158"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (term (G A))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join t1) =
map join (Œ¥ (term ‚óã term) G t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Œ¥ term G (join t2) =
map join (Œ¥ (term ‚óã term) G t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (precompose join ‚àò (Ap (A:=A) ‚àò join))
  (Œ¥ term G (map (Œ¥ term G) t1)) =
map (compose join ‚àò Ap (A:=term A))
  (Œ¥ term G (map (Œ¥ term G) t1))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">fequal.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Set Keyed Unification</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">TraversableMonad_term</span> : TraversableMonad term :=
  {| trvmon_ret := @trvmon_ret_term;
     trvmon_join := @trvmon_join_term;
  |}.</span></span></pre></div>
<div class="section" id="decorated-traversable-monad-instance">
<h2><a class="toc-backref" href="#toc-entry-12">Decorated-Traversable Monad instance</a></h2>
<p>Our hard work has paid off---a DTM is defined as the combination of the typeclass instances we have
given so far, so we can let Coq infer the DTM instance for us.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> : DecoratedTraversableMonad nat term := {}.</span></span></pre></div>
</div>
</div>
</div></body>
</html>
