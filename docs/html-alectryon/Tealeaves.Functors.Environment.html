<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<title>Environment.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.16.0+0.16.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Tealeaves <span class="kn">Require Export</span>
  Classes.Categorical.Monad
  Classes.Kleisli.DecoratedTraversableFunctor
  Classes.Kleisli.DecoratedTraversableMonad
  Classes.Categorical.DecoratedFunctor (shift)
  Functors.Subset
  Functors.Ctxset
  Functors.List.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> DecoratedTraversableFunctor.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Functor.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> List.ListNotations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Product.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Subset.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Applicative.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Strength.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Monoid.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Generalizable Variables</span> <span class="nf">W</span> M A B G œï.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">env</span> (<span class="nv">E</span> : <span class="kt">Type</span>) (<span class="nv">A</span> : <span class="kt">Type</span>) := list (E * A).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * The [env] decorated traversable functor, Kleisli-style *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">env</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    (<span class="nv">E</span> : <span class="kt">Type</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">mapdt_env</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) `{Map G} `{Pure G} `{Mult G}
    `(f : E * A -&gt; G B) (Œì : env E A) : G (env E B) :=
    <span class="kr">match</span> Œì <span class="kr">with</span>
    | nil =&gt; pure (@nil (E * B))
    | (e, a) :: rest =&gt;
        pure (@List.cons (E * B)) &lt;‚ãÜ&gt; œÉ (e, f (e, a)) &lt;‚ãÜ&gt; mapdt_env G f rest
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">traverse_env</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) `{Map G} `{Pure G} `{Mult G}
    `(f : A -&gt; G B) (l : env E A) : G (env E B) :=
    <span class="kr">match</span> l <span class="kr">with</span>
    | nil =&gt; pure (@nil (E * B))
    | (e, a) :: xs =&gt;
        pure (@List.cons (E * B)) &lt;‚ãÜ&gt; œÉ (e, f a) &lt;‚ãÜ&gt; traverse_env G f xs
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">mapd_env</span> `(f : E * A -&gt; B) (Œì : env E A) : env E B :=
    <span class="kr">match</span> Œì <span class="kr">with</span>
    | nil =&gt; @nil (E * B)
    | (e, a) :: rest =&gt;
        (e, f (e, a)) :: mapd_env f rest
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">map_env</span> `(f : A -&gt; B) (Œì : env E A) : env E B :=
    <span class="kr">match</span> Œì <span class="kr">with</span>
    | nil =&gt; @nil (E * B)
    | (e, a) :: rest =&gt;
        (e, f a) :: map_env f rest
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Mapdt_env</span> : Mapdt E (env E) := @mapdt_env.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Traverse_env</span> : Traverse (env E) := @traverse_env.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Mapd_env</span> : Mapd E (env E) := @mapd_env.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Map_env</span> : Map (env E) := @map_env.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">env</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simple_env_tactic</span> :=
  <span class="nb">intros</span>;
  <span class="kr">let</span> <span class="nv">l</span> := <span class="kp">fresh</span> <span class="s2">&quot;l&quot;</span> <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">e</span> := <span class="kp">fresh</span> <span class="s2">&quot;e&quot;</span> <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">a</span> := <span class="kp">fresh</span> <span class="s2">&quot;a&quot;</span> <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">rest</span> := <span class="kp">fresh</span> <span class="s2">&quot;rest&quot;</span> <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">IHrest</span> := <span class="kp">fresh</span> <span class="s2">&quot;IHrest&quot;</span> <span class="kr">in</span>
  ext l;
  ( <span class="nb">induction</span> l <span class="kr">as</span> [|[e a] rest IHrest] ||
  <span class="nb">induction</span> l <span class="kr">as</span> [|a rest IHrest] );
  [ <span class="bp">reflexivity</span> |
    <span class="kp">try</span> (<span class="nb">cbn</span>; <span class="bp">now</span> <span class="nb">rewrite</span> IHrest)].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Specifications for operations *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk0"><span class="kn">Lemma</span> <span class="nf">env_mapd_spec</span> : <span class="kr">forall</span> (<span class="nv">E</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : E * A -&gt; B),
    mapd (T := env E) f = map (F := list) (cobind (W := (E √ó)) f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">E</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : E * A -&gt; B),
mapd f = map (cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">E</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : E * A -&gt; B),
mapd f = map (cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">simple_env_tactic.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk2"><span class="kn">Lemma</span> <span class="nf">env_map_spec</span> :
  <span class="kr">forall</span> (<span class="nv">E</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
    map (F := env E) f = map (F := list) (map (F := (E √ó)) f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">E</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
map f = map (map f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">E</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
map f = map (map f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">simple_env_tactic.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk4"><span class="kn">Lemma</span> <span class="nf">env_map_spec2</span> : <span class="kr">forall</span> (<span class="nv">E</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
    map (F := env E) f = map (Map := Map_compose list (E √ó)) f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">E</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B), map f = map f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">E</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B), map f = map f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk6"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f = map f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> env_map_spec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Compatibility for operations *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk7"><span class="kn">Lemma</span> <span class="nf">env_traverse_compat</span> :
  <span class="kr">forall</span> (<span class="nv">E</span> : <span class="kt">Type</span>) `{Applicative G} (A B : <span class="kt">Type</span>) (f : A -&gt; G B),
    traverse f = mapdt (E := E) (f ‚àò extract).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">E</span> : <span class="kt">Type</span>) (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Map G)
  (<span class="nv">H0</span> : Pure G) (<span class="nv">H1</span> : Mult G),
Applicative G -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; G B),
traverse f = mapdt (f ‚àò extract)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">E</span> : <span class="kt">Type</span>) (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Map G)
  (<span class="nv">H0</span> : Pure G) (<span class="nv">H1</span> : Mult G),
Applicative G -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; G B),
traverse f = mapdt (f ‚àò extract)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">simple_env_tactic.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk9"><span class="kn">Lemma</span> <span class="nf">env_mapd_compat</span> : <span class="kr">forall</span> (<span class="nv">E</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : E * A -&gt; B),
    mapd (T := env E) f = mapdt (E := E) f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">E</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : E * A -&gt; B),
mapd f = mapdt f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chka"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">E</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : E * A -&gt; B),
mapd f = mapdt f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">simple_env_tactic.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chkb"><span class="kn">Lemma</span> <span class="nf">env_map_compat</span> : <span class="kr">forall</span> (<span class="nv">E</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
    map (F := env E) f = mapdt (E := E) (f ‚àò extract (W := (E √ó))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">E</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
map f = mapdt (f ‚àò extract)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chkc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">E</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
map f = mapdt (f ‚àò extract)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">simple_env_tactic.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chkd">#[export] <span class="kn">Instance</span> <span class="nf">Compat_Traverse_Mapdt_env</span> {<span class="nv">E</span>: <span class="kt">Type</span>}:
  Compat_Traverse_Mapdt (E := E).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Compat_Traverse_Mapdt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chke"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Compat_Traverse_Mapdt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chkf"><span class="nb">hnf</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">Map_inst</span> : Map G)
  (<span class="nv">Mult_inst</span> : Mult G) (<span class="nv">Pure_inst</span> : Pure G),
Applicative G -&gt;
@traverse (env E) (Traverse_env E) G Map_inst
  Pure_inst Mult_inst =
@traverse (env E) Traverse_Mapdt G Map_inst Pure_inst
  Mult_inst</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk10"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_inst</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Mult_inst</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Pure_inst</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@traverse (env E) (Traverse_env E) G Map_inst
  Pure_inst Mult_inst =
@traverse (env E) Traverse_Mapdt G Map_inst Pure_inst
  Mult_inst</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk11">ext A B f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_inst</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Mult_inst</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Pure_inst</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f = traverse f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk12"><span class="nb">rewrite</span> (env_traverse_compat E).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_inst</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Mult_inst</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Pure_inst</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt (f ‚àò extract) = traverse f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk13">#[export] <span class="kn">Instance</span> <span class="nf">Compat_Map_Mapdt_env</span> {<span class="nv">E</span>: <span class="kt">Type</span>}:
  Compat_Map_Mapdt (E := E).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Compat_Map_Mapdt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk14"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Compat_Map_Mapdt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk15"><span class="nb">hnf</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map (env E) (Map_env E) = @map (env E) Map_Mapdt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk16">ext A B f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f = map f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk17"><span class="nb">rewrite</span> env_map_compat.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt (f ‚àò extract) = map f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk18">#[export] <span class="kn">Instance</span> <span class="nf">Compat_Mapd_Mapdt_env</span> {<span class="nv">E</span>: <span class="kt">Type</span>}:
  Compat_Mapd_Mapdt (E := E).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Compat_Mapd_Mapdt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk19"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Compat_Mapd_Mapdt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk1a"><span class="nb">hnf</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@mapd E (env E) (Mapd_env E) =
@mapd E (env E) Mapd_Mapdt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk1b">ext A B f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapd f = mapd f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk1c"><span class="nb">rewrite</span> env_mapd_compat.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt f = mapd f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Rewriting lemmas for &lt;&lt;bindt&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">mapdt_rewriting_lemmas</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{Applicative G}
    (E A B : <span class="kt">Type</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk1d"><span class="kn">Lemma</span> <span class="nf">mapdt_env_nil</span> : <span class="kr">forall</span> `(f : E * A -&gt; G B),
      mapdt f (@nil (E * A)) = pure nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">f</span> : E * A -&gt; G B, mapdt f [] = pure []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk1e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">f</span> : E * A -&gt; G B, mapdt f [] = pure []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk1f"><span class="kn">Lemma</span> <span class="nf">mapdt_env_one</span> : <span class="kr">forall</span> (<span class="nv">f</span> : E * A -&gt; G B) (<span class="nv">e</span> : E) (<span class="nv">a</span> : A),
      mapdt f (ret (T := list) (e, a)) = map (ret (T := list) ‚àò pair e) (f (e, a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : E * A -&gt; G B) (<span class="nv">e</span> : E) (<span class="nv">a</span> : A),
mapdt f (ret (e, a)) = map (ret ‚àò pair e) (f (e, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk20"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : E * A -&gt; G B) (<span class="nv">e</span> : E) (<span class="nv">a</span> : A),
mapdt f (ret (e, a)) = map (ret ‚àò pair e) (f (e, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk21"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt f (ret (e, a)) = map (ret ‚àò pair e) (f (e, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk22"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; map (pair e) (f (e, a)) &lt;‚ãÜ&gt; pure [] =
map (ret ‚àò pair e) (f (e, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk23"><span class="nb">rewrite</span> map_to_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; (pure (pair e) &lt;‚ãÜ&gt; f (e, a)) &lt;‚ãÜ&gt; pure [] =
map (ret ‚àò pair e) (f (e, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk24"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;‚ãÜ&gt; pure cons &lt;‚ãÜ&gt; pure (pair e) &lt;‚ãÜ&gt;
f (e, a) &lt;‚ãÜ&gt; pure [] = map (ret ‚àò pair e) (f (e, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk25"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose cons) &lt;‚ãÜ&gt; pure (pair e) &lt;‚ãÜ&gt; f (e, a) &lt;‚ãÜ&gt;
pure [] = map (ret ‚àò pair e) (f (e, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk26"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (cons ‚àò pair e) &lt;‚ãÜ&gt; f (e, a) &lt;‚ãÜ&gt; pure [] =
map (ret ‚àò pair e) (f (e, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk27"><span class="nb">rewrite</span> ap3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (<span class="kr">fun</span> <span class="nv">f</span> : list (E * B) -&gt; list (E * B) =&gt; f []) &lt;‚ãÜ&gt;
(pure (cons ‚àò pair e) &lt;‚ãÜ&gt; f (e, a)) =
map (ret ‚àò pair e) (f (e, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk28"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;‚ãÜ&gt;
pure (<span class="kr">fun</span> <span class="nv">f</span> : list (E * B) -&gt; list (E * B) =&gt; f []) &lt;‚ãÜ&gt;
pure (cons ‚àò pair e) &lt;‚ãÜ&gt; f (e, a) =
map (ret ‚àò pair e) (f (e, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk29"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (compose
     (<span class="kr">fun</span> <span class="nv">f</span> : list (E * B) -&gt; list (E * B) =&gt; f [])) &lt;‚ãÜ&gt;
pure (cons ‚àò pair e) &lt;‚ãÜ&gt; f (e, a) =
map (ret ‚àò pair e) (f (e, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk2a"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  ((<span class="kr">fun</span> <span class="nv">f</span> : list (E * B) -&gt; list (E * B) =&gt; f [])
   ‚àò (cons ‚àò pair e)) &lt;‚ãÜ&gt; f (e, a) =
map (ret ‚àò pair e) (f (e, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk2b"><span class="nb">rewrite</span> &lt;- map_to_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  ((<span class="kr">fun</span> <span class="nv">f</span> : list (E * B) -&gt; list (E * B) =&gt; f [])
   ‚àò (cons ‚àò pair e)) (f (e, a)) =
map (ret ‚àò pair e) (f (e, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk2c"><span class="kn">Lemma</span> <span class="nf">mapdt_env_cons</span> : <span class="kr">forall</span> (<span class="nv">f</span> : E * A -&gt; G B) (<span class="nv">e</span> : E) (<span class="nv">a</span> : A) (<span class="nv">l</span> : env E A),
      mapdt f ((e, a) :: l) =
        pure cons &lt;‚ãÜ&gt; œÉ (e, f (e, a)) &lt;‚ãÜ&gt; mapdt f l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : E * A -&gt; G B) (<span class="nv">e</span> : E) (<span class="nv">a</span> : A)
  (<span class="nv">l</span> : env E A),
mapdt f ((e, a) :: l) =
pure cons &lt;‚ãÜ&gt; œÉ (e, f (e, a)) &lt;‚ãÜ&gt; mapdt f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk2d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : E * A -&gt; G B) (<span class="nv">e</span> : E) (<span class="nv">a</span> : A)
  (<span class="nv">l</span> : env E A),
mapdt f ((e, a) :: l) =
pure cons &lt;‚ãÜ&gt; œÉ (e, f (e, a)) &lt;‚ãÜ&gt; mapdt f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk2e"><span class="kn">Lemma</span> <span class="nf">mapdt_env_app</span> : <span class="kr">forall</span> (<span class="nv">f</span> : E * A -&gt; G B) (<span class="nv">l1</span> <span class="nv">l2</span> : env E A),
      mapdt f (l1 ++ l2) =
        pure (@app (E * B)) &lt;‚ãÜ&gt; mapdt f l1 &lt;‚ãÜ&gt; mapdt f l2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : E * A -&gt; G B) (<span class="nv">l1</span> <span class="nv">l2</span> : env E A),
mapdt f (l1 ++ l2) =
pure (app (A:=E * B)) &lt;‚ãÜ&gt; mapdt f l1 &lt;‚ãÜ&gt; mapdt f l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk2f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : E * A -&gt; G B) (<span class="nv">l1</span> <span class="nv">l2</span> : env E A),
mapdt f (l1 ++ l2) =
pure (app (A:=E * B)) &lt;‚ãÜ&gt; mapdt f l1 &lt;‚ãÜ&gt; mapdt f l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk30"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt f (l1 ++ l2) =
pure (app (A:=E * B)) &lt;‚ãÜ&gt; mapdt f l1 &lt;‚ãÜ&gt; mapdt f l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk31"><span class="nb">induction</span> l1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt f ([] ++ l2) =
pure (app (A:=E * B)) &lt;‚ãÜ&gt; mapdt f [] &lt;‚ãÜ&gt; mapdt f l2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="environment-v-chk32" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>E * A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>mapdt f (l1 ++ l2) =
pure (app (A:=E * B)) &lt;‚ãÜ&gt; mapdt f l1 &lt;‚ãÜ&gt;
mapdt f l2</span></span></span><br></div><label class="goal-separator" for="environment-v-chk32"><hr></label><div class="goal-conclusion">mapdt f ((a :: l1) ++ l2) =
pure (app (A:=E * B)) &lt;‚ãÜ&gt; mapdt f (a :: l1) &lt;‚ãÜ&gt;
mapdt f l2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk33">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt f ([] ++ l2) =
pure (app (A:=E * B)) &lt;‚ãÜ&gt; mapdt f [] &lt;‚ãÜ&gt; mapdt f l2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk34"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt f l2 =
pure (app (A:=E * B)) &lt;‚ãÜ&gt; pure [] &lt;‚ãÜ&gt; mapdt f l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk35"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt f l2 = pure (app []) &lt;‚ãÜ&gt; mapdt f l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk36"><span class="nb">rewrite</span> ap1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt f l2 = mapdt f l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk37">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>E * A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>mapdt f (l1 ++ l2) =
pure (app (A:=E * B)) &lt;‚ãÜ&gt; mapdt f l1 &lt;‚ãÜ&gt;
mapdt f l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt f ((a :: l1) ++ l2) =
pure (app (A:=E * B)) &lt;‚ãÜ&gt; mapdt f (a :: l1) &lt;‚ãÜ&gt;
mapdt f l2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk38"><span class="nb">destruct</span> a  <span class="kr">as</span> (e, a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>mapdt f (l1 ++ l2) =
pure (app (A:=E * B)) &lt;‚ãÜ&gt; mapdt f l1 &lt;‚ãÜ&gt;
mapdt f l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt f (((e, a) :: l1) ++ l2) =
pure (app (A:=E * B)) &lt;‚ãÜ&gt; mapdt f ((e, a) :: l1) &lt;‚ãÜ&gt;
mapdt f l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk39"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>mapdt f (l1 ++ l2) =
pure (app (A:=E * B)) &lt;‚ãÜ&gt; mapdt f l1 &lt;‚ãÜ&gt;
mapdt f l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; map (pair e) (f (e, a)) &lt;‚ãÜ&gt;
mapdt f (l1 ++ l2) =
pure (app (A:=E * B)) &lt;‚ãÜ&gt;
(pure cons &lt;‚ãÜ&gt; map (pair e) (f (e, a)) &lt;‚ãÜ&gt; mapdt f l1) &lt;‚ãÜ&gt;
mapdt f l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk3a"><span class="nb">rewrite</span> IHl1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>mapdt f (l1 ++ l2) =
pure (app (A:=E * B)) &lt;‚ãÜ&gt; mapdt f l1 &lt;‚ãÜ&gt;
mapdt f l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; map (pair e) (f (e, a)) &lt;‚ãÜ&gt;
(pure (app (A:=E * B)) &lt;‚ãÜ&gt; mapdt f l1 &lt;‚ãÜ&gt; mapdt f l2) =
pure (app (A:=E * B)) &lt;‚ãÜ&gt;
(pure cons &lt;‚ãÜ&gt; map (pair e) (f (e, a)) &lt;‚ãÜ&gt; mapdt f l1) &lt;‚ãÜ&gt;
mapdt f l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk3b"><span class="kp">repeat</span> <span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>mapdt f (l1 ++ l2) =
pure (app (A:=E * B)) &lt;‚ãÜ&gt; mapdt f l1 &lt;‚ãÜ&gt;
mapdt f l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
pure compose &lt;‚ãÜ&gt; pure cons &lt;‚ãÜ&gt; map (pair e) (f (e, a)) &lt;‚ãÜ&gt;
pure (app (A:=E * B)) &lt;‚ãÜ&gt; mapdt f l1 &lt;‚ãÜ&gt; mapdt f l2 =
pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
pure (app (A:=E * B)) &lt;‚ãÜ&gt; pure cons &lt;‚ãÜ&gt;
map (pair e) (f (e, a)) &lt;‚ãÜ&gt; mapdt f l1 &lt;‚ãÜ&gt; mapdt f l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk3c"><span class="kp">repeat</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>mapdt f (l1 ++ l2) =
pure (app (A:=E * B)) &lt;‚ãÜ&gt; mapdt f l1 &lt;‚ãÜ&gt;
mapdt f l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  ((compose ‚àò compose) compose compose compose compose
     cons) &lt;‚ãÜ&gt; map (pair e) (f (e, a)) &lt;‚ãÜ&gt;
pure (app (A:=E * B)) &lt;‚ãÜ&gt; mapdt f l1 &lt;‚ãÜ&gt; mapdt f l2 =
pure ((compose ‚àò compose) (app (A:=E * B)) cons) &lt;‚ãÜ&gt;
map (pair e) (f (e, a)) &lt;‚ãÜ&gt; mapdt f l1 &lt;‚ãÜ&gt; mapdt f l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk3d"><span class="nb">rewrite</span> ap3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>mapdt f (l1 ++ l2) =
pure (app (A:=E * B)) &lt;‚ãÜ&gt; mapdt f l1 &lt;‚ãÜ&gt;
mapdt f l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (<span class="kr">fun</span>
     <span class="nv">f</span> : (list (E * B) -&gt; list (E * B) -&gt; list (E * B)) -&gt;
         list (E * B) -&gt; list (E * B) -&gt; list (E * B)
   =&gt; f (app (A:=E * B))) &lt;‚ãÜ&gt;
(pure
   ((compose ‚àò compose) compose compose compose
      compose cons) &lt;‚ãÜ&gt; map (pair e) (f (e, a))) &lt;‚ãÜ&gt;
mapdt f l1 &lt;‚ãÜ&gt; mapdt f l2 =
pure ((compose ‚àò compose) (app (A:=E * B)) cons) &lt;‚ãÜ&gt;
map (pair e) (f (e, a)) &lt;‚ãÜ&gt; mapdt f l1 &lt;‚ãÜ&gt; mapdt f l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk3e"><span class="kp">repeat</span> <span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>mapdt f (l1 ++ l2) =
pure (app (A:=E * B)) &lt;‚ãÜ&gt; mapdt f l1 &lt;‚ãÜ&gt;
mapdt f l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;‚ãÜ&gt;
pure
  (<span class="kr">fun</span>
     <span class="nv">f</span> : (list (E * B) -&gt; list (E * B) -&gt; list (E * B)) -&gt;
         list (E * B) -&gt; list (E * B) -&gt; list (E * B)
   =&gt; f (app (A:=E * B))) &lt;‚ãÜ&gt;
pure
  ((compose ‚àò compose) compose compose compose compose
     cons) &lt;‚ãÜ&gt; map (pair e) (f (e, a)) &lt;‚ãÜ&gt; mapdt f l1 &lt;‚ãÜ&gt;
mapdt f l2 =
pure ((compose ‚àò compose) (app (A:=E * B)) cons) &lt;‚ãÜ&gt;
map (pair e) (f (e, a)) &lt;‚ãÜ&gt; mapdt f l1 &lt;‚ãÜ&gt; mapdt f l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk3f"><span class="kp">repeat</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>mapdt f (l1 ++ l2) =
pure (app (A:=E * B)) &lt;‚ãÜ&gt; mapdt f l1 &lt;‚ãÜ&gt;
mapdt f l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  ((<span class="kr">fun</span>
      <span class="nv">f</span> : (list (E * B) -&gt;
           list (E * B) -&gt; list (E * B)) -&gt;
          list (E * B) -&gt; list (E * B) -&gt; list (E * B)
    =&gt; f (app (A:=E * B)))
   ‚àò (compose ‚àò compose) compose compose compose
       compose cons) &lt;‚ãÜ&gt; map (pair e) (f (e, a)) &lt;‚ãÜ&gt;
mapdt f l1 &lt;‚ãÜ&gt; mapdt f l2 =
pure ((compose ‚àò compose) (app (A:=E * B)) cons) &lt;‚ãÜ&gt;
map (pair e) (f (e, a)) &lt;‚ãÜ&gt; mapdt f l1 &lt;‚ãÜ&gt; mapdt f l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">mapdt_rewriting_lemmas</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Hint Rewrite</span>
  mapdt_env_nil @mapdt_env_cons mapdt_env_one mapdt_env_app :
  tea_env.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Decorated traversable functor instance *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">env_laws</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    (<span class="nv">E</span> : <span class="kt">Type</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk40"><span class="kn">Lemma</span> <span class="nf">env_mapdt1</span> : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, mapdt (extract (W := (E √ó))) = @id (env E A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, mapdt extract = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk41"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, mapdt extract = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk42"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt extract = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk43">ext l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt extract l = id l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk44"><span class="nb">induction</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt extract [] = id []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="environment-v-chk45" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>E * A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>mapdt extract l = id l</span></span></span><br></div><label class="goal-separator" for="environment-v-chk45"><hr></label><div class="goal-conclusion">mapdt extract (a :: l) = id (a :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk46">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt extract [] = id []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk47">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>E * A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>mapdt extract l = id l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt extract (a :: l) = id (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk48"><span class="nb">destruct</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>mapdt extract l = id l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt extract ((e, a) :: l) = id ((e, a) :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk49"><span class="nb">autorewrite with</span> tea_env.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>mapdt extract l = id l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; œÉ (e, extract (e, a)) &lt;‚ãÜ&gt;
mapdt extract l = id ((e, a) :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk4a"><span class="nb">rewrite</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>mapdt extract l = id l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; œÉ (e, extract (e, a)) &lt;‚ãÜ&gt; id l =
id ((e, a) :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk4b"><span class="kn">Lemma</span> <span class="nf">env_mapdt2</span>
    `{Applicative G1}
    `{Applicative G2} :
    <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>)
      (<span class="nv">g</span> : E * B -&gt; G2 C)
      (<span class="nv">f</span> : E * A -&gt; G1 B),
      map (mapdt g) ‚àò mapdt f =
        mapdt (G := G1 ‚àò G2) (g ‚ãÜ<span class="mi">6</span> f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">g</span> : E * B -&gt; G2 C)
  (<span class="nv">f</span> : E * A -&gt; G1 B),
map (mapdt g) ‚àò mapdt f = mapdt (g ‚ãÜ<span class="mi">6</span> f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk4c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">g</span> : E * B -&gt; G2 C)
  (<span class="nv">f</span> : E * A -&gt; G1 B),
map (mapdt g) ‚àò mapdt f = mapdt (g ‚ãÜ<span class="mi">6</span> f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk4d"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mapdt g) ‚àò mapdt f = mapdt (g ‚ãÜ<span class="mi">6</span> f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk4e">ext l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (mapdt g) ‚àò mapdt f) l = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk4f"><span class="nb">induction</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (mapdt g) ‚àò mapdt f) [] = mapdt (g ‚ãÜ<span class="mi">6</span> f) []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="environment-v-chk50" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>E * A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(map (mapdt g) ‚àò mapdt f) l = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br></div><label class="goal-separator" for="environment-v-chk50"><hr></label><div class="goal-conclusion">(map (mapdt g) ‚àò mapdt f) (a :: l) =
mapdt (g ‚ãÜ<span class="mi">6</span> f) (a :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk51">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (mapdt g) ‚àò mapdt f) [] = mapdt (g ‚ãÜ<span class="mi">6</span> f) []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk52"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mapdt g) (mapdt f []) = mapdt (g ‚ãÜ<span class="mi">6</span> f) []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk53"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mapdt g) (pure []) = pure []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk54">compose near (@nil (E * B)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (mapdt g) ‚àò pure) [] = pure []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk55"><span class="nb">rewrite</span> (natural (œï := @pure G1 _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(pure ‚àò map (mapdt g)) [] = pure []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk56">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>E * A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(map (mapdt g) ‚àò mapdt f) l = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (mapdt g) ‚àò mapdt f) (a :: l) =
mapdt (g ‚ãÜ<span class="mi">6</span> f) (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk57"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>E * A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(map (mapdt g) ‚àò mapdt f) l = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mapdt g) (mapdt f (a :: l)) =
mapdt (g ‚ãÜ<span class="mi">6</span> f) (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk58"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">1</span> <span class="kr">in</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>E * A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mapdt g) (mapdt f (a :: l)) =
mapdt (g ‚ãÜ<span class="mi">6</span> f) (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk59"><span class="nb">destruct</span> a <span class="kr">as</span> [e a].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mapdt g) (mapdt f ((e, a) :: l)) =
mapdt (g ‚ãÜ<span class="mi">6</span> f) ((e, a) :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk5a"><span class="nb">autorewrite with</span> tea_env.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mapdt g)
  (pure cons &lt;‚ãÜ&gt; œÉ (e, f (e, a)) &lt;‚ãÜ&gt; mapdt f l) =
pure cons &lt;‚ãÜ&gt; œÉ (e, (g ‚ãÜ<span class="mi">6</span> f) (e, a)) &lt;‚ãÜ&gt;
mapdt (g ‚ãÜ<span class="mi">6</span> f) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk5b"><span class="nb">unfold</span> strength.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mapdt g)
  (pure cons &lt;‚ãÜ&gt; map (pair e) (f (e, a)) &lt;‚ãÜ&gt; mapdt f l) =
pure cons &lt;‚ãÜ&gt; map (pair e) ((g ‚ãÜ<span class="mi">6</span> f) (e, a)) &lt;‚ãÜ&gt;
mapdt (g ‚ãÜ<span class="mi">6</span> f) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk5c"><span class="nb">rewrite</span> (map_to_ap (A := B) (G := G1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mapdt g)
  (pure cons &lt;‚ãÜ&gt; (pure (pair e) &lt;‚ãÜ&gt; f (e, a)) &lt;‚ãÜ&gt;
   mapdt f l) =
pure cons &lt;‚ãÜ&gt; map (pair e) ((g ‚ãÜ<span class="mi">6</span> f) (e, a)) &lt;‚ãÜ&gt;
mapdt (g ‚ãÜ<span class="mi">6</span> f) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk5d"><span class="nb">rewrite</span> &lt;- ap4; <span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mapdt g)
  (pure (cons ‚àò pair e) &lt;‚ãÜ&gt; f (e, a) &lt;‚ãÜ&gt; mapdt f l) =
pure cons &lt;‚ãÜ&gt; map (pair e) ((g ‚ãÜ<span class="mi">6</span> f) (e, a)) &lt;‚ãÜ&gt;
mapdt (g ‚ãÜ<span class="mi">6</span> f) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk5e"><span class="nb">rewrite</span> map_to_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (mapdt g) &lt;‚ãÜ&gt;
(pure (cons ‚àò pair e) &lt;‚ãÜ&gt; f (e, a) &lt;‚ãÜ&gt; mapdt f l) =
pure cons &lt;‚ãÜ&gt; map (pair e) ((g ‚ãÜ<span class="mi">6</span> f) (e, a)) &lt;‚ãÜ&gt;
mapdt (g ‚ãÜ<span class="mi">6</span> f) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk5f"><span class="nb">rewrite</span> &lt;- ap4; <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt g)) &lt;‚ãÜ&gt;
(pure (cons ‚àò pair e) &lt;‚ãÜ&gt; f (e, a)) &lt;‚ãÜ&gt; mapdt f l =
pure cons &lt;‚ãÜ&gt; map (pair e) ((g ‚ãÜ<span class="mi">6</span> f) (e, a)) &lt;‚ãÜ&gt;
mapdt (g ‚ãÜ<span class="mi">6</span> f) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk60"><span class="nb">rewrite</span> &lt;- ap4; <span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt g) ‚àò (cons ‚àò pair e)) &lt;‚ãÜ&gt;
f (e, a) &lt;‚ãÜ&gt; mapdt f l =
pure cons &lt;‚ãÜ&gt; map (pair e) ((g ‚ãÜ<span class="mi">6</span> f) (e, a)) &lt;‚ãÜ&gt;
mapdt (g ‚ãÜ<span class="mi">6</span> f) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="c">(* RHS *)</span>
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk61"><span class="nb">rewrite</span> map_to_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt g) ‚àò (cons ‚àò pair e)) &lt;‚ãÜ&gt;
f (e, a) &lt;‚ãÜ&gt; mapdt f l =
pure cons &lt;‚ãÜ&gt; (pure (pair e) &lt;‚ãÜ&gt; (g ‚ãÜ<span class="mi">6</span> f) (e, a)) &lt;‚ãÜ&gt;
mapdt (g ‚ãÜ<span class="mi">6</span> f) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk62"><span class="nb">rewrite</span> &lt;- ap4; <span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt g) ‚àò (cons ‚àò pair e)) &lt;‚ãÜ&gt;
f (e, a) &lt;‚ãÜ&gt; mapdt f l =
pure (cons ‚àò pair e) &lt;‚ãÜ&gt; (g ‚ãÜ<span class="mi">6</span> f) (e, a) &lt;‚ãÜ&gt;
mapdt (g ‚ãÜ<span class="mi">6</span> f) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk63"><span class="nb">rewrite</span> &lt;- IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt g) ‚àò (cons ‚àò pair e)) &lt;‚ãÜ&gt;
f (e, a) &lt;‚ãÜ&gt; mapdt f l =
pure (cons ‚àò pair e) &lt;‚ãÜ&gt; (g ‚ãÜ<span class="mi">6</span> f) (e, a) &lt;‚ãÜ&gt;
map (mapdt g) (mapdt f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk64"><span class="nb">rewrite</span> map_to_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt g) ‚àò (cons ‚àò pair e)) &lt;‚ãÜ&gt;
f (e, a) &lt;‚ãÜ&gt; mapdt f l =
pure (cons ‚àò pair e) &lt;‚ãÜ&gt; (g ‚ãÜ<span class="mi">6</span> f) (e, a) &lt;‚ãÜ&gt;
(pure (mapdt g) &lt;‚ãÜ&gt; mapdt f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk65"><span class="nb">rewrite</span> (ap_compose1 G2 G1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt g) ‚àò (cons ‚àò pair e)) &lt;‚ãÜ&gt;
f (e, a) &lt;‚ãÜ&gt; mapdt f l =
pure (ap G2) &lt;‚ãÜ&gt;
(pure (cons ‚àò pair e) &lt;‚ãÜ&gt; (g ‚ãÜ<span class="mi">6</span> f) (e, a)) &lt;‚ãÜ&gt;
(pure (mapdt g) &lt;‚ãÜ&gt; mapdt f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk66"><span class="nb">rewrite</span> (ap_compose1 G2 G1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt g) ‚àò (cons ‚àò pair e)) &lt;‚ãÜ&gt;
f (e, a) &lt;‚ãÜ&gt; mapdt f l =
pure (ap G2) &lt;‚ãÜ&gt;
(pure (ap G2) &lt;‚ãÜ&gt; pure (cons ‚àò pair e) &lt;‚ãÜ&gt;
 (g ‚ãÜ<span class="mi">6</span> f) (e, a)) &lt;‚ãÜ&gt; (pure (mapdt g) &lt;‚ãÜ&gt; mapdt f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk67">unfold_ops @Pure_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt g) ‚àò (cons ‚àò pair e)) &lt;‚ãÜ&gt;
f (e, a) &lt;‚ãÜ&gt; mapdt f l =
pure (ap G2) &lt;‚ãÜ&gt;
(pure (ap G2) &lt;‚ãÜ&gt; pure (pure (cons ‚àò pair e)) &lt;‚ãÜ&gt;
 (g ‚ãÜ<span class="mi">6</span> f) (e, a)) &lt;‚ãÜ&gt; (pure (mapdt g) &lt;‚ãÜ&gt; mapdt f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk68"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt g) ‚àò (cons ‚àò pair e)) &lt;‚ãÜ&gt;
f (e, a) &lt;‚ãÜ&gt; mapdt f l =
pure compose &lt;‚ãÜ&gt;
(pure (ap G2) &lt;‚ãÜ&gt;
 (pure (ap G2) &lt;‚ãÜ&gt; pure (pure (cons ‚àò pair e)) &lt;‚ãÜ&gt;
  (g ‚ãÜ<span class="mi">6</span> f) (e, a))) &lt;‚ãÜ&gt; pure (mapdt g) &lt;‚ãÜ&gt; mapdt f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk69"><span class="nb">rewrite</span> &lt;- ap4; <span class="kp">do</span> <span class="mi">3</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt g) ‚àò (cons ‚àò pair e)) &lt;‚ãÜ&gt;
f (e, a) &lt;‚ãÜ&gt; mapdt f l =
pure (compose ‚àò ap G2) &lt;‚ãÜ&gt;
(pure (ap G2 (pure (cons ‚àò pair e))) &lt;‚ãÜ&gt;
 (g ‚ãÜ<span class="mi">6</span> f) (e, a)) &lt;‚ãÜ&gt; pure (mapdt g) &lt;‚ãÜ&gt; mapdt f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk6a"><span class="nb">rewrite</span> &lt;- ap4; <span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt g) ‚àò (cons ‚àò pair e)) &lt;‚ãÜ&gt;
f (e, a) &lt;‚ãÜ&gt; mapdt f l =
pure (compose ‚àò ap G2 ‚àò ap G2 (pure (cons ‚àò pair e))) &lt;‚ãÜ&gt;
(g ‚ãÜ<span class="mi">6</span> f) (e, a) &lt;‚ãÜ&gt; pure (mapdt g) &lt;‚ãÜ&gt; mapdt f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk6b"><span class="nb">unfold</span> kc6, compose, strength.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (<span class="kr">fun</span> <span class="nv">a</span> : B =&gt; mapdt g ‚óã cons (e, a)) &lt;‚ãÜ&gt; f (e, a) &lt;‚ãÜ&gt;
mapdt f l =
pure
  (<span class="kr">fun</span> (<span class="nv">a</span> : G2 C) (<span class="nv">f</span> : env E B -&gt; G2 (list (E * C)))
   =&gt; ap G2 (pure (cons ‚óã pair e) &lt;‚ãÜ&gt; a) ‚óã f) &lt;‚ãÜ&gt;
map g
  (<span class="kr">let</span> &#39;(a, t) := cobind f (e, a) <span class="kr">in</span> map (pair a) t) &lt;‚ãÜ&gt;
pure (mapdt g) &lt;‚ãÜ&gt; mapdt f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk6c"><span class="nb">change</span> (cobind f (e, a)) <span class="kr">with</span> (e, f (e, a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (<span class="kr">fun</span> <span class="nv">a</span> : B =&gt; mapdt g ‚óã cons (e, a)) &lt;‚ãÜ&gt; f (e, a) &lt;‚ãÜ&gt;
mapdt f l =
pure
  (<span class="kr">fun</span> (<span class="nv">a</span> : G2 C) (<span class="nv">f</span> : env E B -&gt; G2 (list (E * C)))
   =&gt; ap G2 (pure (cons ‚óã pair e) &lt;‚ãÜ&gt; a) ‚óã f) &lt;‚ãÜ&gt;
map g (<span class="kr">let</span> &#39;(a, t) := (e, f (e, a)) <span class="kr">in</span> map (pair a) t) &lt;‚ãÜ&gt;
pure (mapdt g) &lt;‚ãÜ&gt; mapdt f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk6d"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> map_to_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (<span class="kr">fun</span> <span class="nv">a</span> : B =&gt; mapdt g ‚óã cons (e, a)) &lt;‚ãÜ&gt; f (e, a) &lt;‚ãÜ&gt;
mapdt f l =
pure
  (<span class="kr">fun</span> (<span class="nv">a</span> : G2 C) (<span class="nv">f</span> : env E B -&gt; G2 (list (E * C)))
   =&gt; ap G2 (pure (cons ‚óã pair e) &lt;‚ãÜ&gt; a) ‚óã f) &lt;‚ãÜ&gt;
(pure g &lt;‚ãÜ&gt; (pure (pair e) &lt;‚ãÜ&gt; f (e, a))) &lt;‚ãÜ&gt;
pure (mapdt g) &lt;‚ãÜ&gt; mapdt f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk6e"><span class="nb">rewrite</span> &lt;- ap4; <span class="kp">repeat</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (<span class="kr">fun</span> <span class="nv">a</span> : B =&gt; mapdt g ‚óã cons (e, a)) &lt;‚ãÜ&gt; f (e, a) &lt;‚ãÜ&gt;
mapdt f l =
pure
  ((<span class="kr">fun</span> (<span class="nv">a</span> : G2 C) (<span class="nv">f</span> : env E B -&gt; G2 (list (E * C)))
    =&gt; ap G2 (pure (cons ‚óã pair e) &lt;‚ãÜ&gt; a) ‚óã f) ‚àò g) &lt;‚ãÜ&gt;
(pure (pair e) &lt;‚ãÜ&gt; f (e, a)) &lt;‚ãÜ&gt; pure (mapdt g) &lt;‚ãÜ&gt;
mapdt f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk6f"><span class="nb">rewrite</span> &lt;- ap4; <span class="kp">repeat</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (<span class="kr">fun</span> <span class="nv">a</span> : B =&gt; mapdt g ‚óã cons (e, a)) &lt;‚ãÜ&gt; f (e, a) &lt;‚ãÜ&gt;
mapdt f l =
pure
  ((<span class="kr">fun</span> (<span class="nv">a</span> : G2 C) (<span class="nv">f</span> : env E B -&gt; G2 (list (E * C)))
    =&gt; ap G2 (pure (cons ‚óã pair e) &lt;‚ãÜ&gt; a) ‚óã f) ‚àò g
   ‚àò pair e) &lt;‚ãÜ&gt; f (e, a) &lt;‚ãÜ&gt; pure (mapdt g) &lt;‚ãÜ&gt;
mapdt f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk70"><span class="nb">rewrite</span> ap3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (<span class="kr">fun</span> <span class="nv">a</span> : B =&gt; mapdt g ‚óã cons (e, a)) &lt;‚ãÜ&gt; f (e, a) &lt;‚ãÜ&gt;
mapdt f l =
pure
  (<span class="kr">fun</span>
     <span class="nv">f</span> : (env E B -&gt; G2 (list (E * C))) -&gt;
         env E B -&gt; G2 (list (E * C)) =&gt; f (mapdt g)) &lt;‚ãÜ&gt;
(pure
   ((<span class="kr">fun</span> (<span class="nv">a</span> : G2 C) (<span class="nv">f</span> : env E B -&gt; G2 (list (E * C)))
     =&gt; ap G2 (pure (cons ‚óã pair e) &lt;‚ãÜ&gt; a) ‚óã f) ‚àò g
    ‚àò pair e) &lt;‚ãÜ&gt; f (e, a)) &lt;‚ãÜ&gt; mapdt f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk71"><span class="nb">rewrite</span> &lt;- ap4; <span class="kp">repeat</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (<span class="kr">fun</span> <span class="nv">a</span> : B =&gt; mapdt g ‚óã cons (e, a)) &lt;‚ãÜ&gt; f (e, a) &lt;‚ãÜ&gt;
mapdt f l =
pure
  ((<span class="kr">fun</span>
      <span class="nv">f</span> : (env E B -&gt; G2 (list (E * C))) -&gt;
          env E B -&gt; G2 (list (E * C)) =&gt; f (mapdt g))
   ‚àò ((<span class="kr">fun</span> (<span class="nv">a</span> : G2 C)
         (<span class="nv">f</span> : env E B -&gt; G2 (list (E * C))) =&gt;
       ap G2 (pure (cons ‚óã pair e) &lt;‚ãÜ&gt; a) ‚óã f) ‚àò g
      ‚àò pair e)) &lt;‚ãÜ&gt; f (e, a) &lt;‚ãÜ&gt; mapdt f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk72"><span class="kp">repeat</span> fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">a</span> : B =&gt; mapdt g ‚óã cons (e, a)) =
(<span class="kr">fun</span>
   <span class="nv">f</span> : (env E B -&gt; G2 (list (E * C))) -&gt;
       env E B -&gt; G2 (list (E * C)) =&gt; f (mapdt g))
‚àò ((<span class="kr">fun</span> (<span class="nv">a</span> : G2 C) (<span class="nv">f</span> : env E B -&gt; G2 (list (E * C)))
    =&gt; ap G2 (pure (cons ‚óã pair e) &lt;‚ãÜ&gt; a) ‚óã f) ‚àò g
   ‚àò pair e)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk73">ext b l&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list (E * B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt g ((e, b) :: l&#39;) =
((<span class="kr">fun</span>
    <span class="nv">f</span> : (env E B -&gt; G2 (list (E * C))) -&gt;
        env E B -&gt; G2 (list (E * C)) =&gt; f (mapdt g))
 ‚àò ((<span class="kr">fun</span> (<span class="nv">a</span> : G2 C) (<span class="nv">f</span> : env E B -&gt; G2 (list (E * C)))
     =&gt; ap G2 (pure (cons ‚óã pair e) &lt;‚ãÜ&gt; a) ‚óã f) ‚àò g
    ‚àò pair e)) b l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk74"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list (E * B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt g ((e, b) :: l&#39;) =
pure (cons ‚óã pair e) &lt;‚ãÜ&gt; g (e, b) &lt;‚ãÜ&gt; mapdt g l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk75"><span class="nb">autorewrite with</span> tea_env.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list (E * B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; œÉ (e, g (e, b)) &lt;‚ãÜ&gt; mapdt g l&#39; =
pure (cons ‚óã pair e) &lt;‚ãÜ&gt; g (e, b) &lt;‚ãÜ&gt; mapdt g l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk76"><span class="nb">unfold</span> strength.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list (E * B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; map (pair e) (g (e, b)) &lt;‚ãÜ&gt; mapdt g l&#39; =
pure (cons ‚óã pair e) &lt;‚ãÜ&gt; g (e, b) &lt;‚ãÜ&gt; mapdt g l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk77"><span class="nb">rewrite</span> map_to_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list (E * B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; (pure (pair e) &lt;‚ãÜ&gt; g (e, b)) &lt;‚ãÜ&gt;
mapdt g l&#39; =
pure (cons ‚óã pair e) &lt;‚ãÜ&gt; g (e, b) &lt;‚ãÜ&gt; mapdt g l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk78"><span class="nb">rewrite</span> &lt;- ap4; <span class="kp">repeat</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g ‚ãÜ<span class="mi">6</span> f) l</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list (E * B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (cons ‚àò pair e) &lt;‚ãÜ&gt; g (e, b) &lt;‚ãÜ&gt; mapdt g l&#39; =
pure (cons ‚óã pair e) &lt;‚ãÜ&gt; g (e, b) &lt;‚ãÜ&gt; mapdt g l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk79"><span class="kn">Lemma</span> <span class="nf">env_mapdt_morph</span>
    `{ApplicativeMorphism G1 G2 œï} :
      <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : E * A -&gt; G1 B),
        mapdt (T := env E) (œï B ‚àò f) =
          œï (env E B) ‚àò mapdt (T := env E) f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>G1 ‚áí G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : E * A -&gt; G1 B),
mapdt (œï B ‚àò f) = œï (env E B) ‚àò mapdt f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk7a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>G1 ‚áí G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : E * A -&gt; G1 B),
mapdt (œï B ‚àò f) = œï (env E B) ‚àò mapdt f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk7b"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>G1 ‚áí G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt (œï B ‚àò f) = œï (env E B) ‚àò mapdt f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk7c">ext l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>G1 ‚áí G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt (œï B ‚àò f) l = (œï (env E B) ‚àò mapdt f) l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk7d"><span class="nb">induction</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>G1 ‚áí G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt (œï B ‚àò f) [] = (œï (env E B) ‚àò mapdt f) []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="environment-v-chk7e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>G1 ‚áí G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>E * A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>mapdt (œï B ‚àò f) l = (œï (env E B) ‚àò mapdt f) l</span></span></span><br></div><label class="goal-separator" for="environment-v-chk7e"><hr></label><div class="goal-conclusion">mapdt (œï B ‚àò f) (a :: l) =
(œï (env E B) ‚àò mapdt f) (a :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk7f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>G1 ‚áí G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt (œï B ‚àò f) [] = (œï (env E B) ‚àò mapdt f) []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk80"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>G1 ‚áí G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt (œï B ‚óã f) [] = œï (env E B) (mapdt f [])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk81"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>G1 ‚áí G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure [] = œï (env E B) (pure [])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk82"><span class="nb">rewrite</span> appmor_pure.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>G1 ‚áí G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure [] = pure []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk83">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>G1 ‚áí G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>E * A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>mapdt (œï B ‚àò f) l = (œï (env E B) ‚àò mapdt f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt (œï B ‚àò f) (a :: l) =
(œï (env E B) ‚àò mapdt f) (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk84"><span class="nb">destruct</span> a <span class="kr">as</span> (e, a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>G1 ‚áí G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>mapdt (œï B ‚àò f) l = (œï (env E B) ‚àò mapdt f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt (œï B ‚àò f) ((e, a) :: l) =
(œï (env E B) ‚àò mapdt f) ((e, a) :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk85"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>G1 ‚áí G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>mapdt (œï B ‚àò f) l = (œï (env E B) ‚àò mapdt f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt (œï B ‚àò f) ((e, a) :: l) =
œï (env E B) (mapdt f ((e, a) :: l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk86"><span class="nb">autorewrite with</span> tea_env.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>G1 ‚áí G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>mapdt (œï B ‚àò f) l = (œï (env E B) ‚àò mapdt f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; œÉ (e, (œï B ‚àò f) (e, a)) &lt;‚ãÜ&gt;
mapdt (œï B ‚àò f) l =
œï (env E B)
  (pure cons &lt;‚ãÜ&gt; œÉ (e, f (e, a)) &lt;‚ãÜ&gt; mapdt f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk87"><span class="nb">rewrite</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>G1 ‚áí G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>mapdt (œï B ‚àò f) l = (œï (env E B) ‚àò mapdt f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; œÉ (e, (œï B ‚àò f) (e, a)) &lt;‚ãÜ&gt;
(œï (env E B) ‚àò mapdt f) l =
œï (env E B)
  (pure cons &lt;‚ãÜ&gt; œÉ (e, f (e, a)) &lt;‚ãÜ&gt; mapdt f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk88"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>G1 ‚áí G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>mapdt (œï B ‚àò f) l = (œï (env E B) ‚àò mapdt f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; œÉ (e, (œï B ‚àò f) (e, a)) &lt;‚ãÜ&gt;
œï (env E B) (mapdt f l) =
œï (env E B)
  (pure cons &lt;‚ãÜ&gt; œÉ (e, f (e, a)) &lt;‚ãÜ&gt; mapdt f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk89"><span class="nb">rewrite</span> ap_morphism_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>G1 ‚áí G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>mapdt (œï B ‚àò f) l = (œï (env E B) ‚àò mapdt f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; œÉ (e, (œï B ‚àò f) (e, a)) &lt;‚ãÜ&gt;
œï (env E B) (mapdt f l) =
œï (list (E * B) -&gt; env E B)
  (pure cons &lt;‚ãÜ&gt; œÉ (e, f (e, a))) &lt;‚ãÜ&gt;
œï (list (E * B)) (mapdt f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk8a"><span class="nb">rewrite</span> ap_morphism_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>G1 ‚áí G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>mapdt (œï B ‚àò f) l = (œï (env E B) ‚àò mapdt f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; œÉ (e, (œï B ‚àò f) (e, a)) &lt;‚ãÜ&gt;
œï (env E B) (mapdt f l) =
œï (E * B -&gt; list (E * B) -&gt; env E B) (pure cons) &lt;‚ãÜ&gt;
œï (E * B) (œÉ (e, f (e, a))) &lt;‚ãÜ&gt;
œï (list (E * B)) (mapdt f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk8b"><span class="nb">rewrite</span> appmor_pure.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>G1 ‚áí G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>mapdt (œï B ‚àò f) l = (œï (env E B) ‚àò mapdt f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; œÉ (e, (œï B ‚àò f) (e, a)) &lt;‚ãÜ&gt;
œï (env E B) (mapdt f l) =
pure cons &lt;‚ãÜ&gt; œï (E * B) (œÉ (e, f (e, a))) &lt;‚ãÜ&gt;
œï (list (E * B)) (mapdt f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk8c"><span class="nb">unfold</span> strength.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>G1 ‚áí G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>mapdt (œï B ‚àò f) l = (œï (env E B) ‚àò mapdt f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; map (pair e) ((œï B ‚àò f) (e, a)) &lt;‚ãÜ&gt;
œï (env E B) (mapdt f l) =
pure cons &lt;‚ãÜ&gt; œï (E * B) (map (pair e) (f (e, a))) &lt;‚ãÜ&gt;
œï (list (E * B)) (mapdt f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk8d"><span class="nb">rewrite</span> appmor_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>G1 ‚áí G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>mapdt (œï B ‚àò f) l = (œï (env E B) ‚àò mapdt f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; map (pair e) ((œï B ‚àò f) (e, a)) &lt;‚ãÜ&gt;
œï (env E B) (mapdt f l) =
pure cons &lt;‚ãÜ&gt; map (pair e) (œï B (f (e, a))) &lt;‚ãÜ&gt;
œï (list (E * B)) (mapdt f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">env_laws</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">DTF_env</span> (<span class="nv">E</span> : <span class="kt">Type</span>) :
  DecoratedTraversableFunctor E (env E) :=
  {| kdtfun_mapdt1 := env_mapdt1 E;
     kdtfun_mapdt2 := @env_mapdt2 E;
     kdtfun_morph := @env_mapdt_morph E;
  |}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * The [env] DTM, Kleisli-style *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">env</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{Monoid W}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Return_env</span> : Return (env W) :=
    <span class="kr">fun</span> <span class="nv">A</span> =&gt; ret (T := list) ‚àò ret (T := (W √ó)) (A := A).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">binddt_env</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) `{Map G} `{Pure G} `{Mult G}
    `(f : W * A -&gt; G (env W B)) (Œì : env W A) : G (env W B) :=
    <span class="kr">match</span> Œì <span class="kr">with</span>
    | nil =&gt; pure (@nil (W * B))
    | (w, a) :: rest =&gt;
        pure (@List.app (W * B)) &lt;‚ãÜ&gt; map (F := G) (<span class="kr">fun</span> <span class="nv">x</span> =&gt; shift list (w, x)) (f (w, a)) &lt;‚ãÜ&gt; binddt_env G f rest
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">bindd_env</span> `(f : W * A -&gt; env W B) (Œì : env W A) : env W B :=
    <span class="kr">match</span> Œì <span class="kr">with</span>
    | nil =&gt; @nil (W * B)
    | (w, a) :: rest =&gt;
        shift list (w, f (w, a)) ++ bindd_env f rest
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">bind_env</span> `(f : A -&gt; env W B) (l : env W A) : env W B :=
    <span class="kr">match</span> l <span class="kr">with</span>
    | nil =&gt; pure (@nil (W * B))
    | (w, a) :: xs =&gt;
        pure (@List.app (W * B)) &lt;‚ãÜ&gt; shift list (w, f a) &lt;‚ãÜ&gt; bind_env f xs
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Binddt_env</span> : Binddt W (env W) (env W) := @binddt_env.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Bindd_env</span> : Bindd W (env W) (env W) := @bindd_env.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Bind_env</span> : Bind (env W) (env W) := @bind_env.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">env</span>.</span></span></pre>
</div>
</div></body>
</html>
