<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<title>TraversableFunctor.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.16.0+0.16.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Tealeaves <span class="kn">Require Export</span>
  Classes.Kleisli.TraversableFunctor
  Classes.Kleisli.Theory.TraversableFunctor
  Classes.Coalgebraic.TraversableFunctor
  Classes.Categorical.ContainerFunctor
  Adapters.KleisliToCoalgebraic.TraversableFunctor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Tealeaves <span class="kn">Require Export</span>
  Classes.Categorical.ShapelyFunctor
  Theory.Batch
  Functors.List.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Subset.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Applicative.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> ContainerFunctor.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> ProductFunctor.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Kleisli.TraversableFunctor.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Batch.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Monoid.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Generalizable Variables</span> <span class="nf">T</span> G A B C M œï.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Misc *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">stuff</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{TraversableFunctor T}
      `{Map T}
      `{ToBatch T}
      `{! Compat_Map_Traverse T}
      `{! Compat_ToBatch_Traverse}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk0"><span class="kn">Lemma</span> <span class="nf">Batch_contents_tolist</span>:
    <span class="kr">forall</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">t</span>: T A),
      Vector_to_list A (Batch_contents (toBatch (A&#39; := B) t)) =
        List.rev (tolist t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">t</span> : T A),
Vector_to_list A (Batch_contents (toBatch t)) =
List.rev (tolist t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">t</span> : T A),
Vector_to_list A (Batch_contents (toBatch t)) =
List.rev (tolist t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk2"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vector_to_list A (Batch_contents (toBatch t)) =
List.rev (tolist t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk3"><span class="nb">rewrite</span> tolist_to_foldMap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vector_to_list A (Batch_contents (toBatch t)) =
List.rev (foldMap ret t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk4"><span class="nb">rewrite</span> (foldMap_through_runBatch2 A B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vector_to_list A (Batch_contents (toBatch t)) =
List.rev
  ((runBatch (const (list A)) ret (T B) ‚àò toBatch) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk5"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vector_to_list A (Batch_contents (toBatch t)) =
List.rev
  (runBatch (const (list A)) ret (T B) (toBatch t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk6"><span class="nb">induction</span> (toBatch t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vector_to_list A (Batch_contents (Done c)) =
List.rev (runBatch (const (list A)) ret C (Done c))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chk7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>Vector_to_list A (Batch_contents b) =
List.rev
  (runBatch (const (list A)) ret (B -&gt; C) b)</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chk7"><hr></label><div class="goal-conclusion">Vector_to_list A (Batch_contents (b ‚ßÜ a)) =
List.rev (runBatch (const (list A)) ret C (b ‚ßÜ a))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vector_to_list A (Batch_contents (Done c)) =
List.rev (runBatch (const (list A)) ret C (Done c))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>Vector_to_list A (Batch_contents b) =
List.rev
  (runBatch (const (list A)) ret (B -&gt; C) b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vector_to_list A (Batch_contents (b ‚ßÜ a)) =
List.rev (runBatch (const (list A)) ret C (b ‚ßÜ a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chka"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>Vector_to_list A (Batch_contents b) =
List.rev
  (runBatch (const (list A)) ret (B -&gt; C) b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vector_to_list A
  (vcons (length_Batch b) a (Batch_contents b)) =
List.rev
  (runBatch (const (list A)) ret (B -&gt; C) b ‚óè ret a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkb"><span class="nb">rewrite</span> Vector_to_list_vcons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>Vector_to_list A (Batch_contents b) =
List.rev
  (runBatch (const (list A)) ret (B -&gt; C) b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: Vector_to_list A (Batch_contents b) =
List.rev
  (runBatch (const (list A)) ret (B -&gt; C) b ‚óè ret a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkc"><span class="nb">rewrite</span> IHb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>Vector_to_list A (Batch_contents b) =
List.rev
  (runBatch (const (list A)) ret (B -&gt; C) b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a
:: List.rev (runBatch (const (list A)) ret (B -&gt; C) b) =
List.rev
  (runBatch (const (list A)) ret (B -&gt; C) b ‚óè ret a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkd">unfold_ops @Monoid_op_list @Return_list.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>Vector_to_list A (Batch_contents b) =
List.rev
  (runBatch (const (list A)) ret (B -&gt; C) b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a
:: List.rev
     (runBatch (const (list A))
        (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a :: nil) (B -&gt; C) b) =
List.rev
  (runBatch (const (list A)) (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a :: nil)
     (B -&gt; C) b ++ a :: nil)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chke"><span class="nb">rewrite</span> List.rev_unit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>Vector_to_list A (Batch_contents b) =
List.rev
  (runBatch (const (list A)) ret (B -&gt; C) b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a
:: List.rev
     (runBatch (const (list A))
        (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a :: nil) (B -&gt; C) b) =
a
:: List.rev
     (runBatch (const (list A))
        (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a :: nil) (B -&gt; C) b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkf"><span class="kn">Lemma</span> <span class="nf">Batch_contents_toBatch_sim</span>:
    <span class="kr">forall</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">B&#39;</span>} (<span class="nv">t</span>: T A),
      Batch_contents
        (toBatch (A&#39; := B) t) ~~
        Batch_contents (toBatch (A&#39; := B&#39;) t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">B&#39;</span> : <span class="kt">Type</span>) (<span class="nv">t</span> : T A),
Batch_contents (toBatch t) ~~
Batch_contents (toBatch t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk10"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">B&#39;</span> : <span class="kt">Type</span>) (<span class="nv">t</span> : T A),
Batch_contents (toBatch t) ~~
Batch_contents (toBatch t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk11"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Batch_contents (toBatch t) ~~
Batch_contents (toBatch t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk12"><span class="nb">unfold</span> Vector_sim.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig (Batch_contents (toBatch t)) =
proj1_sig (Batch_contents (toBatch t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk13"><span class="nb">change</span> (proj1_sig <span class="nl">?v</span>) <span class="kr">with</span> (Vector_to_list _ v).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vector_to_list A (Batch_contents (toBatch t)) =
Vector_to_list A (Batch_contents (toBatch t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk14"><span class="nb">rewrite</span> Batch_contents_tolist.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">List.rev (tolist t) =
Vector_to_list A (Batch_contents (toBatch t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk15"><span class="nb">rewrite</span> Batch_contents_tolist.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">List.rev (tolist t) = List.rev (tolist t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk16"><span class="kn">Lemma</span> <span class="nf">shape_toBatch_spec</span>: <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>) (<span class="nv">t</span>: T A),
      shape (toBatch (A&#39; := B) t) =
        toBatch (A&#39; := B) (shape t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">t</span> : T A),
shape (toBatch t) = toBatch (shape t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk17"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">t</span> : T A),
shape (toBatch t) = toBatch (shape t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk18"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">shape (toBatch t) = toBatch (shape t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk19">compose near t on <span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">shape (toBatch t) = (toBatch ‚àò shape) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk1a"><span class="nb">unfold</span> shape <span class="nb">at</span> <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">shape (toBatch t) = (toBatch ‚àò map (const tt)) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk1b"><span class="nb">rewrite</span> toBatch_mapfst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">shape (toBatch t) =
(mapfst_Batch A unit (const tt) ‚àò toBatch) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk1c"><span class="kn">Lemma</span> <span class="nf">toBatch_shape</span>:
    <span class="kr">forall</span> {<span class="nv">A&#39;</span> <span class="nv">B</span>} `(t1: T A) (t2: T A&#39;),
      shape t1 = shape t2 -&gt;
      shape (F := BATCH1 B (T B))
        (toBatch (A&#39; := B) t1) =
        shape (F := BATCH1 B (T B))
          (toBatch (A&#39; := B) t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A&#39;</span> <span class="nv">B</span> <span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">t1</span> : T A) (<span class="nv">t2</span> : T A&#39;),
shape t1 = shape t2 -&gt;
shape (toBatch t1) = shape (toBatch t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk1d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A&#39;</span> <span class="nv">B</span> <span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">t1</span> : T A) (<span class="nv">t2</span> : T A&#39;),
shape t1 = shape t2 -&gt;
shape (toBatch t1) = shape (toBatch t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk1e">introv Hshape.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A', B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>t2</var><span class="hyp-type"><b>: </b><span>T A&#39;</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t1 = shape t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">shape (toBatch t1) = shape (toBatch t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk1f"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> shape_toBatch_spec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A', B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>t2</var><span class="hyp-type"><b>: </b><span>T A&#39;</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t1 = shape t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">toBatch (shape t1) = toBatch (shape t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk20"><span class="nb">rewrite</span> Hshape.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A', B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>t2</var><span class="hyp-type"><b>: </b><span>T A&#39;</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t1 = shape t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">toBatch (shape t2) = toBatch (shape t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">stuff</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Batch_to_list *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Batch</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk21"><span class="kn">Definition</span> <span class="nf">Batch_to_list</span>: <span class="kr">forall</span> `(b: Batch A B C), list A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>, Batch A B C -&gt; list A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk22"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>, Batch A B C -&gt; list A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk23"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (tolist (F := BATCH1 B C) b).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk24"><span class="kn">Lemma</span> <span class="nf">Batch_contents_list</span>: <span class="kr">forall</span> `(b: Batch A B C),
      proj1_sig (Batch_contents b) = List.rev (Batch_to_list b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">b</span> : Batch A B C),
proj1_sig (Batch_contents b) =
List.rev (Batch_to_list b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk25"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">b</span> : Batch A B C),
proj1_sig (Batch_contents b) =
List.rev (Batch_to_list b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk26"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig (Batch_contents b) =
List.rev (Batch_to_list b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk27"><span class="nb">induction</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig (Batch_contents (Done c)) =
List.rev (Batch_to_list (Done c))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chk28" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>proj1_sig (Batch_contents b) = List.rev (Batch_to_list b)</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chk28"><hr></label><div class="goal-conclusion">proj1_sig (Batch_contents (b ‚ßÜ a)) =
List.rev (Batch_to_list (b ‚ßÜ a))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk29">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig (Batch_contents (Done c)) =
List.rev (Batch_to_list (Done c))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk2a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>proj1_sig (Batch_contents b) = List.rev (Batch_to_list b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig (Batch_contents (b ‚ßÜ a)) =
List.rev (Batch_to_list (b ‚ßÜ a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk2b"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>proj1_sig (Batch_contents b) = List.rev (Batch_to_list b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig
  (vcons (length_Batch b) a (Batch_contents b)) =
List.rev
  (Traverse_Batch1 B (B -&gt; C) (const (list A))
     Map_const Pure_const Mult_const A <span class="kt">False</span> ret b
   ‚óè ret a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk2c"><span class="nb">rewrite</span> proj_vcons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>proj1_sig (Batch_contents b) = List.rev (Batch_to_list b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: proj1_sig (Batch_contents b) =
List.rev
  (Traverse_Batch1 B (B -&gt; C) (const (list A))
     Map_const Pure_const Mult_const A <span class="kt">False</span> ret b
   ‚óè ret a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk2d"><span class="nb">rewrite</span> IHb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>proj1_sig (Batch_contents b) = List.rev (Batch_to_list b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: List.rev (Batch_to_list b) =
List.rev
  (Traverse_Batch1 B (B -&gt; C) (const (list A))
     Map_const Pure_const Mult_const A <span class="kt">False</span> ret b
   ‚óè ret a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk2e"><span class="nb">rewrite</span> &lt;- List.rev_unit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>proj1_sig (Batch_contents b) = List.rev (Batch_to_list b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">List.rev (Batch_to_list b ++ a :: nil) =
List.rev
  (Traverse_Batch1 B (B -&gt; C) (const (list A))
     Map_const Pure_const Mult_const A <span class="kt">False</span> ret b
   ‚óè ret a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk2f"><span class="kn">Lemma</span> <span class="nf">Batch_to_list_rw2</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>}: <span class="kr">forall</span> (<span class="nv">b</span>: Batch A B (B -&gt; C)) (<span class="nv">a</span>: A),
      Batch_to_list (b ‚ßÜ a) = Batch_to_list b ++ (a::nil).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">b</span> : Batch A B (B -&gt; C)) (<span class="nv">a</span> : A),
Batch_to_list (b ‚ßÜ a) = Batch_to_list b ++ a :: nil</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk30"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">b</span> : Batch A B (B -&gt; C)) (<span class="nv">a</span> : A),
Batch_to_list (b ‚ßÜ a) = Batch_to_list b ++ a :: nil</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk31"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Batch_to_list (b ‚ßÜ a) = Batch_to_list b ++ a :: nil</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk32"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Traverse_Batch1 B (B -&gt; C) (const (list A)) Map_const
  Pure_const Mult_const A <span class="kt">False</span> ret b ‚óè ret a =
Batch_to_list b ++ a :: nil</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Batch</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Proof that traversable functors are shapely over lists *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">shapeliness</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{TraversableFunctor T}
    `{Map T}
    `{! Compat_Map_Traverse T}
    `{ToBatch T}
    `{! Compat_ToBatch_Traverse}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk33"><span class="kn">Lemma</span> <span class="nf">shapeliness_tactical</span> : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">b1</span> <span class="nv">b2</span> : Batch A A (T A)),
      runBatch (const (list A)) (ret (T := list)) _ b1 =
        runBatch (const (list A)) (ret (T := list) (A := A)) _ b2 -&gt;
      mapfst_Batch A unit (const tt) b1 = mapfst_Batch A unit (const tt) b2 -&gt;
      runBatch (<span class="kr">fun</span> <span class="nv">A</span> =&gt; A) id (T A) b1 = runBatch (<span class="kr">fun</span> <span class="nv">A</span> =&gt; A) id (T A) b2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">b1</span> <span class="nv">b2</span> : Batch A A (T A)),
runBatch (const (list A)) ret (T A) b1 =
runBatch (const (list A)) ret (T A) b2 -&gt;
mapfst_Batch A unit (const tt) b1 =
mapfst_Batch A unit (const tt) b2 -&gt;
runBatch (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0) id (T A) b1 =
runBatch (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0) id (T A) b2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk34"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">b1</span> <span class="nv">b2</span> : Batch A A (T A)),
runBatch (const (list A)) ret (T A) b1 =
runBatch (const (list A)) ret (T A) b2 -&gt;
mapfst_Batch A unit (const tt) b1 =
mapfst_Batch A unit (const tt) b2 -&gt;
runBatch (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0) id (T A) b1 =
runBatch (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0) id (T A) b2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk35">introv Hlist Hshape.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b1, b2</var><span class="hyp-type"><b>: </b><span>Batch A A (T A)</span></span></span><br><span><var>Hlist</var><span class="hyp-type"><b>: </b><span>runBatch (const (list A)) ret (T A) b1 =
runBatch (const (list A)) ret (T A) b2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>mapfst_Batch A unit (const tt) b1 =
mapfst_Batch A unit (const tt) b2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) id (T A) b1 =
runBatch (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) id (T A) b2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk36"><span class="nb">induction</span> b1 <span class="kr">as</span> [C c1 | C rest1 IHrest1 a1];
      <span class="nb">destruct</span> b2 <span class="kr">as</span> [c2 | rest2 a2]; <span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c1, c2</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>Hlist</var><span class="hyp-type"><b>: </b><span>pure c1 = pure c2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>Done c1 = Done c2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure c1 = pure c2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chk37" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c1</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>rest2</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hlist</var><span class="hyp-type"><b>: </b><span>pure c1 =
runBatch (const (list A)) ret (A -&gt; C) rest2
‚óè ret a2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>Done c1 =
mapfst_Batch A unit (const tt) rest2
‚ßÜ const tt a2</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chk37"><hr></label><div class="goal-conclusion">pure c1 =
runBatch (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) id (A -&gt; C) rest2 (id a2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chk38" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>rest1</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>a1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>c2</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>Hlist</var><span class="hyp-type"><b>: </b><span>runBatch (const (list A)) ret (A -&gt; C) rest1
‚óè ret a1 = pure c2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>mapfst_Batch A unit (const tt) rest1
‚ßÜ const tt a1 = Done c2</span></span></span><br><span><var>IHrest1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b2</span> : Batch A A (A -&gt; C),
runBatch (const (list A)) ret (A -&gt; C) rest1 =
runBatch (const (list A)) ret (A -&gt; C) b2 -&gt;
mapfst_Batch A unit (const tt) rest1 =
mapfst_Batch A unit (const tt) b2 -&gt;
runBatch (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) id 
  (A -&gt; C) rest1 =
runBatch (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) id (A -&gt; C) b2</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chk38"><hr></label><div class="goal-conclusion">runBatch (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) id (A -&gt; C) rest1 (id a1) =
pure c2</div></blockquote><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chk39" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>rest1</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>a1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>rest2</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hlist</var><span class="hyp-type"><b>: </b><span>runBatch (const (list A)) ret (A -&gt; C) rest1
‚óè ret a1 =
runBatch (const (list A)) ret (A -&gt; C) rest2
‚óè ret a2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>mapfst_Batch A unit (const tt) rest1
‚ßÜ const tt a1 =
mapfst_Batch A unit (const tt) rest2
‚ßÜ const tt a2</span></span></span><br><span><var>IHrest1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b2</span> : Batch A A (A -&gt; C),
runBatch (const (list A)) ret (A -&gt; C) rest1 =
runBatch (const (list A)) ret (A -&gt; C) b2 -&gt;
mapfst_Batch A unit (const tt) rest1 =
mapfst_Batch A unit (const tt) b2 -&gt;
runBatch (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) id 
  (A -&gt; C) rest1 =
runBatch (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) id (A -&gt; C) b2</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chk39"><hr></label><div class="goal-conclusion">runBatch (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) id (A -&gt; C) rest1 (id a1) =
runBatch (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) id (A -&gt; C) rest2 (id a2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk3a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c1, c2</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>Hlist</var><span class="hyp-type"><b>: </b><span>pure c1 = pure c2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>Done c1 = Done c2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure c1 = pure c2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk3b"><span class="nb">inversion</span> Hshape.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c1, c2</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>Hlist</var><span class="hyp-type"><b>: </b><span>pure c1 = pure c2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>Done c1 = Done c2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>c1 = c2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure c2 = pure c2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk3c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c1</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>rest2</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hlist</var><span class="hyp-type"><b>: </b><span>pure c1 =
runBatch (const (list A)) ret (A -&gt; C) rest2
‚óè ret a2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>Done c1 =
mapfst_Batch A unit (const tt) rest2
‚ßÜ const tt a2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure c1 =
runBatch (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) id (A -&gt; C) rest2 (id a2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">inversion</span> Hshape.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk3d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>rest1</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>a1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>c2</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>Hlist</var><span class="hyp-type"><b>: </b><span>runBatch (const (list A)) ret (A -&gt; C) rest1
‚óè ret a1 = pure c2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>mapfst_Batch A unit (const tt) rest1
‚ßÜ const tt a1 = Done c2</span></span></span><br><span><var>IHrest1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b2</span> : Batch A A (A -&gt; C),
runBatch (const (list A)) ret (A -&gt; C) rest1 =
runBatch (const (list A)) ret (A -&gt; C) b2 -&gt;
mapfst_Batch A unit (const tt) rest1 =
mapfst_Batch A unit (const tt) b2 -&gt;
runBatch (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) id 
  (A -&gt; C) rest1 =
runBatch (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) id (A -&gt; C) b2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) id (A -&gt; C) rest1 (id a1) =
pure c2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">inversion</span> Hshape.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk3e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>rest1</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>a1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>rest2</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hlist</var><span class="hyp-type"><b>: </b><span>runBatch (const (list A)) ret (A -&gt; C) rest1
‚óè ret a1 =
runBatch (const (list A)) ret (A -&gt; C) rest2
‚óè ret a2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>mapfst_Batch A unit (const tt) rest1
‚ßÜ const tt a1 =
mapfst_Batch A unit (const tt) rest2
‚ßÜ const tt a2</span></span></span><br><span><var>IHrest1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b2</span> : Batch A A (A -&gt; C),
runBatch (const (list A)) ret (A -&gt; C) rest1 =
runBatch (const (list A)) ret (A -&gt; C) b2 -&gt;
mapfst_Batch A unit (const tt) rest1 =
mapfst_Batch A unit (const tt) b2 -&gt;
runBatch (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) id 
  (A -&gt; C) rest1 =
runBatch (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) id (A -&gt; C) b2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) id (A -&gt; C) rest1 (id a1) =
runBatch (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) id (A -&gt; C) rest2 (id a2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk3f"><span class="nb">unfold</span> monoid_op, Monoid_op_list <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>rest1</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>a1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>rest2</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hlist</var><span class="hyp-type"><b>: </b><span>runBatch (const (list A)) ret (A -&gt; C) rest1 ++
ret a1 =
runBatch (const (list A)) ret (A -&gt; C) rest2 ++
ret a2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>mapfst_Batch A unit (const tt) rest1
‚ßÜ const tt a1 =
mapfst_Batch A unit (const tt) rest2
‚ßÜ const tt a2</span></span></span><br><span><var>IHrest1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b2</span> : Batch A A (A -&gt; C),
runBatch (const (list A)) ret (A -&gt; C) rest1 =
runBatch (const (list A)) ret (A -&gt; C) b2 -&gt;
mapfst_Batch A unit (const tt) rest1 =
mapfst_Batch A unit (const tt) b2 -&gt;
runBatch (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) id 
  (A -&gt; C) rest1 =
runBatch (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) id (A -&gt; C) b2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) id (A -&gt; C) rest1 (id a1) =
runBatch (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) id (A -&gt; C) rest2 (id a2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk40"><span class="nb">assert</span> (Hleft := Hlist); <span class="nb">apply</span> list_app_inv_l2 <span class="kr">in</span> Hleft.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>rest1</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>a1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>rest2</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hlist</var><span class="hyp-type"><b>: </b><span>runBatch (const (list A)) ret (A -&gt; C) rest1 ++
ret a1 =
runBatch (const (list A)) ret (A -&gt; C) rest2 ++
ret a2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>mapfst_Batch A unit (const tt) rest1
‚ßÜ const tt a1 =
mapfst_Batch A unit (const tt) rest2
‚ßÜ const tt a2</span></span></span><br><span><var>IHrest1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b2</span> : Batch A A (A -&gt; C),
runBatch (const (list A)) ret (A -&gt; C) rest1 =
runBatch (const (list A)) ret (A -&gt; C) b2 -&gt;
mapfst_Batch A unit (const tt) rest1 =
mapfst_Batch A unit (const tt) b2 -&gt;
runBatch (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) id 
  (A -&gt; C) rest1 =
runBatch (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) id (A -&gt; C) b2</span></span></span><br><span><var>Hleft</var><span class="hyp-type"><b>: </b><span>runBatch (const (list A)) ret (A -&gt; C) rest1 =
runBatch (const (list A)) ret (A -&gt; C) rest2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) id (A -&gt; C) rest1 (id a1) =
runBatch (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) id (A -&gt; C) rest2 (id a2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk41"><span class="nb">rename</span> Hlist <span class="nb">into</span> Hright;  <span class="nb">apply</span> list_app_inv_r2 <span class="kr">in</span> Hright.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>rest1</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>a1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>rest2</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hright</var><span class="hyp-type"><b>: </b><span>a1 = a2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>mapfst_Batch A unit (const tt) rest1
‚ßÜ const tt a1 =
mapfst_Batch A unit (const tt) rest2
‚ßÜ const tt a2</span></span></span><br><span><var>IHrest1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b2</span> : Batch A A (A -&gt; C),
runBatch (const (list A)) ret (A -&gt; C) rest1 =
runBatch (const (list A)) ret (A -&gt; C) b2 -&gt;
mapfst_Batch A unit (const tt) rest1 =
mapfst_Batch A unit (const tt) b2 -&gt;
runBatch (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) id 
  (A -&gt; C) rest1 =
runBatch (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) id (A -&gt; C) b2</span></span></span><br><span><var>Hleft</var><span class="hyp-type"><b>: </b><span>runBatch (const (list A)) ret (A -&gt; C) rest1 =
runBatch (const (list A)) ret (A -&gt; C) rest2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) id (A -&gt; C) rest1 (id a1) =
runBatch (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) id (A -&gt; C) rest2 (id a2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk42"><span class="nb">injection</span> Hshape; <span class="nb">clear</span> Hshape; <span class="nb">intro</span> Hshape.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>rest1</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>a1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>rest2</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hright</var><span class="hyp-type"><b>: </b><span>a1 = a2</span></span></span><br><span><var>IHrest1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b2</span> : Batch A A (A -&gt; C),
runBatch (const (list A)) ret (A -&gt; C) rest1 =
runBatch (const (list A)) ret (A -&gt; C) b2 -&gt;
mapfst_Batch A unit (const tt) rest1 =
mapfst_Batch A unit (const tt) b2 -&gt;
runBatch (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) id 
  (A -&gt; C) rest1 =
runBatch (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) id (A -&gt; C) b2</span></span></span><br><span><var>Hleft</var><span class="hyp-type"><b>: </b><span>runBatch (const (list A)) ret (A -&gt; C) rest1 =
runBatch (const (list A)) ret (A -&gt; C) rest2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>mapfst_Batch A unit (const tt) rest1 =
mapfst_Batch A unit (const tt) rest2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) id (A -&gt; C) rest1 (id a1) =
runBatch (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) id (A -&gt; C) rest2 (id a2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk43"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>rest1, rest2</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHrest1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b2</span> : Batch A A (A -&gt; C),
runBatch (const (list A)) ret (A -&gt; C) rest1 =
runBatch (const (list A)) ret (A -&gt; C) b2 -&gt;
mapfst_Batch A unit (const tt) rest1 =
mapfst_Batch A unit (const tt) b2 -&gt;
runBatch (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) id 
  (A -&gt; C) rest1 =
runBatch (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) id (A -&gt; C) b2</span></span></span><br><span><var>Hleft</var><span class="hyp-type"><b>: </b><span>runBatch (const (list A)) ret (A -&gt; C) rest1 =
runBatch (const (list A)) ret (A -&gt; C) rest2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>mapfst_Batch A unit (const tt) rest1 =
mapfst_Batch A unit (const tt) rest2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) id (A -&gt; C) rest1 (id a2) =
runBatch (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) id (A -&gt; C) rest2 (id a2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">erewrite</span> IHrest1; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk44"><span class="kn">Theorem</span> <span class="nf">shapeliness</span> : <span class="kr">forall</span> <span class="nv">A</span> (<span class="nv">t1</span> <span class="nv">t2</span> : T A),
      shape t1 = shape t2 /\ tolist t1 = tolist t2 -&gt;
      t1 = t2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">t1</span> <span class="nv">t2</span> : T A),
shape t1 = shape t2 /\ tolist t1 = tolist t2 -&gt;
t1 = t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk45"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">t1</span> <span class="nv">t2</span> : T A),
shape t1 = shape t2 /\ tolist t1 = tolist t2 -&gt;
t1 = t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk46">introv [hyp1 hyp2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>hyp1</var><span class="hyp-type"><b>: </b><span>shape t1 = shape t2</span></span></span><br><span><var>hyp2</var><span class="hyp-type"><b>: </b><span>tolist t1 = tolist t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">t1 = t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk47"><span class="nb">assert</span> (hyp1&#39; : (toBatch (A := unit) (A&#39; := A) ‚àò shape) t1 =
                      (toBatch (A := unit) (A&#39; := A) ‚àò shape) t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>hyp1</var><span class="hyp-type"><b>: </b><span>shape t1 = shape t2</span></span></span><br><span><var>hyp2</var><span class="hyp-type"><b>: </b><span>tolist t1 = tolist t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(toBatch ‚àò shape) t1 = (toBatch ‚àò shape) t2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chk48" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>hyp1</var><span class="hyp-type"><b>: </b><span>shape t1 = shape t2</span></span></span><br><span><var>hyp2</var><span class="hyp-type"><b>: </b><span>tolist t1 = tolist t2</span></span></span><br><span><var>hyp1'</var><span class="hyp-type"><b>: </b><span>(toBatch ‚àò shape) t1 = (toBatch ‚àò shape) t2</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chk48"><hr></label><div class="goal-conclusion">t1 = t2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk49">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>hyp1</var><span class="hyp-type"><b>: </b><span>shape t1 = shape t2</span></span></span><br><span><var>hyp2</var><span class="hyp-type"><b>: </b><span>tolist t1 = tolist t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(toBatch ‚àò shape) t1 = (toBatch ‚àò shape) t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk4a"><span class="nb">unfold</span> compose, shape <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>hyp1</var><span class="hyp-type"><b>: </b><span>map (const tt) t1 = map (const tt) t2</span></span></span><br><span><var>hyp2</var><span class="hyp-type"><b>: </b><span>tolist t1 = tolist t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">toBatch (map (const tt) t1) =
toBatch (map (const tt) t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> hyp1.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk4b">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>hyp1</var><span class="hyp-type"><b>: </b><span>shape t1 = shape t2</span></span></span><br><span><var>hyp2</var><span class="hyp-type"><b>: </b><span>tolist t1 = tolist t2</span></span></span><br><span><var>hyp1'</var><span class="hyp-type"><b>: </b><span>(toBatch ‚àò shape) t1 = (toBatch ‚àò shape) t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">t1 = t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk4c"><span class="nb">clear</span> hyp1; <span class="nb">rename</span> hyp1&#39; <span class="nb">into</span> hyp1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>hyp2</var><span class="hyp-type"><b>: </b><span>tolist t1 = tolist t2</span></span></span><br><span><var>hyp1</var><span class="hyp-type"><b>: </b><span>(toBatch ‚àò shape) t1 = (toBatch ‚àò shape) t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">t1 = t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk4d"><span class="nb">unfold</span> shape <span class="kr">in</span> hyp1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>hyp2</var><span class="hyp-type"><b>: </b><span>tolist t1 = tolist t2</span></span></span><br><span><var>hyp1</var><span class="hyp-type"><b>: </b><span>(toBatch ‚àò map (const tt)) t1 =
(toBatch ‚àò map (const tt)) t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">t1 = t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk4e"><span class="nb">rewrite</span> toBatch_mapfst <span class="kr">in</span> hyp1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>hyp2</var><span class="hyp-type"><b>: </b><span>tolist t1 = tolist t2</span></span></span><br><span><var>hyp1</var><span class="hyp-type"><b>: </b><span>(mapfst_Batch A unit (const tt) ‚àò toBatch) t1 =
(mapfst_Batch A unit (const tt) ‚àò toBatch) t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">t1 = t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk4f"><span class="nb">rewrite</span> (tolist_through_runBatch A t1) <span class="kr">in</span> hyp2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>hyp2</var><span class="hyp-type"><b>: </b><span>runBatch (const (list A)) ret 
  (T A) (toBatch t1) = 
tolist t2</span></span></span><br><span><var>hyp1</var><span class="hyp-type"><b>: </b><span>(mapfst_Batch A unit (const tt) ‚àò toBatch) t1 =
(mapfst_Batch A unit (const tt) ‚àò toBatch) t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">t1 = t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk50"><span class="nb">rewrite</span> (tolist_through_runBatch A t2) <span class="kr">in</span> hyp2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>hyp2</var><span class="hyp-type"><b>: </b><span>runBatch (const (list A)) ret 
  (T A) (toBatch t1) =
runBatch (const (list A)) ret 
  (T A) (toBatch t2)</span></span></span><br><span><var>hyp1</var><span class="hyp-type"><b>: </b><span>(mapfst_Batch A unit (const tt) ‚àò toBatch) t1 =
(mapfst_Batch A unit (const tt) ‚àò toBatch) t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">t1 = t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk51"><span class="nb">change</span> (id t1 = id t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>hyp2</var><span class="hyp-type"><b>: </b><span>runBatch (const (list A)) ret 
  (T A) (toBatch t1) =
runBatch (const (list A)) ret 
  (T A) (toBatch t2)</span></span></span><br><span><var>hyp1</var><span class="hyp-type"><b>: </b><span>(mapfst_Batch A unit (const tt) ‚àò toBatch) t1 =
(mapfst_Batch A unit (const tt) ‚àò toBatch) t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">id t1 = id t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk52"><span class="nb">rewrite</span> id_through_runBatch.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>hyp2</var><span class="hyp-type"><b>: </b><span>runBatch (const (list A)) ret 
  (T A) (toBatch t1) =
runBatch (const (list A)) ret 
  (T A) (toBatch t2)</span></span></span><br><span><var>hyp1</var><span class="hyp-type"><b>: </b><span>(mapfst_Batch A unit (const tt) ‚àò toBatch) t1 =
(mapfst_Batch A unit (const tt) ‚àò toBatch) t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(runBatch (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) id (T A) ‚àò toBatch) t1 =
(runBatch (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) id (T A) ‚àò toBatch) t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk53"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>hyp2</var><span class="hyp-type"><b>: </b><span>runBatch (const (list A)) ret 
  (T A) (toBatch t1) =
runBatch (const (list A)) ret 
  (T A) (toBatch t2)</span></span></span><br><span><var>hyp1</var><span class="hyp-type"><b>: </b><span>(mapfst_Batch A unit (const tt) ‚àò toBatch) t1 =
(mapfst_Batch A unit (const tt) ‚àò toBatch) t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) id (T A) (toBatch t1) =
runBatch (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) id (T A) (toBatch t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto using</span> shapeliness_tactical.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">shapeliness</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Pointwise reasoning for operations *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">pointwise</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{Classes.Kleisli.TraversableFunctor.TraversableFunctor T}
    `{ToMap_inst: Map T}
    `{ToSubset_inst: ToSubset T}
    `{ToBatch_inst: ToBatch T}
    `{! Compat_Map_Traverse T}
    `{! Compat_ToSubset_Traverse T}
    `{! Compat_ToBatch_Traverse}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk54"><span class="kn">Lemma</span> <span class="nf">traverse_respectful</span> :
    <span class="kr">forall</span> `{Applicative G} `(f1 : A -&gt; G B) `(f2 : A -&gt; G B) (t : T A),
      (<span class="kr">forall</span> (<span class="nv">a</span> : A), a ‚àà t -&gt; f1 a = f2 a) -&gt; traverse f1 t = traverse f2 t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H2</span> : Map G) (<span class="nv">H3</span> : Pure G)
  (<span class="nv">H4</span> : Mult G),
Applicative G -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f1</span> <span class="nv">f2</span> : A -&gt; G B) (<span class="nv">t</span> : T A),
(<span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; f1 a = f2 a) -&gt;
traverse f1 t = traverse f2 t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk55"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H2</span> : Map G) (<span class="nv">H3</span> : Pure G)
  (<span class="nv">H4</span> : Mult G),
Applicative G -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f1</span> <span class="nv">f2</span> : A -&gt; G B) (<span class="nv">t</span> : T A),
(<span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; f1 a = f2 a) -&gt;
traverse f1 t = traverse f2 t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk56">introv ? hyp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; f1 a = f2 a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f1 t = traverse f2 t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk57"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> traverse_through_runBatch.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; f1 a = f2 a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(runBatch G f1 (T B) ‚àò toBatch) t =
(runBatch G f2 (T B) ‚àò toBatch) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk58"><span class="nb">unfold</span> element_of <span class="kr">in</span> hyp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, tosubset t a -&gt; f1 a = f2 a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(runBatch G f1 (T B) ‚àò toBatch) t =
(runBatch G f2 (T B) ‚àò toBatch) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk59"><span class="nb">rewrite</span> (tosubset_through_runBatch2 A B) <span class="kr">in</span> hyp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
(runBatch (const (A -&gt; <span class="kt">Prop</span>)) ret (T B)
 ‚àò toBatch) t a -&gt; f1 a = f2 a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(runBatch G f1 (T B) ‚àò toBatch) t =
(runBatch G f2 (T B) ‚àò toBatch) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk5a"><span class="nb">unfold</span> compose <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
runBatch (const (A -&gt; <span class="kt">Prop</span>)) ret 
  (T B) (toBatch t) a -&gt; 
f1 a = f2 a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch G f1 (T B) (toBatch t) =
runBatch G f2 (T B) (toBatch t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk5b"><span class="nb">unfold</span> ret <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
runBatch (const (A -&gt; <span class="kt">Prop</span>)) 
  (Return_subset A) (T B) 
  (toBatch t) a -&gt; f1 a = f2 a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch G f1 (T B) (toBatch t) =
runBatch G f2 (T B) (toBatch t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk5c"><span class="nb">induction</span> (toBatch t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
runBatch (const (A -&gt; <span class="kt">Prop</span>)) 
  (Return_subset A) C 
  (Done c) a -&gt; f1 a = f2 a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch G f1 C (Done c) = runBatch G f2 C (Done c)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chk5d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a0</span> : A,
runBatch (const (A -&gt; <span class="kt">Prop</span>)) 
  (Return_subset A) C 
  (b ‚ßÜ a) a0 -&gt; f1 a0 = f2 a0</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">a</span> : A,
 runBatch (const (A -&gt; <span class="kt">Prop</span>)) 
   (Return_subset A) (B -&gt; C) b a -&gt; 
 f1 a = f2 a) -&gt;
runBatch G f1 (B -&gt; C) b =
runBatch G f2 (B -&gt; C) b</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chk5d"><hr></label><div class="goal-conclusion">runBatch G f1 C (b ‚ßÜ a) = runBatch G f2 C (b ‚ßÜ a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk5e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
runBatch (const (A -&gt; <span class="kt">Prop</span>)) 
  (Return_subset A) C 
  (Done c) a -&gt; f1 a = f2 a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch G f1 C (Done c) = runBatch G f2 C (Done c)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk5f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a0</span> : A,
runBatch (const (A -&gt; <span class="kt">Prop</span>)) 
  (Return_subset A) C 
  (b ‚ßÜ a) a0 -&gt; f1 a0 = f2 a0</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">a</span> : A,
 runBatch (const (A -&gt; <span class="kt">Prop</span>)) 
   (Return_subset A) (B -&gt; C) b a -&gt; 
 f1 a = f2 a) -&gt;
runBatch G f1 (B -&gt; C) b =
runBatch G f2 (B -&gt; C) b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch G f1 C (b ‚ßÜ a) = runBatch G f2 C (b ‚ßÜ a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk60"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a0</span> : A,
runBatch (const (A -&gt; <span class="kt">Prop</span>)) 
  (Return_subset A) C 
  (b ‚ßÜ a) a0 -&gt; f1 a0 = f2 a0</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">a</span> : A,
 runBatch (const (A -&gt; <span class="kt">Prop</span>)) 
   (Return_subset A) (B -&gt; C) b a -&gt; 
 f1 a = f2 a) -&gt;
runBatch G f1 (B -&gt; C) b =
runBatch G f2 (B -&gt; C) b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch G f1 (B -&gt; C) b &lt;‚ãÜ&gt; f1 a =
runBatch G f2 (B -&gt; C) b &lt;‚ãÜ&gt; f2 a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk61">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a0</span> : A,
runBatch (const (A -&gt; <span class="kt">Prop</span>)) 
  (Return_subset A) C 
  (b ‚ßÜ a) a0 -&gt; f1 a0 = f2 a0</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">a</span> : A,
 runBatch (const (A -&gt; <span class="kt">Prop</span>)) 
   (Return_subset A) (B -&gt; C) b a -&gt; 
 f1 a = f2 a) -&gt;
runBatch G f1 (B -&gt; C) b =
runBatch G f2 (B -&gt; C) b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch G f1 (B -&gt; C) b = runBatch G f2 (B -&gt; C) b</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chk62" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a0</span> : A,
runBatch (const (A -&gt; <span class="kt">Prop</span>)) 
  (Return_subset A) C 
  (b ‚ßÜ a) a0 -&gt; f1 a0 = f2 a0</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">a</span> : A,
 runBatch (const (A -&gt; <span class="kt">Prop</span>)) 
   (Return_subset A) (B -&gt; C) b a -&gt; 
 f1 a = f2 a) -&gt;
runBatch G f1 (B -&gt; C) b =
runBatch G f2 (B -&gt; C) b</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chk62"><hr></label><div class="goal-conclusion">f1 a = f2 a</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk63">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a0</span> : A,
runBatch (const (A -&gt; <span class="kt">Prop</span>)) 
  (Return_subset A) C 
  (b ‚ßÜ a) a0 -&gt; f1 a0 = f2 a0</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">a</span> : A,
 runBatch (const (A -&gt; <span class="kt">Prop</span>)) 
   (Return_subset A) (B -&gt; C) b a -&gt; 
 f1 a = f2 a) -&gt;
runBatch G f1 (B -&gt; C) b =
runBatch G f2 (B -&gt; C) b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch G f1 (B -&gt; C) b = runBatch G f2 (B -&gt; C) b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk64"><span class="nb">apply</span> IHb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a0</span> : A,
runBatch (const (A -&gt; <span class="kt">Prop</span>)) 
  (Return_subset A) C 
  (b ‚ßÜ a) a0 -&gt; f1 a0 = f2 a0</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">a</span> : A,
 runBatch (const (A -&gt; <span class="kt">Prop</span>)) 
   (Return_subset A) (B -&gt; C) b a -&gt; 
 f1 a = f2 a) -&gt;
runBatch G f1 (B -&gt; C) b =
runBatch G f2 (B -&gt; C) b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
runBatch (const (A -&gt; <span class="kt">Prop</span>)) (Return_subset A)
  (B -&gt; C) b a -&gt; f1 a = f2 a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk65"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a0</span> : A,
runBatch (const (A -&gt; <span class="kt">Prop</span>)) 
  (Return_subset A) C 
  (b ‚ßÜ a) a0 -&gt; f1 a0 = f2 a0</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">a</span> : A,
 runBatch (const (A -&gt; <span class="kt">Prop</span>)) 
   (Return_subset A) (B -&gt; C) b a -&gt; 
 f1 a = f2 a) -&gt;
runBatch G f1 (B -&gt; C) b =
runBatch G f2 (B -&gt; C) b</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>runBatch (const (A -&gt; <span class="kt">Prop</span>)) 
  (Return_subset A) (B -&gt; C) b a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f1 a0 = f2 a0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk66"><span class="nb">apply</span> hyp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a0</span> : A,
runBatch (const (A -&gt; <span class="kt">Prop</span>)) 
  (Return_subset A) C 
  (b ‚ßÜ a) a0 -&gt; f1 a0 = f2 a0</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">a</span> : A,
 runBatch (const (A -&gt; <span class="kt">Prop</span>)) 
   (Return_subset A) (B -&gt; C) b a -&gt; 
 f1 a = f2 a) -&gt;
runBatch G f1 (B -&gt; C) b =
runBatch G f2 (B -&gt; C) b</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>runBatch (const (A -&gt; <span class="kt">Prop</span>)) 
  (Return_subset A) (B -&gt; C) b a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch (const (A -&gt; <span class="kt">Prop</span>)) (Return_subset A) C
  (b ‚ßÜ a) a0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">left</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk67">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a0</span> : A,
runBatch (const (A -&gt; <span class="kt">Prop</span>)) 
  (Return_subset A) C 
  (b ‚ßÜ a) a0 -&gt; f1 a0 = f2 a0</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">a</span> : A,
 runBatch (const (A -&gt; <span class="kt">Prop</span>)) 
   (Return_subset A) (B -&gt; C) b a -&gt; 
 f1 a = f2 a) -&gt;
runBatch G f1 (B -&gt; C) b =
runBatch G f2 (B -&gt; C) b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f1 a = f2 a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk68"><span class="nb">apply</span> hyp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a0</span> : A,
runBatch (const (A -&gt; <span class="kt">Prop</span>)) 
  (Return_subset A) C 
  (b ‚ßÜ a) a0 -&gt; f1 a0 = f2 a0</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">a</span> : A,
 runBatch (const (A -&gt; <span class="kt">Prop</span>)) 
   (Return_subset A) (B -&gt; C) b a -&gt; 
 f1 a = f2 a) -&gt;
runBatch G f1 (B -&gt; C) b =
runBatch G f2 (B -&gt; C) b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch (const (A -&gt; <span class="kt">Prop</span>)) (Return_subset A) C
  (b ‚ßÜ a) a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">right</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** *** Corollaries *)</span>
  <span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk69"><span class="kn">Corollary</span> <span class="nf">traverse_respectful_pure</span> :
    <span class="kr">forall</span> `{Applicative G} `(f1 : A -&gt; G A) (t : T A),
      (<span class="kr">forall</span> (<span class="nv">a</span> : A), a ‚àà t -&gt; f1 a = pure a) -&gt; traverse f1 t = pure t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H2</span> : Map G) (<span class="nv">H3</span> : Pure G)
  (<span class="nv">H4</span> : Mult G),
Applicative G -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">f1</span> : A -&gt; G A) (<span class="nv">t</span> : T A),
(<span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; f1 a = pure a) -&gt;
traverse f1 t = pure t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk6a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H2</span> : Map G) (<span class="nv">H3</span> : Pure G)
  (<span class="nv">H4</span> : Mult G),
Applicative G -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">f1</span> : A -&gt; G A) (<span class="nv">t</span> : T A),
(<span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; f1 a = pure a) -&gt;
traverse f1 t = pure t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk6b"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>A -&gt; G A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; f1 a = pure a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f1 t = pure t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk6c"><span class="nb">rewrite</span> &lt;- traverse_purity1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>A -&gt; G A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; f1 a = pure a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f1 t = traverse pure t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">apply</span> traverse_respectful.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk6d"><span class="kn">Corollary</span> <span class="nf">traverse_respectful_map</span> {<span class="nv">A</span> <span class="nv">B</span>} :
    <span class="kr">forall</span> `{Applicative G} (t : T A) (f : A -&gt; G B) (g : A -&gt; B),
      (<span class="kr">forall</span> <span class="nv">a</span>, a ‚àà t -&gt; f a = pure (g a)) -&gt; traverse f t = pure (map g t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H2</span> : Map G) (<span class="nv">H3</span> : Pure G)
  (<span class="nv">H4</span> : Mult G),
Applicative G -&gt;
<span class="kr">forall</span> (<span class="nv">t</span> : T A) (<span class="nv">f</span> : A -&gt; G B) (<span class="nv">g</span> : A -&gt; B),
(<span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; f a = pure (g a)) -&gt;
traverse f t = pure (map g t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk6e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H2</span> : Map G) (<span class="nv">H3</span> : Pure G)
  (<span class="nv">H4</span> : Mult G),
Applicative G -&gt;
<span class="kr">forall</span> (<span class="nv">t</span> : T A) (<span class="nv">f</span> : A -&gt; G B) (<span class="nv">g</span> : A -&gt; B),
(<span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; f a = pure (g a)) -&gt;
traverse f t = pure (map g t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk6f"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; f a = pure (g a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f t = pure (map g t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk70"><span class="nb">rewrite</span> &lt;- (traverse_purity1 (G := G)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; f a = pure (g a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f t = traverse pure (map g t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk71">compose near t on <span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; f a = pure (g a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f t = (traverse pure ‚àò map g) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk72"><span class="nb">rewrite</span> traverse_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; f a = pure (g a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f t = traverse (pure ‚àò g) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk73"><span class="nb">apply</span> traverse_respectful.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; f a = pure (g a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; f a = (pure ‚àò g) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk74"><span class="kn">Corollary</span> <span class="nf">traverse_respectful_id</span> {<span class="nv">A</span>} :
    <span class="kr">forall</span> (<span class="nv">t</span> : T A) (<span class="nv">f</span> : A -&gt; A),
      (<span class="kr">forall</span> <span class="nv">a</span>, a ‚àà t -&gt; f a = id a) -&gt; traverse (G := <span class="kr">fun</span> <span class="nv">A</span> =&gt; A) f t = t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : T A) (<span class="nv">f</span> : A -&gt; A),
(<span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; f a = id a) -&gt;
traverse f t = t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk75"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : T A) (<span class="nv">f</span> : A -&gt; A),
(<span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; f a = id a) -&gt;
traverse f t = t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk76"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; f a = id a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f t = t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk77"><span class="nb">change</span> t <span class="kr">with</span> (pure (F := <span class="kr">fun</span> <span class="nv">A</span> =&gt; A) t) <span class="nb">at</span> <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; f a = id a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f t = pure t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk78"><span class="nb">apply</span> (traverse_respectful_pure (G := <span class="kr">fun</span> <span class="nv">A</span> =&gt; A)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; f a = id a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; f a = pure a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk79"><span class="kn">Corollary</span> <span class="nf">map_respectful</span> : <span class="kr">forall</span> `(f1 : A -&gt; B) `(f2 : A -&gt; B) (t : T A),
      (<span class="kr">forall</span> (<span class="nv">a</span> : A), a ‚àà t -&gt; f1 a = f2 a) -&gt; map f1 t = map f2 t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f1</span> <span class="nv">f2</span> : A -&gt; B) (<span class="nv">t</span> : T A),
(<span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; f1 a = f2 a) -&gt;
map f1 t = map f2 t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk7a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f1</span> <span class="nv">f2</span> : A -&gt; B) (<span class="nv">t</span> : T A),
(<span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; f1 a = f2 a) -&gt;
map f1 t = map f2 t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk7b">introv hyp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; f1 a = f2 a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f1 t = map f2 t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk7c"><span class="nb">rewrite</span> map_to_traverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; f1 a = f2 a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f1 t = map f2 t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk7d"><span class="nb">rewrite</span> map_to_traverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; f1 a = f2 a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f1 t = traverse f2 t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk7e"><span class="nb">apply</span> (traverse_respectful (G := <span class="kr">fun</span> <span class="nv">A</span> =&gt; A)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; f1 a = f2 a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; f1 a = f2 a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk7f">#[export] <span class="kn">Instance</span> <span class="nf">ContainerFunctor_Traverse</span>:
    ContainerFunctor T.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ContainerFunctor T</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk80"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ContainerFunctor T</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk81"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural (@tosubset T ToSubset_inst)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chk82" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chk82"><hr></label><div class="goal-conclusion">Functor T</div></blockquote><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chk83" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chk83"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">t</span> : T A) (<span class="nv">f</span> <span class="nv">g</span> : A -&gt; B),
(<span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; f a = g a) -&gt;
map f t = map g t</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk84">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural (@tosubset T ToSubset_inst)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk85"><span class="nb">rewrite</span> compat_tosubset_traverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural (@tosubset T ToSubset_Traverse)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk86">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor T</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk87">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">t</span> : T A) (<span class="nv">f</span> <span class="nv">g</span> : A -&gt; B),
(<span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; f a = g a) -&gt;
map f t = map g t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk88"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToMap_inst</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>ToBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; f a = g a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f t = map g t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">apply</span> map_respectful.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">pointwise</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * &lt;&lt;plength&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">length</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{Map T}
      `{ToBatch T}
      `{Traverse T}
      `{! TraversableFunctor T}
      `{! Compat_Map_Traverse T}
      `{! Compat_ToBatch_Traverse (T := T)}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk89"><span class="kn">Lemma</span> <span class="nf">plength_eq_length</span> :
    <span class="kr">forall</span> {<span class="nv">A</span>} {<span class="nv">B</span>} (<span class="nv">t</span>: T A),
      length_Batch (toBatch (A&#39; := B) t) = plength t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">t</span> : T A),
length_Batch (toBatch t) = plength t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk8a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">t</span> : T A),
length_Batch (toBatch t) = plength t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk8b"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length_Batch (toBatch t) = plength t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk8c"><span class="nb">unfold</span> plength.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length_Batch (toBatch t) = foldMap (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; <span class="mi">1</span>) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk8d"><span class="nb">rewrite</span> (foldMap_through_runBatch2 A B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length_Batch (toBatch t) =
(runBatch (const nat) (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; <span class="mi">1</span>) (T B) ‚àò toBatch)
  t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk8e"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length_Batch (toBatch t) =
runBatch (const nat) (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; <span class="mi">1</span>) (T B)
  (toBatch t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk8f"><span class="nb">induction</span> (toBatch t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length_Batch (Done c) =
runBatch (const nat) (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; <span class="mi">1</span>) C (Done c)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chk90" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>length_Batch b =
runBatch (const nat) (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; <span class="mi">1</span>) (B -&gt; C) b</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chk90"><hr></label><div class="goal-conclusion">length_Batch (b ‚ßÜ a) =
runBatch (const nat) (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; <span class="mi">1</span>) C (b ‚ßÜ a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk91">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length_Batch (Done c) =
runBatch (const nat) (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; <span class="mi">1</span>) C (Done c)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk92">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>length_Batch b =
runBatch (const nat) (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; <span class="mi">1</span>) (B -&gt; C) b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length_Batch (b ‚ßÜ a) =
runBatch (const nat) (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; <span class="mi">1</span>) C (b ‚ßÜ a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk93"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>length_Batch b =
runBatch (const nat) (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; <span class="mi">1</span>) (B -&gt; C) b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (length_Batch b) =
runBatch (const nat) (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; <span class="mi">1</span>) (B -&gt; C) b ‚óè <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk94"><span class="nb">rewrite</span> IHb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>length_Batch b =
runBatch (const nat) (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; <span class="mi">1</span>) (B -&gt; C) b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (runBatch (const nat) (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; <span class="mi">1</span>) (B -&gt; C) b) =
runBatch (const nat) (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; <span class="mi">1</span>) (B -&gt; C) b ‚óè <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk95">unfold_ops @NaturalNumbers.Monoid_op_plus.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>length_Batch b =
runBatch (const nat) (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; <span class="mi">1</span>) (B -&gt; C) b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (runBatch (const nat) (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; <span class="mi">1</span>) (B -&gt; C) b) =
(runBatch (const nat) (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; <span class="mi">1</span>) (B -&gt; C) b + <span class="mi">1</span>)%nat</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk96"><span class="kn">Lemma</span> <span class="nf">plength_eq_length&#39;</span>: <span class="kr">forall</span> {<span class="nv">A</span>} (<span class="nv">t</span>: T A),
      plength t = length_Batch (toBatch (A&#39; := <span class="kt">False</span>) t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">t</span> : T A),
plength t = length_Batch (toBatch t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk97"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">t</span> : T A),
plength t = length_Batch (toBatch t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk98"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">plength t = length_Batch (toBatch t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk99"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length_Batch (toBatch t) = plength t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> plength_eq_length.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk9a"><span class="kn">Lemma</span> <span class="nf">length_Batch_independent</span>: <span class="kr">forall</span> `(t: T A) B C,
      length_Batch (toBatch (A&#39; := B) t) =
        length_Batch (toBatch (A&#39; := C) t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">t</span> : T A) (<span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>),
length_Batch (toBatch t) = length_Batch (toBatch t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk9b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">t</span> : T A) (<span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>),
length_Batch (toBatch t) = length_Batch (toBatch t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk9c"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length_Batch (toBatch t) = length_Batch (toBatch t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk9d"><span class="nb">rewrite</span> length_Batch_spec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch (const nat) (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; <span class="mi">1</span>) (T B)
  (toBatch t) = length_Batch (toBatch t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk9e"><span class="nb">rewrite</span> length_Batch_spec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch (const nat) (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; <span class="mi">1</span>) (T B)
  (toBatch t) =
runBatch (const nat) (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; <span class="mi">1</span>) (T C)
  (toBatch t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk9f">compose near t on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(runBatch (const nat) (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; <span class="mi">1</span>) (T B) ‚àò toBatch)
  t =
runBatch (const nat) (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; <span class="mi">1</span>) (T C)
  (toBatch t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chka0">compose near t on <span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(runBatch (const nat) (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; <span class="mi">1</span>) (T B) ‚àò toBatch)
  t =
(runBatch (const nat) (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; <span class="mi">1</span>) (T C) ‚àò toBatch)
  t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chka1"><span class="nb">rewrite</span> &lt;- traverse_through_runBatch.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; <span class="mi">1</span>) t =
(runBatch (const nat) (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; <span class="mi">1</span>) (T C) ‚àò toBatch)
  t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chka2"><span class="nb">rewrite</span> &lt;- traverse_through_runBatch.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; <span class="mi">1</span>) t =
traverse (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; <span class="mi">1</span>) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chka3"><span class="nb">rewrite</span> (traverse_const2 _ B C).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; <span class="mi">1</span>) t =
traverse (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; <span class="mi">1</span>) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">length</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Deconstructing with refinement-type vectors *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">deconstruction</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{Traverse T}
      `{Map T}
      `{toBatch_inst: ToBatch T}
      `{ToSubset T}
      `{! TraversableFunctor T}
      `{! Compat_Map_Traverse T}
      `{! Compat_ToBatch_Traverse}
      `{! Compat_ToSubset_Traverse T}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Generalizable Variables</span> <span class="nf">v</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">trav_contents</span> {<span class="nv">A</span>} (<span class="nv">t</span>: T A):
    Vector (plength t) A :=
    <span class="kr">let</span> <span class="nv">v</span> : Vector (length_Batch
                      (toBatch (ToBatch := toBatch_inst) (A&#39; := <span class="kt">False</span>) t)) A
      := Batch_contents (toBatch t)
    <span class="kr">in</span> coerce_Vector_length (plength_eq_length t) v.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(*</span>
<span class="c">  Definition trav_contents_list {A} (t: T A):</span>
<span class="c">    Vector (plength t) A :=</span>
<span class="c">    let v : Vector (length_Batch (toBatch (A&#39; := False) t)) A</span>
<span class="c">      := Batch_contents (toBatch t)</span>
<span class="c">    in coerce_Vector_length (plength_eq_length t) v.</span>
<span class="c">   *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">trav_make</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">t</span>: T A):
    Vector (plength t) B -&gt; T B :=
    (<span class="kr">fun</span> <span class="nv">v</span> =&gt;
       <span class="kr">let</span> <span class="nv">v&#39;</span> := coerce_Vector_length (eq_sym (plength_eq_length t)) v
       <span class="kr">in</span> Batch_make (toBatch t) v&#39;).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** ** Lemmas regarding &lt;&lt;trav_make&gt;&gt; *)</span>
  <span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">trav_make_lemmas</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
      {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chka4"><span class="kn">Lemma</span> <span class="nf">trav_make_sim1</span>:
      <span class="kr">forall</span> (<span class="nv">t</span> : T A) `{v1 ~~ v2},
        trav_make (B := B) t v1 = trav_make t v2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : T A) (<span class="nv">v1</span> <span class="nv">v2</span> : Vector (plength t) B),
v1 ~~ v2 -&gt; trav_make t v1 = trav_make t v2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chka5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : T A) (<span class="nv">v1</span> <span class="nv">v2</span> : Vector (plength t) B),
v1 ~~ v2 -&gt; trav_make t v1 = trav_make t v2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chka6"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>v1, v2</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>v1 ~~ v2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trav_make t v1 = trav_make t v2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chka7"><span class="nb">unfold</span> trav_make.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>v1, v2</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>v1 ~~ v2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Batch_make (toBatch t)
  (coerce eq_sym (plength_eq_length t) <span class="kr">in</span> v1) =
Batch_make (toBatch t)
  (coerce eq_sym (plength_eq_length t) <span class="kr">in</span> v2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chka8"><span class="nb">apply</span> Batch_make_sim1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>v1, v2</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>v1 ~~ v2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">coerce eq_sym (plength_eq_length t) <span class="kr">in</span> v1 ~~
coerce eq_sym (plength_eq_length t) <span class="kr">in</span> v2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">vector_sim.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chka9"><span class="kn">Lemma</span> <span class="nf">trav_make_sim2</span>:
      <span class="kr">forall</span> `(t1 : T A) (t2: T A)
        `(v1: Vector (plength t1) B)
        `(v2: Vector (plength t2) B),
        t1 = t2 -&gt;
        Vector_sim v1 v2 -&gt;
        trav_make t1 v1 = trav_make t2 v2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : T A) (<span class="nv">v1</span> : Vector (plength t1) B)
  (<span class="nv">v2</span> : Vector (plength t2) B),
t1 = t2 -&gt;
v1 ~~ v2 -&gt; trav_make t1 v1 = trav_make t2 v2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkaa"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : T A) (<span class="nv">v1</span> : Vector (plength t1) B)
  (<span class="nv">v2</span> : Vector (plength t2) B),
t1 = t2 -&gt;
v1 ~~ v2 -&gt; trav_make t1 v1 = trav_make t2 v2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkab"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>v1</var><span class="hyp-type"><b>: </b><span>Vector (plength t1) B</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Vector (plength t2) B</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>t1 = t2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>v1 ~~ v2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trav_make t1 v1 = trav_make t2 v2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkac"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t2</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>v1, v2</var><span class="hyp-type"><b>: </b><span>Vector (plength t2) B</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>v1 ~~ v2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trav_make t2 v1 = trav_make t2 v2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">apply</span> trav_make_sim1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">trav_make_lemmas</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** ** Miscellaneous *)</span>
  <span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">list</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkad"><span class="kn">Lemma</span> <span class="nf">tolist_trav_contents</span> `{t: T A}:
      Vector_to_list A (trav_contents t) = List.rev (tolist t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vector_to_list A (trav_contents t) =
List.rev (tolist t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkae"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vector_to_list A (trav_contents t) =
List.rev (tolist t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkaf"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vector_to_list A (trav_contents t) =
List.rev (tolist t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkb0"><span class="nb">unfold</span> trav_contents.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vector_to_list A
  (coerce plength_eq_length t
   <span class="kr">in</span> Batch_contents (toBatch t)) =
List.rev (tolist t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkb1"><span class="nb">rewrite</span> (tolist_through_runBatch <span class="kt">False</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vector_to_list A
  (coerce plength_eq_length t
   <span class="kr">in</span> Batch_contents (toBatch t)) =
List.rev
  (runBatch (const (list A)) ret (T <span class="kt">False</span>) (toBatch t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkb2"><span class="nb">generalize</span> (plength_eq_length (B := <span class="kt">False</span>) t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">e</span> : length_Batch (toBatch t) = plength t,
Vector_to_list A
  (coerce e <span class="kr">in</span> Batch_contents (toBatch t)) =
List.rev
  (runBatch (const (list A)) ret (T <span class="kt">False</span>) (toBatch t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkb3"><span class="nb">intros</span> Heq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>length_Batch (toBatch t) = plength t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vector_to_list A
  (coerce Heq <span class="kr">in</span> Batch_contents (toBatch t)) =
List.rev
  (runBatch (const (list A)) ret (T <span class="kt">False</span>) (toBatch t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkb4"><span class="nb">generalize dependent</span> (plength t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">Heq</span> : length_Batch (toBatch t) = n),
Vector_to_list A
  (coerce Heq <span class="kr">in</span> Batch_contents (toBatch t)) =
List.rev
  (runBatch (const (list A)) ret (T <span class="kt">False</span>) (toBatch t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkb5"><span class="nb">induction</span> (toBatch (A&#39; := <span class="kt">False</span>) t); <span class="nb">intros</span> n Heq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>length_Batch (Done c) = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vector_to_list A
  (coerce Heq <span class="kr">in</span> Batch_contents (Done c)) =
List.rev (runBatch (const (list A)) ret C (Done c))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chkb6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A <span class="kt">False</span> (<span class="kt">False</span> -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">Heq</span> : length_Batch b = n),
Vector_to_list A
  (coerce Heq <span class="kr">in</span> Batch_contents b) =
List.rev
  (runBatch (const (list A)) ret (<span class="kt">False</span> -&gt; C) b)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>length_Batch (b ‚ßÜ a) = n</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chkb6"><hr></label><div class="goal-conclusion">Vector_to_list A
  (coerce Heq <span class="kr">in</span> Batch_contents (b ‚ßÜ a)) =
List.rev (runBatch (const (list A)) ret C (b ‚ßÜ a))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkb7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>length_Batch (Done c) = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vector_to_list A
  (coerce Heq <span class="kr">in</span> Batch_contents (Done c)) =
List.rev (runBatch (const (list A)) ret C (Done c))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkb8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A <span class="kt">False</span> (<span class="kt">False</span> -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">Heq</span> : length_Batch b = n),
Vector_to_list A
  (coerce Heq <span class="kr">in</span> Batch_contents b) =
List.rev
  (runBatch (const (list A)) ret (<span class="kt">False</span> -&gt; C) b)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>length_Batch (b ‚ßÜ a) = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vector_to_list A
  (coerce Heq <span class="kr">in</span> Batch_contents (b ‚ßÜ a)) =
List.rev (runBatch (const (list A)) ret C (b ‚ßÜ a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkb9"><span class="nb">rewrite</span> runBatch_rw2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A <span class="kt">False</span> (<span class="kt">False</span> -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">Heq</span> : length_Batch b = n),
Vector_to_list A
  (coerce Heq <span class="kr">in</span> Batch_contents b) =
List.rev
  (runBatch (const (list A)) ret (<span class="kt">False</span> -&gt; C) b)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>length_Batch (b ‚ßÜ a) = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vector_to_list A
  (coerce Heq <span class="kr">in</span> Batch_contents (b ‚ßÜ a)) =
List.rev
  (runBatch (const (list A)) ret (<span class="kt">False</span> -&gt; C) b &lt;‚ãÜ&gt;
   ret a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkba"><span class="nb">rewrite</span> Batch_contents_rw2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A <span class="kt">False</span> (<span class="kt">False</span> -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">Heq</span> : length_Batch b = n),
Vector_to_list A
  (coerce Heq <span class="kr">in</span> Batch_contents b) =
List.rev
  (runBatch (const (list A)) ret (<span class="kt">False</span> -&gt; C) b)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>length_Batch (b ‚ßÜ a) = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vector_to_list A
  (coerce Heq
   <span class="kr">in</span> vcons (length_Batch b) a (Batch_contents b)) =
List.rev
  (runBatch (const (list A)) ret (<span class="kt">False</span> -&gt; C) b &lt;‚ãÜ&gt;
   ret a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkbb"><span class="nb">unfold</span> Vector_to_list.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A <span class="kt">False</span> (<span class="kt">False</span> -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">Heq</span> : length_Batch b = n),
Vector_to_list A
  (coerce Heq <span class="kr">in</span> Batch_contents b) =
List.rev
  (runBatch (const (list A)) ret (<span class="kt">False</span> -&gt; C) b)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>length_Batch (b ‚ßÜ a) = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig
  (coerce Heq
   <span class="kr">in</span> vcons (length_Batch b) a (Batch_contents b)) =
List.rev
  (runBatch (const (list A)) ret (<span class="kt">False</span> -&gt; C) b &lt;‚ãÜ&gt;
   ret a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkbc"><span class="nb">rewrite</span> &lt;- coerce_Vector_contents.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A <span class="kt">False</span> (<span class="kt">False</span> -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">Heq</span> : length_Batch b = n),
Vector_to_list A
  (coerce Heq <span class="kr">in</span> Batch_contents b) =
List.rev
  (runBatch (const (list A)) ret (<span class="kt">False</span> -&gt; C) b)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>length_Batch (b ‚ßÜ a) = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig
  (vcons (length_Batch b) a (Batch_contents b)) =
List.rev
  (runBatch (const (list A)) ret (<span class="kt">False</span> -&gt; C) b &lt;‚ãÜ&gt;
   ret a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkbd"><span class="nb">unfold</span> length_Batch <span class="nb">at</span> <span class="mi">1</span>. <span class="c">(* hidden *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A <span class="kt">False</span> (<span class="kt">False</span> -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">Heq</span> : length_Batch b = n),
Vector_to_list A
  (coerce Heq <span class="kr">in</span> Batch_contents b) =
List.rev
  (runBatch (const (list A)) ret (<span class="kt">False</span> -&gt; C) b)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>length_Batch (b ‚ßÜ a) = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig
  (vcons (length_Batch b) a (Batch_contents b)) =
List.rev
  (runBatch (const (list A)) ret (<span class="kt">False</span> -&gt; C) b &lt;‚ãÜ&gt;
   ret a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkbe"><span class="nb">rewrite</span> proj_vcons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A <span class="kt">False</span> (<span class="kt">False</span> -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">Heq</span> : length_Batch b = n),
Vector_to_list A
  (coerce Heq <span class="kr">in</span> Batch_contents b) =
List.rev
  (runBatch (const (list A)) ret (<span class="kt">False</span> -&gt; C) b)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>length_Batch (b ‚ßÜ a) = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: proj1_sig (Batch_contents b) =
List.rev
  (runBatch (const (list A)) ret (<span class="kt">False</span> -&gt; C) b &lt;‚ãÜ&gt;
   ret a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkbf"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A <span class="kt">False</span> (<span class="kt">False</span> -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">Heq</span> : length_Batch b = n),
Vector_to_list A
  (coerce Heq <span class="kr">in</span> Batch_contents b) =
List.rev
  (runBatch (const (list A)) ret (<span class="kt">False</span> -&gt; C) b)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>length_Batch (b ‚ßÜ a) = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: proj1_sig (Batch_contents b) =
List.rev
  (runBatch (const (list A)) ret (<span class="kt">False</span> -&gt; C) b
   ‚óè ret a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkc0">unfold_ops @Monoid_op_list.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A <span class="kt">False</span> (<span class="kt">False</span> -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">Heq</span> : length_Batch b = n),
Vector_to_list A
  (coerce Heq <span class="kr">in</span> Batch_contents b) =
List.rev
  (runBatch (const (list A)) ret (<span class="kt">False</span> -&gt; C) b)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>length_Batch (b ‚ßÜ a) = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: proj1_sig (Batch_contents b) =
List.rev
  (runBatch (const (list A)) ret (<span class="kt">False</span> -&gt; C) b ++
   ret a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkc1">unfold_ops @Return_list.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A <span class="kt">False</span> (<span class="kt">False</span> -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">Heq</span> : length_Batch b = n),
Vector_to_list A
  (coerce Heq <span class="kr">in</span> Batch_contents b) =
List.rev
  (runBatch (const (list A)) ret (<span class="kt">False</span> -&gt; C) b)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>length_Batch (b ‚ßÜ a) = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: proj1_sig (Batch_contents b) =
List.rev
  (runBatch (const (list A)) (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a :: nil)
     (<span class="kt">False</span> -&gt; C) b ++ a :: nil)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkc2"><span class="nb">rewrite</span> List.rev_unit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A <span class="kt">False</span> (<span class="kt">False</span> -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">Heq</span> : length_Batch b = n),
Vector_to_list A
  (coerce Heq <span class="kr">in</span> Batch_contents b) =
List.rev
  (runBatch (const (list A)) ret (<span class="kt">False</span> -&gt; C) b)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>length_Batch (b ‚ßÜ a) = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: proj1_sig (Batch_contents b) =
a
:: List.rev
     (runBatch (const (list A))
        (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a :: nil) (<span class="kt">False</span> -&gt; C) b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkc3">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A <span class="kt">False</span> (<span class="kt">False</span> -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">Heq</span> : length_Batch b = n),
Vector_to_list A
  (coerce Heq <span class="kr">in</span> Batch_contents b) =
List.rev
  (runBatch (const (list A)) ret (<span class="kt">False</span> -&gt; C) b)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>length_Batch (b ‚ßÜ a) = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig (Batch_contents b) =
List.rev
  (runBatch (const (list A)) (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a :: nil)
     (<span class="kt">False</span> -&gt; C) b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkc4"><span class="nb">cbn</span> <span class="kr">in</span> Heq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A <span class="kt">False</span> (<span class="kt">False</span> -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">Heq</span> : length_Batch b = n),
Vector_to_list A
  (coerce Heq <span class="kr">in</span> Batch_contents b) =
List.rev
  (runBatch (const (list A)) ret (<span class="kt">False</span> -&gt; C) b)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>S (length_Batch b) = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig (Batch_contents b) =
List.rev
  (runBatch (const (list A)) (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a :: nil)
     (<span class="kt">False</span> -&gt; C) b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkc5"><span class="nb">assert</span> (Hlen: length_Batch b = (n -<span class="mi">1</span>)) <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A <span class="kt">False</span> (<span class="kt">False</span> -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">Heq</span> : length_Batch b = n),
Vector_to_list A
  (coerce Heq <span class="kr">in</span> Batch_contents b) =
List.rev
  (runBatch (const (list A)) ret (<span class="kt">False</span> -&gt; C) b)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>S (length_Batch b) = n</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>length_Batch b = n - <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig (Batch_contents b) =
List.rev
  (runBatch (const (list A)) (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a :: nil)
     (<span class="kt">False</span> -&gt; C) b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkc6"><span class="nb">specialize</span> (IHb (n - <span class="mi">1</span>) Hlen).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A <span class="kt">False</span> (<span class="kt">False</span> -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>length_Batch b = n - <span class="mi">1</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>Vector_to_list A
  (coerce Hlen <span class="kr">in</span> Batch_contents b) =
List.rev
  (runBatch (const (list A)) ret (<span class="kt">False</span> -&gt; C) b)</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>S (length_Batch b) = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig (Batch_contents b) =
List.rev
  (runBatch (const (list A)) (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a :: nil)
     (<span class="kt">False</span> -&gt; C) b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkc7"><span class="nb">change</span> (<span class="kr">fun</span> <span class="nv">a</span> =&gt; a :: nil) <span class="kr">with</span> (@ret list _ A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A <span class="kt">False</span> (<span class="kt">False</span> -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>length_Batch b = n - <span class="mi">1</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>Vector_to_list A
  (coerce Hlen <span class="kr">in</span> Batch_contents b) =
List.rev
  (runBatch (const (list A)) ret (<span class="kt">False</span> -&gt; C) b)</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>S (length_Batch b) = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig (Batch_contents b) =
List.rev
  (runBatch (const (list A)) ret (<span class="kt">False</span> -&gt; C) b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkc8"><span class="nb">cbn</span> <span class="kr">in</span> IHb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A <span class="kt">False</span> (<span class="kt">False</span> -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>length_Batch b = n - <span class="mi">1</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>Vector_to_list A
  (coerce Hlen <span class="kr">in</span> Batch_contents b) =
List.rev
  (runBatch (const (list A)) ret (<span class="kt">False</span> -&gt; C) b)</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>S (length_Batch b) = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig (Batch_contents b) =
List.rev
  (runBatch (const (list A)) ret (<span class="kt">False</span> -&gt; C) b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkc9"><span class="nb">change</span> (@app A) <span class="kr">with</span> (@Monoid_op_list A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A <span class="kt">False</span> (<span class="kt">False</span> -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>length_Batch b = n - <span class="mi">1</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>Vector_to_list A
  (coerce Hlen <span class="kr">in</span> Batch_contents b) =
List.rev
  (runBatch (const (list A)) ret (<span class="kt">False</span> -&gt; C) b)</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>S (length_Batch b) = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig (Batch_contents b) =
List.rev
  (runBatch (const (list A)) ret (<span class="kt">False</span> -&gt; C) b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkca"><span class="nb">rewrite</span> &lt;- IHb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A <span class="kt">False</span> (<span class="kt">False</span> -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>length_Batch b = n - <span class="mi">1</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>Vector_to_list A
  (coerce Hlen <span class="kr">in</span> Batch_contents b) =
List.rev
  (runBatch (const (list A)) ret (<span class="kt">False</span> -&gt; C) b)</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>S (length_Batch b) = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig (Batch_contents b) =
Vector_to_list A (coerce Hlen <span class="kr">in</span> Batch_contents b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkcb"><span class="nb">unfold</span> Vector_to_list.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A <span class="kt">False</span> (<span class="kt">False</span> -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>length_Batch b = n - <span class="mi">1</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>Vector_to_list A
  (coerce Hlen <span class="kr">in</span> Batch_contents b) =
List.rev
  (runBatch (const (list A)) ret (<span class="kt">False</span> -&gt; C) b)</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>S (length_Batch b) = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig (Batch_contents b) =
proj1_sig (coerce Hlen <span class="kr">in</span> Batch_contents b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkcc"><span class="nb">rewrite</span> &lt;- coerce_Vector_contents.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A <span class="kt">False</span> (<span class="kt">False</span> -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>length_Batch b = n - <span class="mi">1</span></span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>Vector_to_list A
  (coerce Hlen <span class="kr">in</span> Batch_contents b) =
List.rev
  (runBatch (const (list A)) ret (<span class="kt">False</span> -&gt; C) b)</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>S (length_Batch b) = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig (Batch_contents b) =
proj1_sig (Batch_contents b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">list</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** ** Lens-like laws *)</span>
  <span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">lens_laws</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** *** get-put *)</span>
    <span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkcd"><span class="kn">Lemma</span> <span class="nf">trav_get_put</span> `{t: T A}:
      trav_make t (trav_contents t) = t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trav_make t (trav_contents t) = t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkce"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trav_make t (trav_contents t) = t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkcf"><span class="nb">unfold</span> trav_make, trav_contents.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Batch_make (toBatch t)
  (coerce eq_sym (plength_eq_length t)
   <span class="kr">in</span> coerce plength_eq_length t
      <span class="kr">in</span> Batch_contents (toBatch t)) = t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkd0"><span class="nb">enough</span> (<span class="nb">cut</span>: Batch_make
                     (toBatch t)
                     (coerce eq_sym (plength_eq_length t)
                       <span class="kr">in</span> coerce (plength_eq_length (B := <span class="kt">False</span>) t)
                         <span class="kr">in</span> Batch_contents (toBatch t)) =
                     Batch_make (toBatch t) (Batch_contents (toBatch t))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>cut</var><span class="hyp-type"><b>: </b><span>Batch_make (toBatch t)
  (coerce eq_sym (plength_eq_length t)
   <span class="kr">in</span> coerce plength_eq_length t
      <span class="kr">in</span> Batch_contents (toBatch t)) =
Batch_make (toBatch t)
  (Batch_contents (toBatch t))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Batch_make (toBatch t)
  (coerce eq_sym (plength_eq_length t)
   <span class="kr">in</span> coerce plength_eq_length t
      <span class="kr">in</span> Batch_contents (toBatch t)) = t</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chkd1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chkd1"><hr></label><div class="goal-conclusion">Batch_make (toBatch t)
  (coerce eq_sym (plength_eq_length t)
   <span class="kr">in</span> coerce plength_eq_length t
      <span class="kr">in</span> Batch_contents (toBatch t)) =
Batch_make (toBatch t) (Batch_contents (toBatch t))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkd2"><span class="nb">rewrite</span> <span class="nb">cut</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>cut</var><span class="hyp-type"><b>: </b><span>Batch_make (toBatch t)
  (coerce eq_sym (plength_eq_length t)
   <span class="kr">in</span> coerce plength_eq_length t
      <span class="kr">in</span> Batch_contents (toBatch t)) =
Batch_make (toBatch t)
  (Batch_contents (toBatch t))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Batch_make (toBatch t) (Batch_contents (toBatch t)) =
t</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chkd3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chkd3"><hr></label><div class="goal-conclusion">Batch_make (toBatch t)
  (coerce eq_sym (plength_eq_length t)
   <span class="kr">in</span> coerce plength_eq_length t
      <span class="kr">in</span> Batch_contents (toBatch t)) =
Batch_make (toBatch t) (Batch_contents (toBatch t))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkd4"><span class="nb">rewrite</span> Batch_make_contents.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>cut</var><span class="hyp-type"><b>: </b><span>Batch_make (toBatch t)
  (coerce eq_sym (plength_eq_length t)
   <span class="kr">in</span> coerce plength_eq_length t
      <span class="kr">in</span> Batch_contents (toBatch t)) =
Batch_make (toBatch t)
  (Batch_contents (toBatch t))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">extract_Batch (toBatch t) = t</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chkd5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chkd5"><hr></label><div class="goal-conclusion">Batch_make (toBatch t)
  (coerce eq_sym (plength_eq_length t)
   <span class="kr">in</span> coerce plength_eq_length t
      <span class="kr">in</span> Batch_contents (toBatch t)) =
Batch_make (toBatch t) (Batch_contents (toBatch t))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkd6">compose near t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>cut</var><span class="hyp-type"><b>: </b><span>Batch_make (toBatch t)
  (coerce eq_sym (plength_eq_length t)
   <span class="kr">in</span> coerce plength_eq_length t
      <span class="kr">in</span> Batch_contents (toBatch t)) =
Batch_make (toBatch t)
  (Batch_contents (toBatch t))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(extract_Batch ‚àò toBatch) t = t</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chkd7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chkd7"><hr></label><div class="goal-conclusion">Batch_make (toBatch t)
  (coerce eq_sym (plength_eq_length t)
   <span class="kr">in</span> coerce plength_eq_length t
      <span class="kr">in</span> Batch_contents (toBatch t)) =
Batch_make (toBatch t) (Batch_contents (toBatch t))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkd8"><span class="bp">now</span> <span class="nb">rewrite</span> trf_extract.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Batch_make (toBatch t)
  (coerce eq_sym (plength_eq_length t)
   <span class="kr">in</span> coerce plength_eq_length t
      <span class="kr">in</span> Batch_contents (toBatch t)) =
Batch_make (toBatch t) (Batch_contents (toBatch t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkd9">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Batch_make (toBatch t)
  (coerce eq_sym (plength_eq_length t)
   <span class="kr">in</span> coerce plength_eq_length t
      <span class="kr">in</span> Batch_contents (toBatch t)) =
Batch_make (toBatch t) (Batch_contents (toBatch t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkda"><span class="nb">apply</span> Batch_make_sim1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">coerce eq_sym (plength_eq_length t)
<span class="kr">in</span> coerce plength_eq_length t
   <span class="kr">in</span> Batch_contents (toBatch t) ~~
Batch_contents (toBatch t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkdb">vector_sim.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Batch_contents (toBatch t) ~~
Batch_contents (toBatch t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Batch_contents_toBatch_sim.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkdc"><span class="kn">Lemma</span> <span class="nf">toBatch_trav_make</span> {<span class="nv">A</span> <span class="nv">A&#39;</span> <span class="nv">B</span>} {<span class="nv">t</span>: T A} {<span class="nv">v</span>: Vector (plength t) B}:
      toBatch (A&#39; := A&#39;) (trav_make t v) =
        Batch_replace_contents
          (toBatch (A&#39; := A&#39;) t)
          (coerce eq_sym (plength_eq_length t) <span class="kr">in</span> v).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">toBatch (trav_make t v) =
Batch_replace_contents (toBatch t)
  (coerce eq_sym (plength_eq_length t) <span class="kr">in</span> v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkdd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">toBatch (trav_make t v) =
Batch_replace_contents (toBatch t)
  (coerce eq_sym (plength_eq_length t) <span class="kr">in</span> v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkde"><span class="nb">unfold</span> trav_make.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">toBatch
  (Batch_make (toBatch t)
     (coerce eq_sym (plength_eq_length t) <span class="kr">in</span> v)) =
Batch_replace_contents (toBatch t)
  (coerce eq_sym (plength_eq_length t) <span class="kr">in</span> v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkdf"><span class="nb">rewrite</span> Batch_make_compose_rw1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Batch_make (map toBatch (toBatch t))
  (coerce batch_length_map toBatch (toBatch t)
   <span class="kr">in</span> coerce eq_sym (plength_eq_length t) <span class="kr">in</span> v) =
Batch_replace_contents (toBatch t)
  (coerce eq_sym (plength_eq_length t) <span class="kr">in</span> v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chke0"><span class="nb">rewrite</span> Batch_replace_spec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Batch_make (map toBatch (toBatch t))
  (coerce batch_length_map toBatch (toBatch t)
   <span class="kr">in</span> coerce eq_sym (plength_eq_length t) <span class="kr">in</span> v) =
Batch_make (cojoin_Batch (toBatch t))
  (coerce length_cojoin_Batch (toBatch t)
   <span class="kr">in</span> coerce eq_sym (plength_eq_length t) <span class="kr">in</span> v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chke1"><span class="nb">apply</span> Batch_make_sim2; vector_sim.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map toBatch (toBatch t) = cojoin_Batch (toBatch t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chke2">compose near t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map toBatch ‚àò toBatch) t = (cojoin_Batch ‚àò toBatch) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> &lt;- trf_duplicate.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** *** put-get *)</span>
    <span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chke3"><span class="kn">Lemma</span> <span class="nf">trav_contents_make</span> {<span class="nv">A</span>} {<span class="nv">t</span>: T A} {<span class="nv">v</span>: Vector (plength t) A}:
      trav_contents (trav_make t v) ~~ v.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector (plength t) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trav_contents (trav_make t v) ~~ v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chke4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector (plength t) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trav_contents (trav_make t v) ~~ v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chke5"><span class="nb">unfold</span> trav_contents.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector (plength t) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">coerce plength_eq_length (trav_make t v)
<span class="kr">in</span> Batch_contents (toBatch (trav_make t v)) ~~ v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chke6">vector_sim.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector (plength t) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Batch_contents (toBatch (trav_make t v)) ~~ v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chke7"><span class="nb">rewrite</span> toBatch_trav_make.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector (plength t) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Batch_contents
  (Batch_replace_contents (toBatch t)
     (coerce eq_sym (plength_eq_length t) <span class="kr">in</span> v)) ~~ v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chke8"><span class="nb">rewrite</span> Batch_put_get.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector (plength t) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">coerce length_replace_contents (toBatch t)
         (coerce eq_sym (plength_eq_length t) <span class="kr">in</span> v)
<span class="kr">in</span> coerce eq_sym (plength_eq_length t) <span class="kr">in</span> v ~~ v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">vector_sim.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** *** put-put *)</span>
    <span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chke9"><span class="kn">Lemma</span> <span class="nf">trav_make_make</span>
            `(t: T A) `(v: Vector (plength t) B)
            `(v1: Vector _ B&#39;)
            (v2: Vector _ B&#39;)
            (pf: v1 ~~ v2):
      trav_make (trav_make t v) v1 =
        trav_make t v2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br><span><var>B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v1</var><span class="hyp-type"><b>: </b><span>Vector (plength (trav_make t v)) B&#39;</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B&#39;</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>v1 ~~ v2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trav_make (trav_make t v) v1 = trav_make t v2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkea"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br><span><var>B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v1</var><span class="hyp-type"><b>: </b><span>Vector (plength (trav_make t v)) B&#39;</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B&#39;</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>v1 ~~ v2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trav_make (trav_make t v) v1 = trav_make t v2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkeb"><span class="nb">unfold</span> trav_make <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br><span><var>B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v1</var><span class="hyp-type"><b>: </b><span>Vector (plength (trav_make t v)) B&#39;</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B&#39;</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>v1 ~~ v2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Batch_make (toBatch (trav_make t v))
  (coerce eq_sym (plength_eq_length (trav_make t v))
   <span class="kr">in</span> v1) = trav_make t v2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkec"><span class="nb">unfold</span> trav_make <span class="nb">at</span> <span class="mi">7</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br><span><var>B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v1</var><span class="hyp-type"><b>: </b><span>Vector (plength (trav_make t v)) B&#39;</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B&#39;</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>v1 ~~ v2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Batch_make (toBatch (trav_make t v))
  (coerce eq_sym (plength_eq_length (trav_make t v))
   <span class="kr">in</span> v1) =
Batch_make (toBatch t)
  (coerce eq_sym (plength_eq_length t) <span class="kr">in</span> v2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chked"><span class="nb">apply</span> Batch_make_sim3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br><span><var>B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v1</var><span class="hyp-type"><b>: </b><span>Vector (plength (trav_make t v)) B&#39;</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B&#39;</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>v1 ~~ v2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">shape (toBatch (trav_make t v)) = shape (toBatch t)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chkee" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br><span><var>B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v1</var><span class="hyp-type"><b>: </b><span>Vector (plength (trav_make t v)) B&#39;</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B&#39;</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>v1 ~~ v2</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chkee"><hr></label><div class="goal-conclusion">coerce eq_sym (plength_eq_length (trav_make t v))
<span class="kr">in</span> v1 ~~ coerce eq_sym (plength_eq_length t) <span class="kr">in</span> v2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkef">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br><span><var>B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v1</var><span class="hyp-type"><b>: </b><span>Vector (plength (trav_make t v)) B&#39;</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B&#39;</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>v1 ~~ v2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">shape (toBatch (trav_make t v)) = shape (toBatch t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkf0"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br><span><var>B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v1</var><span class="hyp-type"><b>: </b><span>Vector (plength (trav_make t v)) B&#39;</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B&#39;</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>v1 ~~ v2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">shape (toBatch t) = shape (toBatch (trav_make t v))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkf1"><span class="nb">rewrite</span> toBatch_trav_make.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br><span><var>B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v1</var><span class="hyp-type"><b>: </b><span>Vector (plength (trav_make t v)) B&#39;</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B&#39;</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>v1 ~~ v2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">shape (toBatch t) =
shape
  (Batch_replace_contents (toBatch t)
     (coerce eq_sym (plength_eq_length t) <span class="kr">in</span> v))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Batch_shape_replace_contents.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkf2">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br><span><var>B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v1</var><span class="hyp-type"><b>: </b><span>Vector (plength (trav_make t v)) B&#39;</span></span></span><br><span><var>v2</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B&#39;</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>v1 ~~ v2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">coerce eq_sym (plength_eq_length (trav_make t v))
<span class="kr">in</span> v1 ~~ coerce eq_sym (plength_eq_length t) <span class="kr">in</span> v2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">vector_sim.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;precoerce&#39; Hlen &#39;in&#39; F&quot;</span> :=
      (F ‚óã coerce_Vector_length Hlen)
        (<span class="kn">at level</span> <span class="mi">10</span>, F <span class="kn">at level</span> <span class="mi">20</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkf3" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkf3"><span class="kn">Lemma</span> <span class="nf">trav_same_shape</span>
            `(t1: T A) `(t2: T A&#39;):
      shape t1 = shape t2 -&gt;
      <span class="kr">forall</span> <span class="nv">B</span>, trav_make (B := B) t1 ~!~ trav_make t2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t2</var><span class="hyp-type"><b>: </b><span>T A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">shape t1 = shape t2 -&gt;
<span class="kr">forall</span> <span class="nv">B</span> : <span class="kt">Type</span>, trav_make t1 ~!~ trav_make t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkf4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t2</var><span class="hyp-type"><b>: </b><span>T A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">shape t1 = shape t2 -&gt;
<span class="kr">forall</span> <span class="nv">B</span> : <span class="kt">Type</span>, trav_make t1 ~!~ trav_make t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkf5" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkf5"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t2</var><span class="hyp-type"><b>: </b><span>T A&#39;</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>shape t1 = shape t2</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trav_make t1 ~!~ trav_make t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkf6"><span class="nb">unfold</span> trav_make.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t2</var><span class="hyp-type"><b>: </b><span>T A&#39;</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>shape t1 = shape t2</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">precoerce eq_sym (plength_eq_length t1)
<span class="kr">in</span> Batch_make (toBatch t1) ~!~
precoerce eq_sym (plength_eq_length t2)
<span class="kr">in</span> Batch_make (toBatch t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkf7" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkf7"><span class="nb">apply</span> Vector_coerce_fun_sim_l&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t2</var><span class="hyp-type"><b>: </b><span>T A&#39;</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>shape t1 = shape t2</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Batch_make (toBatch t1) ~!~
precoerce eq_sym (plength_eq_length t2)
<span class="kr">in</span> Batch_make (toBatch t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkf8"><span class="nb">apply</span> Vector_coerce_fun_sim_r&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t2</var><span class="hyp-type"><b>: </b><span>T A&#39;</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>shape t1 = shape t2</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Batch_make (toBatch t1) ~!~ Batch_make (toBatch t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkf9"><span class="nb">apply</span> Batch_make_shape.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t2</var><span class="hyp-type"><b>: </b><span>T A&#39;</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>shape t1 = shape t2</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">shape (toBatch t1) = shape (toBatch t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkfa" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkfa"><span class="nb">apply</span> toBatch_shape.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t2</var><span class="hyp-type"><b>: </b><span>T A&#39;</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>shape t1 = shape t2</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">shape t1 = shape t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">lens_laws</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** ** Representation theorems *)</span>
  <span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkfb"><span class="kn">Lemma</span> <span class="nf">traverse_repr</span>:
    <span class="kr">forall</span> `{Applicative G} (A B: <span class="kt">Type</span>) (t: T A) (f: A -&gt; G B),
      traverse f t =
        map (trav_make t) (forwards (traverse (mkBackwards ‚àò f) (trav_contents t))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H3</span> : Map G) (<span class="nv">H4</span> : Pure G)
  (<span class="nv">H5</span> : Mult G),
Applicative G -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">t</span> : T A) (<span class="nv">f</span> : A -&gt; G B),
traverse f t =
map (trav_make t)
  (forwards
     (traverse (mkBackwards ‚àò f) (trav_contents t)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkfc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H3</span> : Map G) (<span class="nv">H4</span> : Pure G)
  (<span class="nv">H5</span> : Mult G),
Applicative G -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">t</span> : T A) (<span class="nv">f</span> : A -&gt; G B),
traverse f t =
map (trav_make t)
  (forwards
     (traverse (mkBackwards ‚àò f) (trav_contents t)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkfd"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f t =
map (trav_make t)
  (forwards
     (traverse (mkBackwards ‚àò f) (trav_contents t)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkfe"><span class="nb">rewrite</span> traverse_through_runBatch.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(runBatch G f (T B) ‚àò toBatch) t =
map (trav_make t)
  (forwards
     (traverse (mkBackwards ‚àò f) (trav_contents t)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkff" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkff"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch G f (T B) (toBatch t) =
map (trav_make t)
  (forwards
     (traverse (mkBackwards ‚óã f) (trav_contents t)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk100"><span class="nb">rewrite</span> runBatch_repr2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Batch_make (toBatch t))
  (forwards
     (traverse (mkBackwards ‚àò f)
        (Batch_contents (toBatch t)))) =
map (trav_make t)
  (forwards
     (traverse (mkBackwards ‚óã f) (trav_contents t)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk101" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk101"><span class="nb">unfold</span> trav_make, trav_contents.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Batch_make (toBatch t))
  (forwards
     (traverse (mkBackwards ‚àò f)
        (Batch_contents (toBatch t)))) =
map
  (Batch_make (toBatch t)
   ‚óã coerce_Vector_length
       (eq_sym (plength_eq_length t)))
  (forwards
     (traverse (mkBackwards ‚óã f)
        (coerce plength_eq_length t
         <span class="kr">in</span> Batch_contents (toBatch t))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk102"><span class="nb">rewrite</span> (traverse_Vector_coerce _ _ _ (plength_eq_length t)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Batch_make (toBatch t))
  (forwards
     (map
        (<span class="kr">fun</span> <span class="nv">v</span> : Vector (plength t) B =&gt;
         coerce eq_sym (plength_eq_length t) <span class="kr">in</span> v)
        (traverse (mkBackwards ‚àò f)
           (coerce plength_eq_length t
            <span class="kr">in</span> Batch_contents (toBatch t))))) =
map
  (Batch_make (toBatch t)
   ‚óã coerce_Vector_length
       (eq_sym (plength_eq_length t)))
  (forwards
     (traverse (mkBackwards ‚óã f)
        (coerce plength_eq_length t
         <span class="kr">in</span> Batch_contents (toBatch t))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk103" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk103">change_left (
        map (Batch_make (toBatch t))
            (map
               (<span class="kr">fun</span> <span class="nv">v</span> : Vector (plength t) B =&gt;
                  coerce eq_sym (plength_eq_length (B := B) t) <span class="kr">in</span> v)
               (forwards
                  (traverse (mkBackwards ‚àò f)
                            (coerce (plength_eq_length (B := B) t) <span class="kr">in</span>
                              Batch_contents (toBatch t)))))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Batch_make (toBatch t))
  (map
     (<span class="kr">fun</span> <span class="nv">v</span> : Vector (plength t) B =&gt;
      coerce eq_sym (plength_eq_length t) <span class="kr">in</span> v)
     (forwards
        (traverse (mkBackwards ‚àò f)
           (coerce plength_eq_length t
            <span class="kr">in</span> Batch_contents (toBatch t))))) =
map
  (Batch_make (toBatch t)
   ‚óã coerce_Vector_length
       (eq_sym (plength_eq_length t)))
  (forwards
     (traverse (mkBackwards ‚óã f)
        (coerce plength_eq_length t
         <span class="kr">in</span> Batch_contents (toBatch t))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk104">compose near ((forwards
                     (traverse (mkBackwards ‚àò f)
                               (coerce (plength_eq_length (B := B) t)
                                 <span class="kr">in</span> Batch_contents (toBatch t))))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (Batch_make (toBatch t))
 ‚àò map
     (<span class="kr">fun</span> <span class="nv">v</span> : Vector (plength t) B =&gt;
      coerce eq_sym (plength_eq_length t) <span class="kr">in</span> v))
  (forwards
     (traverse (mkBackwards ‚àò f)
        (coerce plength_eq_length t
         <span class="kr">in</span> Batch_contents (toBatch t)))) =
map
  (Batch_make (toBatch t)
   ‚óã coerce_Vector_length
       (eq_sym (plength_eq_length t)))
  (forwards
     (traverse (mkBackwards ‚óã f)
        (coerce plength_eq_length t
         <span class="kr">in</span> Batch_contents (toBatch t))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk105" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk105"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (Batch_make (toBatch t)
   ‚àò (<span class="kr">fun</span> <span class="nv">v</span> : Vector (plength t) B =&gt;
      coerce eq_sym (plength_eq_length t) <span class="kr">in</span> v))
  (forwards
     (traverse (mkBackwards ‚àò f)
        (coerce plength_eq_length t
         <span class="kr">in</span> Batch_contents (toBatch t)))) =
map
  (Batch_make (toBatch t)
   ‚óã coerce_Vector_length
       (eq_sym (plength_eq_length t)))
  (forwards
     (traverse (mkBackwards ‚óã f)
        (coerce plength_eq_length t
         <span class="kr">in</span> Batch_contents (toBatch t))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk106" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk106">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">forwards
  (traverse (mkBackwards ‚àò f)
     (coerce plength_eq_length t
      <span class="kr">in</span> Batch_contents (toBatch t))) =
forwards
  (traverse (mkBackwards ‚óã f)
     (coerce plength_eq_length t
      <span class="kr">in</span> Batch_contents (toBatch t)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk107" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk107">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (mkBackwards ‚àò f)
  (coerce plength_eq_length t
   <span class="kr">in</span> Batch_contents (toBatch t)) =
traverse (mkBackwards ‚óã f)
  (coerce plength_eq_length t
   <span class="kr">in</span> Batch_contents (toBatch t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk108" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk108">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">coerce plength_eq_length t
<span class="kr">in</span> Batch_contents (toBatch t) =
coerce plength_eq_length t
<span class="kr">in</span> Batch_contents (toBatch t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk109" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk109"><span class="nb">apply</span> Vector_eq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig
  (coerce plength_eq_length t
   <span class="kr">in</span> Batch_contents (toBatch t)) =
proj1_sig
  (coerce plength_eq_length t
   <span class="kr">in</span> Batch_contents (toBatch t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk10a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk10a"><span class="nb">apply</span> Vector_coerce_sim_l&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Batch_contents (toBatch t) ~~
coerce plength_eq_length t
<span class="kr">in</span> Batch_contents (toBatch t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk10b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk10b"><span class="nb">apply</span> Vector_coerce_sim_r&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Batch_contents (toBatch t) ~~
Batch_contents (toBatch t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> Batch_contents_toBatch_sim.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** ** Lemmas regarding &lt;&lt;plength&gt;&gt; *)</span>
  <span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk10c"><span class="kn">Lemma</span> <span class="nf">plength_trav_make</span>: <span class="kr">forall</span> `(t: T A) `(v: Vector _ B),
      plength t = plength (trav_make t v).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">t</span> : T A) (<span class="nv">B</span> : <span class="kt">Type</span>)
  (<span class="nv">v</span> : Vector (plength t) B),
plength t = plength (trav_make t v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk10d" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk10d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">t</span> : T A) (<span class="nv">B</span> : <span class="kt">Type</span>)
  (<span class="nv">v</span> : Vector (plength t) B),
plength t = plength (trav_make t v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk10e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk10e"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">plength t = plength (trav_make t v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk10f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk10f"><span class="nb">unfold</span> plength <span class="nb">at</span> <span class="mi">1</span> <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; <span class="mi">1</span>) t =
foldMap (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; <span class="mi">1</span>) (trav_make t v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk110" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk110"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">change</span> (<span class="kr">fun</span> (<span class="nv">x</span>:<span class="nl">?X</span>) =&gt; <span class="mi">1</span>) <span class="kr">with</span> (const (A := X) <span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap (const <span class="mi">1</span>) t =
foldMap (const <span class="mi">1</span>) (trav_make t v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk111"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> (foldMap_through_runBatch2 _ B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(runBatch (const nat) (const <span class="mi">1</span>) (T B) ‚àò toBatch) t =
(runBatch (const nat) (const <span class="mi">1</span>) (T B) ‚àò toBatch)
  (trav_make t v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk112" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk112"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch (const nat) (const <span class="mi">1</span>) (T B) (toBatch t) =
runBatch (const nat) (const <span class="mi">1</span>) (T B)
  (toBatch (trav_make t v))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk113" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk113"><span class="nb">rewrite</span> (@toBatch_trav_make A B B t v).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch (const nat) (const <span class="mi">1</span>) (T B) (toBatch t) =
runBatch (const nat) (const <span class="mi">1</span>) (T B)
  (Batch_replace_contents (toBatch t)
     (coerce eq_sym (plength_eq_length t) <span class="kr">in</span> v))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk114" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk114"><span class="nb">rewrite</span> &lt;- (runBatch_const_contents (G := @const <span class="kt">Type</span> <span class="kt">Type</span> nat)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>toBatch_inst</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch (const nat) (const <span class="mi">1</span>) (T B) (toBatch t) =
runBatch (const nat) (const <span class="mi">1</span>) (T B) (toBatch t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">deconstruction</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk115" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk115">#[export] <span class="kn">Instance</span> <span class="nf">ToSubset_Vector</span> {<span class="nv">n</span>}: ToSubset (Vector n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ToSubset (Vector n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk116" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk116"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ToSubset (Vector n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk117" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk117"><span class="nb">unfold</span> Vector.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ToSubset (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; {l : list A | length l = n})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk118" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk118"><span class="nb">intro</span> X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{l : list X | length l = n} -&gt; X -&gt; <span class="kt">Prop</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk119" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk119"><span class="nb">intros</span> [l pf].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>length l = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X -&gt; <span class="kt">Prop</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk11a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk11a"><span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>length l = n</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Prop</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (x ‚àà l).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Auto-refining &lt;&lt;Batch&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> ContainerFunctor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> ContainerFunctor.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Applicative.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">ToSubset_Batch1</span> {<span class="nv">B</span> <span class="nv">C</span>}: ToSubset (BATCH1 B C) :=
  ToSubset_Traverse.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">pw_Batch</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk11b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk11b"><span class="kn">Lemma</span> <span class="nf">foldMap_Batch_rw2</span>: <span class="kr">forall</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>: <span class="kt">Type</span>} `{Monoid M}
      (f : A -&gt; M) (a: A) (rest: Batch A B (B -&gt; C)),
      foldMap (T := BATCH1 B C) f (rest ‚ßÜ a) =
        foldMap f rest ‚óè f a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">M</span> : <span class="kt">Type</span>) (<span class="nv">op</span> : Monoid_op M)
  (<span class="nv">unit0</span> : Monoid_unit M),
Monoid M -&gt;
<span class="kr">forall</span> (<span class="nv">f</span> : A -&gt; M) (<span class="nv">a</span> : A)
  (<span class="nv">rest</span> : Batch A B (B -&gt; C)),
foldMap f (rest ‚ßÜ a) = foldMap f rest ‚óè f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk11c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk11c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">M</span> : <span class="kt">Type</span>) (<span class="nv">op</span> : Monoid_op M)
  (<span class="nv">unit0</span> : Monoid_unit M),
Monoid M -&gt;
<span class="kr">forall</span> (<span class="nv">f</span> : A -&gt; M) (<span class="nv">a</span> : A)
  (<span class="nv">rest</span> : Batch A B (B -&gt; C)),
foldMap f (rest ‚ßÜ a) = foldMap f rest ‚óè f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk11d" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk11d"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>rest</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap f (rest ‚ßÜ a) = foldMap f rest ‚óè f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk11e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk11e"><span class="nb">unfold</span> foldMap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>rest</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f (rest ‚ßÜ a) = traverse f rest ‚óè f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk11f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk11f"><span class="nb">rewrite</span> traverse_Batch_rw2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>rest</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map Step (traverse f rest) &lt;‚ãÜ&gt; f a =
traverse f rest ‚óè f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk120" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk120"><span class="kn">Definition</span> <span class="nf">tosubset_Step1</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>:<span class="kt">Type</span>}:
    <span class="kr">forall</span> (<span class="nv">a&#39;</span> : A) (<span class="nv">rest</span>: Batch A B (B -&gt; C)),
      <span class="kr">forall</span> (<span class="nv">a</span> : A),
        tosubset (F := BATCH1 B (B -&gt; C)) rest a -&gt;
        tosubset (F := BATCH1 B C) (Step rest a&#39;) a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a&#39;</span> : A) (<span class="nv">rest</span> : Batch A B (B -&gt; C)) (<span class="nv">a</span> : A),
tosubset rest a -&gt; tosubset (rest ‚ßÜ a&#39;) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk121" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk121"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a&#39;</span> : A) (<span class="nv">rest</span> : Batch A B (B -&gt; C)) (<span class="nv">a</span> : A),
tosubset rest a -&gt; tosubset (rest ‚ßÜ a&#39;) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk122" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk122">introv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>rest</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tosubset rest a -&gt; tosubset (rest ‚ßÜ a&#39;) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk123" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk123">unfold_ops @ToSubset_Batch1 @ToSubset_Traverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>rest</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap ret rest a -&gt; foldMap ret (rest ‚ßÜ a&#39;) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk124" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk124">introv Hin.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>rest</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>foldMap ret rest a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap ret (rest ‚ßÜ a&#39;) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk125" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk125"><span class="nb">change</span> ((evalAt a ‚àò foldMap (T := BATCH1 B (B -&gt; C))
                    (ret (T := subset))) rest) <span class="kr">in</span> Hin.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>rest</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>(evalAt a ‚àò foldMap ret) rest</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap ret (rest ‚ßÜ a&#39;) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk126" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk126"><span class="nb">change</span> ((evalAt a ‚àò foldMap (T := BATCH1 B C)
                    (ret (T := subset))) (rest ‚ßÜ a&#39;)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>rest</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>(evalAt a ‚àò foldMap ret) rest</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(evalAt a ‚àò foldMap ret) (rest ‚ßÜ a&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk127" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk127"><span class="nb">rewrite</span> (foldMap_morphism
               (T := BATCH1 B (B -&gt; C))
               _ _ (œï := evalAt a)) <span class="kr">in</span> Hin.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>rest</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>foldMap (evalAt a ‚àò ret) rest</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(evalAt a ‚àò foldMap ret) (rest ‚ßÜ a&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk128" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk128"><span class="nb">rewrite</span> (foldMap_morphism
               (T := BATCH1 B C)
               _ _ (œï := evalAt a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>rest</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>foldMap (evalAt a ‚àò ret) rest</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap (evalAt a ‚àò ret) (rest ‚ßÜ a&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk129" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk129"><span class="nb">rewrite</span> foldMap_Batch_rw2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>rest</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>foldMap (evalAt a ‚àò ret) rest</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap (evalAt a ‚àò ret) rest ‚óè (evalAt a ‚àò ret) a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">left</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk12a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk12a"><span class="kn">Definition</span> <span class="nf">tosubset_Step2</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>:<span class="kt">Type</span>}:
    <span class="kr">forall</span> (<span class="nv">rest</span>: Batch A B (B -&gt; C)) (<span class="nv">a</span>: A),
      tosubset (F := BATCH1 B C) (Step rest a) a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">rest</span> : Batch A B (B -&gt; C)) (<span class="nv">a</span> : A),
tosubset (rest ‚ßÜ a) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk12b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk12b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">rest</span> : Batch A B (B -&gt; C)) (<span class="nv">a</span> : A),
tosubset (rest ‚ßÜ a) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk12c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk12c"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>rest</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tosubset (rest ‚ßÜ a) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk12d" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk12d">unfold_ops @ToSubset_Batch1 @ToSubset_Traverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>rest</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap ret (rest ‚ßÜ a) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk12e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk12e"><span class="nb">change</span> ((evalAt a ‚àò foldMap (T := BATCH1 B C)
                    (ret (T := subset))) (rest ‚ßÜ a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>rest</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(evalAt a ‚àò foldMap ret) (rest ‚ßÜ a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk12f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk12f"><span class="nb">rewrite</span> (foldMap_morphism
               (T := BATCH1 B C)
               _ _ (œï := evalAt a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>rest</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap (evalAt a ‚àò ret) (rest ‚ßÜ a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk130" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk130"><span class="nb">rewrite</span> foldMap_Batch_rw2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>rest</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap (evalAt a ‚àò ret) rest ‚óè (evalAt a ‚àò ret) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">right</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk131" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk131"><span class="kn">Lemma</span> <span class="nf">element_of_Step_spec</span>: <span class="kr">forall</span> `(b: Batch A B (B -&gt; C)) a a&#39;,
      a&#39; ‚àà (b ‚ßÜ a) = (a&#39; ‚àà b \/ a&#39; = a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">b</span> : Batch A B (B -&gt; C))
  (<span class="nv">a</span> <span class="nv">a&#39;</span> : A), a&#39; ‚àà (b ‚ßÜ a) = (a&#39; ‚àà b \/ a&#39; = a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk132" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk132"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">b</span> : Batch A B (B -&gt; C))
  (<span class="nv">a</span> <span class="nv">a&#39;</span> : A), a&#39; ‚àà (b ‚ßÜ a) = (a&#39; ‚àà b \/ a&#39; = a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk133" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk133"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a&#39; ‚àà (b ‚ßÜ a) = (a&#39; ‚àà b \/ a&#39; = a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk134" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk134"><span class="nb">rewrite</span> element_of_to_foldMap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap {{a&#39;}} (b ‚ßÜ a) = (a&#39; ‚àà b \/ a&#39; = a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk135" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk135"><span class="nb">rewrite</span> element_of_to_foldMap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap {{a&#39;}} (b ‚ßÜ a) = (foldMap {{a&#39;}} b \/ a&#39; = a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk136" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk136"><span class="nb">rewrite</span> foldMap_Batch_rw2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap {{a&#39;}} b ‚óè {{a&#39;}} a =
(foldMap {{a&#39;}} b \/ a&#39; = a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">sigMapP</span> (<span class="nv">A</span>: <span class="kt">Type</span>) (<span class="nv">P</span> <span class="nv">Q</span>: A -&gt; <span class="kt">Prop</span>) (<span class="nv">Himpl</span>: <span class="kr">forall</span> <span class="nv">a</span>, P a -&gt; Q a):
    sig P -&gt; sig Q :=
    <span class="kr">fun</span> <span class="nv">œÉ</span> =&gt; <span class="kr">match</span> œÉ <span class="kr">with</span>
          | exist _ a h =&gt; exist Q a (Himpl a h)
          <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">elt_decorate</span>
   {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>: <span class="kt">Type</span>}
   (<span class="nv">b</span> : Batch A B C):
    Batch {a| tosubset (F := BATCH1 B C) b a} B C :=
    <span class="kr">match</span> b <span class="kr">with</span>
    | Done c =&gt; Done c
    | Step rest a =&gt;
        Step (map (F := BATCH1 B (B -&gt; C))
                  (sigMapP A
                           (tosubset (F := BATCH1 B (B -&gt; C)) rest)
                           (tosubset (F := BATCH1 B C) (Step rest a))
                           (tosubset_Step1 a rest)
                  )
                  (elt_decorate rest))
             (exist _ a (tosubset_Step2 rest a))
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk137" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk137"><span class="kn">Definition</span> <span class="nf">runBatch_pw</span>
               {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>} (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
               `{Applicative G}:
    <span class="kr">forall</span> (<span class="nv">b</span>: Batch A B C) `(f1 : {a | tosubset (F := BATCH1 B C) b a} -&gt; G B), G C.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : Batch A B C,
({a : A | tosubset b a} -&gt; G B) -&gt; G C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk138" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk138"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : Batch A B C,
({a : A | tosubset b a} -&gt; G B) -&gt; G C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk139" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk139"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B C</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>{a : A | tosubset b a} -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk13a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk13a"><span class="nb">induction</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>{a : A | tosubset (Done c) a} -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G C</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chk13b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>{a0 : A | tosubset (b ‚ßÜ a) a0} -&gt; G B</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>({a : A | tosubset b a} -&gt; G B) -&gt; G (B -&gt; C)</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chk13b"><hr></label><div class="goal-conclusion">G C</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk13c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk13c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>{a : A | tosubset (Done c) a} -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G C</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (pure c).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk13d" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk13d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>{a0 : A | tosubset (b ‚ßÜ a) a0} -&gt; G B</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>({a : A | tosubset b a} -&gt; G B) -&gt; G (B -&gt; C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G C</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk13e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk13e"><span class="nb">apply</span> (ap G (A := B)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>{a0 : A | tosubset (b ‚ßÜ a) a0} -&gt; G B</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>({a : A | tosubset b a} -&gt; G B) -&gt; G (B -&gt; C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G (B -&gt; C)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chk13f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>{a0 : A | tosubset (b ‚ßÜ a) a0} -&gt; G B</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>({a : A | tosubset b a} -&gt; G B) -&gt; G (B -&gt; C)</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chk13f"><hr></label><div class="goal-conclusion">G B</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk140" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk140"><span class="nb">apply</span> IHb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>{a0 : A | tosubset (b ‚ßÜ a) a0} -&gt; G B</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>({a : A | tosubset b a} -&gt; G B) -&gt; G (B -&gt; C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{a : A | tosubset b a} -&gt; G B</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chk141" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>{a0 : A | tosubset (b ‚ßÜ a) a0} -&gt; G B</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>({a : A | tosubset b a} -&gt; G B) -&gt; G (B -&gt; C)</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chk141"><hr></label><div class="goal-conclusion">G B</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk142" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk142">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>{a0 : A | tosubset (b ‚ßÜ a) a0} -&gt; G B</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>({a : A | tosubset b a} -&gt; G B) -&gt; G (B -&gt; C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{a : A | tosubset b a} -&gt; G B</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk143" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk143"><span class="nb">intros</span> [a&#39; a&#39;in].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>{a0 : A | tosubset (b ‚ßÜ a) a0} -&gt; G B</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>({a : A | tosubset b a} -&gt; G B) -&gt; G (B -&gt; C)</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>a'in</var><span class="hyp-type"><b>: </b><span>tosubset b a&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk144" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk144"><span class="nb">apply</span> f1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>{a0 : A | tosubset (b ‚ßÜ a) a0} -&gt; G B</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>({a : A | tosubset b a} -&gt; G B) -&gt; G (B -&gt; C)</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>a'in</var><span class="hyp-type"><b>: </b><span>tosubset b a&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{a0 : A | tosubset (b ‚ßÜ a) a0}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk145" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk145"><span class="kr">exists</span> <span class="nv">a&#39;</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>{a0 : A | tosubset (b ‚ßÜ a) a0} -&gt; G B</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>({a : A | tosubset b a} -&gt; G B) -&gt; G (B -&gt; C)</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>a'in</var><span class="hyp-type"><b>: </b><span>tosubset b a&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tosubset (b ‚ßÜ a) a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk146" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk146"><span class="nb">change</span> (a&#39; ‚àà (b ‚ßÜ a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>{a0 : A | tosubset (b ‚ßÜ a) a0} -&gt; G B</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>({a : A | tosubset b a} -&gt; G B) -&gt; G (B -&gt; C)</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>a'in</var><span class="hyp-type"><b>: </b><span>tosubset b a&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a&#39; ‚àà (b ‚ßÜ a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk147" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk147"><span class="nb">rewrite</span> element_of_Step_spec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>{a0 : A | tosubset (b ‚ßÜ a) a0} -&gt; G B</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>({a : A | tosubset b a} -&gt; G B) -&gt; G (B -&gt; C)</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>a'in</var><span class="hyp-type"><b>: </b><span>tosubset b a&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a&#39; ‚àà b \/ a&#39; = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">left</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk148" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk148">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>{a0 : A | tosubset (b ‚ßÜ a) a0} -&gt; G B</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>({a : A | tosubset b a} -&gt; G B) -&gt; G (B -&gt; C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G B</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk149" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk149"><span class="nb">apply</span> f1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>{a0 : A | tosubset (b ‚ßÜ a) a0} -&gt; G B</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>({a : A | tosubset b a} -&gt; G B) -&gt; G (B -&gt; C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{a0 : A | tosubset (b ‚ßÜ a) a0}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk14a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk14a"><span class="kr">exists</span> <span class="nv">a</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>{a0 : A | tosubset (b ‚ßÜ a) a0} -&gt; G B</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>({a : A | tosubset b a} -&gt; G B) -&gt; G (B -&gt; C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tosubset (b ‚ßÜ a) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk14b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk14b"><span class="nb">change</span> (a ‚àà (b ‚ßÜ a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>{a0 : A | tosubset (b ‚ßÜ a) a0} -&gt; G B</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>({a : A | tosubset b a} -&gt; G B) -&gt; G (B -&gt; C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a ‚àà (b ‚ßÜ a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk14c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk14c"><span class="nb">rewrite</span> element_of_Step_spec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>{a0 : A | tosubset (b ‚ßÜ a) a0} -&gt; G B</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>({a : A | tosubset b a} -&gt; G B) -&gt; G (B -&gt; C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a ‚àà b \/ a = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">right</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">pw_Batch</span>.</span></span></pre>
</div>
</div></body>
</html>
