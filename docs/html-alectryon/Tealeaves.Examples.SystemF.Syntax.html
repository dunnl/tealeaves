<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<title>Syntax.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.16.0+0.16.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Tealeaves <span class="kn">Require Export</span>
  Theory.DecoratedTraversableMonad
  Theory.Multisorted.DecoratedTraversableMonad
  Backends.Multisorted.LN
  Simplification.Simplification
  Simplification.MBinddt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span> LN.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Generalizable Variables</span> <span class="nf">F</span> G A B C œï.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * The index [K] *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">K2</span> : <span class="kt">Type</span> := ktyp | ktrm.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk0">#[export] <span class="kn">Instance</span> <span class="nf">Keq</span> : EqDec K2 eq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">EqDec K2 eq</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">EqDec K2 eq</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk2"><span class="nb">change</span> (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : K2, {x = y} + {x &lt;&gt; y}).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : K2, {x = y} + {x &lt;&gt; y}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">decide equality</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">I2</span> : Index := {| K := K2 |}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * System F syntax and typeclass instances *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Parameter</span> <span class="nv">base_typ</span> : <span class="kt">Type</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">syntax</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    {<span class="nv">V</span> : <span class="kt">Type</span>}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">typ</span> : <span class="kt">Type</span> :=
  | ty_c : base_typ -&gt; typ
  | ty_v : V -&gt; typ
  | ty_ar : typ -&gt; typ -&gt; typ
  | ty_univ : typ -&gt; typ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">term</span> : <span class="kt">Type</span> :=
  | tm_var : V -&gt; term
  | tm_abs : typ -&gt; term -&gt; term
  | tm_app : term -&gt; term -&gt; term
  | tm_tab : term -&gt; term
  | tm_tap : term -&gt; typ -&gt; term.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">syntax</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Clear the implicit arguments to the type constructors. This keeps &lt;&lt;V&gt;&gt;</span>
<span class="sd">    implicit for the constructors. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> typ V : <span class="kn">clear implicits</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> term V : <span class="kn">clear implicits</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">SystemF</span> (<span class="nv">k</span> : K) (<span class="nv">v</span> : <span class="kt">Type</span>) : <span class="kt">Type</span> :=
  <span class="kr">match</span> k <span class="kr">with</span>
  | ktyp =&gt; typ v
  | ktrm =&gt; term v
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Notations *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">Notations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Declare Scope</span> SystemF_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** *** Notations for type expressions *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;A ‚üπ B&quot;</span> := (ty_ar A B) (<span class="kn">at level</span> <span class="mi">51</span>, <span class="kn">right associativity</span>) : SystemF_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;‚àÄ œÑ&quot;</span> := (ty_univ œÑ) (<span class="kn">at level</span> <span class="mi">60</span>) : SystemF_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** *** Notations for term expressions *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;Œª&#39; X ‚ãÖ body&quot;</span> := (tm_abs X body) (<span class="kn">at level</span> <span class="mi">45</span>) : SystemF_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;t1 @ t2&quot;</span> := (tm_app t1 t2) (<span class="kn">at level</span> <span class="mi">40</span>) : SystemF_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;Œõ&#39; body&quot;</span> := (tm_tab body) (<span class="kn">at level</span> <span class="mi">45</span>) : SystemF_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;t1 @@ t2&quot;</span> := (tm_tap t1 t2) (<span class="kn">at level</span> <span class="mi">40</span>) : SystemF_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** *** Coercions from variables to leaves *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">Fr</span> : atom &gt;-&gt; LN.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">Bd</span> : nat &gt;-&gt; LN.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** *** Coercions from leaves to term expressions *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">tm_var_</span> : LN -&gt; term LN := @tm_var LN.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">tm_var_</span> : LN &gt;-&gt; term.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** *** Coercions from leaves to type expressions *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">c_base_type</span>: base_typ -&gt; typ LN := @ty_c LN.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">c_LN_type</span> : LN -&gt; typ LN := @ty_v LN.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">c_base_type</span> : base_typ &gt;-&gt; typ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">c_LN_type</span> : LN &gt;-&gt; typ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Notations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> SystemF_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Example expressions *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">examples</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : atom)
    (<span class="nv">c1</span> <span class="nv">c2</span> <span class="nv">c3</span> : base_typ).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** *** Raw abstract syntax *)</span>
  <span class="sd">(** Abstract syntax trees without notations or coercions *)</span>
  <span class="sd">(******************************************************************************)</span>

  <span class="sd">(** *** Constants and variables *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_1</span> : typ LN := ty_v (Fr x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_2</span> : typ LN := ty_v (Fr y).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_3</span> : typ LN := ty_v (Fr z).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_4</span> : typ LN := ty_v (Bd <span class="mi">0</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_5</span> : typ LN := ty_v (Bd <span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_6</span> : typ LN := ty_v (Bd <span class="mi">2</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_7</span> : typ LN := ty_c c1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_8</span> : typ LN := ty_c c2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** *** Simple types *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_9</span>  : typ LN := ty_ar (ty_v (Fr x))
                                     (ty_v (Fr x)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_10</span> : typ LN := ty_ar (ty_v (Fr x))
                                     (ty_v (Fr y)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_11</span> : typ LN := ty_ar (ty_v (Fr x))
                                     (ty_v (Bd <span class="mi">1</span>)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_12</span> : typ LN := ty_ar (ty_v (Bd <span class="mi">1</span>))
                                     (ty_c c1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_13</span> : typ LN := ty_ar (ty_ar (ty_v (Bd <span class="mi">0</span>))
                                            (ty_v (Fr x)))
                                     (ty_v (Bd <span class="mi">1</span>)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_14</span> : typ LN := ty_ar (ty_c c2)
                                     (ty_ar (ty_v (Fr x))
                                            (ty_v (Bd <span class="mi">1</span>))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_15</span> : typ LN := ty_ar (ty_ar (ty_v (Bd <span class="mi">2</span>))
                                            (ty_c c1))
                                     (ty_ar (ty_v (Fr y))
                                            (ty_v (Fr x))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_16</span> : typ LN := ty_ar (ty_ar (ty_v (Bd <span class="mi">2</span>))
                                            (ty_v (Bd <span class="mi">1</span>)))
                                     (ty_ar (ty_v (Fr y))
                                            (ty_v (Fr x))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** *** Universal types *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_17</span> : typ LN := ty_univ (ty_ar (ty_v (Bd <span class="mi">0</span>))
                                              (ty_v (Bd <span class="mi">0</span>))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_18</span> : typ LN := ty_univ (ty_ar (ty_ar (ty_v (Bd <span class="mi">2</span>))
                                                     (ty_v (Bd <span class="mi">1</span>)))
                                              (ty_ar (ty_v (Fr y))
                                                     (ty_v (Fr x)))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** *** Printy printed syntax *)</span>
  <span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">pretty</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Open Scope</span> SystemF_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk3"><span class="kn">Compute</span> (<span class="mi">0</span> : typ LN).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= ty_v <span class="mi">0</span>
: typ LN</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk4"><span class="kn">Compute</span> (x : typ LN).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= ty_v x
: typ LN</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk5"><span class="kn">Compute</span> (c1 : typ LN).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= ty_c c1
: typ LN</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** Constants and variables *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_1</span> : typ LN := x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_2</span> : typ LN := y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_3</span> : typ LN := Fr z.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_4</span> : typ LN := <span class="mi">0</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_5</span> : typ LN := Bd <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_6</span> : typ LN := <span class="mi">2</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_7</span> : typ LN := c1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_8</span> : typ LN := c2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** Simple types *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_9</span>  : typ LN := x ‚üπ x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_10</span> : typ LN := x ‚üπ y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk6"><span class="kn">Goal</span> ((x ‚üπ x : typ LN) = Fr x ‚üπ Fr x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(x ‚üπ x : typ LN) = x ‚üπ x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk7"><span class="kn">Goal</span> ((x ‚üπ <span class="mi">1</span> : typ LN) = Fr x ‚üπ Bd <span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(x ‚üπ <span class="mi">1</span> : typ LN) = x ‚üπ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_11</span> : typ LN := x ‚üπ <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_12</span> : typ LN := x ‚üπ c1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_13</span> : typ LN := (x ‚üπ <span class="mi">0</span>) ‚üπ <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_14</span> : typ LN := c2 ‚üπ (x ‚üπ <span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk8"><span class="kn">Goal</span> c2 ‚üπ x ‚üπ <span class="mi">1</span> = c2 ‚üπ (x ‚üπ <span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">c2 ‚üπ x ‚üπ <span class="mi">1</span> = c2 ‚üπ x ‚üπ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_15</span> : typ LN := (<span class="mi">2</span> ‚üπ c1) ‚üπ (y ‚üπ x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_16</span> : typ LN := (<span class="mi">2</span> ‚üπ <span class="mi">1</span>) ‚üπ (y ‚üπ x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** Universal types *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_17</span> : typ LN := <span class="kr">‚àÄ</span> (<span class="mi">0</span> ‚üπ <span class="mi">0</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk9"><span class="kn">Goal</span> <span class="kr">‚àÄ</span> (<span class="mi">0</span> ‚üπ <span class="mi">0</span>) = <span class="kr">‚àÄ</span> <span class="mi">0</span> ‚üπ <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="mi">0</span> ‚üπ <span class="mi">0</span> = <span class="kr">‚àÄ</span> <span class="mi">0</span> ‚üπ <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_18</span> : typ LN := <span class="kr">‚àÄ</span> (<span class="mi">2</span> ‚üπ <span class="mi">1</span>) ‚üπ (y ‚üπ x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chka"><span class="kn">Goal</span> <span class="kr">‚àÄ</span> (<span class="mi">2</span> ‚üπ <span class="mi">1</span>) ‚üπ (y ‚üπ x) = <span class="kr">‚àÄ</span> ((<span class="mi">2</span> ‚üπ <span class="mi">1</span>) ‚üπ (y ‚üπ x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="mi">2</span> ‚üπ <span class="mi">1</span>) ‚üπ y ‚üπ x = <span class="kr">‚àÄ</span> (<span class="mi">2</span> ‚üπ <span class="mi">1</span>) ‚üπ y ‚üπ x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_19</span> : typ LN := (<span class="kr">‚àÄ</span> <span class="mi">2</span> ‚üπ <span class="mi">1</span>) ‚üπ (y ‚üπ x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">typ_20</span> : typ LN := (<span class="mi">2</span> ‚üπ <span class="mi">1</span>) ‚üπ <span class="kr">‚àÄ</span> <span class="nv">y</span> ‚üπ x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">pretty</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">term_1</span> : term LN := tm_var (Fr x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">term_2</span> : term LN := tm_var (Bd <span class="mi">0</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">term_3</span> : term LN := tm_app term_1 term_2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">term_4</span> : term LN := tm_app term_3 term_3.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Identity function on type [c1]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">term_5</span> : term LN := tm_abs (ty_c c1) (tm_var (Bd <span class="mi">0</span>)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">term_6</span> : term LN := tm_app term_5 term_3.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Polymorphic identity function. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">term_7</span> : term LN := tm_tab (tm_abs (ty_v (Bd <span class="mi">0</span>))(tm_var (Bd <span class="mi">0</span>))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Instantiate identity at &lt;&lt;c1&gt;&gt; *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">term_8</span> : term LN := tm_tap term_7 c1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Open Scope</span> SystemF_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">term_9</span> : term LN := (Œõ <span class="kr">Œª</span> <span class="mi">0</span> ‚ãÖ <span class="mi">0</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">examples</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** &lt;&lt;binddt&gt;&gt; operations *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">operations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    (<span class="nv">F</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    `{Applicative F}
    {A B : <span class="kt">Type</span>}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">bind_type</span> (<span class="nv">f</span> : <span class="kr">forall</span> (<span class="nv">k</span> : K), list K2 * A -&gt; F (SystemF k B)) (<span class="nv">t</span> : typ A) : F (typ B) :=
    <span class="kr">match</span> t <span class="kr">with</span>
    | ty_c t =&gt;
        pure (ty_c t)
    | ty_v a =&gt;
        f ktyp (nil, a)
    | ty_ar t1 t2 =&gt;
        pure ty_ar &lt;‚ãÜ&gt; bind_type f t1 &lt;‚ãÜ&gt; bind_type f t2
    | ty_univ body =&gt;
        pure ty_univ &lt;‚ãÜ&gt; bind_type (f ‚óª allK (incr [ktyp])) body
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">bind_term</span> (<span class="nv">f</span> : <span class="kr">forall</span> (<span class="nv">k</span> : K), list K2 * A -&gt; F (SystemF k B)) (<span class="nv">t</span> : term A) : F (term B) :=
    <span class="kr">match</span> t <span class="kr">with</span>
    | tm_var a =&gt;
        f ktrm (nil, a)
    | tm_abs ty body =&gt;
        pure tm_abs
        &lt;‚ãÜ&gt; bind_type f ty
        &lt;‚ãÜ&gt; bind_term (f ‚óª allK (incr [ktrm])) body
    | tm_app t1 t2 =&gt;
        pure tm_app &lt;‚ãÜ&gt; bind_term f t1 &lt;‚ãÜ&gt; bind_term f t2
    | tm_tab body =&gt;
        pure tm_tab &lt;‚ãÜ&gt; bind_term (f ‚óª allK (incr [ktyp])) body
    | tm_tap t1 ty =&gt;
        pure tm_tap &lt;‚ãÜ&gt; bind_term f t1 &lt;‚ãÜ&gt; bind_type f ty
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">operations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">MReturn_SystemF</span> : MReturn SystemF :=
  <span class="kr">fun</span> <span class="nv">A</span> <span class="nv">k</span> =&gt; <span class="kr">match</span> k <span class="kr">with</span>
          | ktyp =&gt; ty_v
          | ktrm =&gt; tm_var
          <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">MBind_type</span> : MBind (list K2) SystemF typ := @bind_type.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">MBind_term</span> : MBind (list K2) SystemF term := @bind_term.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">MBind_SystemF</span> : <span class="kr">forall</span> <span class="nv">k</span>, MBind (list K2) SystemF (SystemF k) :=
  <span class="kp">ltac</span>:(<span class="nb">intros</span> [|]; <span class="nb">typeclasses eauto</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">cbn_mbinddt_post_hook</span> ::=
  <span class="kp">try</span> <span class="kr">match goal with</span>
  | |- <span class="kp">context</span>[bind_type <span class="nl">?G</span> <span class="nl">?f</span> <span class="nl">?œÑ</span>] =&gt;
      <span class="nb">change</span> (bind_type G f œÑ) <span class="kr">with</span> (mbinddt typ G f œÑ)
  | |- <span class="kp">context</span>[bind_term <span class="nl">?G</span> <span class="nl">?f</span> <span class="nl">?t</span>] =&gt;
      <span class="nb">change</span> (bind_term G f t) <span class="kr">with</span> (mbinddt term G f t)
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(*</span>
<span class="c">Ltac simplify_mbinddt_unfold_ret_hook ::=</span>
<span class="c">  unfold_ops @MReturn_SystemF.</span>
<span class="c">*)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">use_operational_tcs</span> :=
  ltac_trace <span class="s2">&quot;use_operational_tcs&quot;</span>;
  <span class="nb">change</span> (bind_type <span class="nl">?F</span> <span class="nl">?f</span>) <span class="kr">with</span> (mbinddt typ F f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">grammatical_categories_down</span> :=
  ltac_trace <span class="s2">&quot;grammatical_categories_down&quot;</span>;
  <span class="nb">change</span> (SystemF ktyp) <span class="kr">with</span> typ;
  <span class="nb">change</span> (MBind_SystemF ktyp) <span class="kr">with</span> MBind_type.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">grammatical_categories_up</span> :=
  ltac_trace <span class="s2">&quot;grammatical_categories_up&quot;</span>;
  <span class="nb">change</span> typ <span class="kr">with</span> (SystemF ktyp);
  <span class="nb">change</span> (MBind_type) <span class="kr">with</span> (MBind_SystemF ktyp).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">K_down</span> :=
  ltac_trace <span class="s2">&quot;K_down&quot;</span>;
  <span class="nb">change</span> (@K I2) <span class="kr">with</span> K2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">K_up</span> :=
  ltac_trace <span class="s2">&quot;K_up&quot;</span>;
  <span class="nb">change</span> K2 <span class="kr">with</span> (@K I2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Example computations *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">example_computations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> SystemF_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : atom)
    (<span class="nv">c1</span> <span class="nv">c2</span> <span class="nv">c3</span> : base_typ).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** ** Demo of opening operation *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb"><span class="kn">Goal</span> open (T := SystemF) typ ktyp (Fr x) (Bd <span class="mi">0</span>) = Fr x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>c1, c2, c3</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">open typ ktyp x <span class="mi">0</span> = x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc"><span class="kn">Goal</span> open typ ktyp (Fr x) (Bd <span class="mi">1</span>) = Bd <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>c1, c2, c3</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">open typ ktyp x <span class="mi">1</span> = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd"><span class="kn">Goal</span> open typ ktyp (Fr x) (Fr x) = Fr x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>c1, c2, c3</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">open typ ktyp x x = x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke"><span class="kn">Goal</span> open typ ktyp (Fr x) (Fr y) = Fr y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>c1, c2, c3</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">open typ ktyp x y = y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkf"><span class="kn">Goal</span> open typ ktyp (Fr y) (Fr x) = Fr x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>c1, c2, c3</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">open typ ktyp y x = x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk10"><span class="kn">Goal</span> open typ ktyp (Fr y) (Fr y) = Fr y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>c1, c2, c3</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">open typ ktyp y y = y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk11"><span class="kn">Goal</span> open typ ktyp (Fr x) (<span class="kr">‚àÄ</span> <span class="nv">Bd</span> <span class="mi">0</span>) = (<span class="kr">‚àÄ</span> (<span class="nv">Bd</span> <span class="mi">0</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>c1, c2, c3</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">open typ ktyp x (<span class="kr">‚àÄ</span> <span class="mi">0</span>) = <span class="kr">‚àÄ</span> <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk12"><span class="kn">Goal</span> open typ ktyp (Fr x) (<span class="kr">‚àÄ</span> <span class="nv">Bd</span> <span class="mi">1</span>) = (<span class="kr">‚àÄ</span> (<span class="nv">Fr</span> <span class="nv">x</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>c1, c2, c3</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">open typ ktyp x (<span class="kr">‚àÄ</span> <span class="mi">1</span>) = <span class="kr">‚àÄ</span> <span class="nv">x</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk13"><span class="kn">Goal</span> open typ ktyp (Fr x) (<span class="kr">‚àÄ</span> (<span class="nv">Bd</span> <span class="mi">1</span> ‚üπ Bd <span class="mi">0</span>)) = (<span class="kr">‚àÄ</span> <span class="nv">Fr</span> <span class="nv">x</span> ‚üπ Bd <span class="mi">0</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>c1, c2, c3</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">open typ ktyp x (<span class="kr">‚àÄ</span> <span class="mi">1</span> ‚üπ <span class="mi">0</span>) = <span class="kr">‚àÄ</span> <span class="nv">x</span> ‚üπ <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk14"><span class="kn">Goal</span> open typ ktyp (Fr x) (<span class="kr">‚àÄ</span> <span class="nv">Bd</span> <span class="mi">1</span> ‚üπ Bd <span class="mi">2</span>) = (<span class="kr">‚àÄ</span> <span class="nv">Fr</span> <span class="nv">x</span> ‚üπ Bd <span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>c1, c2, c3</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">open typ ktyp x (<span class="kr">‚àÄ</span> <span class="mi">1</span> ‚üπ <span class="mi">2</span>) = <span class="kr">‚àÄ</span> <span class="nv">x</span> ‚üπ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">example_computations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Proofs of the DTM axioms *)</span>
<span class="sd">(******************************************************************************)</span>

<span class="sd">(** ** Helper lemmas for proving DTM axioms *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">DTM_instance_lemmas</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    (<span class="nv">W</span> : <span class="kt">Type</span>)
    (<span class="nv">S</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    (<span class="nv">T</span> : K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    `{! MReturn T}
    `{! MBind W T S}
    `{! <span class="kr">forall</span> <span class="nv">k</span>, MBind W T (T k)}
    {mn_op : Monoid_op W}
    {mn_unit : Monoid_unit W}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk15"><span class="kn">Lemma</span> <span class="nf">mbinddt_inst_law1_case1</span> : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">t</span> : S A) (<span class="nv">w</span> : W),
      (mbinddt S (<span class="kr">fun</span> <span class="nv">A</span> =&gt; A) (<span class="kr">fun</span> <span class="nv">k</span> =&gt; mret T k ‚àò extract (W := (W √ó))) t = t) -&gt;
      (mbinddt S (<span class="kr">fun</span> <span class="nv">A</span> =&gt; A) (<span class="kr">fun</span> <span class="nv">k</span> =&gt; (mret T k ‚àò extract (W := (W √ó))) ‚¶ø w) t = t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">t</span> : S A) (<span class="nv">w</span> : W),
mbinddt S (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret T k ‚àò extract) t = t -&gt;
mbinddt S (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; (mret T k ‚àò extract) ‚¶ø w) t = t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk16"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">t</span> : S A) (<span class="nv">w</span> : W),
mbinddt S (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret T k ‚àò extract) t = t -&gt;
mbinddt S (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; (mret T k ‚àò extract) ‚¶ø w) t = t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk17">introv IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>S A</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>mbinddt S (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret T k ‚àò extract) t = t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt S (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; (mret T k ‚àò extract) ‚¶ø w) t = t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk18"><span class="nb">rewrite</span> &lt;- IH <span class="nb">at</span> <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>S A</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>mbinddt S (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret T k ‚àò extract) t = t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt S (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; (mret T k ‚àò extract) ‚¶ø w) t =
mbinddt S (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret T k ‚àò extract) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk19">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>S A</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>mbinddt S (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret T k ‚àò extract) t = t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; (mret T k ‚àò extract) ‚¶ø w) =
(<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret T k ‚àò extract)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk1a">ext k [w&#39; a].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>S A</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>mbinddt S (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret T k ‚àò extract) t = t</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>w'</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((mret T k ‚àò extract) ‚¶ø w) (w&#39;, a) =
(mret T k ‚àò extract) (w&#39;, a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk1b"><span class="kn">Lemma</span> <span class="nf">mbinddt_inst_law1_case12</span> : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">w</span> : W),
      mbinddt S (<span class="kr">fun</span> <span class="nv">A</span> =&gt; A) (<span class="kr">fun</span> <span class="nv">k</span> =&gt; mret T k ‚àò extract (W := (W √ó))) (A := A) =
        mbinddt S (<span class="kr">fun</span> <span class="nv">A</span> =&gt; A) ((<span class="kr">fun</span> <span class="nv">k</span> =&gt; mret T k ‚àò extract (W := (W √ó))) ‚óª allK (incr w)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">w</span> : W),
mbinddt S (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret T k ‚àò extract) =
mbinddt S (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  ((<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret T k ‚àò extract) ‚óª allK (incr w))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk1c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">w</span> : W),
mbinddt S (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret T k ‚àò extract) =
mbinddt S (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  ((<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret T k ‚àò extract) ‚óª allK (incr w))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk1d">introv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt S (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret T k ‚àò extract) =
mbinddt S (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  ((<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret T k ‚àò extract) ‚óª allK (incr w))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk1e">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret T k ‚àò extract) =
(<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; mret T k ‚àò extract) ‚óª allK (incr w)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> ext k [w&#39; a].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{Applicative G}
    `{Applicative F}
    `{! Monoid W}
    {A B C : <span class="kt">Type</span>}
    (g : <span class="kr">forall</span> <span class="nv">k</span>, W * B -&gt; G (T k C))
    (f : <span class="kr">forall</span> <span class="nv">k</span>, W * A -&gt; F (T k B)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(* for Var case *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk1f"><span class="kn">Lemma</span> <span class="nf">mbinddt_inst_law2_case2</span> : <span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">k</span> : K),
    map (F := F) (mbinddt (T k) G g) (f k (∆µ, a)) =
    map (F := F) (mbinddt (T k) G (g ‚óª allK (incr ∆µ))) (f k (∆µ, a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid W</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * B -&gt; G (T k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * A -&gt; F (T k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">k</span> : K),
map (mbinddt (T k) G g) (f k (∆µ, a)) =
map (mbinddt (T k) G (g ‚óª allK (incr ∆µ))) (f k (∆µ, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk20"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid W</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * B -&gt; G (T k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * A -&gt; F (T k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">k</span> : K),
map (mbinddt (T k) G g) (f k (∆µ, a)) =
map (mbinddt (T k) G (g ‚óª allK (incr ∆µ))) (f k (∆µ, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk21"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid W</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * B -&gt; G (T k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * A -&gt; F (T k B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt (T k) G g) (f k (∆µ, a)) =
map (mbinddt (T k) G (g ‚óª allK (incr ∆µ))) (f k (∆µ, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk22"><span class="kp">repeat</span> fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid W</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * B -&gt; G (T k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * A -&gt; F (T k B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g = g ‚óª allK (incr ∆µ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk23">ext k&#39; [w b].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid W</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * B -&gt; G (T k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * A -&gt; F (T k B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g k&#39; (w, b) = (g ‚óª allK (incr ∆µ)) k&#39; (w, b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk24"><span class="nb">rewrite</span> vec_compose_lemma2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid W</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * B -&gt; G (T k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * A -&gt; F (T k B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g k&#39; (w, b) = (g k&#39; ‚àò incr ∆µ) (w, b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk25"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid W</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * B -&gt; G (T k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * A -&gt; F (T k B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g k&#39; (w, b) = g k&#39; (incr ∆µ (w, b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk26"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid W</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * B -&gt; G (T k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * A -&gt; F (T k B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g k&#39; (w, b) = g k&#39; (∆µ ‚óè w, b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> simpl_monoid.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk27"><span class="kn">Lemma</span> <span class="nf">compose_dtm_incr</span> : <span class="kr">forall</span> (<span class="nv">w</span> : W),
      ((compose_dtm (F := F) (G := G) g f) ‚óª (allK (incr w))) =
      (g ‚óª allK (incr w)) ‚ãÜdtm (f ‚óª allK (incr w)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid W</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * B -&gt; G (T k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * A -&gt; F (T k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">w</span> : W,
g ‚ãÜdtm f ‚óª allK (incr w) =
(g ‚óª allK (incr w)) ‚ãÜdtm (f ‚óª allK (incr w))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk28"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid W</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * B -&gt; G (T k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * A -&gt; F (T k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">w</span> : W,
g ‚ãÜdtm f ‚óª allK (incr w) =
(g ‚óª allK (incr w)) ‚ãÜdtm (f ‚óª allK (incr w))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk29"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid W</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * B -&gt; G (T k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, W * A -&gt; F (T k B)</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g ‚ãÜdtm f ‚óª allK (incr w) =
(g ‚óª allK (incr w)) ‚ãÜdtm (f ‚óª allK (incr w))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (compose_dtm_incr_alt W); <span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">DTM_instance_lemmas</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> compose_dtm_incr {W}%type_scope {T}%function_scope {H}%function_scope {mn_op mn_unit}
  {G}%function_scope {H0 H1 H2} {F}%function_scope {H4 H5 H6 Monoid0} {A B C}%type_scope (_
  _)%function_scope _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** &lt;&lt;mbinddt_mret&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk2a"><span class="kn">Lemma</span> <span class="nf">mbinddt_mret_typ</span> : <span class="kr">forall</span> (<span class="nv">A</span>: <span class="kt">Type</span>),
    mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> =&gt; A) (mret SystemF ‚óª allK extract) = @id (typ A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
mbinddt typ (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  (mret SystemF ‚óª allK extract) = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk2b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
mbinddt typ (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  (mret SystemF ‚óª allK extract) = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk2c"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk2d">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t = id t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk2e"><span class="nb">unfold</span> id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t = t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk2f"><span class="nb">induction</span> t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) (ty_c b) = ty_c b</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntax-v-chk30" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk30"><hr></label><div class="goal-conclusion">mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) (ty_v v) = ty_v v</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntax-v-chk31" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t1 = t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t2 = t2</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk31"><hr></label><div class="goal-conclusion">mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) (t1 ‚üπ t2) = t1 ‚üπ t2</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntax-v-chk32" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t = t</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk32"><hr></label><div class="goal-conclusion">mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) 
  (<span class="kr">‚àÄ</span> <span class="nv">t</span>) = <span class="kr">‚àÄ</span> <span class="nv">t</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk33">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) (ty_c b) = ty_c b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk34">simplify_mbinddt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (ty_c b) = ty_c b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk35">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) (ty_v v) = ty_v v</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk36">simplify_mbinddt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ty_v v = ty_v v</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk37">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t1 = t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t2 = t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) (t1 ‚üπ t2) = t1 ‚üπ t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk38">simplify_mbinddt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t1 = t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t2 = t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ty_ar
  (mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
     (mret SystemF ‚óª allK extract) t1)
  (mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
     (mret SystemF ‚óª allK extract) t2) = t1 ‚üπ t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk39">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t1 = t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t2 = t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t1 = t1</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntax-v-chk3a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t1 = t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t2 = t2</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk3a"><hr></label><div class="goal-conclusion">mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t2 = t2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk3b"><span class="nb">apply</span> IHt1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t1 = t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t2 = t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t2 = t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IHt2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk3c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (mret SystemF ‚óª allK extract) t = t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) (<span class="kr">‚àÄ</span> <span class="nv">t</span>) = <span class="kr">‚àÄ</span> <span class="nv">t</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk3d"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (mret SystemF ‚óª allK extract) t = t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ty_univ
  (mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
     ((mret SystemF ‚óª allK extract)
      ‚óª allK (incr [ktyp])) t) = <span class="kr">‚àÄ</span> <span class="nv">t</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk3e">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (mret SystemF ‚óª allK extract) t = t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  ((mret SystemF ‚óª allK extract) ‚óª allK (incr [ktyp]))
  t = t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk3f"><span class="nb">rewrite</span> vec_compose_assoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (mret SystemF ‚óª allK extract) t = t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª (allK extract ‚óª allK (incr [ktyp])))
  t = t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk40">K_up.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (mret SystemF ‚óª allK extract) t = t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª (allK extract ‚óª allK (incr [ktyp])))
  t = t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk41"><span class="nb">rewrite</span> vec_compose_allK.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (mret SystemF ‚óª allK extract) t = t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK (extract ‚àò incr [ktyp])) t = t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk42"><span class="nb">rewrite</span> extract_incr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (mret SystemF ‚óª allK extract) t = t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t = t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk43"><span class="kn">Lemma</span> <span class="nf">mbinddt_mret_term</span> : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>),
    mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> =&gt; A) (mret SystemF ‚óª allK (extract (W := (list K2 √ó)))) = @id (term A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
mbinddt term (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  (mret SystemF ‚óª allK extract) = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk44"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
mbinddt term (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0)
  (mret SystemF ‚óª allK extract) = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk45"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk46">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t = id t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk47"><span class="nb">unfold</span> id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t = t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk48"><span class="nb">induction</span> t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) (tm_var v) = tm_var v</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntax-v-chk49" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (mret SystemF ‚óª allK extract) t0 = t0</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk49"><hr></label><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) (<span class="kr">Œª</span> <span class="nv">t</span> ‚ãÖ t0) = <span class="kr">Œª</span> <span class="nv">t</span> ‚ãÖ t0</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntax-v-chk4a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t1 = t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t2 = t2</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk4a"><hr></label><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) (t1 @ t2) = t1 @ t2</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntax-v-chk4b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t = t</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk4b"><hr></label><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) 
  (Œõ t) = Œõ t</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntax-v-chk4c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t = t</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk4c"><hr></label><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) 
  (t @@ t0) = t @@ t0</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk4d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) (tm_var v) = tm_var v</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk4e">simplify_mbinddt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tm_var v = tm_var v</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk4f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (mret SystemF ‚óª allK extract) t0 = t0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) (<span class="kr">Œª</span> <span class="nv">t</span> ‚ãÖ t0) = <span class="kr">Œª</span> <span class="nv">t</span> ‚ãÖ t0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk50">cbn_mbinddt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (mret SystemF ‚óª allK extract) t0 = t0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure tm_abs
  (mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
     (mret SystemF ‚óª allK extract) t)
  (mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
     ((mret SystemF ‚óª allK extract)
      ‚óª allK (incr [ktrm])) t0) = <span class="kr">Œª</span> <span class="nv">t</span> ‚ãÖ t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk51">fequal
    + use_operational_tcs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (mret SystemF ‚óª allK extract) t0 = t0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt typ (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t = t</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntax-v-chk52" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (mret SystemF ‚óª allK extract) t0 = t0</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk52"><hr></label><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  ((mret SystemF ‚óª allK extract) ‚óª allK (incr [ktrm]))
  t0 = t0</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk53"><span class="bp">now</span> <span class="nb">rewrite</span> mbinddt_mret_typ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (mret SystemF ‚óª allK extract) t0 = t0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  ((mret SystemF ‚óª allK extract) ‚óª allK (incr [ktrm]))
  t0 = t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk54">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (mret SystemF ‚óª allK extract) t0 = t0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  ((mret SystemF ‚óª allK extract) ‚óª allK (incr [ktrm]))
  t0 = t0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk55"><span class="nb">rewrite</span> vec_compose_assoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (mret SystemF ‚óª allK extract) t0 = t0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª (allK extract ‚óª allK (incr [ktrm])))
  t0 = t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk56">K_up.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (mret SystemF ‚óª allK extract) t0 = t0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª (allK extract ‚óª allK (incr [ktrm])))
  t0 = t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk57"><span class="nb">rewrite</span> vec_compose_allK.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (mret SystemF ‚óª allK extract) t0 = t0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK (extract ‚àò incr [ktrm])) t0 =
t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk58"><span class="nb">rewrite</span> extract_incr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (mret SystemF ‚óª allK extract) t0 = t0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t0 = t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk59">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t1 = t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t2 = t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) (t1 @ t2) = t1 @ t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk5a"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t1 = t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t2 = t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure tm_app
  (mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
     (mret SystemF ‚óª allK extract) t1)
  (mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
     (mret SystemF ‚óª allK extract) t2) = t1 @ t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk5b">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t1 = t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t2 = t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t1 = t1</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntax-v-chk5c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t1 = t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t2 = t2</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk5c"><hr></label><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t2 = t2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk5d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t1 = t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t2 = t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t1 = t1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IHt1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk5e">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t1 = t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t2 = t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t2 = t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IHt2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk5f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (mret SystemF ‚óª allK extract) t = t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) (Œõ t) = Œõ t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk60"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (mret SystemF ‚óª allK extract) t = t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure tm_tab
  (mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
     ((mret SystemF ‚óª allK extract)
      ‚óª allK (incr [ktyp])) t) = Œõ t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk61">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (mret SystemF ‚óª allK extract) t = t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  ((mret SystemF ‚óª allK extract) ‚óª allK (incr [ktyp]))
  t = t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk62"><span class="nb">rewrite</span> vec_compose_assoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (mret SystemF ‚óª allK extract) t = t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª (allK extract ‚óª allK (incr [ktyp])))
  t = t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk63">K_up.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (mret SystemF ‚óª allK extract) t = t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª (allK extract ‚óª allK (incr [ktyp])))
  t = t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk64"><span class="nb">rewrite</span> vec_compose_allK.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (mret SystemF ‚óª allK extract) t = t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK (extract ‚àò incr [ktyp])) t = t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk65"><span class="nb">rewrite</span> extract_incr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (mret SystemF ‚óª allK extract) t = t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t = t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk66">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (mret SystemF ‚óª allK extract) t = t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) (t @@ t0) = t @@ t0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk67"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (mret SystemF ‚óª allK extract) t = t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure tm_tap
  (mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
     (mret SystemF ‚óª allK extract) t)
  (bind_type (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
     (mret SystemF ‚óª allK extract) t0) = t @@ t0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk68">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (mret SystemF ‚óª allK extract) t = t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t = t</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntax-v-chk69" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (mret SystemF ‚óª allK extract) t = t</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk69"><hr></label><div class="goal-conclusion">bind_type (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t0 = t0</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk6a">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (mret SystemF ‚óª allK extract) t = t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t = t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IHt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk6b">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>mbinddt term (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) (mret SystemF ‚óª allK extract) t = t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bind_type (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)
  (mret SystemF ‚óª allK extract) t0 = t0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> mbinddt_mret_typ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** &lt;&lt;mbinddt_mbinddt&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk6c"><span class="kn">Lemma</span> <span class="nf">mbinddt_mbinddt_typ</span> :
  <span class="kr">forall</span> (<span class="nv">F</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    `{Applicative F}
    `{Applicative G}
    `(g : <span class="kr">forall</span> <span class="nv">k</span>, list K2 * B -&gt; G (SystemF k C))
    `(f : <span class="kr">forall</span> <span class="nv">k</span>, list K2 * A -&gt; F (SystemF k B)),
    map (F := F) (mbinddt typ G g) ‚àò mbinddt typ F f =
    mbinddt typ (F ‚àò G) (g ‚ãÜdtm f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">F</span> <span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Map F) (<span class="nv">H0</span> : Pure F)
  (<span class="nv">H1</span> : Mult F),
Applicative F -&gt;
<span class="kr">forall</span> (<span class="nv">H3</span> : Map G) (<span class="nv">H4</span> : Pure G) (<span class="nv">H5</span> : Mult G),
Applicative G -&gt;
<span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>)
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">A</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) ‚àò mbinddt typ F f =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk6d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">F</span> <span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Map F) (<span class="nv">H0</span> : Pure F)
  (<span class="nv">H1</span> : Mult F),
Applicative F -&gt;
<span class="kr">forall</span> (<span class="nv">H3</span> : Map G) (<span class="nv">H4</span> : Pure G) (<span class="nv">H5</span> : Mult G),
Applicative G -&gt;
<span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>)
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">A</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) ‚àò mbinddt typ F f =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk6e"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt typ G g) ‚àò mbinddt typ F f =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk6f">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (mbinddt typ G g) ‚àò mbinddt typ F f) t =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk70"><span class="nb">generalize dependent</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B),
(map (mbinddt typ G g) ‚àò mbinddt typ F f) t =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk71"><span class="nb">generalize dependent</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
(map (mbinddt typ G g) ‚àò mbinddt typ F f) t =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk72"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk73"><span class="nb">induction</span> t; <span class="nb">intros</span> g f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt typ G g) (mbinddt typ F f (ty_c b)) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) (ty_c b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntax-v-chk74" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk74"><hr></label><div class="goal-conclusion">map (mbinddt typ G g) (mbinddt typ F f (ty_v v)) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) (ty_v v)</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntax-v-chk75" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t1) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t2) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk75"><hr></label><div class="goal-conclusion">map (mbinddt typ G g) (mbinddt typ F f (t1 ‚üπ t2)) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) (t1 ‚üπ t2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntax-v-chk76" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk76"><hr></label><div class="goal-conclusion">map (mbinddt typ G g) (mbinddt typ F f (<span class="kr">‚àÄ</span> <span class="nv">t</span>)) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) (<span class="kr">‚àÄ</span> <span class="nv">t</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk77">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt typ G g) (mbinddt typ F f (ty_c b)) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) (ty_c b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk78"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt typ G g) (pure (ty_c b)) = pure (ty_c b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk79"><span class="nb">rewrite</span> (app_pure_natural).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (mbinddt typ G g (ty_c b)) = pure (ty_c b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk7a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt typ G g) (mbinddt typ F f (ty_v v)) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) (ty_v v)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk7b"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt typ G g) (f ktyp ([], v)) =
map (MBind_type G H3 H4 H5 B C (g ‚óª allK (incr [])))
  (f ktyp ([], v))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk7c"><span class="nb">change</span> (MBind_type <span class="nl">?G</span> H3 H4 H5 <span class="nl">?A</span> <span class="nl">?B</span>) <span class="kr">with</span> (mbinddt typ G (A := A) (B := B)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt typ G g) (f ktyp ([], v)) =
map (mbinddt typ G (g ‚óª allK (incr [])))
  (f ktyp ([], v))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk7d"><span class="nb">change</span> [] <span class="kr">with</span> (∆µ : list K2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt typ G g) (f ktyp (∆µ : list K2, v)) =
map (mbinddt typ G (g ‚óª allK (incr (∆µ : list K2))))
  (f ktyp (∆µ : list K2, v))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk7e"><span class="nb">change</span> typ <span class="kr">with</span> (SystemF ktyp).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt (SystemF ktyp) G g)
  (f ktyp (∆µ : list K2, v)) =
map
  (mbinddt (SystemF ktyp) G
     (g ‚óª allK (incr (∆µ : list K2))))
  (f ktyp (∆µ : list K2, v))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk7f"><span class="nb">unfold</span> vec_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt (SystemF ktyp) G g) (f ktyp (∆µ, v)) =
map
  (mbinddt (SystemF ktyp) G
     (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; g k ‚àò allK (incr ∆µ) k))
  (f ktyp (∆µ, v))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk80"><span class="kn">Set Keyed Unification</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt (SystemF ktyp) G g) (f ktyp (∆µ, v)) =
map
  (mbinddt (SystemF ktyp) G
     (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; g k ‚àò allK (incr ∆µ) k))
  (f ktyp (∆µ, v))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk81"><span class="nb">rewrite</span> &lt;- (mbinddt_inst_law2_case2 (list K2)
                 SystemF (H := MBind_SystemF) _ _ _ ktyp).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt (SystemF ktyp) G g) (f ktyp (∆µ, v)) =
map (mbinddt (SystemF ktyp) G g) (f ktyp (∆µ, v))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk82"><span class="kn">Unset Keyed Unification</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt (SystemF ktyp) G g) (f ktyp (∆µ, v)) =
map (mbinddt (SystemF ktyp) G g) (f ktyp (∆µ, v))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk83">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t1) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t2) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt typ G g) (mbinddt typ F f (t1 ‚üπ t2)) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) (t1 ‚üπ t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk84"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t1) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t2) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt typ G g)
  (pure ty_ar &lt;‚ãÜ&gt; mbinddt typ F f t1 &lt;‚ãÜ&gt;
   mbinddt typ F f t2) =
pure ty_ar &lt;‚ãÜ&gt; mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t1 &lt;‚ãÜ&gt;
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk85"><span class="nb">rewrite</span> &lt;- IHt1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t1) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t2) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt typ G g)
  (pure ty_ar &lt;‚ãÜ&gt; mbinddt typ F f t1 &lt;‚ãÜ&gt;
   mbinddt typ F f t2) =
pure ty_ar &lt;‚ãÜ&gt;
map (mbinddt typ G g) (mbinddt typ F f t1) &lt;‚ãÜ&gt;
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk86"><span class="nb">rewrite</span> &lt;- IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t1) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t2) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt typ G g)
  (pure ty_ar &lt;‚ãÜ&gt; mbinddt typ F f t1 &lt;‚ãÜ&gt;
   mbinddt typ F f t2) =
pure ty_ar &lt;‚ãÜ&gt;
map (mbinddt typ G g) (mbinddt typ F f t1) &lt;‚ãÜ&gt;
map (mbinddt typ G g) (mbinddt typ F f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk87"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> (ap_compose2 G F).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t1) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t2) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt typ G g)
  (pure ty_ar &lt;‚ãÜ&gt; mbinddt typ F f t1 &lt;‚ãÜ&gt;
   mbinddt typ F f t2) =
map (ap G)
  (map (ap G) (pure ty_ar) &lt;‚ãÜ&gt;
   map (mbinddt typ G g) (mbinddt typ F f t1)) &lt;‚ãÜ&gt;
map (mbinddt typ G g) (mbinddt typ F f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk88"><span class="nb">rewrite</span> &lt;- (ap_map (G := F)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t1) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t2) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt typ G g)
  (pure ty_ar &lt;‚ãÜ&gt; mbinddt typ F f t1 &lt;‚ãÜ&gt;
   mbinddt typ F f t2) =
map (precompose (mbinddt typ G g))
  (map (ap G)
     (map (ap G) (pure ty_ar) &lt;‚ãÜ&gt;
      map (mbinddt typ G g) (mbinddt typ F f t1))) &lt;‚ãÜ&gt;
mbinddt typ F f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk89"><span class="nb">rewrite</span> &lt;- (ap_map (G := F)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t1) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t2) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt typ G g)
  (pure ty_ar &lt;‚ãÜ&gt; mbinddt typ F f t1 &lt;‚ãÜ&gt;
   mbinddt typ F f t2) =
map (precompose (mbinddt typ G g))
  (map (ap G)
     (map (precompose (mbinddt typ G g))
        (map (ap G) (pure ty_ar)) &lt;‚ãÜ&gt;
      mbinddt typ F f t1)) &lt;‚ãÜ&gt; mbinddt typ F f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk8a"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t1) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t2) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (compose (mbinddt typ G g))) (pure ty_ar) &lt;‚ãÜ&gt;
mbinddt typ F f t1 &lt;‚ãÜ&gt; mbinddt typ F f t2 =
map (precompose (mbinddt typ G g))
  (map (ap G)
     (map (precompose (mbinddt typ G g))
        (map (ap G) (pure ty_ar)) &lt;‚ãÜ&gt;
      mbinddt typ F f t1)) &lt;‚ãÜ&gt; mbinddt typ F f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk8b"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t1) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t2) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (compose (mbinddt typ G g))) (pure ty_ar) &lt;‚ãÜ&gt;
mbinddt typ F f t1 &lt;‚ãÜ&gt; mbinddt typ F f t2 =
map (compose (precompose (mbinddt typ G g)))
  (map (compose (ap G))
     (map (precompose (mbinddt typ G g))
        (map (ap G) (pure ty_ar)))) &lt;‚ãÜ&gt;
mbinddt typ F f t1 &lt;‚ãÜ&gt; mbinddt typ F f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk8c"><span class="nb">assert</span> (Functor F) <span class="bp">by</span> <span class="nb">apply</span> app_functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t1) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t2) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (compose (mbinddt typ G g))) (pure ty_ar) &lt;‚ãÜ&gt;
mbinddt typ F f t1 &lt;‚ãÜ&gt; mbinddt typ F f t2 =
map (compose (precompose (mbinddt typ G g)))
  (map (compose (ap G))
     (map (precompose (mbinddt typ G g))
        (map (ap G) (pure ty_ar)))) &lt;‚ãÜ&gt;
mbinddt typ F f t1 &lt;‚ãÜ&gt; mbinddt typ F f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk8d"><span class="kp">do</span> <span class="mi">3</span> (compose near (pure (F := (F ‚àò G)) (ty_ar (V := C)));
          <span class="nb">rewrite</span> (fun_map_map (F := F))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t1) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t2) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (compose (mbinddt typ G g))) (pure ty_ar) &lt;‚ãÜ&gt;
mbinddt typ F f t1 &lt;‚ãÜ&gt; mbinddt typ F f t2 =
map
  (compose (precompose (mbinddt typ G g))
   ‚àò (compose (ap G)
      ‚àò (precompose (mbinddt typ G g) ‚àò ap G)))
  (pure ty_ar) &lt;‚ãÜ&gt; mbinddt typ F f t1 &lt;‚ãÜ&gt;
mbinddt typ F f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk8e">unfold_ops @Pure_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t1) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t2) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (compose (mbinddt typ G g))) (pure ty_ar) &lt;‚ãÜ&gt;
mbinddt typ F f t1 &lt;‚ãÜ&gt; mbinddt typ F f t2 =
map
  (compose (precompose (mbinddt typ G g))
   ‚àò (compose (ap G)
      ‚àò (precompose (mbinddt typ G g) ‚àò ap G)))
  (pure (pure ty_ar)) &lt;‚ãÜ&gt; mbinddt typ F f t1 &lt;‚ãÜ&gt;
mbinddt typ F f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk8f"><span class="nb">rewrite</span> (app_pure_natural).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t1) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t2) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mbinddt typ G g) ‚àò ty_ar) &lt;‚ãÜ&gt;
mbinddt typ F f t1 &lt;‚ãÜ&gt; mbinddt typ F f t2 =
map
  (compose (precompose (mbinddt typ G g))
   ‚àò (compose (ap G)
      ‚àò (precompose (mbinddt typ G g) ‚àò ap G)))
  (pure (pure ty_ar)) &lt;‚ãÜ&gt; mbinddt typ F f t1 &lt;‚ãÜ&gt;
mbinddt typ F f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk90"><span class="nb">rewrite</span> (app_pure_natural).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t1) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t2) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mbinddt typ G g) ‚àò ty_ar) &lt;‚ãÜ&gt;
mbinddt typ F f t1 &lt;‚ãÜ&gt; mbinddt typ F f t2 =
pure
  ((compose (precompose (mbinddt typ G g))
    ‚àò (compose (ap G)
       ‚àò (precompose (mbinddt typ G g) ‚àò ap G)))
     (pure ty_ar)) &lt;‚ãÜ&gt; mbinddt typ F f t1 &lt;‚ãÜ&gt;
mbinddt typ F f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk91">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t) = mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt typ G g) (mbinddt typ F f (<span class="kr">‚àÄ</span> <span class="nv">t</span>)) =
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) (<span class="kr">‚àÄ</span> <span class="nv">t</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk92"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t) = mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt typ G g)
  (pure ty_univ &lt;‚ãÜ&gt;
   mbinddt typ F (f ‚óª allK (incr [ktyp])) t) =
pure ty_univ &lt;‚ãÜ&gt;
mbinddt typ (F ‚àò G) (g ‚ãÜdtm f ‚óª allK (incr [ktyp])) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk93"><span class="nb">setoid_rewrite</span> compose_dtm_incr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t) = mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt typ G g)
  (pure ty_univ &lt;‚ãÜ&gt;
   mbinddt typ F (f ‚óª allK (incr [ktyp])) t) =
pure ty_univ &lt;‚ãÜ&gt;
mbinddt typ (F ‚àò G)
  ((g ‚óª allK (incr [ktyp]))
   ‚ãÜdtm (f ‚óª allK (incr [ktyp]))) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk94"><span class="nb">rewrite</span> &lt;- IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t) = mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt typ G g)
  (pure ty_univ &lt;‚ãÜ&gt;
   mbinddt typ F (f ‚óª allK (incr [ktyp])) t) =
pure ty_univ &lt;‚ãÜ&gt;
map (mbinddt typ G (g ‚óª allK (incr [ktyp])))
  (mbinddt typ F (f ‚óª allK (incr [ktyp])) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk95"><span class="nb">rewrite</span> (ap_compose2 G F).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t) = mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt typ G g)
  (pure ty_univ &lt;‚ãÜ&gt;
   mbinddt typ F (f ‚óª allK (incr [ktyp])) t) =
map (ap G) (pure ty_univ) &lt;‚ãÜ&gt;
map (mbinddt typ G (g ‚óª allK (incr [ktyp])))
  (mbinddt typ F (f ‚óª allK (incr [ktyp])) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk96"><span class="nb">rewrite</span> &lt;- (ap_map (G := F)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t) = mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt typ G g)
  (pure ty_univ &lt;‚ãÜ&gt;
   mbinddt typ F (f ‚óª allK (incr [ktyp])) t) =
map
  (precompose (mbinddt typ G (g ‚óª allK (incr [ktyp]))))
  (map (ap G) (pure ty_univ)) &lt;‚ãÜ&gt;
mbinddt typ F (f ‚óª allK (incr [ktyp])) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk97">compose near (pure (F := F ‚àò G) (ty_univ (V := C))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t) = mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt typ G g)
  (pure ty_univ &lt;‚ãÜ&gt;
   mbinddt typ F (f ‚óª allK (incr [ktyp])) t) =
(map
   (precompose
      (mbinddt typ G (g ‚óª allK (incr [ktyp]))))
 ‚àò map (ap G)) (pure ty_univ) &lt;‚ãÜ&gt;
mbinddt typ F (f ‚óª allK (incr [ktyp])) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk98"><span class="nb">assert</span> (Functor F) <span class="bp">by</span> <span class="nb">apply</span> app_functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t) = mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt typ G g)
  (pure ty_univ &lt;‚ãÜ&gt;
   mbinddt typ F (f ‚óª allK (incr [ktyp])) t) =
(map
   (precompose
      (mbinddt typ G (g ‚óª allK (incr [ktyp]))))
 ‚àò map (ap G)) (pure ty_univ) &lt;‚ãÜ&gt;
mbinddt typ F (f ‚óª allK (incr [ktyp])) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk99"><span class="nb">rewrite</span> (fun_map_map (F := F)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t) = mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt typ G g)
  (pure ty_univ &lt;‚ãÜ&gt;
   mbinddt typ F (f ‚óª allK (incr [ktyp])) t) =
map
  (precompose (mbinddt typ G (g ‚óª allK (incr [ktyp])))
   ‚àò ap G) (pure ty_univ) &lt;‚ãÜ&gt;
mbinddt typ F (f ‚óª allK (incr [ktyp])) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk9a">unfold_ops @Pure_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t) = mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt typ G g)
  (pure ty_univ &lt;‚ãÜ&gt;
   mbinddt typ F (f ‚óª allK (incr [ktyp])) t) =
map
  (precompose (mbinddt typ G (g ‚óª allK (incr [ktyp])))
   ‚àò ap G) (pure (pure ty_univ)) &lt;‚ãÜ&gt;
mbinddt typ F (f ‚óª allK (incr [ktyp])) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk9b"><span class="nb">rewrite</span> (app_pure_natural).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t) = mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt typ G g)
  (pure ty_univ &lt;‚ãÜ&gt;
   mbinddt typ F (f ‚óª allK (incr [ktyp])) t) =
pure
  ((precompose
      (mbinddt typ G (g ‚óª allK (incr [ktyp]))) ‚àò ap G)
     (pure ty_univ)) &lt;‚ãÜ&gt;
mbinddt typ F (f ‚óª allK (incr [ktyp])) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk9c"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t) = mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (mbinddt typ G g)) (pure ty_univ) &lt;‚ãÜ&gt;
mbinddt typ F (f ‚óª allK (incr [ktyp])) t =
pure
  ((precompose
      (mbinddt typ G (g ‚óª allK (incr [ktyp]))) ‚àò ap G)
     (pure ty_univ)) &lt;‚ãÜ&gt;
mbinddt typ F (f ‚óª allK (incr [ktyp])) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk9d"><span class="nb">rewrite</span> (app_pure_natural).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt typ G g) (mbinddt typ F f t) = mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (mbinddt typ G g ‚àò ty_univ) &lt;‚ãÜ&gt;
mbinddt typ F (f ‚óª allK (incr [ktyp])) t =
pure
  ((precompose
      (mbinddt typ G (g ‚óª allK (incr [ktyp]))) ‚àò ap G)
     (pure ty_univ)) &lt;‚ãÜ&gt;
mbinddt typ F (f ‚óª allK (incr [ktyp])) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk9e"><span class="kn">Lemma</span> <span class="nf">mbinddt_mbinddt_term</span> :
  <span class="kr">forall</span> (<span class="nv">F</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    `{Applicative F}
    `{Applicative G}
    `(g : <span class="kr">forall</span> <span class="nv">k</span>, list K2 * B -&gt; G (SystemF k C))
    `(f : <span class="kr">forall</span> <span class="nv">k</span>, list K2 * A -&gt; F (SystemF k B)),
    map (F := F) (mbinddt term G g) ‚àò mbinddt term F f =
    mbinddt term (F ‚àò G) (g ‚ãÜdtm f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">F</span> <span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Map F) (<span class="nv">H0</span> : Pure F)
  (<span class="nv">H1</span> : Mult F),
Applicative F -&gt;
<span class="kr">forall</span> (<span class="nv">H3</span> : Map G) (<span class="nv">H4</span> : Pure G) (<span class="nv">H5</span> : Mult G),
Applicative G -&gt;
<span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>)
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">A</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) ‚àò mbinddt term F f =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk9f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">F</span> <span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Map F) (<span class="nv">H0</span> : Pure F)
  (<span class="nv">H1</span> : Mult F),
Applicative F -&gt;
<span class="kr">forall</span> (<span class="nv">H3</span> : Map G) (<span class="nv">H4</span> : Pure G) (<span class="nv">H5</span> : Mult G),
Applicative G -&gt;
<span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>)
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">A</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) ‚àò mbinddt term F f =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chka0"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt term G g) ‚àò mbinddt term F f =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chka1">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (mbinddt term G g) ‚àò mbinddt term F f) t =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chka2"><span class="nb">generalize dependent</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B),
(map (mbinddt term G g) ‚àò mbinddt term F f) t =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chka3"><span class="nb">generalize dependent</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
(map (mbinddt term G g) ‚àò mbinddt term F f) t =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chka4"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chka5"><span class="nb">induction</span> t; <span class="nb">intros</span> g f;
    <span class="nb">assert</span> (Functor F) <span class="bp">by</span> <span class="nb">apply</span> app_functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt term G g) (mbinddt term F f (tm_var v)) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) (tm_var v)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntax-v-chka6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t0) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><label class="goal-separator" for="syntax-v-chka6"><hr></label><div class="goal-conclusion">map (mbinddt term G g) (mbinddt term F f (<span class="kr">Œª</span> <span class="nv">t</span> ‚ãÖ t0)) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) (<span class="kr">Œª</span> <span class="nv">t</span> ‚ãÖ t0)</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntax-v-chka7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t1) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t2) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><label class="goal-separator" for="syntax-v-chka7"><hr></label><div class="goal-conclusion">map (mbinddt term G g) (mbinddt term F f (t1 @ t2)) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) (t1 @ t2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntax-v-chka8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><label class="goal-separator" for="syntax-v-chka8"><hr></label><div class="goal-conclusion">map (mbinddt term G g) (mbinddt term F f (Œõ t)) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) (Œõ t)</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntax-v-chka9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><label class="goal-separator" for="syntax-v-chka9"><hr></label><div class="goal-conclusion">map (mbinddt term G g) (mbinddt term F f (t @@ t0)) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) (t @@ t0)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkaa">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt term G g) (mbinddt term F f (tm_var v)) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) (tm_var v)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkab"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt term G g) (f ktrm ([], v)) =
map (MBind_term G H3 H4 H5 B C (g ‚óª allK (incr [])))
  (f ktrm ([], v))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkac"><span class="nb">change</span> (MBind_term <span class="nl">?G</span> H3 H4 H5 <span class="nl">?A</span> <span class="nl">?B</span>) <span class="kr">with</span> (mbinddt term G (A := A) (B := B)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt term G g) (f ktrm ([], v)) =
map (mbinddt term G (g ‚óª allK (incr [])))
  (f ktrm ([], v))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkad">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mbinddt term G g = mbinddt term G (g ‚óª allK (incr []))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkae">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g = g ‚óª allK (incr [])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> ext k [w a].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkaf">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t0) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt term G g) (mbinddt term F f (<span class="kr">Œª</span> <span class="nv">t</span> ‚ãÖ t0)) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) (<span class="kr">Œª</span> <span class="nv">t</span> ‚ãÖ t0)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb0"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t0) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt term G g)
  (pure tm_abs &lt;‚ãÜ&gt; bind_type F f t &lt;‚ãÜ&gt;
   mbinddt term F (f ‚óª allK (incr [ktrm])) t0) =
pure tm_abs &lt;‚ãÜ&gt; bind_type (F ‚àò G) (g ‚ãÜdtm f) t &lt;‚ãÜ&gt;
mbinddt term (F ‚àò G) (g ‚ãÜdtm f ‚óª allK (incr [ktrm]))
  t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb1"><span class="nb">change</span> (bind_type <span class="nl">?F</span> <span class="nl">?f</span>) <span class="kr">with</span> (mbinddt typ F f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t0) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt term G g)
  (pure tm_abs &lt;‚ãÜ&gt; mbinddt typ F f t &lt;‚ãÜ&gt;
   mbinddt term F (f ‚óª allK (incr [ktrm])) t0) =
pure tm_abs &lt;‚ãÜ&gt; mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t &lt;‚ãÜ&gt;
mbinddt term (F ‚àò G) (g ‚ãÜdtm f ‚óª allK (incr [ktrm]))
  t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb2"><span class="nb">setoid_rewrite</span> compose_dtm_incr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t0) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt term G g)
  (pure tm_abs &lt;‚ãÜ&gt; mbinddt typ F f t &lt;‚ãÜ&gt;
   mbinddt term F (f ‚óª allK (incr [ktrm])) t0) =
pure tm_abs &lt;‚ãÜ&gt; mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t &lt;‚ãÜ&gt;
mbinddt term (F ‚àò G)
  ((g ‚óª allK (incr [ktrm]))
   ‚ãÜdtm (f ‚óª allK (incr [ktrm]))) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb3"><span class="nb">rewrite</span> &lt;- IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t0) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt term G g)
  (pure tm_abs &lt;‚ãÜ&gt; mbinddt typ F f t &lt;‚ãÜ&gt;
   mbinddt term F (f ‚óª allK (incr [ktrm])) t0) =
pure tm_abs &lt;‚ãÜ&gt; mbinddt typ (F ‚àò G) (g ‚ãÜdtm f) t &lt;‚ãÜ&gt;
map (mbinddt term G (g ‚óª allK (incr [ktrm])))
  (mbinddt term F (f ‚óª allK (incr [ktrm])) t0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb4"><span class="nb">rewrite</span> &lt;- (mbinddt_mbinddt_typ F G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t0) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt term G g)
  (pure tm_abs &lt;‚ãÜ&gt; mbinddt typ F f t &lt;‚ãÜ&gt;
   mbinddt term F (f ‚óª allK (incr [ktrm])) t0) =
pure tm_abs &lt;‚ãÜ&gt;
(map (mbinddt typ G g) ‚àò mbinddt typ F f) t &lt;‚ãÜ&gt;
map (mbinddt term G (g ‚óª allK (incr [ktrm])))
  (mbinddt term F (f ‚óª allK (incr [ktrm])) t0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb5"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t0) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt term G g)
  (pure tm_abs &lt;‚ãÜ&gt; mbinddt typ F f t &lt;‚ãÜ&gt;
   mbinddt term F (f ‚óª allK (incr [ktrm])) t0) =
pure tm_abs &lt;‚ãÜ&gt;
(map (mbinddt typ G g) ‚àò mbinddt typ F f) t &lt;‚ãÜ&gt;
map (mbinddt term G (g ‚óª allK (incr [ktrm])))
  (mbinddt term F (f ‚óª allK (incr [ktrm])) t0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb6"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> (ap_compose2 G F).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t0) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt term G g)
  (pure tm_abs &lt;‚ãÜ&gt; mbinddt typ F f t &lt;‚ãÜ&gt;
   mbinddt term F (f ‚óª allK (incr [ktrm])) t0) =
map (ap G)
  (map (ap G) (pure tm_abs) &lt;‚ãÜ&gt;
   (map (mbinddt typ G g) ‚àò mbinddt typ F f) t) &lt;‚ãÜ&gt;
map (mbinddt term G (g ‚óª allK (incr [ktrm])))
  (mbinddt term F (f ‚óª allK (incr [ktrm])) t0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb7"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t0) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt term G g)
  (pure tm_abs &lt;‚ãÜ&gt; mbinddt typ F f t &lt;‚ãÜ&gt;
   mbinddt term F (f ‚óª allK (incr [ktrm])) t0) =
map (ap G)
  (map (ap G) (pure tm_abs) &lt;‚ãÜ&gt;
   map (mbinddt typ G g) (mbinddt typ F f t)) &lt;‚ãÜ&gt;
map (mbinddt term G (g ‚óª allK (incr [ktrm])))
  (mbinddt term F (f ‚óª allK (incr [ktrm])) t0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb8"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> &lt;- (ap_map (G := F)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t0) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt term G g)
  (pure tm_abs &lt;‚ãÜ&gt; mbinddt typ F f t &lt;‚ãÜ&gt;
   mbinddt term F (f ‚óª allK (incr [ktrm])) t0) =
map
  (precompose
     (mbinddt term G (g ‚óª allK (incr [ktrm]))))
  (map (ap G)
     (map (precompose (mbinddt typ G g))
        (map (ap G) (pure tm_abs)) &lt;‚ãÜ&gt;
      mbinddt typ F f t)) &lt;‚ãÜ&gt;
mbinddt term F (f ‚óª allK (incr [ktrm])) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb9">unfold_ops @Pure_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t0) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt term G g)
  (pure tm_abs &lt;‚ãÜ&gt; mbinddt typ F f t &lt;‚ãÜ&gt;
   mbinddt term F (f ‚óª allK (incr [ktrm])) t0) =
map
  (precompose
     (mbinddt term G (g ‚óª allK (incr [ktrm]))))
  (map (ap G)
     (map (precompose (mbinddt typ G g))
        (map (ap G) (pure (pure tm_abs))) &lt;‚ãÜ&gt;
      mbinddt typ F f t)) &lt;‚ãÜ&gt;
mbinddt term F (f ‚óª allK (incr [ktrm])) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkba"><span class="nb">rewrite</span> (app_pure_natural).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t0) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt term G g)
  (pure tm_abs &lt;‚ãÜ&gt; mbinddt typ F f t &lt;‚ãÜ&gt;
   mbinddt term F (f ‚óª allK (incr [ktrm])) t0) =
map
  (precompose
     (mbinddt term G (g ‚óª allK (incr [ktrm]))))
  (map (ap G)
     (map (precompose (mbinddt typ G g))
        (pure (ap G (pure tm_abs))) &lt;‚ãÜ&gt;
      mbinddt typ F f t)) &lt;‚ãÜ&gt;
mbinddt term F (f ‚óª allK (incr [ktrm])) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkbb"><span class="kp">do</span> <span class="mi">4</span> <span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t0) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (compose (mbinddt term G g)))
  (pure tm_abs) &lt;‚ãÜ&gt; mbinddt typ F f t &lt;‚ãÜ&gt;
mbinddt term F (f ‚óª allK (incr [ktrm])) t0 =
map
  (compose
     (precompose
        (mbinddt term G (g ‚óª allK (incr [ktrm])))))
  (map (compose (ap G))
     (map (precompose (mbinddt typ G g))
        (pure (ap G (pure tm_abs))))) &lt;‚ãÜ&gt;
mbinddt typ F f t &lt;‚ãÜ&gt;
mbinddt term F (f ‚óª allK (incr [ktrm])) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkbc">compose near ((pure (F := F) (ap G (pure (F := G) (@tm_abs C))))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t0) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (compose (mbinddt term G g)))
  (pure tm_abs) &lt;‚ãÜ&gt; mbinddt typ F f t &lt;‚ãÜ&gt;
mbinddt term F (f ‚óª allK (incr [ktrm])) t0 =
map
  (compose
     (precompose
        (mbinddt term G (g ‚óª allK (incr [ktrm])))))
  ((map (compose (ap G))
    ‚àò map (precompose (mbinddt typ G g)))
     (pure (ap G (pure tm_abs)))) &lt;‚ãÜ&gt;
mbinddt typ F f t &lt;‚ãÜ&gt;
mbinddt term F (f ‚óª allK (incr [ktrm])) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkbd"><span class="nb">rewrite</span> (fun_map_map (F := F)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t0) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (compose (mbinddt term G g)))
  (pure tm_abs) &lt;‚ãÜ&gt; mbinddt typ F f t &lt;‚ãÜ&gt;
mbinddt term F (f ‚óª allK (incr [ktrm])) t0 =
map
  (compose
     (precompose
        (mbinddt term G (g ‚óª allK (incr [ktrm])))))
  (map (compose (ap G) ‚àò precompose (mbinddt typ G g))
     (pure (ap G (pure tm_abs)))) &lt;‚ãÜ&gt;
mbinddt typ F f t &lt;‚ãÜ&gt;
mbinddt term F (f ‚óª allK (incr [ktrm])) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkbe"><span class="kp">do</span> <span class="mi">3</span> <span class="nb">rewrite</span> (app_pure_natural).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t0) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mbinddt term G g) ‚àò tm_abs) &lt;‚ãÜ&gt;
mbinddt typ F f t &lt;‚ãÜ&gt;
mbinddt term F (f ‚óª allK (incr [ktrm])) t0 =
pure
  (precompose
     (mbinddt term G (g ‚óª allK (incr [ktrm])))
   ‚àò (compose (ap G) ‚àò precompose (mbinddt typ G g))
       (ap G (pure tm_abs))) &lt;‚ãÜ&gt; mbinddt typ F f t &lt;‚ãÜ&gt;
mbinddt term F (f ‚óª allK (incr [ktrm])) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkbf">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t1) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t2) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt term G g) (mbinddt term F f (t1 @ t2)) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) (t1 @ t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc0"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t1) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t2) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt term G g)
  (pure tm_app &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
   mbinddt term F f t2) =
pure tm_app &lt;‚ãÜ&gt; mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t1 &lt;‚ãÜ&gt;
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc1"><span class="nb">rewrite</span> &lt;- IHt1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t1) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t2) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt term G g)
  (pure tm_app &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
   mbinddt term F f t2) =
pure tm_app &lt;‚ãÜ&gt;
map (mbinddt term G g) (mbinddt term F f t1) &lt;‚ãÜ&gt;
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc2"><span class="nb">rewrite</span> &lt;- IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t1) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t2) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt term G g)
  (pure tm_app &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
   mbinddt term F f t2) =
pure tm_app &lt;‚ãÜ&gt;
map (mbinddt term G g) (mbinddt term F f t1) &lt;‚ãÜ&gt;
map (mbinddt term G g) (mbinddt term F f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc3"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> (ap_compose2 G F).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t1) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t2) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt term G g)
  (pure tm_app &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
   mbinddt term F f t2) =
map (ap G)
  (map (ap G) (pure tm_app) &lt;‚ãÜ&gt;
   map (mbinddt term G g) (mbinddt term F f t1)) &lt;‚ãÜ&gt;
map (mbinddt term G g) (mbinddt term F f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc4"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> &lt;- (ap_map (G := F)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t1) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t2) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt term G g)
  (pure tm_app &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
   mbinddt term F f t2) =
map (precompose (mbinddt term G g))
  (map (ap G)
     (map (precompose (mbinddt term G g))
        (map (ap G) (pure tm_app)) &lt;‚ãÜ&gt;
      mbinddt term F f t1)) &lt;‚ãÜ&gt; mbinddt term F f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc5"><span class="kp">do</span> <span class="mi">4</span> <span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t1) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t2) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (compose (mbinddt term G g)))
  (pure tm_app) &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
mbinddt term F f t2 =
map (compose (precompose (mbinddt term G g)))
  (map (compose (ap G))
     (map (precompose (mbinddt term G g))
        (map (ap G) (pure tm_app)))) &lt;‚ãÜ&gt;
mbinddt term F f t1 &lt;‚ãÜ&gt; mbinddt term F f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc6">compose near (pure (F := F ‚àò G) (@tm_app C)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t1) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t2) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (compose (mbinddt term G g)))
  (pure tm_app) &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
mbinddt term F f t2 =
map (compose (precompose (mbinddt term G g)))
  (map (compose (ap G))
     ((map (precompose (mbinddt term G g))
       ‚àò map (ap G)) (pure tm_app))) &lt;‚ãÜ&gt;
mbinddt term F f t1 &lt;‚ãÜ&gt; mbinddt term F f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc7"><span class="nb">rewrite</span> (fun_map_map (F := F)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t1) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t2) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (compose (mbinddt term G g)))
  (pure tm_app) &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
mbinddt term F f t2 =
map (compose (precompose (mbinddt term G g)))
  (map (compose (ap G))
     (map (precompose (mbinddt term G g) ‚àò ap G)
        (pure tm_app))) &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
mbinddt term F f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc8">compose near (pure (F := F ‚àò G) (@tm_app C)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t1) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t2) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (compose (mbinddt term G g)))
  (pure tm_app) &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
mbinddt term F f t2 =
map (compose (precompose (mbinddt term G g)))
  ((map (compose (ap G))
    ‚àò map (precompose (mbinddt term G g) ‚àò ap G))
     (pure tm_app)) &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
mbinddt term F f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc9"><span class="nb">rewrite</span> (fun_map_map (F := F)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t1) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t2) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (compose (mbinddt term G g)))
  (pure tm_app) &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
mbinddt term F f t2 =
map (compose (precompose (mbinddt term G g)))
  (map
     (compose (ap G)
      ‚àò (precompose (mbinddt term G g) ‚àò ap G))
     (pure tm_app)) &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
mbinddt term F f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkca">compose near (pure (F := F ‚àò G) (@tm_app C)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t1) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t2) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (compose (mbinddt term G g)))
  (pure tm_app) &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
mbinddt term F f t2 =
(map (compose (precompose (mbinddt term G g)))
 ‚àò map
     (compose (ap G)
      ‚àò (precompose (mbinddt term G g) ‚àò ap G)))
  (pure tm_app) &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
mbinddt term F f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkcb"><span class="nb">rewrite</span> (fun_map_map (F := F)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t1) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t2) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (compose (mbinddt term G g)))
  (pure tm_app) &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
mbinddt term F f t2 =
map
  (compose (precompose (mbinddt term G g))
   ‚àò (compose (ap G)
      ‚àò (precompose (mbinddt term G g) ‚àò ap G)))
  (pure tm_app) &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
mbinddt term F f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkcc">unfold_ops @Pure_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t1) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t2) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (compose (mbinddt term G g)))
  (pure tm_app) &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
mbinddt term F f t2 =
map
  (compose (precompose (mbinddt term G g))
   ‚àò (compose (ap G)
      ‚àò (precompose (mbinddt term G g) ‚àò ap G)))
  (pure (pure tm_app)) &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
mbinddt term F f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkcd"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> (app_pure_natural).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t1) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * B -&gt; G (SystemF k C))
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
       list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t2) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mbinddt term G g) ‚àò tm_app) &lt;‚ãÜ&gt;
mbinddt term F f t1 &lt;‚ãÜ&gt; mbinddt term F f t2 =
pure
  ((compose (precompose (mbinddt term G g))
    ‚àò (compose (ap G)
       ‚àò (precompose (mbinddt term G g) ‚àò ap G)))
     (pure tm_app)) &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
mbinddt term F f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkce">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt term G g) (mbinddt term F f (Œõ t)) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) (Œõ t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkcf"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt term G g)
  (pure tm_tab &lt;‚ãÜ&gt;
   mbinddt term F (f ‚óª allK (incr [ktyp])) t) =
pure tm_tab &lt;‚ãÜ&gt;
mbinddt term (F ‚àò G) (g ‚ãÜdtm f ‚óª allK (incr [ktyp])) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd0"><span class="nb">setoid_rewrite</span> compose_dtm_incr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt term G g)
  (pure tm_tab &lt;‚ãÜ&gt;
   mbinddt term F (f ‚óª allK (incr [ktyp])) t) =
pure tm_tab &lt;‚ãÜ&gt;
mbinddt term (F ‚àò G)
  ((g ‚óª allK (incr [ktyp]))
   ‚ãÜdtm (f ‚óª allK (incr [ktyp]))) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd1"><span class="nb">rewrite</span> &lt;- IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt term G g)
  (pure tm_tab &lt;‚ãÜ&gt;
   mbinddt term F (f ‚óª allK (incr [ktyp])) t) =
pure tm_tab &lt;‚ãÜ&gt;
map (mbinddt term G (g ‚óª allK (incr [ktyp])))
  (mbinddt term F (f ‚óª allK (incr [ktyp])) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd2"><span class="nb">rewrite</span> (ap_compose2 G F).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt term G g)
  (pure tm_tab &lt;‚ãÜ&gt;
   mbinddt term F (f ‚óª allK (incr [ktyp])) t) =
map (ap G) (pure tm_tab) &lt;‚ãÜ&gt;
map (mbinddt term G (g ‚óª allK (incr [ktyp])))
  (mbinddt term F (f ‚óª allK (incr [ktyp])) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd3"><span class="nb">rewrite</span> &lt;- (ap_map (G := F)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt term G g)
  (pure tm_tab &lt;‚ãÜ&gt;
   mbinddt term F (f ‚óª allK (incr [ktyp])) t) =
map
  (precompose
     (mbinddt term G (g ‚óª allK (incr [ktyp]))))
  (map (ap G) (pure tm_tab)) &lt;‚ãÜ&gt;
mbinddt term F (f ‚óª allK (incr [ktyp])) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd4"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (mbinddt term G g)) (pure tm_tab) &lt;‚ãÜ&gt;
mbinddt term F (f ‚óª allK (incr [ktyp])) t =
map
  (precompose
     (mbinddt term G (g ‚óª allK (incr [ktyp]))))
  (map (ap G) (pure tm_tab)) &lt;‚ãÜ&gt;
mbinddt term F (f ‚óª allK (incr [ktyp])) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd5">unfold_ops @Pure_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (mbinddt term G g)) (pure tm_tab) &lt;‚ãÜ&gt;
mbinddt term F (f ‚óª allK (incr [ktyp])) t =
map
  (precompose
     (mbinddt term G (g ‚óª allK (incr [ktyp]))))
  (map (ap G) (pure (pure tm_tab))) &lt;‚ãÜ&gt;
mbinddt term F (f ‚óª allK (incr [ktyp])) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd6"><span class="kp">do</span> <span class="mi">3</span> <span class="nb">rewrite</span> (app_pure_natural).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (mbinddt term G g ‚àò tm_tab) &lt;‚ãÜ&gt;
mbinddt term F (f ‚óª allK (incr [ktyp])) t =
pure
  (precompose
     (mbinddt term G (g ‚óª allK (incr [ktyp])))
     (ap G (pure tm_tab))) &lt;‚ãÜ&gt;
mbinddt term F (f ‚óª allK (incr [ktyp])) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt term G g) (mbinddt term F f (t @@ t0)) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) (t @@ t0)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd8"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt term G g)
  (pure tm_tap &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
   bind_type F f t0) =
pure tm_tap &lt;‚ãÜ&gt; mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t &lt;‚ãÜ&gt;
bind_type (F ‚àò G) (g ‚ãÜdtm f) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd9"><span class="nb">rewrite</span> &lt;- IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt term G g)
  (pure tm_tap &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
   bind_type F f t0) =
pure tm_tap &lt;‚ãÜ&gt;
map (mbinddt term G g) (mbinddt term F f t) &lt;‚ãÜ&gt;
bind_type (F ‚àò G) (g ‚ãÜdtm f) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkda"><span class="nb">rewrite</span> &lt;- (mbinddt_mbinddt_typ F G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt term G g)
  (pure tm_tap &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
   bind_type F f t0) =
pure tm_tap &lt;‚ãÜ&gt;
map (mbinddt term G g) (mbinddt term F f t) &lt;‚ãÜ&gt;
(map (mbinddt typ G g) ‚àò mbinddt typ F f) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkdb"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">4</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt term G g)
  (pure tm_tap &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
   bind_type F f t0) =
pure tm_tap &lt;‚ãÜ&gt;
map (mbinddt term G g) (mbinddt term F f t) &lt;‚ãÜ&gt;
map (mbinddt typ G g) (mbinddt typ F f t0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkdc"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> (ap_compose2 G F).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt term G g)
  (pure tm_tap &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
   bind_type F f t0) =
map (ap G)
  (map (ap G) (pure tm_tap) &lt;‚ãÜ&gt;
   map (mbinddt term G g) (mbinddt term F f t)) &lt;‚ãÜ&gt;
map (mbinddt typ G g) (mbinddt typ F f t0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkdd"><span class="kp">repeat</span> <span class="nb">rewrite</span> &lt;- (ap_map (G := F)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt term G g)
  (pure tm_tap &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
   bind_type F f t0) =
map (precompose (mbinddt typ G g))
  (map (ap G)
     (map (precompose (mbinddt term G g))
        (map (ap G) (pure tm_tap)) &lt;‚ãÜ&gt;
      mbinddt term F f t)) &lt;‚ãÜ&gt; mbinddt typ F f t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkde"><span class="nb">change</span> (bind_type <span class="nl">?F</span> <span class="nl">?f</span>) <span class="kr">with</span> (mbinddt typ F f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mbinddt term G g)
  (pure tm_tap &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
   mbinddt typ F f t0) =
map (precompose (mbinddt typ G g))
  (map (ap G)
     (map (precompose (mbinddt term G g))
        (map (ap G) (pure tm_tap)) &lt;‚ãÜ&gt;
      mbinddt term F f t)) &lt;‚ãÜ&gt; mbinddt typ F f t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkdf"><span class="kp">do</span> <span class="mi">4</span> <span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (compose (mbinddt term G g)))
  (pure tm_tap) &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
mbinddt typ F f t0 =
map (compose (precompose (mbinddt typ G g)))
  (map (compose (ap G))
     (map (precompose (mbinddt term G g))
        (map (ap G) (pure tm_tap)))) &lt;‚ãÜ&gt;
mbinddt term F f t &lt;‚ãÜ&gt; mbinddt typ F f t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke0">compose near (pure (F := F ‚àò G) (@tm_tap C)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (compose (mbinddt term G g)))
  (pure tm_tap) &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
mbinddt typ F f t0 =
map (compose (precompose (mbinddt typ G g)))
  (map (compose (ap G))
     ((map (precompose (mbinddt term G g))
       ‚àò map (ap G)) (pure tm_tap))) &lt;‚ãÜ&gt;
mbinddt term F f t &lt;‚ãÜ&gt; mbinddt typ F f t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke1"><span class="nb">rewrite</span> (fun_map_map (F := F)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (compose (mbinddt term G g)))
  (pure tm_tap) &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
mbinddt typ F f t0 =
map (compose (precompose (mbinddt typ G g)))
  (map (compose (ap G))
     (map (precompose (mbinddt term G g) ‚àò ap G)
        (pure tm_tap))) &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
mbinddt typ F f t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke2">compose near (pure (F := F ‚àò G) (@tm_tap C)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (compose (mbinddt term G g)))
  (pure tm_tap) &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
mbinddt typ F f t0 =
map (compose (precompose (mbinddt typ G g)))
  ((map (compose (ap G))
    ‚àò map (precompose (mbinddt term G g) ‚àò ap G))
     (pure tm_tap)) &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
mbinddt typ F f t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke3"><span class="nb">rewrite</span> (fun_map_map (F := F)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (compose (mbinddt term G g)))
  (pure tm_tap) &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
mbinddt typ F f t0 =
map (compose (precompose (mbinddt typ G g)))
  (map
     (compose (ap G)
      ‚àò (precompose (mbinddt term G g) ‚àò ap G))
     (pure tm_tap)) &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
mbinddt typ F f t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke4">compose near (pure (F := F ‚àò G) (@tm_tap C)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (compose (mbinddt term G g)))
  (pure tm_tap) &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
mbinddt typ F f t0 =
(map (compose (precompose (mbinddt typ G g)))
 ‚àò map
     (compose (ap G)
      ‚àò (precompose (mbinddt term G g) ‚àò ap G)))
  (pure tm_tap) &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
mbinddt typ F f t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke5"><span class="nb">rewrite</span> (fun_map_map (F := F)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (compose (mbinddt term G g)))
  (pure tm_tap) &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
mbinddt typ F f t0 =
map
  (compose (precompose (mbinddt typ G g))
   ‚àò (compose (ap G)
      ‚àò (precompose (mbinddt term G g) ‚àò ap G)))
  (pure tm_tap) &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
mbinddt typ F f t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke6">unfold_ops @Pure_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (compose (mbinddt term G g)))
  (pure tm_tap) &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
mbinddt typ F f t0 =
map
  (compose (precompose (mbinddt typ G g))
   ‚àò (compose (ap G)
      ‚àò (precompose (mbinddt term G g) ‚àò ap G)))
  (pure (pure tm_tap)) &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
mbinddt typ F f t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke7"><span class="nb">rewrite</span> (app_pure_natural).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mbinddt term G g) ‚àò tm_tap) &lt;‚ãÜ&gt;
mbinddt term F f t &lt;‚ãÜ&gt; mbinddt typ F f t0 =
map
  (compose (precompose (mbinddt typ G g))
   ‚àò (compose (ap G)
      ‚àò (precompose (mbinddt term G g) ‚àò ap G)))
  (pure (pure tm_tap)) &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
mbinddt typ F f t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke8"><span class="nb">rewrite</span> (app_pure_natural).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B, C, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
map (mbinddt term G g) (mbinddt term F f t) =
mbinddt term (F ‚àò G) (g ‚ãÜdtm f) t</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * B -&gt; G (SystemF k C)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mbinddt term G g) ‚àò tm_tap) &lt;‚ãÜ&gt;
mbinddt term F f t &lt;‚ãÜ&gt; mbinddt typ F f t0 =
pure
  ((compose (precompose (mbinddt typ G g))
    ‚àò (compose (ap G)
       ‚àò (precompose (mbinddt term G g) ‚àò ap G)))
     (pure tm_tap)) &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
mbinddt typ F f t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** &lt;&lt;mbinddt_morphism&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Set Keyed Unification</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke9"><span class="kn">Lemma</span> <span class="nf">mbinddt_morphism_typ</span> :
  <span class="kr">forall</span> (<span class="nv">F</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    `{ApplicativeMorphism F G œï}
    `(f : <span class="kr">forall</span> <span class="nv">k</span>, list K2 * A -&gt; F (SystemF k B)),
    œï (typ B) ‚àò mbinddt typ F f =
    mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> =&gt; œï (SystemF k B) ‚àò f k).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">F</span> <span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Map F) (<span class="nv">H0</span> : Mult F)
  (<span class="nv">H1</span> : Pure F) (<span class="nv">H2</span> : Map G) (<span class="nv">H3</span> : Mult G)
  (<span class="nv">H4</span> : Pure G) (<span class="nv">œï</span> : F ‚áí G),
ApplicativeMorphism F G œï -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
œï (typ B) ‚àò mbinddt typ F f =
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚àò f k)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkea"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">F</span> <span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Map F) (<span class="nv">H0</span> : Mult F)
  (<span class="nv">H1</span> : Pure F) (<span class="nv">H2</span> : Map G) (<span class="nv">H3</span> : Mult G)
  (<span class="nv">H4</span> : Pure G) (<span class="nv">œï</span> : F ‚áí G),
ApplicativeMorphism F G œï -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
œï (typ B) ‚àò mbinddt typ F f =
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚àò f k)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkeb"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (typ B) ‚àò mbinddt typ F f =
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚àò f k)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkec">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(œï (typ B) ‚àò mbinddt typ F f) t =
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚àò f k) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chked"><span class="nb">generalize dependent</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B),
(œï (typ B) ‚àò mbinddt typ F f) t =
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚àò f k) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkee" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkee"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B),
œï (typ B) (mbinddt typ F f t) =
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkef"><span class="nb">induction</span> t; <span class="nb">intro</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (typ B) (mbinddt typ F f (ty_c b)) =
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k)
  (ty_c b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntax-v-chkf0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><label class="goal-separator" for="syntax-v-chkf0"><hr></label><div class="goal-conclusion">œï (typ B) (mbinddt typ F f (ty_v v)) =
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k)
  (ty_v v)</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntax-v-chkf1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (typ B) (mbinddt typ F f t1) =
mbinddt typ G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (typ B) (mbinddt typ F f t2) =
mbinddt typ G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><label class="goal-separator" for="syntax-v-chkf1"><hr></label><div class="goal-conclusion">œï (typ B) (mbinddt typ F f (t1 ‚üπ t2)) =
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k)
  (t1 ‚üπ t2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntax-v-chkf2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (typ B) (mbinddt typ F f t) =
mbinddt typ G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><label class="goal-separator" for="syntax-v-chkf2"><hr></label><div class="goal-conclusion">œï (typ B) (mbinddt typ F f (<span class="kr">‚àÄ</span> <span class="nv">t</span>)) =
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k)
  (<span class="kr">‚àÄ</span> <span class="nv">t</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkf3" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkf3">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (typ B) (mbinddt typ F f (ty_c b)) =
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k)
  (ty_c b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkf4"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (typ B) (pure (ty_c b)) = pure (ty_c b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkf5" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkf5"><span class="nb">rewrite</span> (appmor_pure).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>base_typ</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (ty_c b) = pure (ty_c b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkf6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (typ B) (mbinddt typ F f (ty_v v)) =
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k)
  (ty_v v)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkf7" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkf7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (typ B) (mbinddt typ F f t1) =
mbinddt typ G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (typ B) (mbinddt typ F f t2) =
mbinddt typ G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (typ B) (mbinddt typ F f (t1 ‚üπ t2)) =
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k)
  (t1 ‚üπ t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkf8"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (typ B) (mbinddt typ F f t1) =
mbinddt typ G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (typ B) (mbinddt typ F f t2) =
mbinddt typ G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (typ B)
  (pure ty_ar &lt;‚ãÜ&gt; mbinddt typ F f t1 &lt;‚ãÜ&gt;
   mbinddt typ F f t2) =
pure ty_ar &lt;‚ãÜ&gt;
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k) t1 &lt;‚ãÜ&gt;
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k) t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkf9"><span class="nb">rewrite</span> &lt;- IHt1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (typ B) (mbinddt typ F f t1) =
mbinddt typ G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (typ B) (mbinddt typ F f t2) =
mbinddt typ G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (typ B)
  (pure ty_ar &lt;‚ãÜ&gt; mbinddt typ F f t1 &lt;‚ãÜ&gt;
   mbinddt typ F f t2) =
pure ty_ar &lt;‚ãÜ&gt; œï (typ B) (mbinddt typ F f t1) &lt;‚ãÜ&gt;
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k) t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkfa" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkfa"><span class="nb">clear</span> IHt1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (typ B) (mbinddt typ F f t2) =
mbinddt typ G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (typ B)
  (pure ty_ar &lt;‚ãÜ&gt; mbinddt typ F f t1 &lt;‚ãÜ&gt;
   mbinddt typ F f t2) =
pure ty_ar &lt;‚ãÜ&gt; œï (typ B) (mbinddt typ F f t1) &lt;‚ãÜ&gt;
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k) t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkfb"><span class="nb">rewrite</span> &lt;- IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (typ B) (mbinddt typ F f t2) =
mbinddt typ G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (typ B)
  (pure ty_ar &lt;‚ãÜ&gt; mbinddt typ F f t1 &lt;‚ãÜ&gt;
   mbinddt typ F f t2) =
pure ty_ar &lt;‚ãÜ&gt; œï (typ B) (mbinddt typ F f t1) &lt;‚ãÜ&gt;
œï (typ B) (mbinddt typ F f t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkfc"><span class="nb">clear</span> IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (typ B)
  (pure ty_ar &lt;‚ãÜ&gt; mbinddt typ F f t1 &lt;‚ãÜ&gt;
   mbinddt typ F f t2) =
pure ty_ar &lt;‚ãÜ&gt; œï (typ B) (mbinddt typ F f t1) &lt;‚ãÜ&gt;
œï (typ B) (mbinddt typ F f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkfd"><span class="nb">rewrite</span> ap_morphism_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (typ B -&gt; typ B) (pure ty_ar &lt;‚ãÜ&gt; mbinddt typ F f t1) &lt;‚ãÜ&gt;
œï (typ B) (mbinddt typ F f t2) =
pure ty_ar &lt;‚ãÜ&gt; œï (typ B) (mbinddt typ F f t1) &lt;‚ãÜ&gt;
œï (typ B) (mbinddt typ F f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkfe"><span class="nb">rewrite</span> ap_morphism_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (typ B -&gt; typ B -&gt; typ B) (pure ty_ar) &lt;‚ãÜ&gt;
œï (typ B) (mbinddt typ F f t1) &lt;‚ãÜ&gt;
œï (typ B) (mbinddt typ F f t2) =
pure ty_ar &lt;‚ãÜ&gt; œï (typ B) (mbinddt typ F f t1) &lt;‚ãÜ&gt;
œï (typ B) (mbinddt typ F f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkff" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkff"><span class="nb">rewrite</span> (appmor_pure).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ty_ar &lt;‚ãÜ&gt; œï (typ B) (mbinddt typ F f t1) &lt;‚ãÜ&gt;
œï (typ B) (mbinddt typ F f t2) =
pure ty_ar &lt;‚ãÜ&gt; œï (typ B) (mbinddt typ F f t1) &lt;‚ãÜ&gt;
œï (typ B) (mbinddt typ F f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk100">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B),
œï (typ B) (mbinddt typ F f t) =
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (typ B) (mbinddt typ F f (<span class="kr">‚àÄ</span> <span class="nv">t</span>)) =
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k)
  (<span class="kr">‚àÄ</span> <span class="nv">t</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk101" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk101"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B),
œï (typ B) (mbinddt typ F f t) =
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (typ B)
  (pure ty_univ &lt;‚ãÜ&gt;
   mbinddt typ F (f ‚óª allK (incr [ktyp])) t) =
pure ty_univ &lt;‚ãÜ&gt;
mbinddt typ G
  ((<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k)
   ‚óª allK (incr [ktyp])) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk102"><span class="nb">rewrite</span> &lt;- IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B),
œï (typ B) (mbinddt typ F f t) =
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (typ B)
  (pure ty_univ &lt;‚ãÜ&gt;
   mbinddt typ F (f ‚óª allK (incr [ktyp])) t) =
pure ty_univ &lt;‚ãÜ&gt;
œï (typ B)
  (mbinddt typ F
     (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚óã allK (incr [ktyp]) k) t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk103" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk103"><span class="nb">clear</span> IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (typ B)
  (pure ty_univ &lt;‚ãÜ&gt;
   mbinddt typ F (f ‚óª allK (incr [ktyp])) t) =
pure ty_univ &lt;‚ãÜ&gt;
œï (typ B)
  (mbinddt typ F
     (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚óã allK (incr [ktyp]) k) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk104"><span class="nb">rewrite</span> ap_morphism_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (typ B -&gt; typ B) (pure ty_univ) &lt;‚ãÜ&gt;
œï (typ B) (mbinddt typ F (f ‚óª allK (incr [ktyp])) t) =
pure ty_univ &lt;‚ãÜ&gt;
œï (typ B)
  (mbinddt typ F
     (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚óã allK (incr [ktyp]) k) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk105" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk105"><span class="nb">rewrite</span> (appmor_pure).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ty_univ &lt;‚ãÜ&gt;
œï (typ B) (mbinddt typ F (f ‚óª allK (incr [ktyp])) t) =
pure ty_univ &lt;‚ãÜ&gt;
œï (typ B)
  (mbinddt typ F
     (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚óã allK (incr [ktyp]) k) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk106" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk106"><span class="kn">Lemma</span> <span class="nf">mbinddt_morphism_term</span> :
  <span class="kr">forall</span> (<span class="nv">F</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    `{ApplicativeMorphism F G œï}
    `(f : <span class="kr">forall</span> <span class="nv">k</span>, list K2 * A -&gt; F (SystemF k B)),
    œï (term B) ‚àò mbinddt term F f =
    mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> =&gt; œï (SystemF k B) ‚àò f k).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">F</span> <span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Map F) (<span class="nv">H0</span> : Mult F)
  (<span class="nv">H1</span> : Pure F) (<span class="nv">H2</span> : Map G) (<span class="nv">H3</span> : Mult G)
  (<span class="nv">H4</span> : Pure G) (<span class="nv">œï</span> : F ‚áí G),
ApplicativeMorphism F G œï -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
œï (term B) ‚àò mbinddt term F f =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚àò f k)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk107" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk107"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">F</span> <span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Map F) (<span class="nv">H0</span> : Mult F)
  (<span class="nv">H1</span> : Pure F) (<span class="nv">H2</span> : Map G) (<span class="nv">H3</span> : Mult G)
  (<span class="nv">H4</span> : Pure G) (<span class="nv">œï</span> : F ‚áí G),
ApplicativeMorphism F G œï -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
œï (term B) ‚àò mbinddt term F f =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚àò f k)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk108" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk108"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B) ‚àò mbinddt term F f =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚àò f k)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk109" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk109">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(œï (term B) ‚àò mbinddt term F f) t =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚àò f k) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk10a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk10a"><span class="nb">generalize dependent</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B),
(œï (term B) ‚àò mbinddt term F f) t =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚àò f k) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk10b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk10b"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t) =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk10c"><span class="nb">induction</span> t; <span class="nb">intro</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B) (mbinddt term F f (tm_var v)) =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k)
  (tm_var v)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntax-v-chk10d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t0) =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk10d"><hr></label><div class="goal-conclusion">œï (term B) (mbinddt term F f (<span class="kr">Œª</span> <span class="nv">t</span> ‚ãÖ t0)) =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k)
  (<span class="kr">Œª</span> <span class="nv">t</span> ‚ãÖ t0)</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntax-v-chk10e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t1) =
mbinddt term G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t2) =
mbinddt term G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk10e"><hr></label><div class="goal-conclusion">œï (term B) (mbinddt term F f (t1 @ t2)) =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k)
  (t1 @ t2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntax-v-chk10f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t) =
mbinddt term G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk10f"><hr></label><div class="goal-conclusion">œï (term B) (mbinddt term F f (Œõ t)) =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k)
  (Œõ t)</div></blockquote><input class="alectryon-extra-goal-toggle" id="syntax-v-chk110" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t) =
mbinddt term G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk110"><hr></label><div class="goal-conclusion">œï (term B) (mbinddt term F f (t @@ t0)) =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k)
  (t @@ t0)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk111">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B) (mbinddt term F f (tm_var v)) =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k)
  (tm_var v)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk112" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk112">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t0) =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B) (mbinddt term F f (<span class="kr">Œª</span> <span class="nv">t</span> ‚ãÖ t0)) =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k)
  (<span class="kr">Œª</span> <span class="nv">t</span> ‚ãÖ t0)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk113" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk113"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t0) =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B)
  (pure tm_abs &lt;‚ãÜ&gt; bind_type F f t &lt;‚ãÜ&gt;
   mbinddt term F (f ‚óª allK (incr [ktrm])) t0) =
pure tm_abs &lt;‚ãÜ&gt;
bind_type G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k) t &lt;‚ãÜ&gt;
mbinddt term G
  ((<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k)
   ‚óª allK (incr [ktrm])) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk114" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk114"><span class="nb">rewrite</span> &lt;- IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t0) =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B)
  (pure tm_abs &lt;‚ãÜ&gt; bind_type F f t &lt;‚ãÜ&gt;
   mbinddt term F (f ‚óª allK (incr [ktrm])) t0) =
pure tm_abs &lt;‚ãÜ&gt;
bind_type G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k) t &lt;‚ãÜ&gt;
œï (term B)
  (mbinddt term F
     (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚óã allK (incr [ktrm]) k) t0)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk115" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk115"><span class="nb">clear</span> IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B)
  (pure tm_abs &lt;‚ãÜ&gt; bind_type F f t &lt;‚ãÜ&gt;
   mbinddt term F (f ‚óª allK (incr [ktrm])) t0) =
pure tm_abs &lt;‚ãÜ&gt;
bind_type G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k) t &lt;‚ãÜ&gt;
œï (term B)
  (mbinddt term F
     (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚óã allK (incr [ktrm]) k) t0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk116" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk116"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> ap_morphism_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (typ B -&gt; term B -&gt; term B) (pure tm_abs) &lt;‚ãÜ&gt;
œï (typ B) (bind_type F f t) &lt;‚ãÜ&gt;
œï (term B)
  (mbinddt term F (f ‚óª allK (incr [ktrm])) t0) =
pure tm_abs &lt;‚ãÜ&gt;
bind_type G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k) t &lt;‚ãÜ&gt;
œï (term B)
  (mbinddt term F
     (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚óã allK (incr [ktrm]) k) t0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk117" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk117"><span class="nb">rewrite</span> (appmor_pure).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure tm_abs &lt;‚ãÜ&gt; œï (typ B) (bind_type F f t) &lt;‚ãÜ&gt;
œï (term B)
  (mbinddt term F (f ‚óª allK (incr [ktrm])) t0) =
pure tm_abs &lt;‚ãÜ&gt;
bind_type G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k) t &lt;‚ãÜ&gt;
œï (term B)
  (mbinddt term F
     (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚óã allK (incr [ktrm]) k) t0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk118" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk118"><span class="nb">change</span> (bind_type <span class="nl">?F</span> <span class="nl">?f</span>) <span class="kr">with</span> (mbinddt typ F f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure tm_abs &lt;‚ãÜ&gt; œï (typ B) (mbinddt typ F f t) &lt;‚ãÜ&gt;
œï (term B)
  (mbinddt term F (f ‚óª allK (incr [ktrm])) t0) =
pure tm_abs &lt;‚ãÜ&gt;
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k) t &lt;‚ãÜ&gt;
œï (term B)
  (mbinddt term F
     (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚óã allK (incr [ktrm]) k) t0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk119" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk119">compose near t on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure tm_abs &lt;‚ãÜ&gt; (œï (typ B) ‚àò mbinddt typ F f) t &lt;‚ãÜ&gt;
œï (term B)
  (mbinddt term F (f ‚óª allK (incr [ktrm])) t0) =
pure tm_abs &lt;‚ãÜ&gt;
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k) t &lt;‚ãÜ&gt;
œï (term B)
  (mbinddt term F
     (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚óã allK (incr [ktrm]) k) t0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk11a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk11a"><span class="nb">rewrite</span> (mbinddt_morphism_typ F G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure tm_abs &lt;‚ãÜ&gt;
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚àò f k) t &lt;‚ãÜ&gt;
œï (term B)
  (mbinddt term F (f ‚óª allK (incr [ktrm])) t0) =
pure tm_abs &lt;‚ãÜ&gt;
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k) t &lt;‚ãÜ&gt;
œï (term B)
  (mbinddt term F
     (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚óã allK (incr [ktrm]) k) t0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk11b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk11b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t1) =
mbinddt term G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t2) =
mbinddt term G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B) (mbinddt term F f (t1 @ t2)) =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k)
  (t1 @ t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk11c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk11c"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t1) =
mbinddt term G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t2) =
mbinddt term G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B)
  (pure tm_app &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
   mbinddt term F f t2) =
pure tm_app &lt;‚ãÜ&gt;
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k)
  t1 &lt;‚ãÜ&gt;
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k)
  t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk11d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk11d"><span class="nb">rewrite</span> &lt;- IHt1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t1) =
mbinddt term G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t2) =
mbinddt term G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B)
  (pure tm_app &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
   mbinddt term F f t2) =
pure tm_app &lt;‚ãÜ&gt; œï (term B) (mbinddt term F f t1) &lt;‚ãÜ&gt;
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k)
  t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk11e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk11e"><span class="nb">clear</span> IHt1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t2) =
mbinddt term G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B)
  (pure tm_app &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
   mbinddt term F f t2) =
pure tm_app &lt;‚ãÜ&gt; œï (term B) (mbinddt term F f t1) &lt;‚ãÜ&gt;
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k)
  t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk11f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk11f"><span class="nb">rewrite</span> &lt;- IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K,
      list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t2) =
mbinddt term G
  (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B)
  (pure tm_app &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
   mbinddt term F f t2) =
pure tm_app &lt;‚ãÜ&gt; œï (term B) (mbinddt term F f t1) &lt;‚ãÜ&gt;
œï (term B) (mbinddt term F f t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk120" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk120"><span class="nb">clear</span> IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B)
  (pure tm_app &lt;‚ãÜ&gt; mbinddt term F f t1 &lt;‚ãÜ&gt;
   mbinddt term F f t2) =
pure tm_app &lt;‚ãÜ&gt; œï (term B) (mbinddt term F f t1) &lt;‚ãÜ&gt;
œï (term B) (mbinddt term F f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk121" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk121"><span class="nb">rewrite</span> ap_morphism_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B -&gt; term B)
  (pure tm_app &lt;‚ãÜ&gt; mbinddt term F f t1) &lt;‚ãÜ&gt;
œï (term B) (mbinddt term F f t2) =
pure tm_app &lt;‚ãÜ&gt; œï (term B) (mbinddt term F f t1) &lt;‚ãÜ&gt;
œï (term B) (mbinddt term F f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk122" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk122"><span class="nb">rewrite</span> ap_morphism_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B -&gt; term B -&gt; term B) (pure tm_app) &lt;‚ãÜ&gt;
œï (term B) (mbinddt term F f t1) &lt;‚ãÜ&gt;
œï (term B) (mbinddt term F f t2) =
pure tm_app &lt;‚ãÜ&gt; œï (term B) (mbinddt term F f t1) &lt;‚ãÜ&gt;
œï (term B) (mbinddt term F f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk123" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk123"><span class="nb">rewrite</span> (appmor_pure).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure tm_app &lt;‚ãÜ&gt; œï (term B) (mbinddt term F f t1) &lt;‚ãÜ&gt;
œï (term B) (mbinddt term F f t2) =
pure tm_app &lt;‚ãÜ&gt; œï (term B) (mbinddt term F f t1) &lt;‚ãÜ&gt;
œï (term B) (mbinddt term F f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk124" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk124">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t) =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B) (mbinddt term F f (Œõ t)) =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k)
  (Œõ t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk125" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk125"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t) =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B)
  (pure tm_tab &lt;‚ãÜ&gt;
   mbinddt term F (f ‚óª allK (incr [ktyp])) t) =
pure tm_tab &lt;‚ãÜ&gt;
mbinddt term G
  ((<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k)
   ‚óª allK (incr [ktyp])) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk126" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk126"><span class="nb">rewrite</span> &lt;- IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t) =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B)
  (pure tm_tab &lt;‚ãÜ&gt;
   mbinddt term F (f ‚óª allK (incr [ktyp])) t) =
pure tm_tab &lt;‚ãÜ&gt;
œï (term B)
  (mbinddt term F
     (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚óã allK (incr [ktyp]) k) t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk127" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk127"><span class="nb">clear</span> IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B)
  (pure tm_tab &lt;‚ãÜ&gt;
   mbinddt term F (f ‚óª allK (incr [ktyp])) t) =
pure tm_tab &lt;‚ãÜ&gt;
œï (term B)
  (mbinddt term F
     (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚óã allK (incr [ktyp]) k) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk128" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk128"><span class="nb">rewrite</span> ap_morphism_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B -&gt; term B) (pure tm_tab) &lt;‚ãÜ&gt;
œï (term B) (mbinddt term F (f ‚óª allK (incr [ktyp])) t) =
pure tm_tab &lt;‚ãÜ&gt;
œï (term B)
  (mbinddt term F
     (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚óã allK (incr [ktyp]) k) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk129" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk129"><span class="nb">rewrite</span> (appmor_pure).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure tm_tab &lt;‚ãÜ&gt;
œï (term B) (mbinddt term F (f ‚óª allK (incr [ktyp])) t) =
pure tm_tab &lt;‚ãÜ&gt;
œï (term B)
  (mbinddt term F
     (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; f k ‚óã allK (incr [ktyp]) k) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk12a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk12a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t) =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B) (mbinddt term F f (t @@ t0)) =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k)
  (t @@ t0)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk12b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk12b"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t) =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B)
  (pure tm_tap &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
   bind_type F f t0) =
pure tm_tap &lt;‚ãÜ&gt;
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k) t &lt;‚ãÜ&gt;
bind_type G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk12c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk12c"><span class="nb">rewrite</span> &lt;- IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B),
œï (term B) (mbinddt term F f t) =
mbinddt term G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚óã f k) t</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B)
  (pure tm_tap &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
   bind_type F f t0) =
pure tm_tap &lt;‚ãÜ&gt; œï (term B) (mbinddt term F f t) &lt;‚ãÜ&gt;
bind_type G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k) t0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk12d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk12d"><span class="nb">clear</span> IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B)
  (pure tm_tap &lt;‚ãÜ&gt; mbinddt term F f t &lt;‚ãÜ&gt;
   bind_type F f t0) =
pure tm_tap &lt;‚ãÜ&gt; œï (term B) (mbinddt term F f t) &lt;‚ãÜ&gt;
bind_type G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk12e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk12e"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> ap_morphism_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (term B -&gt; typ B -&gt; term B) (pure tm_tap) &lt;‚ãÜ&gt;
œï (term B) (mbinddt term F f t) &lt;‚ãÜ&gt;
œï (typ B) (bind_type F f t0) =
pure tm_tap &lt;‚ãÜ&gt; œï (term B) (mbinddt term F f t) &lt;‚ãÜ&gt;
bind_type G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk12f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk12f"><span class="nb">rewrite</span> (appmor_pure).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure tm_tap &lt;‚ãÜ&gt; œï (term B) (mbinddt term F f t) &lt;‚ãÜ&gt;
œï (typ B) (bind_type F f t0) =
pure tm_tap &lt;‚ãÜ&gt; œï (term B) (mbinddt term F f t) &lt;‚ãÜ&gt;
bind_type G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk130" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk130"><span class="nb">change</span> (bind_type <span class="nl">?F</span> <span class="nl">?f</span>) <span class="kr">with</span> (mbinddt typ F f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure tm_tap &lt;‚ãÜ&gt; œï (term B) (mbinddt term F f t) &lt;‚ãÜ&gt;
œï (typ B) (mbinddt typ F f t0) =
pure tm_tap &lt;‚ãÜ&gt; œï (term B) (mbinddt term F f t) &lt;‚ãÜ&gt;
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk131" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk131">compose near t0 on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure tm_tap &lt;‚ãÜ&gt; œï (term B) (mbinddt term F f t) &lt;‚ãÜ&gt;
(œï (typ B) ‚àò mbinddt typ F f) t0 =
pure tm_tap &lt;‚ãÜ&gt; œï (term B) (mbinddt term F f t) &lt;‚ãÜ&gt;
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk132" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk132"><span class="nb">rewrite</span> (mbinddt_morphism_typ F G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>F ‚áí G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>typ A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure tm_tap &lt;‚ãÜ&gt; œï (term B) (mbinddt term F f t) &lt;‚ãÜ&gt;
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K =&gt; œï (SystemF k B) ‚àò f k) t0 =
pure tm_tap &lt;‚ãÜ&gt; œï (term B) (mbinddt term F f t) &lt;‚ãÜ&gt;
mbinddt typ G (<span class="kr">fun</span> <span class="nv">k</span> : K2 =&gt; œï (SystemF k B) ‚óã f k) t0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Unset Keyed Unification</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** &lt;&lt;mbinddt_comp_mret&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk133" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk133"><span class="kn">Lemma</span> <span class="nf">mbinddt_comp_mret_typ</span> :
  <span class="kr">forall</span> (<span class="nv">F</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    `{Applicative F}
    `(f : <span class="kr">forall</span> <span class="nv">k</span>, list K2 * A -&gt; F (SystemF k B)),
    mbinddt typ F f ‚àò mret SystemF ktyp = f ktyp ‚àò pair nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">F</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Map F) (<span class="nv">H0</span> : Pure F)
  (<span class="nv">H1</span> : Mult F),
Applicative F -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
mbinddt typ F f ‚àò mret SystemF ktyp = f ktyp ‚àò pair []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk134" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk134"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">F</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Map F) (<span class="nv">H0</span> : Pure F)
  (<span class="nv">H1</span> : Mult F),
Applicative F -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
mbinddt typ F f ‚àò mret SystemF ktyp = f ktyp ‚àò pair []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk135" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk135"><span class="kn">Lemma</span> <span class="nf">mbinddt_comp_mret_term</span> :
  <span class="kr">forall</span> (<span class="nv">F</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    `{Applicative F}
    `(f : <span class="kr">forall</span> <span class="nv">k</span>, list K2 * A -&gt; F (SystemF k B)),
    mbinddt term F f ‚àò mret SystemF ktrm = f ktrm ‚àò pair nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">F</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Map F) (<span class="nv">H0</span> : Pure F)
  (<span class="nv">H1</span> : Mult F),
Applicative F -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
mbinddt term F f ‚àò mret SystemF ktrm =
f ktrm ‚àò pair []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk136" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk136"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">F</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Map F) (<span class="nv">H0</span> : Pure F)
  (<span class="nv">H1</span> : Mult F),
Applicative F -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
mbinddt term F f ‚àò mret SystemF ktrm =
f ktrm ‚àò pair []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk137" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk137"><span class="kn">Corollary</span> <span class="nf">mbinddt_comp_mret_F</span> :
  <span class="kr">forall</span> <span class="nv">k</span> <span class="nv">F</span> `{Applicative F}
    `(f : <span class="kr">forall</span> <span class="nv">k</span>, (list K2) * A -&gt; F (SystemF k B)),
    mbinddt (W := list K2) (T := SystemF) (SystemF k) F f ‚àò mret SystemF k = (<span class="kr">fun</span> <span class="nv">a</span> =&gt; f k (∆µ, a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">k</span> : K) (<span class="nv">F</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Map F)
  (<span class="nv">H0</span> : Pure F) (<span class="nv">H1</span> : Mult F),
Applicative F -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k0</span> : K, list K2 * A -&gt; F (SystemF k0 B)),
mbinddt (SystemF k) F f ‚àò mret SystemF k =
f k ‚óã pair ∆µ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk138" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk138"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">k</span> : K) (<span class="nv">F</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Map F)
  (<span class="nv">H0</span> : Pure F) (<span class="nv">H1</span> : Mult F),
Applicative F -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k0</span> : K, list K2 * A -&gt; F (SystemF k0 B)),
mbinddt (SystemF k) F f ‚àò mret SystemF k =
f k ‚óã pair ∆µ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk139" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk139"><span class="nb">intro</span> k.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">F</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Map F) (<span class="nv">H0</span> : Pure F)
  (<span class="nv">H1</span> : Mult F),
Applicative F -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
mbinddt (SystemF k) F f ‚àò mret SystemF k =
f k ‚óã pair ∆µ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk13a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk13a"><span class="nb">destruct</span> k.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">F</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Map F) (<span class="nv">H0</span> : Pure F)
  (<span class="nv">H1</span> : Mult F),
Applicative F -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
mbinddt (SystemF ktyp) F f ‚àò mret SystemF ktyp =
f ktyp ‚óã pair ∆µ</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">F</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Map F) (<span class="nv">H0</span> : Pure F)
  (<span class="nv">H1</span> : Mult F),
Applicative F -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
mbinddt (SystemF ktrm) F f ‚àò mret SystemF ktrm =
f ktrm ‚óã pair ∆µ</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk13b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk13b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">F</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Map F) (<span class="nv">H0</span> : Pure F)
  (<span class="nv">H1</span> : Mult F),
Applicative F -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
mbinddt (SystemF ktyp) F f ‚àò mret SystemF ktyp =
f ktyp ‚óã pair ∆µ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> mbinddt_comp_mret_typ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk13c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk13c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">F</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Map F) (<span class="nv">H0</span> : Pure F)
  (<span class="nv">H1</span> : Mult F),
Applicative F -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : K, list K2 * A -&gt; F (SystemF k B)),
mbinddt (SystemF ktrm) F f ‚àò mret SystemF ktrm =
f ktrm ‚óã pair ∆µ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> mbinddt_comp_mret_term.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** &lt;&lt;DTPreModule&gt;&gt; instances *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">DTP_typ</span>: MultiDecoratedTraversablePreModule
                              (list K2) SystemF typ :=
  {| dtp_mbinddt_mret := @mbinddt_mret_typ;
     dtp_mbinddt_mbinddt := @mbinddt_mbinddt_typ;
     dtp_mbinddt_morphism := @mbinddt_morphism_typ;
  |}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">DTP_term</span>: MultiDecoratedTraversablePreModule
                               (list K2) SystemF term :=
  {| dtp_mbinddt_mret := @mbinddt_mret_term;
     dtp_mbinddt_mbinddt := @mbinddt_mbinddt_term;
     dtp_mbinddt_morphism := @mbinddt_morphism_term;
  |}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span>: <span class="kr">forall</span> <span class="nv">k</span>, MultiDecoratedTraversablePreModule
                           (list K2) SystemF (SystemF k) :=
  <span class="kr">fun</span> <span class="nv">k</span> =&gt; <span class="kr">match</span> k <span class="kr">with</span>
        | ktyp =&gt; DTP_typ
        | ktrm =&gt; DTP_term
        <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span>: MultiDecoratedTraversableMonad (list K2) SystemF :=
  {| dtm_mbinddt_comp_mret := mbinddt_comp_mret_F;
  |}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * System F type system and operational rules *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot;Œî ; Œì ‚ä¢ t : œÑ&quot;</span> (<span class="kn">at level</span> <span class="mi">90</span>, t <span class="kn">at level</span> <span class="mi">99</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Contexts and well-formedness predicates *)</span>
<span class="sd">(******************************************************************************)</span>

<span class="sd">(** *** Context of type variables *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">kind_ctx</span> := alist unit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Context of term variables *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">type_ctx</span> := alist (typ LN).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Well-formedness for kinding contexts *)</span>
<span class="sd">(** A kinding context is well-formed when its keys, i.e. type</span>
<span class="sd">    variables, are unique. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ok_kind_ctx</span> : kind_ctx -&gt; <span class="kt">Prop</span> := uniq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Hint Unfold</span> ok_kind_ctx : tea_alist.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Well-formedness of type expressions in a kinding context *)</span>
<span class="sd">(** A type is well-formed in a kinding context &lt;&lt;Œî&gt;&gt; when all of its</span>
<span class="sd">    type variables appear in Œî and the type is locally closed. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ok_type</span> : kind_ctx -&gt; typ LN -&gt; <span class="kt">Prop</span> :=
  <span class="kr">fun</span> <span class="nv">Œî</span> <span class="nv">œÑ</span> =&gt; scoped typ ktyp œÑ (domset Œî) /\ LC typ ktyp œÑ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Well-formedness for typing contexts *)</span>
<span class="sd">(** A typing context &lt;&lt;Œì&gt;&gt; is well-formed in kinding context &lt;&lt;Œî&gt;&gt;</span>
<span class="sd">    when the keys of &lt;&lt;Œì&gt;&gt; (i.e. term variables) are unique, and each</span>
<span class="sd">    associated type is itself well-formed in context &lt;&lt;Œî&gt;&gt;. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ok_type_ctx</span> : kind_ctx -&gt; type_ctx -&gt; <span class="kt">Prop</span> :=
  <span class="kr">fun</span> <span class="nv">Œî</span> <span class="nv">Œì</span> =&gt; uniq Œì /\ <span class="kr">forall</span> <span class="nv">œÑ</span>, œÑ ‚àà range Œì -&gt; ok_type Œî œÑ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Well-formedness of term expressions in context *)</span>
<span class="sd">(** A term &lt;&lt;t&gt;&gt; is well-formed in contexts &lt;&lt;Œî&gt;&gt; and &lt;&lt;Œì&gt;&gt; when its</span>
<span class="sd">    type variables are declared in &lt;&lt;Œî&gt;&gt;, its term variables are</span>
<span class="sd">    declared in &lt;&lt;Œì&gt;&gt;, and it is locally closed with respect to both</span>
<span class="sd">    kinds of variables. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ok_term</span> : kind_ctx -&gt; type_ctx -&gt; term LN -&gt; <span class="kt">Prop</span> :=
  <span class="kr">fun</span> <span class="nv">Œî</span> <span class="nv">Œì</span> <span class="nv">t</span> =&gt; scoped term ktyp t (domset Œî) /\
            scoped term ktrm t (domset Œì) /\
            LC term ktrm t /\
            LC term ktyp t.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Typing judgments *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Implicit Types</span> (<span class="nv">Œî</span> : kind_ctx) (<span class="nv">Œì</span> : type_ctx) (<span class="nv">œÑ</span> : typ LN).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">Judgment</span> : kind_ctx -&gt; type_ctx -&gt; term LN -&gt; typ LN -&gt; <span class="kt">Prop</span> :=
| j_var :
    <span class="kr">forall</span> <span class="nv">Œî</span> <span class="nv">Œì</span> <span class="nv">x</span> <span class="nv">œÑ</span>,
      ok_kind_ctx Œî -&gt;
      ok_type_ctx Œî Œì -&gt;
      (x, œÑ) ‚àà (Œì : list (atom * typ LN)) -&gt;
      (Œî ; Œì ‚ä¢ tm_var (Fr x) : œÑ)
| j_abs :
    <span class="kr">forall</span> <span class="nv">Œî</span> <span class="nv">Œì</span> (<span class="nv">L</span>:AtomSet.t) <span class="nv">t</span> <span class="nv">œÑ1</span> <span class="nv">œÑ2</span>,
      (<span class="kr">forall</span> <span class="nv">x</span>, x `notin` L  -&gt;
            Œî ; Œì ++ x ~ œÑ1 ‚ä¢ open term ktrm (tm_var (Fr x)) t : œÑ2) -&gt;
      (Œî ; Œì ‚ä¢ tm_abs œÑ1 t : ty_ar œÑ1 œÑ2)
| j_app :
    <span class="kr">forall</span> <span class="nv">Œî</span> <span class="nv">Œì</span> <span class="nv">t1</span> <span class="nv">t2</span> <span class="nv">œÑ1</span> <span class="nv">œÑ2</span>,
      (Œî ; Œì ‚ä¢ t1 : ty_ar œÑ1 œÑ2) -&gt;
      (Œî ; Œì ‚ä¢ t2 : œÑ1) -&gt;
      (Œî ; Œì ‚ä¢ tm_app t1 t2 : œÑ2)
| j_univ :
    <span class="kr">forall</span> <span class="nv">Œî</span> <span class="nv">Œì</span> <span class="nv">L</span> <span class="nv">œÑ</span> <span class="nv">t</span>,
      (<span class="kr">forall</span> <span class="nv">x</span>, x `notin` L -&gt;
            Œî ++ x ~ tt ; Œì ‚ä¢ open term ktyp (ty_v (Fr x)) t
                          : open typ ktyp (ty_v (Fr x)) œÑ) -&gt;
      (Œî ; Œì ‚ä¢ tm_tab t : ty_univ œÑ)
| j_inst :
    <span class="kr">forall</span> <span class="nv">Œî</span> <span class="nv">Œì</span> <span class="nv">t</span> <span class="nv">œÑ1</span> <span class="nv">œÑ2</span>,
      ok_type Œî œÑ1 -&gt;
      (Œî ; Œì ‚ä¢ t : ty_univ œÑ2) -&gt;
      (Œî ; Œì ‚ä¢ tm_tap t œÑ1 : open typ ktyp œÑ1 œÑ2)
<span class="kn">where</span> <span class="s2">&quot;Œî ; Œì ‚ä¢ t : œÑ&quot;</span> := (Judgment Œî Œì t œÑ).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Values and reduction rules *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">value</span> : term LN -&gt; <span class="kt">Prop</span> :=
| val_abs : <span class="kr">forall</span> <span class="nv">T</span> <span class="nv">t</span>, value (tm_abs T t)
| val_tab : <span class="kr">forall</span> <span class="nv">t</span>, value (tm_tab t).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">red</span> : term LN -&gt; term LN -&gt; <span class="kt">Prop</span> :=
| red_app_l : <span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t1&#39;</span> <span class="nv">t2</span>,
    <span class="nb">red</span> t1 t1&#39; -&gt;
    <span class="nb">red</span> (tm_app t1 t2) (tm_app t1&#39; t2)
| red_app_r : <span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> <span class="nv">t2&#39;</span>,
    value t1 -&gt;
    <span class="nb">red</span> t2 t2&#39; -&gt;
    <span class="nb">red</span> (tm_app t1 t2) (tm_app t1 t2&#39;)
| red_abs : <span class="kr">forall</span> <span class="nv">T</span> <span class="nv">t1</span> <span class="nv">t2</span>,
    value t2 -&gt;
    <span class="nb">red</span> (tm_app (tm_abs T t1) t2) (open term ktrm t2 t1)
| red_tapl : <span class="kr">forall</span> <span class="nv">t</span> <span class="nv">t&#39;</span> <span class="nv">T</span>,
    <span class="nb">red</span> t t&#39; -&gt;
    <span class="nb">red</span> (tm_tap t T) (tm_tap t&#39; T)
| red_tab : <span class="kr">forall</span> <span class="nv">T</span> <span class="nv">t</span>,
    <span class="nb">red</span> (tm_tap (tm_tab t) T) (open term ktyp T t).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">preservation</span> := <span class="kr">forall</span> <span class="nv">t</span> <span class="nv">t&#39;</span> <span class="nv">œÑ</span>,
    (nil ; nil ‚ä¢ t : œÑ) -&gt;
    <span class="nb">red</span> t t&#39; -&gt;
    (nil ; nil ‚ä¢ t&#39; : œÑ).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">progress</span> := <span class="kr">forall</span> <span class="nv">t</span> <span class="nv">œÑ</span>,
    (nil ; nil ‚ä¢ t : œÑ) -&gt;
    value t \/ <span class="kr">exists</span> <span class="nv">t&#39;</span>, <span class="nb">red</span> t t&#39;.</span></span></pre>
</div>
</div></body>
</html>
