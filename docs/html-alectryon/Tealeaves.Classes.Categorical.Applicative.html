<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<title>Applicative.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.16.0+0.16.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Tealeaves <span class="kn">Require Export</span>
  Tactics.Prelude
  Classes.Functor
  Misc.Product
  Misc.Strength
  Functors.Identity
  Functors.Compose.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Product.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Generalizable Variables</span> <span class="nf">œï</span> F G A B C.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Applicative functors *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">Pure</span> (<span class="nv">F</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) :=
  pure : <span class="kr">forall</span> {<span class="nv">A</span>}, A -&gt; F A.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">Mult</span> (<span class="nv">F</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) :=
  mult : <span class="kr">forall</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>}, F A * F B -&gt; F (A * B).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Notation</span> <span class="s2">&quot;x ‚äó y&quot;</span> := (mult (x, y)) (<span class="kn">at level</span> <span class="mi">50</span>, <span class="kn">left associativity</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">Applicative</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    `{Map G} `{Pure G} `{Mult G} :=
  { app_functor :&gt; Functor G;
    app_pure_natural : <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : A),
      map f (pure x) = pure (f x);
    app_mult_natural : <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; C) (<span class="nv">g</span> : B -&gt; D) (<span class="nv">x</span> : G A) (<span class="nv">y</span> : G B),
      map f x ‚äó map g y = map (map_tensor f g) (x ‚äó y);
    app_assoc : <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G A) (<span class="nv">y</span> : G B) (<span class="nv">z</span> : G C),
      map Œ± ((x ‚äó y) ‚äó z) = x ‚äó (y ‚äó z);
    app_unital_l : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G A),
      map left_unitor (pure tt ‚äó x) = x;
    app_unital_r : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G A),
      map right_unitor (x ‚äó pure tt) = x;
    app_mult_pure : <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
      pure a ‚äó pure b = pure (a, b);
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk0">#[<span class="kn">global</span>] <span class="kn">Instance</span> <span class="nf">Pure_Natural</span> `{Applicative G} : Natural (@pure G _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural (@pure G H0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural (@pure G H0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk2"><span class="nb">constructor</span>; <span class="kp">try</span> <span class="nb">typeclasses eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
map f ‚àò pure = pure ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk3">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
map f ‚àò pure = pure ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk4"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f ‚àò pure = pure ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk5"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f ‚óã pure = pure ‚óã map f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk6">ext a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f (pure a) = pure (map f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> app_pure_natural.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Homomorphisms between applicative functors *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">ApplicativeMorphism</span> (<span class="nv">F</span> <span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
  `{Map F} `{Mult F} `{Pure F}
  `{Map G} `{Mult G} `{Pure G}
  (œï : <span class="kr">forall</span> {<span class="nv">A</span>}, F A -&gt; G A) :=
  { appmor_app_F : Applicative F;
    appmor_app_G : Applicative G;
    appmor_natural : <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F A),
      œï (map f x) = map f (œï x);
    appmor_pure : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
      œï (pure a) = pure a;
    appmor_mult : <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : F A) (<span class="nv">y</span> : F B),
      œï (x ‚äó y) = œï x ‚äó œï y;
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk7">#[export] <span class="kn">Instance</span> <span class="nf">Natural_ApplicativeMorphism</span>
  `{morphism : ApplicativeMorphism F G œï} : Natural œï.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>morphism</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural œï</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>morphism</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural œï</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk9"><span class="nb">inversion</span> morphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>morphism</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : F A),
œï B (map f x) = map f (œï A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : F A) (<span class="nv">y</span> : F B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural œï</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chka"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>morphism</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : F A),
œï B (map f x) = map f (œï A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : F A) (<span class="nv">y</span> : F B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor F</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="applicative-v-chkb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>morphism</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : F A),
œï B (map f x) = map f (œï A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : F A) (<span class="nv">y</span> : F B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br></div><label class="goal-separator" for="applicative-v-chkb"><hr></label><div class="goal-conclusion">Functor G</div></blockquote><input class="alectryon-extra-goal-toggle" id="applicative-v-chkc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>morphism</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : F A),
œï B (map f x) = map f (œï A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : F A) (<span class="nv">y</span> : F B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br></div><label class="goal-separator" for="applicative-v-chkc"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
map f ‚àò œï A = œï B ‚àò map f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkd">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>morphism</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : F A),
œï B (map f x) = map f (œï A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : F A) (<span class="nv">y</span> : F B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor F</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chke">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>morphism</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : F A),
œï B (map f x) = map f (œï A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : F A) (<span class="nv">y</span> : F B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor G</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkf">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>morphism</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : F A),
œï B (map f x) = map f (œï A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : F A) (<span class="nv">y</span> : F B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
map f ‚àò œï A = œï B ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk10"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>morphism</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : F A),
œï B (map f x) = map f (œï A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : F A) (<span class="nv">y</span> : F B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f ‚àò œï A = œï B ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk11">ext fa.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>morphism</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : F A),
œï B (map f x) = map f (œï A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : F A) (<span class="nv">y</span> : F B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fa</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map f ‚àò œï A) fa = (œï B ‚àò map f) fa</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk12"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>morphism</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : F A),
œï B (map f x) = map f (œï A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : F A) (<span class="nv">y</span> : F B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fa</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f (œï A fa) = œï B (map f fa)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk13"><span class="nb">rewrite</span> appmor_natural0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F, G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F A -&gt; G A</span></span></span><br><span><var>morphism</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F G œï</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">x</span> : F A),
œï B (map f x) = map f (œï A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : F A) (<span class="nv">y</span> : F B),
œï (A * B) (x ‚äó y) = œï A x ‚äó œï B y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fa</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f (œï A fa) = map f (œï A fa)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">infer_applicative_instances</span> :=
  <span class="kr">match goal with</span>
  | H : ApplicativeMorphism <span class="nl">?G1</span> <span class="nl">?G2</span> <span class="nl">?œï</span> |- _ =&gt;
      <span class="kr">let</span> <span class="nv">app1</span> := <span class="kp">fresh</span> <span class="s2">&quot;app1&quot;</span>
      <span class="kr">in</span> <span class="nb">assert</span> (app1: Applicative G1) <span class="bp">by</span> <span class="bp">now</span> <span class="nb">inversion</span> H
  <span class="kr">end</span>; <span class="kr">match goal with</span>
       | H : ApplicativeMorphism <span class="nl">?G1</span> <span class="nl">?G2</span> <span class="nl">?œï</span> |- _ =&gt;
           <span class="kr">let</span> <span class="nv">app2</span> := <span class="kp">fresh</span> <span class="s2">&quot;app2&quot;</span>
           <span class="kr">in</span> <span class="nb">assert</span> (app2 : Applicative G2) <span class="bp">by</span> <span class="bp">now</span> <span class="nb">inversion</span> H
       <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** The identity transformation on any &lt;&lt;F&gt;&gt; is a homomorphism *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk14">#[export] <span class="kn">Instance</span> <span class="nf">ApplicativeMorphism_id</span> `{Applicative F} :
  ApplicativeMorphism F F (<span class="kr">fun</span> <span class="nv">A</span> =&gt; @id (F A)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ApplicativeMorphism F F (@id ‚óã F)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk15"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ApplicativeMorphism F F (@id ‚óã F)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">constructor</span>; <span class="bp">now</span> <span class="kp">try</span> <span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Basic lemmas *)</span>
<span class="sd">(** TODO: Find a better name. I don&#39;t remember why these are</span>
<span class="sd">named @triangle_x@. *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">basics</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{Applicative F}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk16"><span class="kn">Lemma</span> <span class="nf">triangle_1</span> : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">t</span> : F A),
      pure tt ‚äó t = map left_unitor_inv t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">t</span> : F A),
pure tt ‚äó t = map left_unitor_inv t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk17"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">t</span> : F A),
pure tt ‚äó t = map left_unitor_inv t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk18"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure tt ‚äó t = map left_unitor_inv t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk19"><span class="nb">rewrite</span> &lt;- (app_unital_l A t) <span class="nb">at</span> <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure tt ‚äó t =
map left_unitor_inv (map left_unitor (pure tt ‚äó t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1a">compose near (pure tt ‚äó t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure tt ‚äó t =
(map left_unitor_inv ‚àò map left_unitor) (pure tt ‚äó t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1b"><span class="nb">rewrite</span> fun_map_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure tt ‚äó t =
map (left_unitor_inv ‚àò left_unitor) (pure tt ‚äó t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1c"><span class="nb">rewrite</span> unitors_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure tt ‚äó t = map id (pure tt ‚äó t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1d"><span class="nb">rewrite</span> fun_map_id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure tt ‚äó t = id (pure tt ‚äó t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1e"><span class="kn">Lemma</span> <span class="nf">triangle_2</span> : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">t</span> : F A),
      t ‚äó pure tt = map right_unitor_inv t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">t</span> : F A),
t ‚äó pure tt = map right_unitor_inv t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">t</span> : F A),
t ‚äó pure tt = map right_unitor_inv t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk20"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">t ‚äó pure tt = map right_unitor_inv t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk21"><span class="nb">rewrite</span> &lt;- (app_unital_r A t) <span class="nb">at</span> <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">t ‚äó pure tt =
map right_unitor_inv (map right_unitor (t ‚äó pure tt))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk22">compose near (t ‚äó pure tt).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">t ‚äó pure tt =
(map right_unitor_inv ‚àò map right_unitor)
  (t ‚äó pure tt)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk23"><span class="nb">rewrite</span> fun_map_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">t ‚äó pure tt =
map (right_unitor_inv ‚àò right_unitor) (t ‚äó pure tt)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk24"><span class="nb">rewrite</span> unitors_3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">t ‚äó pure tt = map id (t ‚äó pure tt)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk25"><span class="nb">rewrite</span> fun_map_id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">t ‚äó pure tt = id (t ‚äó pure tt)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk26"><span class="kn">Lemma</span> <span class="nf">triangle_3</span> : <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A) (<span class="nv">t</span> : F B),
      pure a ‚äó t = strength (a, t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A) (<span class="nv">t</span> : F B),
pure a ‚äó t = strength (a, t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk27"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A) (<span class="nv">t</span> : F B),
pure a ‚äó t = strength (a, t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk28"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure a ‚äó t = strength (a, t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk29"><span class="nb">unfold</span> strength.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure a ‚äó t = map (pair a) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk2a"><span class="nb">rewrite</span> &lt;- (app_unital_l B t) <span class="nb">at</span> <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure a ‚äó t =
map (pair a) (map left_unitor (pure tt ‚äó t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk2b">compose near (pure tt ‚äó t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure a ‚äó t =
(map (pair a) ‚àò map left_unitor) (pure tt ‚äó t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk2c"><span class="nb">rewrite</span> fun_map_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure a ‚äó t = map (pair a ‚àò left_unitor) (pure tt ‚äó t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk2d"><span class="nb">replace</span> (pair a ‚àò left_unitor) <span class="kr">with</span>
      (map_fst (X := unit) (Y := B) (const a)) <span class="bp">by</span>
      (<span class="bp">now</span> ext [[] ?]).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure a ‚äó t = map (map_fst (const a)) (pure tt ‚äó t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk2e"><span class="nb">unfold</span> map_fst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure a ‚äó t =
map (map_tensor (const a) id) (pure tt ‚äó t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk2f"><span class="nb">rewrite</span> &lt;- app_mult_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure a ‚äó t = map (const a) (pure tt) ‚äó map id t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk30"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure a ‚äó t = pure (const a tt) ‚äó map id t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk31"><span class="nb">rewrite</span> fun_map_id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure a ‚äó t = pure (const a tt) ‚äó id t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk32"><span class="kn">Lemma</span> <span class="nf">triangle_4</span> : <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A) (<span class="nv">t</span> : F B),
      t ‚äó pure a = map (<span class="kr">fun</span> <span class="nv">b</span> =&gt; (b, a)) t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A) (<span class="nv">t</span> : F B),
t ‚äó pure a = map (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; (b, a)) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk33"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A) (<span class="nv">t</span> : F B),
t ‚äó pure a = map (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; (b, a)) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk34"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">t ‚äó pure a = map (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; (b, a)) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk35"><span class="nb">rewrite</span> &lt;- (app_unital_r B t) <span class="nb">at</span> <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">t ‚äó pure a =
map (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; (b, a))
  (map right_unitor (t ‚äó pure tt))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk36">compose near (t ‚äó pure tt).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">t ‚äó pure a =
(map (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; (b, a)) ‚àò map right_unitor)
  (t ‚äó pure tt)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk37"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">t ‚äó pure a =
map ((<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; (b, a)) ‚àò right_unitor)
  (t ‚äó pure tt)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk38"><span class="nb">replace</span> ((<span class="kr">fun</span> <span class="nv">b</span> =&gt; (b, a)) ‚àò right_unitor) <span class="kr">with</span>
      (map_snd (X := B) (Y := unit) (const a))
      <span class="bp">by</span> (<span class="bp">now</span> ext [? []]).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">t ‚äó pure a = map (map_snd (const a)) (t ‚äó pure tt)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk39"><span class="nb">unfold</span> map_snd.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">t ‚äó pure a =
map (map_tensor id (const a)) (t ‚äó pure tt)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk3a"><span class="nb">rewrite</span> &lt;- app_mult_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">t ‚äó pure a = map id t ‚äó map (const a) (pure tt)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk3b"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">t ‚äó pure a = map id t ‚äó pure (const a tt)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk3c"><span class="nb">rewrite</span> fun_map_id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">t ‚äó pure a = id t ‚äó pure (const a tt)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk3d"><span class="kn">Lemma</span> <span class="nf">weird_1</span> : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>),
      map left_unitor ‚àò mult ‚àò pair (pure tt) = @id (F A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
map left_unitor ‚àò mult ‚àò pair (pure tt) = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk3e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
map left_unitor ‚àò mult ‚àò pair (pure tt) = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk3f"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map left_unitor ‚àò mult ‚àò pair (pure tt) = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk40">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map left_unitor ‚àò mult ‚àò pair (pure tt)) t = id t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk41"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map left_unitor (pure tt ‚äó t) = id t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk42"><span class="nb">rewrite</span> triangle_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map left_unitor (map left_unitor_inv t) = id t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk43">compose near t on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map left_unitor ‚àò map left_unitor_inv) t = id t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk44"><span class="nb">rewrite</span> fun_map_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (left_unitor ‚àò left_unitor_inv) t = id t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk45"><span class="nb">rewrite</span> unitors_2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map id t = id t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk46"><span class="nb">rewrite</span> fun_map_id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">id t = id t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk47"><span class="kn">Lemma</span> <span class="nf">weird_2</span> : <span class="kr">forall</span> <span class="nv">A</span>,
      map right_unitor ‚àò mult ‚àò (<span class="kr">fun</span> <span class="nv">b</span> : F A =&gt; (b, pure tt)) = @id (F A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
map right_unitor ‚àò mult
‚àò (<span class="kr">fun</span> <span class="nv">b</span> : F A =&gt; (b, pure tt)) = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk48"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
map right_unitor ‚àò mult
‚àò (<span class="kr">fun</span> <span class="nv">b</span> : F A =&gt; (b, pure tt)) = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk49"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map right_unitor ‚àò mult
‚àò (<span class="kr">fun</span> <span class="nv">b</span> : F A =&gt; (b, pure tt)) = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk4a">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map right_unitor ‚àò mult
 ‚àò (<span class="kr">fun</span> <span class="nv">b</span> : F A =&gt; (b, pure tt))) t = id t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk4b"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map right_unitor (t ‚äó pure tt) = id t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk4c"><span class="nb">rewrite</span> triangle_2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map right_unitor (map right_unitor_inv t) = id t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk4d">compose near t on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map right_unitor ‚àò map right_unitor_inv) t = id t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk4e"><span class="nb">rewrite</span> fun_map_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (right_unitor ‚àò right_unitor_inv) t = id t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk4f"><span class="nb">rewrite</span> unitors_4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map id t = id t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk50"><span class="nb">rewrite</span> fun_map_id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">id t = id t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">basics</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Mapping and reassociating &lt;&lt;‚äó&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Applicative_corollaries</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    (<span class="nv">F</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    `{Applicative F}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk51"><span class="kn">Lemma</span> <span class="nf">app_mult_natural_l</span> :
    <span class="kr">forall</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; C) (<span class="nv">x</span> : F A) (<span class="nv">y</span> : F B),
      map f x ‚äó y = map (map_fst f) (x ‚äó y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; C) (<span class="nv">x</span> : F A) (<span class="nv">y</span> : F B),
map f x ‚äó y = map (map_fst f) (x ‚äó y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk52"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; C) (<span class="nv">x</span> : F A) (<span class="nv">y</span> : F B),
map f x ‚äó y = map (map_fst f) (x ‚äó y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk53"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>F B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f x ‚äó y = map (map_fst f) (x ‚äó y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk54"><span class="nb">replace</span> y <span class="kr">with</span> (map id y) <span class="nb">at</span> <span class="mi">1</span>
      <span class="bp">by</span> (<span class="bp">now</span> <span class="nb">rewrite</span> fun_map_id).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>F B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f x ‚äó map id y = map (map_fst f) (x ‚äó y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk55"><span class="nb">rewrite</span> app_mult_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>F B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map_tensor f id) (x ‚äó y) =
map (map_fst f) (x ‚äó y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk56"><span class="kn">Lemma</span> <span class="nf">app_mult_natural_r</span> :
    <span class="kr">forall</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">D</span> : <span class="kt">Type</span>} (<span class="nv">g</span> : B -&gt; D) (<span class="nv">x</span> : F A) (<span class="nv">y</span> : F B),
      x ‚äó map g y = map (map_snd g) (x ‚äó y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">D</span> : <span class="kt">Type</span>) (<span class="nv">g</span> : B -&gt; D) (<span class="nv">x</span> : F A) (<span class="nv">y</span> : F B),
x ‚äó map g y = map (map_snd g) (x ‚äó y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk57"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">D</span> : <span class="kt">Type</span>) (<span class="nv">g</span> : B -&gt; D) (<span class="nv">x</span> : F A) (<span class="nv">y</span> : F B),
x ‚äó map g y = map (map_snd g) (x ‚äó y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk58"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A, B, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>F B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ‚äó map g y = map (map_snd g) (x ‚äó y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk59"><span class="nb">replace</span> x <span class="kr">with</span> (map id x) <span class="nb">at</span> <span class="mi">1</span>
      <span class="bp">by</span> (<span class="bp">now</span> <span class="nb">rewrite</span> fun_map_id).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A, B, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>F B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map id x ‚äó map g y = map (map_snd g) (x ‚äó y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk5a"><span class="nb">rewrite</span> app_mult_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A, B, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>F B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map_tensor id g) (x ‚äó y) =
map (map_snd g) (x ‚äó y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk5b"><span class="kn">Corollary</span> <span class="nf">app_mult_natural_1</span> :
    <span class="kr">forall</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">E</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; C) (<span class="nv">h</span> : C * B -&gt; E) (<span class="nv">x</span> : F A) (<span class="nv">y</span> : F B),
      map h (map f x ‚äó y) = map (h ‚àò map_fst f) (x ‚äó y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">E</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; C) (<span class="nv">h</span> : C * B -&gt; E)
  (<span class="nv">x</span> : F A) (<span class="nv">y</span> : F B),
map h (map f x ‚äó y) = map (h ‚àò map_fst f) (x ‚äó y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk5c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">E</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; C) (<span class="nv">h</span> : C * B -&gt; E)
  (<span class="nv">x</span> : F A) (<span class="nv">y</span> : F B),
map h (map f x ‚äó y) = map (h ‚àò map_fst f) (x ‚äó y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk5d"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A, B, C, E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>C * B -&gt; E</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>F B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map h (map f x ‚äó y) = map (h ‚àò map_fst f) (x ‚äó y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk5e"><span class="nb">rewrite</span> app_mult_natural_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A, B, C, E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>C * B -&gt; E</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>F B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map h (map (map_fst f) (x ‚äó y)) =
map (h ‚àò map_fst f) (x ‚äó y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk5f">compose near (x ‚äó y) on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A, B, C, E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>C * B -&gt; E</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>F B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map h ‚àò map (map_fst f)) (x ‚äó y) =
map (h ‚àò map_fst f) (x ‚äó y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk60"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A, B, C, E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>C * B -&gt; E</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>F B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (h ‚àò map_fst f) (x ‚äó y) =
map (h ‚àò map_fst f) (x ‚äó y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk61"><span class="kn">Corollary</span> <span class="nf">app_mult_natural_2</span> :
    <span class="kr">forall</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">D</span> <span class="nv">E</span> : <span class="kt">Type</span>} (<span class="nv">g</span> : B -&gt; D) (<span class="nv">h</span> : A * D -&gt; E) (<span class="nv">x</span> : F A) (<span class="nv">y</span> : F B),
      map h (x ‚äó map g y) = map (h ‚àò map_snd g) (x ‚äó y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">D</span> <span class="nv">E</span> : <span class="kt">Type</span>) (<span class="nv">g</span> : B -&gt; D) (<span class="nv">h</span> : A * D -&gt; E)
  (<span class="nv">x</span> : F A) (<span class="nv">y</span> : F B),
map h (x ‚äó map g y) = map (h ‚àò map_snd g) (x ‚äó y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk62"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">D</span> <span class="nv">E</span> : <span class="kt">Type</span>) (<span class="nv">g</span> : B -&gt; D) (<span class="nv">h</span> : A * D -&gt; E)
  (<span class="nv">x</span> : F A) (<span class="nv">y</span> : F B),
map h (x ‚äó map g y) = map (h ‚àò map_snd g) (x ‚äó y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk63"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A, B, D, E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A * D -&gt; E</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>F B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map h (x ‚äó map g y) = map (h ‚àò map_snd g) (x ‚äó y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk64"><span class="nb">rewrite</span> app_mult_natural_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A, B, D, E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A * D -&gt; E</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>F B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map h (map (map_snd g) (x ‚äó y)) =
map (h ‚àò map_snd g) (x ‚äó y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk65">compose near (x ‚äó y) on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A, B, D, E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A * D -&gt; E</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>F B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map h ‚àò map (map_snd g)) (x ‚äó y) =
map (h ‚àò map_snd g) (x ‚äó y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk66"><span class="nb">rewrite</span> fun_map_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A, B, D, E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A * D -&gt; E</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>F B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (h ‚àò map_snd g) (x ‚äó y) =
map (h ‚àò map_snd g) (x ‚äó y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk67"><span class="kn">Lemma</span> <span class="nf">app_assoc_inv</span> :
    <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : F A) (<span class="nv">y</span> : F B) (<span class="nv">z</span> : F C),
      map Œ±^-<span class="mi">1</span> (x ‚äó (y ‚äó z)) = (x ‚äó y ‚äó z).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : F A) (<span class="nv">y</span> : F B) (<span class="nv">z</span> : F C),
map Œ±^-<span class="mi">1</span> (x ‚äó (y ‚äó z)) = x ‚äó y ‚äó z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk68"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : F A) (<span class="nv">y</span> : F B) (<span class="nv">z</span> : F C),
map Œ±^-<span class="mi">1</span> (x ‚äó (y ‚äó z)) = x ‚äó y ‚äó z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk69"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>F B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>F C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map Œ±^-<span class="mi">1</span> (x ‚äó (y ‚äó z)) = x ‚äó y ‚äó z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk6a"><span class="nb">rewrite</span> &lt;- app_assoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>F B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>F C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map Œ±^-<span class="mi">1</span> (map Œ± (x ‚äó y ‚äó z)) = x ‚äó y ‚äó z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk6b">compose near (x ‚äó y ‚äó z).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>F B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>F C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map Œ±^-<span class="mi">1</span> ‚àò map Œ±) (x ‚äó y ‚äó z) = x ‚äó y ‚äó z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk6c"><span class="nb">rewrite</span> fun_map_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>F B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>F C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Œ±^-<span class="mi">1</span> ‚àò Œ±) (x ‚äó y ‚äó z) = x ‚äó y ‚äó z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk6d"><span class="nb">rewrite</span> associator_iso_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>F B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>F C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map id (x ‚äó y ‚äó z) = x ‚äó y ‚äó z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk6e"><span class="nb">rewrite</span> fun_map_id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure F</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative F</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>F B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>F C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">id (x ‚äó y ‚äó z) = x ‚äó y ‚äó z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Applicative_corollaries</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * The category of applicative functors *)</span>
<span class="sd">(******************************************************************************)</span>

<span class="sd">(** ** The identity applicative functor *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Pure_I</span> : Pure (<span class="kr">fun</span> <span class="nv">A</span> =&gt; A) := @id.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Mult_I</span> : Mult (<span class="kr">fun</span> <span class="nv">A</span> =&gt; A) := <span class="kr">fun</span> <span class="nv">A</span> <span class="nv">B</span> (<span class="nv">p</span> : A * B) =&gt; p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export, program] <span class="kn">Instance</span> <span class="nf">Applicative_I</span> : Applicative (<span class="kr">fun</span> <span class="nv">A</span> =&gt; A).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** &lt;&lt;pure F&gt;&gt; is a homomorphism from the identity functor *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">pure_as_applicative_transformation</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{Applicative G}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk6f"><span class="kn">Lemma</span> <span class="nf">pure_appmor_1</span> : <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">t</span> : A),
      pure (map (F := <span class="kr">fun</span> <span class="nv">A</span> =&gt; A) f t) = map f (pure t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">t</span> : A),
pure (map f t) = map f (pure t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk70"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">t</span> : A),
pure (map f t) = map f (pure t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk71"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (map f t) = map f (pure t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk72"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (map f t) = pure (f t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk73"><span class="kn">Lemma</span> <span class="nf">pure_appmor_2</span> : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
      pure (F := G) (pure (F := <span class="kr">fun</span> <span class="nv">A</span> =&gt; A) a) = pure a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A), pure (pure a) = pure a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk74"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A), pure (pure a) = pure a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk75"><span class="kn">Lemma</span> <span class="nf">pure_appmor_3</span> : <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
      pure (mult (F := <span class="kr">fun</span> <span class="nv">A</span> =&gt; A) (a, b)) = pure a ‚äó pure b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
pure (a ‚äó b) = pure a ‚äó pure b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk76"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
pure (a ‚äó b) = pure a ‚äó pure b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk77"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (a ‚äó b) = pure a ‚äó pure b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk78"><span class="nb">unfold</span> transparent tcs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (a, b) = pure a ‚äó pure b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk79"><span class="nb">rewrite</span> app_mult_pure.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (a, b) = pure (a, b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">ApplicativeMorphism_pure</span> :
    ApplicativeMorphism (<span class="kr">fun</span> <span class="nv">A</span> =&gt; A) G (@pure G _) :=
    {| appmor_natural := pure_appmor_1;
       appmor_pure := pure_appmor_2;
       appmor_mult := pure_appmor_3;
    |}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">pure_as_applicative_transformation</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Composition of applicative functors *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">applicative_compose</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    (<span class="nv">G2</span> <span class="nv">G1</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    `{Applicative G1}
    `{Applicative G2}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Pure_compose</span> : Pure (G2 ‚àò G1) :=
    <span class="kr">fun</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A) =&gt; pure (F := G2) (pure (F := G1) a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Mult_compose</span> : Mult (G2 ‚àò G1) :=
    <span class="kr">fun</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">p</span> : G2 (G1 A) * G2 (G1 B)) =&gt;
      map (F := G2) (mult (F := G1))
        (mult (F := G2) (fst p, snd p)) : G2 (G1 (A * B)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk7a"><span class="kn">Lemma</span> <span class="nf">app_pure_nat_compose</span> : <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : A),
      map (F := G2 ‚àò G1) f (pure (F := G2 ‚àò G1) x) = pure (f x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : A),
map f (pure x) = pure (f x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk7b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : A),
map f (pure x) = pure (f x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk7c"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f (pure x) = pure (f x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk7d"><span class="nb">unfold</span> transparent tcs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map f) (pure (pure x)) = pure (pure (f x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk7e"><span class="nb">rewrite</span> <span class="mi">2</span>(app_pure_natural _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (pure (f x)) = pure (pure (f x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk7f"><span class="kn">Lemma</span> <span class="nf">app_mult_nat_compose</span> : <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; C) (<span class="nv">g</span> : B -&gt; D) (<span class="nv">x</span> : G2 (G1 A)) (<span class="nv">y</span> : G2 (G1 B)),
      map f x ‚äó map g y = map (map_tensor f g) (x ‚äó y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; C) (<span class="nv">g</span> : B -&gt; D)
  (<span class="nv">x</span> : G2 (G1 A)) (<span class="nv">y</span> : G2 (G1 B)),
map f x ‚äó map g y = map (map_tensor f g) (x ‚äó y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk80"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; C) (<span class="nv">g</span> : B -&gt; D)
  (<span class="nv">x</span> : G2 (G1 A)) (<span class="nv">y</span> : G2 (G1 B)),
map f x ‚äó map g y = map (map_tensor f g) (x ‚äó y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk81"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G2 (G1 B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f x ‚äó map g y = map (map_tensor f g) (x ‚äó y)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk82"><span class="nb">unfold</span> transparent tcs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G2 (G1 B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map mult
  (fst (map (map f) x, map (map g) y)
   ‚äó snd (map (map f) x, map (map g) y)) =
map (map (map_tensor f g))
  (map mult (fst (x, y) ‚äó snd (x, y)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk83"><span class="nb">cbn</span> [fst snd].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G2 (G1 B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map mult (map (map f) x ‚äó map (map g) y) =
map (map (map_tensor f g)) (map mult (x ‚äó y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk84"><span class="nb">rewrite</span> (app_mult_natural).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G2 (G1 B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map mult (map (map_tensor (map f) (map g)) (x ‚äó y)) =
map (map (map_tensor f g)) (map mult (x ‚äó y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk85">compose near (mult (x, y)) on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G2 (G1 B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map mult ‚àò map (map_tensor (map f) (map g))) (x ‚äó y) =
map (map (map_tensor f g)) (map mult (x ‚äó y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk86"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G2 (G1 B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mult ‚àò map_tensor (map f) (map g)) (x ‚äó y) =
map (map (map_tensor f g)) (map mult (x ‚äó y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk87">compose near (mult (x, y)) on <span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G2 (G1 B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mult ‚àò map_tensor (map f) (map g)) (x ‚äó y) =
(map (map (map_tensor f g)) ‚àò map mult) (x ‚äó y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk88"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G2 (G1 B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mult ‚àò map_tensor (map f) (map g)) (x ‚äó y) =
map (map (map_tensor f g) ‚àò mult) (x ‚äó y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk89">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G2 (G1 B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mult ‚àò map_tensor (map f) (map g) =
map (map_tensor f g) ‚àò mult</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk8a">ext [fa fb].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G2 (G1 B)</span></span></span><br><span><var>fa</var><span class="hyp-type"><b>: </b><span>G1 A</span></span></span><br><span><var>fb</var><span class="hyp-type"><b>: </b><span>G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(mult ‚àò map_tensor (map f) (map g)) (fa, fb) =
(map (map_tensor f g) ‚àò mult) (fa, fb)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk8b"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G2 (G1 B)</span></span></span><br><span><var>fa</var><span class="hyp-type"><b>: </b><span>G1 A</span></span></span><br><span><var>fb</var><span class="hyp-type"><b>: </b><span>G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mult (map_tensor (map f) (map g) (fa, fb)) =
map (map_tensor f g) (fa ‚äó fb)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk8c"><span class="nb">rewrite</span> &lt;- (app_mult_natural).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G2 (G1 B)</span></span></span><br><span><var>fa</var><span class="hyp-type"><b>: </b><span>G1 A</span></span></span><br><span><var>fb</var><span class="hyp-type"><b>: </b><span>G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mult (map_tensor (map f) (map g) (fa, fb)) =
map f fa ‚äó map g fb</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk8d"><span class="kn">Theorem</span> <span class="nf">app_asc_compose</span> : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> (<span class="nv">x</span> : G2 (G1 A)) (<span class="nv">y</span> : G2 (G1 B)) (<span class="nv">z</span> : G2 (G1 C)),
      map (F := G2 ‚àò G1) Œ± (x ‚äó y ‚äó z) = x ‚äó (y ‚äó z).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G2 (G1 A)) (<span class="nv">y</span> : G2 (G1 B))
  (<span class="nv">z</span> : G2 (G1 C)), map Œ± (x ‚äó y ‚äó z) = x ‚äó (y ‚äó z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk8e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G2 (G1 A)) (<span class="nv">y</span> : G2 (G1 B))
  (<span class="nv">z</span> : G2 (G1 C)), map Œ± (x ‚äó y ‚äó z) = x ‚äó (y ‚äó z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk8f"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G2 (G1 B)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>G2 (G1 C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map Œ± (x ‚äó y ‚äó z) = x ‚äó (y ‚äó z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk90"><span class="nb">unfold</span> transparent tcs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G2 (G1 B)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>G2 (G1 C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map Œ±)
  (map mult
     (fst (map mult (fst (x, y) ‚äó snd (x, y)), z)
      ‚äó snd (map mult (fst (x, y) ‚äó snd (x, y)), z))) =
map mult
  (fst (x, map mult (fst (y, z) ‚äó snd (y, z)))
   ‚äó snd (x, map mult (fst (y, z) ‚äó snd (y, z))))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk91"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G2 (G1 B)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>G2 (G1 C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map Œ±) (map mult (map mult (x ‚äó y) ‚äó z)) =
map mult (x ‚äó map mult (y ‚äó z))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk92"><span class="nb">replace</span> (map (F := G2) (mult (F := G1)) (x ‚äó y) ‚äó z) <span class="kr">with</span>
        (map (F := G2) (map_tensor (mult (F := G1)) id) ((x ‚äó y) ‚äó z)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G2 (G1 B)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>G2 (G1 C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map Œ±)
  (map mult (map (map_tensor mult id) (x ‚äó y ‚äó z))) =
map mult (x ‚äó map mult (y ‚äó z))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="applicative-v-chk93" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G2 (G1 B)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>G2 (G1 C)</span></span></span><br></div><label class="goal-separator" for="applicative-v-chk93"><hr></label><div class="goal-conclusion">map (map_tensor mult id) (x ‚äó y ‚äó z) =
map mult (x ‚äó y) ‚äó z</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk94"><span class="mi">2</span>: {</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G2 (G1 B)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>G2 (G1 C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map_tensor mult id) (x ‚äó y ‚äó z) =
map mult (x ‚äó y) ‚äó z</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk95"><span class="nb">rewrite</span> &lt;- (app_mult_natural (G := G2)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G2 (G1 B)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>G2 (G1 C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map mult (x ‚äó y) ‚äó map id z = map mult (x ‚äó y) ‚äó z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">         </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> fun_map_id.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk96">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G2 (G1 B)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>G2 (G1 C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map Œ±)
  (map mult (map (map_tensor mult id) (x ‚äó y ‚äó z))) =
map mult (x ‚äó map mult (y ‚äó z))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk97">compose near (x ‚äó y ‚äó z) on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G2 (G1 B)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>G2 (G1 C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map Œ±)
  ((map mult ‚àò map (map_tensor mult id)) (x ‚äó y ‚äó z)) =
map mult (x ‚äó map mult (y ‚äó z))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk98"><span class="nb">rewrite</span> fun_map_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G2 (G1 B)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>G2 (G1 C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map Œ±)
  (map (mult ‚àò map_tensor mult id) (x ‚äó y ‚äó z)) =
map mult (x ‚äó map mult (y ‚äó z))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk99">compose near (x ‚äó y ‚äó z) on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G2 (G1 B)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>G2 (G1 C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (map Œ±) ‚àò map (mult ‚àò map_tensor mult id))
  (x ‚äó y ‚äó z) = map mult (x ‚äó map mult (y ‚äó z))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk9a"><span class="nb">rewrite</span> fun_map_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G2 (G1 B)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>G2 (G1 C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map Œ± ‚àò (mult ‚àò map_tensor mult id)) (x ‚äó y ‚äó z) =
map mult (x ‚äó map mult (y ‚äó z))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk9b"><span class="nb">replace</span> (x ‚äó map mult (y ‚äó z)) <span class="kr">with</span>
        (map (map_tensor id mult) (x ‚äó (y ‚äó z))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G2 (G1 B)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>G2 (G1 C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map Œ± ‚àò (mult ‚àò map_tensor mult id)) (x ‚äó y ‚äó z) =
map mult (map (map_tensor id mult) (x ‚äó (y ‚äó z)))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="applicative-v-chk9c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G2 (G1 B)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>G2 (G1 C)</span></span></span><br></div><label class="goal-separator" for="applicative-v-chk9c"><hr></label><div class="goal-conclusion">map (map_tensor id mult) (x ‚äó (y ‚äó z)) =
x ‚äó map mult (y ‚äó z)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk9d"><span class="mi">2</span>: {</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G2 (G1 B)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>G2 (G1 C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map_tensor id mult) (x ‚äó (y ‚äó z)) =
x ‚äó map mult (y ‚äó z)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk9e"><span class="nb">rewrite</span> &lt;- app_mult_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G2 (G1 B)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>G2 (G1 C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map id x ‚äó map mult (y ‚äó z) = x ‚äó map mult (y ‚äó z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">         </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk9f"><span class="nb">rewrite</span> fun_map_id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G2 (G1 B)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>G2 (G1 C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">id x ‚äó map mult (y ‚äó z) = x ‚äó map mult (y ‚äó z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">         </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chka0">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G2 (G1 B)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>G2 (G1 C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map Œ± ‚àò (mult ‚àò map_tensor mult id)) (x ‚äó y ‚äó z) =
map mult (map (map_tensor id mult) (x ‚äó (y ‚äó z)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chka1">compose near (x ‚äó (y ‚äó z)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G2 (G1 B)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>G2 (G1 C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map Œ± ‚àò (mult ‚àò map_tensor mult id)) (x ‚äó y ‚äó z) =
(map mult ‚àò map (map_tensor id mult)) (x ‚äó (y ‚äó z))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chka2"><span class="nb">rewrite</span> fun_map_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G2 (G1 B)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>G2 (G1 C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map Œ± ‚àò (mult ‚àò map_tensor mult id)) (x ‚äó y ‚äó z) =
map (mult ‚àò map_tensor id mult) (x ‚äó (y ‚äó z))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chka3"><span class="nb">rewrite</span> &lt;- app_assoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G2 (G1 B)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>G2 (G1 C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map Œ± ‚àò (mult ‚àò map_tensor mult id)) (x ‚äó y ‚äó z) =
map (mult ‚àò map_tensor id mult) (map Œ± (x ‚äó y ‚äó z))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chka4">compose near (x ‚äó y ‚äó z) on <span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G2 (G1 B)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>G2 (G1 C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map Œ± ‚àò (mult ‚àò map_tensor mult id)) (x ‚äó y ‚äó z) =
(map (mult ‚àò map_tensor id mult) ‚àò map Œ±) (x ‚äó y ‚äó z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chka5"><span class="nb">rewrite</span> fun_map_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G2 (G1 B)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>G2 (G1 C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map Œ± ‚àò (mult ‚àò map_tensor mult id)) (x ‚äó y ‚äó z) =
map (mult ‚àò map_tensor id mult ‚àò Œ±) (x ‚äó y ‚äó z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chka6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G2 (G1 B)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>G2 (G1 C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map Œ± ‚àò (mult ‚àò map_tensor mult id)) (x ‚äó y ‚äó z) =
map (mult ‚àò map_tensor id mult ‚àò Œ±) (x ‚äó y ‚äó z)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chka7">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G2 (G1 B)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>G2 (G1 C)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map Œ± ‚àò (mult ‚àò map_tensor mult id) =
mult ‚àò map_tensor id mult ‚àò Œ±</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chka8">ext [[ga gb] gc].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G2 (G1 B)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>G2 (G1 C)</span></span></span><br><span><var>ga</var><span class="hyp-type"><b>: </b><span>G1 A</span></span></span><br><span><var>gb</var><span class="hyp-type"><b>: </b><span>G1 B</span></span></span><br><span><var>gc</var><span class="hyp-type"><b>: </b><span>G1 C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map Œ± ‚àò (mult ‚àò map_tensor mult id)) (ga, gb, gc) =
(mult ‚àò map_tensor id mult ‚àò Œ±) (ga, gb, gc)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chka9"><span class="nb">unfold</span> compose, id; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G2 (G1 B)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>G2 (G1 C)</span></span></span><br><span><var>ga</var><span class="hyp-type"><b>: </b><span>G1 A</span></span></span><br><span><var>gb</var><span class="hyp-type"><b>: </b><span>G1 B</span></span></span><br><span><var>gc</var><span class="hyp-type"><b>: </b><span>G1 C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map Œ± (ga ‚äó gb ‚äó gc) = ga ‚äó (gb ‚äó gc)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkaa"><span class="nb">rewrite</span> app_assoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G2 (G1 B)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>G2 (G1 C)</span></span></span><br><span><var>ga</var><span class="hyp-type"><b>: </b><span>G1 A</span></span></span><br><span><var>gb</var><span class="hyp-type"><b>: </b><span>G1 B</span></span></span><br><span><var>gc</var><span class="hyp-type"><b>: </b><span>G1 C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ga ‚äó (gb ‚äó gc) = ga ‚äó (gb ‚äó gc)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkab"><span class="kn">Theorem</span> <span class="nf">app_unital_l_compose</span> : <span class="kr">forall</span> <span class="nv">A</span> (<span class="nv">x</span> : G2 (G1 A)),
      map (F := G2 ‚àò G1) left_unitor (pure (F := G2 ‚àò G1) tt ‚äó x) = x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G2 (G1 A)),
map left_unitor (pure tt ‚äó x) = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkac"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G2 (G1 A)),
map left_unitor (pure tt ‚äó x) = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkad"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map left_unitor (pure tt ‚äó x) = x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkae"><span class="nb">unfold</span> transparent tcs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map left_unitor)
  (map mult
     (fst (pure (pure tt), x)
      ‚äó snd (pure (pure tt), x))) = x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkaf"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map left_unitor) (map mult (pure (pure tt) ‚äó x)) =
x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkb0">compose near (pure (F := G2) (pure (F := G1) tt) ‚äó x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (map left_unitor) ‚àò map mult)
  (pure (pure tt) ‚äó x) = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkb1"><span class="nb">rewrite</span> fun_map_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map left_unitor ‚àò mult) (pure (pure tt) ‚äó x) = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkb2"><span class="nb">rewrite</span> triangle_3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map left_unitor ‚àò mult) (strength (pure tt, x)) =
x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkb3"><span class="nb">unfold</span> strength.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map left_unitor ‚àò mult) (map (pair (pure tt)) x) =
x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkb4">compose near x on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (map left_unitor ‚àò mult) ‚àò map (pair (pure tt)))
  x = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkb5"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map left_unitor ‚àò mult ‚àò pair (pure tt)) x = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkb6"><span class="nb">rewrite</span> weird_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map id x = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkb7"><span class="nb">rewrite</span> (fun_map_id).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">id x = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkb8"><span class="kn">Theorem</span> <span class="nf">app_unital_r_compose</span> : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : (G2 ‚àò G1) A),
      map (F := G2 ‚àò G1) right_unitor (x ‚äó pure (F := G2 ‚àò G1) tt) = x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : (G2 ‚àò G1) A),
map right_unitor (x ‚äó pure tt) = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkb9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : (G2 ‚àò G1) A),
map right_unitor (x ‚äó pure tt) = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkba"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>(G2 ‚àò G1) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map right_unitor (x ‚äó pure tt) = x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkbb"><span class="nb">unfold</span> compose <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map right_unitor (x ‚äó pure tt) = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkbc"><span class="nb">unfold</span> transparent tcs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map right_unitor)
  (map mult
     (fst (x, pure (pure tt))
      ‚äó snd (x, pure (pure tt)))) = x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkbd"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map right_unitor) (map mult (x ‚äó pure (pure tt))) =
x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkbe">compose near (x ‚äó pure (F := G2) (pure (F := G1) tt)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (map right_unitor) ‚àò map mult)
  (x ‚äó pure (pure tt)) = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkbf"><span class="nb">rewrite</span> fun_map_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map right_unitor ‚àò mult) (x ‚äó pure (pure tt)) = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkc0"><span class="nb">rewrite</span> triangle_4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map right_unitor ‚àò mult)
  (map (<span class="kr">fun</span> <span class="nv">b</span> : G1 A =&gt; (b, pure tt)) x) = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkc1">compose near x on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (map right_unitor ‚àò mult)
 ‚àò map (<span class="kr">fun</span> <span class="nv">b</span> : G1 A =&gt; (b, pure tt))) x = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkc2"><span class="nb">rewrite</span> fun_map_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (map right_unitor ‚àò mult
   ‚àò (<span class="kr">fun</span> <span class="nv">b</span> : G1 A =&gt; (b, pure tt))) x = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkc3"><span class="nb">rewrite</span> weird_2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map id x = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkc4"><span class="nb">rewrite</span> (fun_map_id).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">id x = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkc5"><span class="kn">Lemma</span> <span class="nf">app_mult_pure_compose</span> : <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
      pure (F := G2 ‚àò G1) a ‚äó pure (F := G2 ‚àò G1) b =
        pure (F := G2 ‚àò G1) (a, b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
pure a ‚äó pure b = pure (a, b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkc6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
pure a ‚äó pure b = pure (a, b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkc7"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure a ‚äó pure b = pure (a, b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkc8"><span class="nb">unfold</span> transparent tcs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map mult
  (fst (pure (pure a), pure (pure b))
   ‚äó snd (pure (pure a), pure (pure b))) =
pure (pure (a, b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkc9"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map mult (pure (pure a) ‚äó pure (pure b)) =
pure (pure (a, b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkca"><span class="nb">assert</span> (square: <span class="kr">forall</span> (<span class="nv">p</span> : G1 A * G1 B),
               map mult (pure (F := G2) p) = pure (F := G2) (mult p)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">p</span> : G1 A * G1 B,
map mult (pure p) = pure (mult p)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="applicative-v-chkcb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>square</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : G1 A * G1 B,
map mult (pure p) = pure (mult p)</span></span></span><br></div><label class="goal-separator" for="applicative-v-chkcb"><hr></label><div class="goal-conclusion">map mult (pure (pure a) ‚äó pure (pure b)) =
pure (pure (a, b))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkcc">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">p</span> : G1 A * G1 B,
map mult (pure p) = pure (mult p)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkcd"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>G1 A * G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map mult (pure p) = pure (mult p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkce"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>G1 A * G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (mult p) = pure (mult p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkcf">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>square</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : G1 A * G1 B,
map mult (pure p) = pure (mult p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map mult (pure (pure a) ‚äó pure (pure b)) =
pure (pure (a, b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkd0"><span class="nb">rewrite</span> &lt;- (app_mult_pure (G := G1)). <span class="c">(* top triangle *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>square</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : G1 A * G1 B,
map mult (pure p) = pure (mult p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map mult (pure (pure a) ‚äó pure (pure b)) =
pure (pure a ‚äó pure b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkd1"><span class="nb">rewrite</span> &lt;- square. <span class="c">(* bottom right square *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>square</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : G1 A * G1 B,
map mult (pure p) = pure (mult p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map mult (pure (pure a) ‚äó pure (pure b)) =
map mult (pure (pure a, pure b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkd2"><span class="nb">rewrite</span> &lt;- (app_mult_pure (G := G2)). <span class="c">(* bottom left triangle *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>square</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : G1 A * G1 B,
map mult (pure p) = pure (mult p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map mult (pure (pure a) ‚äó pure (pure b)) =
map mult (pure (pure a) ‚äó pure (pure b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export, program] <span class="kn">Instance</span> <span class="nf">Applicative_compose</span> : Applicative (G2 ‚àò G1) :=
    {| app_pure_natural := app_pure_nat_compose;
       app_mult_natural := app_mult_nat_compose;
       app_assoc := app_asc_compose;
       app_unital_l := app_unital_l_compose;
       app_unital_r := app_unital_r_compose;
       app_mult_pure := app_mult_pure_compose;
    |}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">applicative_compose</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Composing applicative functors with the identity *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">applicative_compose_laws</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    `{Applicative G}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkd3"><span class="kn">Theorem</span> <span class="nf">Pure_compose_identity1</span> :
    Pure_compose G (<span class="kr">fun</span> <span class="nv">A</span> =&gt; A) = @pure G _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Pure_compose G (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) = @pure G H0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkd4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Pure_compose G (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) = @pure G H0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkd5"><span class="kn">Theorem</span> <span class="nf">Pure_compose_identity2</span> :
    Pure_compose (<span class="kr">fun</span> <span class="nv">A</span> =&gt; A) G = @pure G _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Pure_compose (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) G = @pure G H0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkd6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Pure_compose (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) G = @pure G H0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkd7"><span class="kn">Theorem</span> <span class="nf">Mult_compose_identity1</span> :
    Mult_compose G (<span class="kr">fun</span> <span class="nv">A</span> =&gt; A) = @mult G _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Mult_compose G (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) = @mult G H1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkd8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Mult_compose G (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) = @mult G H1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkd9">ext A B [x y].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>(G ‚àò (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)) A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>(G ‚àò (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A)) B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Mult_compose G (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) A B (x, y) = x ‚äó y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkda"><span class="nb">cbv</span> <span class="kr">in</span> x, y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Mult_compose G (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) A B (x, y) = x ‚äó y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkdb"><span class="nb">unfold</span> Mult_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map mult (fst (x, y) ‚äó snd (x, y)) = x ‚äó y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkdc"><span class="nb">rewrite</span> (fun_map_id).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">id (fst (x, y) ‚äó snd (x, y)) = x ‚äó y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkdd"><span class="kn">Theorem</span> <span class="nf">Mult_compose_identity2</span> :
    Mult_compose (<span class="kr">fun</span> <span class="nv">A</span> =&gt; A) G = @mult G _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Mult_compose (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) G = @mult G H1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkde"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Mult_compose (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) G = @mult G H1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkdf">ext A B [x y].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>((<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) ‚àò G) A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>((<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) ‚àò G) B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Mult_compose (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) G A B (x, y) = x ‚äó y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chke0"><span class="nb">cbv</span> <span class="kr">in</span> x, y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Mult_compose (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) G A B (x, y) = x ‚äó y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chke1"><span class="nb">unfold</span> Mult_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map mult (fst (x, y) ‚äó snd (x, y)) = x ‚äó y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">applicative_compose_laws</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Parallel composition of applicative morphisms *)</span>
<span class="sd">(******************************************************************************)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">applicative_compose_laws</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chke2">#[export] <span class="kn">Instance</span> <span class="nf">ApplicativeMorphism_parallel</span>
    (<span class="nv">F1</span> <span class="nv">F2</span> <span class="nv">G1</span> <span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    `{Applicative G1}
    `{Applicative G2}
    `{Applicative F1}
    `{Applicative F2}
    `{! ApplicativeMorphism F1 G1 œï1}
    `{! ApplicativeMorphism F2 G2 œï2} :
  ApplicativeMorphism (F1 ‚àò F2) (G1 ‚àò G2) (<span class="kr">fun</span> <span class="nv">A</span> =&gt; œï1 (G2 A) ‚àò map (F := F1) (œï2 A)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ApplicativeMorphism (F1 ‚àò F2) (G1 ‚àò G2)
  (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; œï1 (G2 A) ‚àò map (œï2 A))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chke3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ApplicativeMorphism (F1 ‚àò F2) (G1 ‚àò G2)
  (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; œï1 (G2 A) ‚àò map (œï2 A))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chke4"><span class="nb">inversion</span> ApplicativeMorphism0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ApplicativeMorphism (F1 ‚àò F2) (G1 ‚àò G2)
  (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; œï1 (G2 A) ‚àò map (œï2 A))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chke5"><span class="nb">inversion</span> ApplicativeMorphism1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ApplicativeMorphism (F1 ‚àò F2) (G1 ‚àò G2)
  (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; œï1 (G2 A) ‚àò map (œï2 A))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chke6"><span class="nb">constructor</span>; <span class="kp">try</span> <span class="nb">typeclasses eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : (F1 ‚àò F2) A),
(œï1 (G2 B) ‚àò map (œï2 B)) (map f x) =
map f ((œï1 (G2 A) ‚àò map (œï2 A)) x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="applicative-v-chke7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br></div><label class="goal-separator" for="applicative-v-chke7"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
(œï1 (G2 A) ‚àò map (œï2 A)) (pure a) = pure a</div></blockquote><input class="alectryon-extra-goal-toggle" id="applicative-v-chke8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br></div><label class="goal-separator" for="applicative-v-chke8"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : (F1 ‚àò F2) A) 
  (<span class="nv">y</span> : (F1 ‚àò F2) B),
(œï1 (G2 (A * B)) ‚àò map (œï2 (A * B))) (x ‚äó y) =
(œï1 (G2 A) ‚àò map (œï2 A)) x
‚äó (œï1 (G2 B) ‚àò map (œï2 B)) y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chke9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : (F1 ‚àò F2) A),
(œï1 (G2 B) ‚àò map (œï2 B)) (map f x) =
map f ((œï1 (G2 A) ‚àò map (œï2 A)) x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkea"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>(F1 ‚àò F2) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(œï1 (G2 B) ‚àò map (œï2 B)) (map f x) =
map f ((œï1 (G2 A) ‚àò map (œï2 A)) x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkeb">unfold_ops @Map_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>(F1 ‚àò F2) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(œï1 (G2 B) ‚àò map (œï2 B)) (map (map f) x) =
map (map f) ((œï1 (G2 A) ‚àò map (œï2 A)) x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkec"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>(F1 ‚àò F2) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï1 (G2 B) (map (œï2 B) (map (map f) x)) =
map (map f) (œï1 (G2 A) (map (œï2 A) x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chked">compose near x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>(F1 ‚àò F2) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï1 (G2 B) ((map (œï2 B) ‚àò map (map f)) x) =
map (map f) ((œï1 (G2 A) ‚àò map (œï2 A)) x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkee" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkee"><span class="nb">rewrite</span> (fun_map_map (F := F1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>(F1 ‚àò F2) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï1 (G2 B) (map (œï2 B ‚àò map f) x) =
map (map f) ((œï1 (G2 A) ‚àò map (œï2 A)) x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkef"><span class="nb">assert</span> (appmor_natural1&#39; :
               <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
                 œï2 B ‚àò map (F := F2) f = map (F := G2) f ‚àò œï2 A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>(F1 ‚àò F2) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
œï2 B ‚àò map f = map f ‚àò œï2 A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="applicative-v-chkf0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>(F1 ‚àò F2) A</span></span></span><br><span><var>appmor_natural1'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
œï2 B ‚àò map f = map f ‚àò œï2 A</span></span></span><br></div><label class="goal-separator" for="applicative-v-chkf0"><hr></label><div class="goal-conclusion">œï1 (G2 B) (map (œï2 B ‚àò map f) x) =
map (map f) ((œï1 (G2 A) ‚àò map (œï2 A)) x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkf1">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>(F1 ‚àò F2) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
œï2 B ‚àò map f = map f ‚àò œï2 A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkf2"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>(F1 ‚àò F2) A</span></span></span><br><span><var>A0, B0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>A0 -&gt; B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï2 B0 ‚àò map f0 = map f0 ‚àò œï2 A0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkf3" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkf3">ext f2a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>(F1 ‚àò F2) A</span></span></span><br><span><var>A0, B0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>A0 -&gt; B0</span></span></span><br><span><var>f2a</var><span class="hyp-type"><b>: </b><span>F2 A0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(œï2 B0 ‚àò map f0) f2a = (map f0 ‚àò œï2 A0) f2a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> appmor_natural1.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkf4">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>(F1 ‚àò F2) A</span></span></span><br><span><var>appmor_natural1'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
œï2 B ‚àò map f = map f ‚àò œï2 A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï1 (G2 B) (map (œï2 B ‚àò map f) x) =
map (map f) ((œï1 (G2 A) ‚àò map (œï2 A)) x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkf5" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkf5"><span class="nb">rewrite</span> appmor_natural1&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>(F1 ‚àò F2) A</span></span></span><br><span><var>appmor_natural1'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
œï2 B ‚àò map f = map f ‚àò œï2 A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï1 (G2 B) (map (map f ‚àò œï2 A) x) =
map (map f) ((œï1 (G2 A) ‚àò map (œï2 A)) x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkf6"><span class="nb">rewrite</span> &lt;- (fun_map_map (F := F1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>(F1 ‚àò F2) A</span></span></span><br><span><var>appmor_natural1'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
œï2 B ‚àò map f = map f ‚àò œï2 A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï1 (G2 B) ((map (map f) ‚àò map (œï2 A)) x) =
map (map f) ((œï1 (G2 A) ‚àò map (œï2 A)) x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkf7" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkf7"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>(F1 ‚àò F2) A</span></span></span><br><span><var>appmor_natural1'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
œï2 B ‚àò map f = map f ‚àò œï2 A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï1 (G2 B) (map (map f) (map (œï2 A) x)) =
map (map f) (œï1 (G2 A) (map (œï2 A) x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkf8"><span class="nb">rewrite</span> appmor_natural0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>(F1 ‚àò F2) A</span></span></span><br><span><var>appmor_natural1'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
œï2 B ‚àò map f = map f ‚àò œï2 A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map f) (œï1 (G2 A) (map (œï2 A) x)) =
map (map f) (œï1 (G2 A) (map (œï2 A) x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkf9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
(œï1 (G2 A) ‚àò map (œï2 A)) (pure a) = pure a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkfa" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkfa"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(œï1 (G2 A) ‚àò map (œï2 A)) (pure a) = pure a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkfb">unfold_ops @Pure_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(œï1 (G2 A) ‚àò map (œï2 A)) (pure (pure a)) =
pure (pure a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkfc"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï1 (G2 A) (map (œï2 A) (pure (pure a))) = pure (pure a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkfd"><span class="nb">rewrite</span> (app_pure_natural (G := F1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï1 (G2 A) (pure (œï2 A (pure a))) = pure (pure a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkfe"><span class="nb">rewrite</span> appmor_pure0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (œï2 A (pure a)) = pure (pure a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chkff" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chkff"><span class="nb">rewrite</span> appmor_pure1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (pure a) = pure (pure a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk100">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : (F1 ‚àò F2) A)
  (<span class="nv">y</span> : (F1 ‚àò F2) B),
(œï1 (G2 (A * B)) ‚àò map (œï2 (A * B))) (x ‚äó y) =
(œï1 (G2 A) ‚àò map (œï2 A)) x
‚äó (œï1 (G2 B) ‚àò map (œï2 B)) y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk101" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk101"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>(F1 ‚àò F2) A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>(F1 ‚àò F2) B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(œï1 (G2 (A * B)) ‚àò map (œï2 (A * B))) (x ‚äó y) =
(œï1 (G2 A) ‚àò map (œï2 A)) x
‚äó (œï1 (G2 B) ‚àò map (œï2 B)) y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk102">unfold_ops @Mult_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>(F1 ‚àò F2) A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>(F1 ‚àò F2) B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(œï1 (G2 (A * B)) ‚àò map (œï2 (A * B)))
  (map mult (fst (x, y) ‚äó snd (x, y))) =
map mult
  (fst
     ((œï1 (G2 A) ‚àò map (œï2 A)) x,
      (œï1 (G2 B) ‚àò map (œï2 B)) y)
   ‚äó snd
       ((œï1 (G2 A) ‚àò map (œï2 A)) x,
        (œï1 (G2 B) ‚àò map (œï2 B)) y))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk103" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk103"><span class="nb">unfold</span> compose <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>F1 (F2 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>F1 (F2 B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï1 (G2 (A * B))
  (map (œï2 (A * B))
     (map mult (fst (x, y) ‚äó snd (x, y)))) =
map mult
  (fst
     (œï1 (G2 A) (map (œï2 A) x),
      œï1 (G2 B) (map (œï2 B) y))
   ‚äó snd
       (œï1 (G2 A) (map (œï2 A) x),
        œï1 (G2 B) (map (œï2 B) y)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk104"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>F1 (F2 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>F1 (F2 B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï1 (G2 (A * B)) (map (œï2 (A * B)) (map mult (x ‚äó y))) =
map mult
  (œï1 (G2 A) (map (œï2 A) x) ‚äó œï1 (G2 B) (map (œï2 B) y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk105" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk105">compose near (x ‚äó y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>F1 (F2 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>F1 (F2 B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï1 (G2 (A * B))
  ((map (œï2 (A * B)) ‚àò map mult) (x ‚äó y)) =
map mult
  (œï1 (G2 A) (map (œï2 A) x) ‚äó œï1 (G2 B) (map (œï2 B) y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk106" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk106"><span class="nb">rewrite</span> (fun_map_map (F := F1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>F1 (F2 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>F1 (F2 B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï1 (G2 (A * B)) (map (œï2 (A * B) ‚àò mult) (x ‚äó y)) =
map mult
  (œï1 (G2 A) (map (œï2 A) x) ‚äó œï1 (G2 B) (map (œï2 B) y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk107" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk107"><span class="nb">assert</span> (appmor_mult1&#39; :
               <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>),
                 œï2 (A * B) ‚àò mult (F := F2) =
                   mult (F := G2) ‚àò map_tensor (œï2 A) (œï2 B)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>F1 (F2 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>F1 (F2 B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>,
œï2 (A * B) ‚àò mult = mult ‚àò map_tensor (œï2 A) (œï2 B)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="applicative-v-chk108" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>F1 (F2 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>F1 (F2 B)</span></span></span><br><span><var>appmor_mult1'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>,
œï2 (A * B) ‚àò mult =
mult ‚àò map_tensor (œï2 A) (œï2 B)</span></span></span><br></div><label class="goal-separator" for="applicative-v-chk108"><hr></label><div class="goal-conclusion">œï1 (G2 (A * B)) (map (œï2 (A * B) ‚àò mult) (x ‚äó y)) =
map mult
  (œï1 (G2 A) (map (œï2 A) x) ‚äó œï1 (G2 B) (map (œï2 B) y))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk109" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk109">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>F1 (F2 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>F1 (F2 B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>,
œï2 (A * B) ‚àò mult = mult ‚àò map_tensor (œï2 A) (œï2 B)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk10a" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk10a"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>F1 (F2 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>F1 (F2 B)</span></span></span><br><span><var>A0, B0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï2 (A0 * B0) ‚àò mult =
mult ‚àò map_tensor (œï2 A0) (œï2 B0)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk10b" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk10b">ext [x&#39; y&#39;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>F1 (F2 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>F1 (F2 B)</span></span></span><br><span><var>A0, B0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>F2 A0</span></span></span><br><span><var>y'</var><span class="hyp-type"><b>: </b><span>F2 B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(œï2 (A0 * B0) ‚àò mult) (x&#39;, y&#39;) =
(mult ‚àò map_tensor (œï2 A0) (œï2 B0)) (x&#39;, y&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk10c"><span class="nb">unfold</span> compose; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>F1 (F2 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>F1 (F2 B)</span></span></span><br><span><var>A0, B0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>F2 A0</span></span></span><br><span><var>y'</var><span class="hyp-type"><b>: </b><span>F2 B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï2 (A0 * B0) (x&#39; ‚äó y&#39;) = œï2 A0 x&#39; ‚äó œï2 B0 y&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk10d" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk10d"><span class="nb">rewrite</span> appmor_mult1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>F1 (F2 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>F1 (F2 B)</span></span></span><br><span><var>A0, B0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>F2 A0</span></span></span><br><span><var>y'</var><span class="hyp-type"><b>: </b><span>F2 B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï2 A0 x&#39; ‚äó œï2 B0 y&#39; = œï2 A0 x&#39; ‚äó œï2 B0 y&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk10e" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk10e">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>F1 (F2 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>F1 (F2 B)</span></span></span><br><span><var>appmor_mult1'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>,
œï2 (A * B) ‚àò mult =
mult ‚àò map_tensor (œï2 A) (œï2 B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï1 (G2 (A * B)) (map (œï2 (A * B) ‚àò mult) (x ‚äó y)) =
map mult
  (œï1 (G2 A) (map (œï2 A) x) ‚äó œï1 (G2 B) (map (œï2 B) y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk10f" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk10f"><span class="nb">rewrite</span> appmor_mult1&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>F1 (F2 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>F1 (F2 B)</span></span></span><br><span><var>appmor_mult1'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>,
œï2 (A * B) ‚àò mult =
mult ‚àò map_tensor (œï2 A) (œï2 B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï1 (G2 (A * B))
  (map (mult ‚àò map_tensor (œï2 A) (œï2 B)) (x ‚äó y)) =
map mult
  (œï1 (G2 A) (map (œï2 A) x) ‚äó œï1 (G2 B) (map (œï2 B) y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk110" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk110"><span class="nb">rewrite</span> appmor_natural0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>F1 (F2 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>F1 (F2 B)</span></span></span><br><span><var>appmor_mult1'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>,
œï2 (A * B) ‚àò mult =
mult ‚àò map_tensor (œï2 A) (œï2 B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mult ‚àò map_tensor (œï2 A) (œï2 B))
  (œï1 (F2 A * F2 B) (x ‚äó y)) =
map mult
  (œï1 (G2 A) (map (œï2 A) x) ‚äó œï1 (G2 B) (map (œï2 B) y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk111"><span class="nb">rewrite</span> &lt;- (fun_map_map (F := G1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>F1 (F2 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>F1 (F2 B)</span></span></span><br><span><var>appmor_mult1'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>,
œï2 (A * B) ‚àò mult =
mult ‚àò map_tensor (œï2 A) (œï2 B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map mult ‚àò map (map_tensor (œï2 A) (œï2 B)))
  (œï1 (F2 A * F2 B) (x ‚äó y)) =
map mult
  (œï1 (G2 A) (map (œï2 A) x) ‚äó œï1 (G2 B) (map (œï2 B) y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk112" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk112"><span class="nb">rewrite</span> appmor_mult0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>F1 (F2 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>F1 (F2 B)</span></span></span><br><span><var>appmor_mult1'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>,
œï2 (A * B) ‚àò mult =
mult ‚àò map_tensor (œï2 A) (œï2 B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map mult ‚àò map (map_tensor (œï2 A) (œï2 B)))
  (œï1 (F2 A) x ‚äó œï1 (F2 B) y) =
map mult
  (œï1 (G2 A) (map (œï2 A) x) ‚äó œï1 (G2 B) (map (œï2 B) y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk113" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk113"><span class="nb">unfold</span> compose; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>F1 (F2 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>F1 (F2 B)</span></span></span><br><span><var>appmor_mult1'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>,
œï2 (A * B) ‚àò mult =
mult ‚àò map_tensor (œï2 A) (œï2 B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map mult
  (map (map_tensor (œï2 A) (œï2 B))
     (œï1 (F2 A) x ‚äó œï1 (F2 B) y)) =
map mult
  (œï1 (G2 A) (map (œï2 A) x) ‚äó œï1 (G2 B) (map (œï2 B) y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="c">(* rhs *)</span>
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk114" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk114"><span class="nb">rewrite</span> appmor_natural0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>F1 (F2 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>F1 (F2 B)</span></span></span><br><span><var>appmor_mult1'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>,
œï2 (A * B) ‚àò mult =
mult ‚àò map_tensor (œï2 A) (œï2 B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map mult
  (map (map_tensor (œï2 A) (œï2 B))
     (œï1 (F2 A) x ‚äó œï1 (F2 B) y)) =
map mult
  (map (œï2 A) (œï1 (F2 A) x) ‚äó œï1 (G2 B) (map (œï2 B) y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk115" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk115"><span class="nb">rewrite</span> appmor_natural0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>F1 (F2 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>F1 (F2 B)</span></span></span><br><span><var>appmor_mult1'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>,
œï2 (A * B) ‚àò mult =
mult ‚àò map_tensor (œï2 A) (œï2 B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map mult
  (map (map_tensor (œï2 A) (œï2 B))
     (œï1 (F2 A) x ‚äó œï1 (F2 B) y)) =
map mult
  (map (œï2 A) (œï1 (F2 A) x) ‚äó map (œï2 B) (œï1 (F2 B) y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk116" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk116"><span class="nb">rewrite</span> (app_mult_natural (G := G1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H11</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H12</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H13</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H14</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism1</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br><span><var>appmor_app_F0</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>appmor_app_G0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>appmor_natural0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F1 A),
œï1 B (map f x) = map f (œï1 A x)</span></span></span><br><span><var>appmor_pure0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï1 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F1 A) (<span class="nv">y</span> : F1 B),
œï1 (A * B) (x ‚äó y) = œï1 A x ‚äó œï1 B y</span></span></span><br><span><var>appmor_app_F1</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>appmor_app_G1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>appmor_natural1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">x</span> : F2 A),
œï2 B (map f x) = map f (œï2 A x)</span></span></span><br><span><var>appmor_pure1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
œï2 A (pure a) = pure a</span></span></span><br><span><var>appmor_mult1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">x</span> : F2 A) (<span class="nv">y</span> : F2 B),
œï2 (A * B) (x ‚äó y) = œï2 A x ‚äó œï2 B y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>F1 (F2 A)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>F1 (F2 B)</span></span></span><br><span><var>appmor_mult1'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>,
œï2 (A * B) ‚àò mult =
mult ‚àò map_tensor (œï2 A) (œï2 B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map mult
  (map (map_tensor (œï2 A) (œï2 B))
     (œï1 (F2 A) x ‚äó œï1 (F2 B) y)) =
map mult
  (map (map_tensor (œï2 A) (œï2 B))
     (œï1 (F2 A) x ‚äó œï1 (F2 B) y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk117" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk117">#[export] <span class="kn">Instance</span> <span class="nf">ApplicativeMorphism_parallel_left</span>
    (<span class="nv">F1</span> <span class="nv">F2</span> <span class="nv">G1</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    `{Applicative G1}
    `{Applicative F1}
    `{Applicative F2}
    `{! ApplicativeMorphism F1 G1 œï1} :
    ApplicativeMorphism (F1 ‚àò F2) (G1 ‚àò F2) (<span class="kr">fun</span> <span class="nv">A</span> =&gt; œï1 (F2 A)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ApplicativeMorphism (F1 ‚àò F2) (G1 ‚àò F2) (œï1 ‚óã F2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk118" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk118"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ApplicativeMorphism (F1 ‚àò F2) (G1 ‚àò F2) (œï1 ‚óã F2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk119" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk119"><span class="nb">replace</span> (œï1 ‚óã F2) <span class="kr">with</span> (<span class="kr">fun</span> <span class="nv">A</span> =&gt; œï1 (F2 A) ‚àò map (F := F1) (@id (F2 A))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ApplicativeMorphism (F1 ‚àò F2) (G1 ‚àò F2)
  (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; œï1 (F2 A) ‚àò map id)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="applicative-v-chk11a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br></div><label class="goal-separator" for="applicative-v-chk11a"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; œï1 (F2 A) ‚àò map id) = œï1 ‚óã F2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk11b" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk11b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ApplicativeMorphism (F1 ‚àò F2) (G1 ‚àò F2)
  (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; œï1 (F2 A) ‚àò map id)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (ApplicativeMorphism_parallel F1 F2 G1 F2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk11c" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk11c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; œï1 (F2 A) ‚àò map id) = œï1 ‚óã F2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk11d" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk11d">ext A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F1 A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F1 G1 œï1</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï1 (F2 A) ‚àò map id = œï1 (F2 A)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> (fun_map_id (F := F1)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk11e" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk11e">#[export] <span class="kn">Instance</span> <span class="nf">ApplicativeMorphism_parallel_right</span>
    (<span class="nv">F1</span> <span class="nv">F2</span> <span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    `{Applicative G2}
    `{Applicative F1}
    `{Applicative F2}
    `{! ApplicativeMorphism F2 G2 œï2} :
    ApplicativeMorphism (F1 ‚àò F2) (F1 ‚àò G2) (<span class="kr">fun</span> <span class="nv">A</span> =&gt; map (F := F1) (œï2 A)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ApplicativeMorphism (F1 ‚àò F2) (F1 ‚àò G2)
  (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; map (œï2 A))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk11f" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk11f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ApplicativeMorphism (F1 ‚àò F2) (F1 ‚àò G2)
  (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; map (œï2 A))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk120" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk120"><span class="nb">change</span> (<span class="kr">fun</span> <span class="nv">A</span> =&gt; map (œï2 A)) <span class="kr">with</span>
      ((<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; (<span class="kr">fun</span> <span class="nv">X</span> =&gt; @id (F1 X)) (G2 A) ‚àò map (œï2 A))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, F2, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H10</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, F2 A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism F2 G2 œï2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ApplicativeMorphism (F1 ‚àò F2) (F1 ‚àò G2)
  (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; (@id ‚óã F1) (G2 A) ‚àò map (œï2 A))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (ApplicativeMorphism_parallel F1 F2 F1 G2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk121" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk121">#[export] <span class="kn">Instance</span> <span class="nf">ApplicativeMorphism_parallel_left_id</span>
    (<span class="nv">F2</span> <span class="nv">G1</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    `{Applicative G1}
    `{Applicative F2}
    `{! ApplicativeMorphism (<span class="kr">fun</span> <span class="nv">A</span> =&gt; A) G1 œï1} :
    ApplicativeMorphism F2 (G1 ‚àò F2) (<span class="kr">fun</span> <span class="nv">A</span> =&gt; œï1 (F2 A)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0) A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism
  (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) G1 œï1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ApplicativeMorphism F2 (G1 ‚àò F2) (œï1 ‚óã F2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk122" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk122"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0) A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism
  (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) G1 œï1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ApplicativeMorphism F2 (G1 ‚àò F2) (œï1 ‚óã F2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk123" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk123"><span class="nb">change</span> F2 <span class="kr">with</span> ((<span class="kr">fun</span> <span class="nv">A</span> =&gt; A) ‚àò F2) <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0) A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism
  (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) G1 œï1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ApplicativeMorphism ((<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) ‚àò F2)
  (G1 ‚àò F2) (œï1 ‚óã F2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk124" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk124"><span class="nb">change</span> H3 <span class="kr">with</span> (Map_compose (<span class="kr">fun</span> <span class="nv">X</span> =&gt; X) F2) <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0) A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism
  (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) G1 œï1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ApplicativeMorphism ((<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) ‚àò F2)
  (G1 ‚àò F2) (œï1 ‚óã F2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk125" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk125"><span class="nb">change</span> H5 <span class="kr">with</span> (@mult F2 _) <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0) A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism
  (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) G1 œï1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ApplicativeMorphism ((<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) ‚àò F2)
  (G1 ‚àò F2) (œï1 ‚óã F2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk126" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk126"><span class="nb">rewrite</span> &lt;- (Mult_compose_identity2 F2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0) A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism
  (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) G1 œï1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ApplicativeMorphism ((<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) ‚àò F2)
  (G1 ‚àò F2) (œï1 ‚óã F2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk127" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk127"><span class="nb">change</span> H4 <span class="kr">with</span> (@pure F2 _) <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0) A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism
  (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) G1 œï1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ApplicativeMorphism ((<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) ‚àò F2)
  (G1 ‚àò F2) (œï1 ‚óã F2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk128" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk128"><span class="nb">rewrite</span> &lt;- (Pure_compose_identity2 F2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F2, G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map F2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure F2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult F2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative F2</span></span></span><br><span><var>œï1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0) A -&gt; G1 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism
  (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) G1 œï1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ApplicativeMorphism ((<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) ‚àò F2)
  (G1 ‚àò F2) (œï1 ‚óã F2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (ApplicativeMorphism_parallel_left
             (<span class="kr">fun</span> <span class="nv">X</span> =&gt; X) F2 G1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk129" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk129">#[export] <span class="kn">Instance</span> <span class="nf">ApplicativeMorphism_parallel_right_id</span>
    (<span class="nv">F1</span> <span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    `{Applicative G2}
    `{Applicative F1}
    `{! ApplicativeMorphism (<span class="kr">fun</span> <span class="nv">A</span> =&gt; A) G2 œï2} :
    ApplicativeMorphism F1 (F1 ‚àò G2) (<span class="kr">fun</span> <span class="nv">A</span> =&gt; map (F := F1) (œï2 A)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0) A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism
  (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) G2 œï2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ApplicativeMorphism F1 (F1 ‚àò G2)
  (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; map (œï2 A))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk12a" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk12a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative F1</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0) A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism
  (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) G2 œï2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ApplicativeMorphism F1 (F1 ‚àò G2)
  (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; map (œï2 A))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk12b" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk12b"><span class="kn">Set Printing Implicit</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G2 H H0 H1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>@Applicative F1 H3 H4 H5</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0) A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>@ApplicativeMorphism
  (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) G2 Map_I
  Mult_I Pure_I H H1 H0 œï2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@ApplicativeMorphism F1 (F1 ‚àò G2) H3 H5 H4
  (@Map_compose F1 G2 H H3)
  (@Mult_compose F1 G2 H1 H3 H5)
  (@Pure_compose F1 G2 H0 H4)
  (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; @map F1 H3 A (G2 A) (œï2 A))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk12c" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk12c"><span class="nb">change</span> F1 <span class="kr">with</span> (F1 ‚àò (<span class="kr">fun</span> <span class="nv">A</span> =&gt; A)) <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G2 H H0 H1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>@Applicative F1 H3 H4 H5</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0) A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>@ApplicativeMorphism
  (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) G2 Map_I
  Mult_I Pure_I H H1 H0 œï2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@ApplicativeMorphism (F1 ‚àò (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A))
  (F1 ‚àò G2) H3 H5 H4 (@Map_compose F1 G2 H H3)
  (@Mult_compose F1 G2 H1 H3 H5)
  (@Pure_compose F1 G2 H0 H4)
  (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; @map F1 H3 A (G2 A) (œï2 A))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk12d" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk12d"><span class="nb">change</span> H3 <span class="kr">with</span> (Map_compose F1 (<span class="kr">fun</span> <span class="nv">X</span> =&gt; X)) <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G2 H H0 H1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>@Applicative F1 H3 H4 H5</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0) A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>@ApplicativeMorphism
  (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) G2 Map_I
  Mult_I Pure_I H H1 H0 œï2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@ApplicativeMorphism (F1 ‚àò (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A))
  (F1 ‚àò G2)
  (@Map_compose F1 (<span class="kr">fun</span> <span class="nv">X</span> : <span class="kt">Type</span> =&gt; X) Map_I H3) H5 H4
  (@Map_compose F1 G2 H H3)
  (@Mult_compose F1 G2 H1 H3 H5)
  (@Pure_compose F1 G2 H0 H4)
  (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; @map F1 H3 A (G2 A) (œï2 A))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk12e" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk12e"><span class="nb">change</span> H5 <span class="kr">with</span> (@mult F1 _) <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G2 H H0 H1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>@Applicative F1 H3 H4 H5</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0) A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>@ApplicativeMorphism
  (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) G2 Map_I
  Mult_I Pure_I H H1 H0 œï2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@ApplicativeMorphism (F1 ‚àò (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A))
  (F1 ‚àò G2)
  (@Map_compose F1 (<span class="kr">fun</span> <span class="nv">X</span> : <span class="kt">Type</span> =&gt; X) Map_I H3)
  (@mult F1 H5) H4 (@Map_compose F1 G2 H H3)
  (@Mult_compose F1 G2 H1 H3 H5)
  (@Pure_compose F1 G2 H0 H4)
  (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; @map F1 H3 A (G2 A) (œï2 A))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk12f" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk12f"><span class="nb">rewrite</span> &lt;- (Mult_compose_identity1 F1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G2 H H0 H1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>@Applicative F1 H3 H4 H5</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0) A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>@ApplicativeMorphism
  (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) G2 Map_I
  Mult_I Pure_I H H1 H0 œï2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@ApplicativeMorphism (F1 ‚àò (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A))
  (F1 ‚àò G2)
  (@Map_compose F1 (<span class="kr">fun</span> <span class="nv">X</span> : <span class="kt">Type</span> =&gt; X) Map_I H3)
  (@Mult_compose F1 (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) Mult_I H3 H5)
  H4 (@Map_compose F1 G2 H H3)
  (@Mult_compose F1 G2 H1 H3 H5)
  (@Pure_compose F1 G2 H0 H4)
  (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; @map F1 H3 A (G2 A) (œï2 A))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk130" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk130"><span class="nb">change</span> H4 <span class="kr">with</span> (@pure F1 _) <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G2 H H0 H1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>@Applicative F1 H3 H4 H5</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0) A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>@ApplicativeMorphism
  (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) G2 Map_I
  Mult_I Pure_I H H1 H0 œï2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@ApplicativeMorphism (F1 ‚àò (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A))
  (F1 ‚àò G2)
  (@Map_compose F1 (<span class="kr">fun</span> <span class="nv">X</span> : <span class="kt">Type</span> =&gt; X) Map_I H3)
  (@Mult_compose F1 (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) Mult_I H3 H5)
  (@pure F1 H4) (@Map_compose F1 G2 H H3)
  (@Mult_compose F1 G2 H1 H3 H5)
  (@Pure_compose F1 G2 H0 H4)
  (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; @map F1 H3 A (G2 A) (œï2 A))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk131" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk131"><span class="nb">rewrite</span> &lt;- (Pure_compose_identity1 F1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G2 H H0 H1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map F1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure F1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult F1</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>@Applicative F1 H3 H4 H5</span></span></span><br><span><var>œï2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, (<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; A0) A -&gt; G2 A</span></span></span><br><span><var>ApplicativeMorphism0</var><span class="hyp-type"><b>: </b><span>@ApplicativeMorphism
  (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) G2 Map_I
  Mult_I Pure_I H H1 H0 œï2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@ApplicativeMorphism (F1 ‚àò (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A))
  (F1 ‚àò G2)
  (@Map_compose F1 (<span class="kr">fun</span> <span class="nv">X</span> : <span class="kt">Type</span> =&gt; X) Map_I H3)
  (@Mult_compose F1 (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) Mult_I H3 H5)
  (@Pure_compose F1 (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) Pure_I H4)
  (@Map_compose F1 G2 H H3)
  (@Mult_compose F1 G2 H1 H3 H5)
  (@Pure_compose F1 G2 H0 H4)
  (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; @map F1 H3 A (G2 A) (œï2 A))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (ApplicativeMorphism_parallel_right
             F1 (<span class="kr">fun</span> <span class="nv">X</span> =&gt; X) G2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">applicative_compose_laws</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * The &quot;ap&quot; combinator &lt;&lt; &lt;‚ãÜ&gt; &gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ap</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) `{Map G} `{Mult G} {A B : <span class="kt">Type</span>} :
  G (A -&gt; B) -&gt; G A -&gt; G B
  := <span class="kr">fun</span> <span class="nv">Gf</span> <span class="nv">Ga</span> =&gt; map (<span class="kr">fun</span> &#39;(f, a) =&gt; f a) (Gf ‚äó Ga).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Notation</span> <span class="s2">&quot;Gf &lt;‚ãÜ&gt; Ga&quot;</span> := (ap _ Gf Ga) (<span class="kn">at level</span> <span class="mi">50</span>, <span class="kn">left associativity</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">ApplicativeFunctor_ap</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{Applicative G}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk132" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk132"><span class="kn">Theorem</span> <span class="nf">map_to_ap</span> : <span class="kr">forall</span> `(f : A -&gt; B) (t : G A),
      map f t = pure f &lt;‚ãÜ&gt; t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">t</span> : G A),
@map G H A B f t = @pure G H0 (A -&gt; B) f &lt;‚ãÜ&gt; t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk133" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk133"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">t</span> : G A),
@map G H A B f t = @pure G H0 (A -&gt; B) f &lt;‚ãÜ&gt; t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk134" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk134"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H A B f t = @pure G H0 (A -&gt; B) f &lt;‚ãÜ&gt; t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk135" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk135"><span class="nb">unfold</span> ap; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H A B f t =
@map G H ((A -&gt; B) * A) B (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
  (@pure G H0 (A -&gt; B) f ‚äó t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk136" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk136"><span class="nb">rewrite</span> triangle_3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H A B f t =
@map G H ((A -&gt; B) * A) B (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
  (@strength G H (A -&gt; B) A (f, t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk137" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk137"><span class="nb">unfold</span> strength.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H A B f t =
@map G H ((A -&gt; B) * A) B (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
  (@map G H A ((A -&gt; B) * A) (@pair (A -&gt; B) A f) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk138" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk138">compose near t on <span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H A B f t =
(@map G H ((A -&gt; B) * A) B (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
 ‚àò @map G H A ((A -&gt; B) * A) (@pair (A -&gt; B) A f)) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk139" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk139"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H A B f t =
@map G H A B
  ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a) ‚àò @pair (A -&gt; B) A f) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk13a" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk13a"><span class="kn">Theorem</span> <span class="nf">ap_morphism_1</span> :
    <span class="kr">forall</span> `{ApplicativeMorphism G G2} {A B}
      (x : G (A -&gt; B)) (y : G A),
      œï B (x &lt;‚ãÜ&gt; y) = (œï (A -&gt; B) x) &lt;‚ãÜ&gt; œï A y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H3</span> : Map G) (<span class="nv">H4</span> : Mult G)
  (<span class="nv">H5</span> : Pure G) (<span class="nv">H6</span> : Map G2) (<span class="nv">H7</span> : Mult G2)
  (<span class="nv">H8</span> : Pure G2) (<span class="nv">œï</span> : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G A -&gt; G2 A),
@ApplicativeMorphism G G2 H3 H4 H5 H6 H7 H8 œï -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G (A -&gt; B)) (<span class="nv">y</span> : G A),
œï B (x &lt;‚ãÜ&gt; y) = œï (A -&gt; B) x &lt;‚ãÜ&gt; œï A y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk13b" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk13b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H3</span> : Map G) (<span class="nv">H4</span> : Mult G)
  (<span class="nv">H5</span> : Pure G) (<span class="nv">H6</span> : Map G2) (<span class="nv">H7</span> : Mult G2)
  (<span class="nv">H8</span> : Pure G2) (<span class="nv">œï</span> : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G A -&gt; G2 A),
@ApplicativeMorphism G G2 H3 H4 H5 H6 H7 H8 œï -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G (A -&gt; B)) (<span class="nv">y</span> : G A),
œï B (x &lt;‚ãÜ&gt; y) = œï (A -&gt; B) x &lt;‚ãÜ&gt; œï A y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk13c" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk13c"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>@ApplicativeMorphism G G2 H3 H4 H5 H6 H7 H8 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G (A -&gt; B)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï B (x &lt;‚ãÜ&gt; y) = œï (A -&gt; B) x &lt;‚ãÜ&gt; œï A y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk13d" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk13d"><span class="nb">unfold</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>@ApplicativeMorphism G G2 H3 H4 H5 H6 H7 H8 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G (A -&gt; B)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï B
  (@map G H3 ((A -&gt; B) * A) B (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
     (x ‚äó y)) =
@map G2 H6 ((A -&gt; B) * A) B (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
  (œï (A -&gt; B) x ‚äó œï A y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk13e" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk13e"><span class="nb">rewrite</span> appmor_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>@ApplicativeMorphism G G2 H3 H4 H5 H6 H7 H8 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G (A -&gt; B)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G2 H6 ((A -&gt; B) * A) B (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
  (œï ((A -&gt; B) * A) (x ‚äó y)) =
@map G2 H6 ((A -&gt; B) * A) B (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
  (œï (A -&gt; B) x ‚äó œï A y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk13f" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk13f"><span class="nb">rewrite</span> appmor_mult.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G A -&gt; G2 A</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>@ApplicativeMorphism G G2 H3 H4 H5 H6 H7 H8 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G (A -&gt; B)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G2 H6 ((A -&gt; B) * A) B (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
  (œï (A -&gt; B) x ‚äó œï A y) =
@map G2 H6 ((A -&gt; B) * A) B (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
  (œï (A -&gt; B) x ‚äó œï A y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk140" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk140"><span class="kn">Theorem</span> <span class="nf">ap1</span> : <span class="kr">forall</span> `(t : G A),
      pure id &lt;‚ãÜ&gt; t = t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">t</span> : G A),
@pure G H0 (A -&gt; A) (@id A) &lt;‚ãÜ&gt; t = t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk141" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk141"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">t</span> : G A),
@pure G H0 (A -&gt; A) (@id A) &lt;‚ãÜ&gt; t = t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk142" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk142"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@pure G H0 (A -&gt; A) (@id A) &lt;‚ãÜ&gt; t = t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk143" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk143"><span class="nb">rewrite</span> &lt;- map_to_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H A A (@id A) t = t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> (fun_map_id).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk144" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk144"><span class="kn">Theorem</span> <span class="nf">ap2</span> : <span class="kr">forall</span> `(f : A -&gt; B) (a : A),
      pure f &lt;‚ãÜ&gt; pure a = pure (f a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">a</span> : A),
@pure G H0 (A -&gt; B) f &lt;‚ãÜ&gt; @pure G H0 A a =
@pure G H0 B (f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk145" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk145"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">a</span> : A),
@pure G H0 (A -&gt; B) f &lt;‚ãÜ&gt; @pure G H0 A a =
@pure G H0 B (f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk146" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk146"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@pure G H0 (A -&gt; B) f &lt;‚ãÜ&gt; @pure G H0 A a =
@pure G H0 B (f a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk147" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk147"><span class="nb">unfold</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H ((A -&gt; B) * A) B (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
  (@pure G H0 (A -&gt; B) f ‚äó @pure G H0 A a) =
@pure G H0 B (f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk148" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk148"><span class="nb">rewrite</span> app_mult_pure.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H ((A -&gt; B) * A) B (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
  (@pure G H0 ((A -&gt; B) * A) (f, a)) =
@pure G H0 B (f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> app_pure_natural.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk149" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk149"><span class="kn">Theorem</span> <span class="nf">ap3</span> : <span class="kr">forall</span> `(f : G (A -&gt; B)) (a : A),
      f &lt;‚ãÜ&gt; pure a = pure (<span class="kr">fun</span> <span class="nv">f</span> =&gt; f a) &lt;‚ãÜ&gt; f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : G (A -&gt; B)) (<span class="nv">a</span> : A),
f &lt;‚ãÜ&gt; @pure G H0 A a =
@pure G H0 ((A -&gt; B) -&gt; B) (<span class="kr">fun</span> <span class="nv">f0</span> : A -&gt; B =&gt; f0 a) &lt;‚ãÜ&gt;
f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk14a" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk14a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : G (A -&gt; B)) (<span class="nv">a</span> : A),
f &lt;‚ãÜ&gt; @pure G H0 A a =
@pure G H0 ((A -&gt; B) -&gt; B) (<span class="kr">fun</span> <span class="nv">f0</span> : A -&gt; B =&gt; f0 a) &lt;‚ãÜ&gt;
f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk14b" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk14b"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G (A -&gt; B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f &lt;‚ãÜ&gt; @pure G H0 A a =
@pure G H0 ((A -&gt; B) -&gt; B) (<span class="kr">fun</span> <span class="nv">f</span> : A -&gt; B =&gt; f a) &lt;‚ãÜ&gt;
f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk14c" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk14c"><span class="nb">unfold</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G (A -&gt; B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H ((A -&gt; B) * A) B (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
  (f ‚äó @pure G H0 A a) =
@map G H (((A -&gt; B) -&gt; B) * (A -&gt; B)) B
  (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
  (@pure G H0 ((A -&gt; B) -&gt; B) (<span class="kr">fun</span> <span class="nv">f</span> : A -&gt; B =&gt; f a)
   ‚äó f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk14d" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk14d"><span class="nb">rewrite</span> triangle_3, triangle_4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G (A -&gt; B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H ((A -&gt; B) * A) B (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
  (@map G H (A -&gt; B) ((A -&gt; B) * A)
     (<span class="kr">fun</span> <span class="nv">b</span> : A -&gt; B =&gt; (b, a)) f) =
@map G H (((A -&gt; B) -&gt; B) * (A -&gt; B)) B
  (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
  (@strength G H ((A -&gt; B) -&gt; B) (A -&gt; B)
     (<span class="kr">fun</span> <span class="nv">f</span> : A -&gt; B =&gt; f a, f))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk14e" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk14e"><span class="nb">unfold</span> strength.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G (A -&gt; B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H ((A -&gt; B) * A) B (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
  (@map G H (A -&gt; B) ((A -&gt; B) * A)
     (<span class="kr">fun</span> <span class="nv">b</span> : A -&gt; B =&gt; (b, a)) f) =
@map G H (((A -&gt; B) -&gt; B) * (A -&gt; B)) B
  (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
  (@map G H (A -&gt; B) (((A -&gt; B) -&gt; B) * (A -&gt; B))
     (@pair ((A -&gt; B) -&gt; B) (A -&gt; B)
        (<span class="kr">fun</span> <span class="nv">f</span> : A -&gt; B =&gt; f a)) f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk14f" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk14f">compose near f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G (A -&gt; B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(@map G H ((A -&gt; B) * A) B (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
 ‚àò @map G H (A -&gt; B) ((A -&gt; B) * A)
     (<span class="kr">fun</span> <span class="nv">b</span> : A -&gt; B =&gt; (b, a))) f =
(@map G H (((A -&gt; B) -&gt; B) * (A -&gt; B)) B
   (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
 ‚àò @map G H (A -&gt; B) (((A -&gt; B) -&gt; B) * (A -&gt; B))
     (@pair ((A -&gt; B) -&gt; B) (A -&gt; B)
        (<span class="kr">fun</span> <span class="nv">f</span> : A -&gt; B =&gt; f a))) f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> (fun_map_map).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk150" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk150"><span class="kn">Theorem</span> <span class="nf">ap4</span> : <span class="kr">forall</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : G (B -&gt; C)) (<span class="nv">g</span> : G (A -&gt; B)) (<span class="nv">a</span> : G A),
      (pure compose) &lt;‚ãÜ&gt; f &lt;‚ãÜ&gt; g &lt;‚ãÜ&gt; a =
      f &lt;‚ãÜ&gt; (g &lt;‚ãÜ&gt; a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : G (B -&gt; C))
  (<span class="nv">g</span> : G (A -&gt; B)) (<span class="nv">a</span> : G A),
@pure G H0 ((B -&gt; C) -&gt; (A -&gt; B) -&gt; A -&gt; C)
  (@compose A B C) &lt;‚ãÜ&gt; f &lt;‚ãÜ&gt; g &lt;‚ãÜ&gt; a = f &lt;‚ãÜ&gt; (g &lt;‚ãÜ&gt; a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk151" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk151"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : G (B -&gt; C))
  (<span class="nv">g</span> : G (A -&gt; B)) (<span class="nv">a</span> : G A),
@pure G H0 ((B -&gt; C) -&gt; (A -&gt; B) -&gt; A -&gt; C)
  (@compose A B C) &lt;‚ãÜ&gt; f &lt;‚ãÜ&gt; g &lt;‚ãÜ&gt; a = f &lt;‚ãÜ&gt; (g &lt;‚ãÜ&gt; a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk152" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk152"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G (B -&gt; C)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G (A -&gt; B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@pure G H0 ((B -&gt; C) -&gt; (A -&gt; B) -&gt; A -&gt; C)
  (@compose A B C) &lt;‚ãÜ&gt; f &lt;‚ãÜ&gt; g &lt;‚ãÜ&gt; a = f &lt;‚ãÜ&gt; (g &lt;‚ãÜ&gt; a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk153" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk153"><span class="nb">unfold</span> ap; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G (B -&gt; C)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G (A -&gt; B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H ((A -&gt; C) * A) C (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
  (@map G H (((A -&gt; B) -&gt; A -&gt; C) * (A -&gt; B)) (A -&gt; C)
     (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
     (@map G H
        (((B -&gt; C) -&gt; (A -&gt; B) -&gt; A -&gt; C) * (B -&gt; C))
        ((A -&gt; B) -&gt; A -&gt; C) (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
        (@pure G H0 ((B -&gt; C) -&gt; (A -&gt; B) -&gt; A -&gt; C)
           (@compose A B C) ‚äó f) ‚äó g) ‚äó a) =
@map G H ((B -&gt; C) * B) C (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
  (f
   ‚äó @map G H ((A -&gt; B) * A) B (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
       (g ‚äó a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk154" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk154"><span class="nb">rewrite</span> (app_mult_natural_1 G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G (B -&gt; C)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G (A -&gt; B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (((A -&gt; B) -&gt; A -&gt; C) * (A -&gt; B) * A) C
  ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
   ‚àò @map_fst A (((A -&gt; B) -&gt; A -&gt; C) * (A -&gt; B))
       (A -&gt; C) (<span class="kr">fun</span> &#39;(f, a) =&gt; f a))
  (@map G H
     (((B -&gt; C) -&gt; (A -&gt; B) -&gt; A -&gt; C) * (B -&gt; C))
     ((A -&gt; B) -&gt; A -&gt; C) (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
     (@pure G H0 ((B -&gt; C) -&gt; (A -&gt; B) -&gt; A -&gt; C)
        (@compose A B C) ‚äó f) ‚äó g ‚äó a) =
@map G H ((B -&gt; C) * B) C (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
  (f
   ‚äó @map G H ((A -&gt; B) * A) B (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
       (g ‚äó a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk155" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk155"><span class="nb">rewrite</span> (app_mult_natural_2 G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G (B -&gt; C)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G (A -&gt; B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (((A -&gt; B) -&gt; A -&gt; C) * (A -&gt; B) * A) C
  ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
   ‚àò @map_fst A (((A -&gt; B) -&gt; A -&gt; C) * (A -&gt; B))
       (A -&gt; C) (<span class="kr">fun</span> &#39;(f, a) =&gt; f a))
  (@map G H
     (((B -&gt; C) -&gt; (A -&gt; B) -&gt; A -&gt; C) * (B -&gt; C))
     ((A -&gt; B) -&gt; A -&gt; C) (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
     (@pure G H0 ((B -&gt; C) -&gt; (A -&gt; B) -&gt; A -&gt; C)
        (@compose A B C) ‚äó f) ‚äó g ‚äó a) =
@map G H ((B -&gt; C) * ((A -&gt; B) * A)) C
  ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
   ‚àò @map_snd (B -&gt; C) ((A -&gt; B) * A) B
       (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)) (f ‚äó (g ‚äó a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk156" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk156"><span class="nb">rewrite</span> triangle_3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G (B -&gt; C)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G (A -&gt; B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (((A -&gt; B) -&gt; A -&gt; C) * (A -&gt; B) * A) C
  ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
   ‚àò @map_fst A (((A -&gt; B) -&gt; A -&gt; C) * (A -&gt; B))
       (A -&gt; C) (<span class="kr">fun</span> &#39;(f, a) =&gt; f a))
  (@map G H
     (((B -&gt; C) -&gt; (A -&gt; B) -&gt; A -&gt; C) * (B -&gt; C))
     ((A -&gt; B) -&gt; A -&gt; C) (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
     (@strength G H ((B -&gt; C) -&gt; (A -&gt; B) -&gt; A -&gt; C)
        (B -&gt; C) (@compose A B C, f)) ‚äó g ‚äó a) =
@map G H ((B -&gt; C) * ((A -&gt; B) * A)) C
  ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
   ‚àò @map_snd (B -&gt; C) ((A -&gt; B) * A) B
       (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)) (f ‚äó (g ‚äó a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk157" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk157"><span class="nb">unfold</span> strength.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G (B -&gt; C)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G (A -&gt; B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (((A -&gt; B) -&gt; A -&gt; C) * (A -&gt; B) * A) C
  ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
   ‚àò @map_fst A (((A -&gt; B) -&gt; A -&gt; C) * (A -&gt; B))
       (A -&gt; C) (<span class="kr">fun</span> &#39;(f, a) =&gt; f a))
  (@map G H
     (((B -&gt; C) -&gt; (A -&gt; B) -&gt; A -&gt; C) * (B -&gt; C))
     ((A -&gt; B) -&gt; A -&gt; C) (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
     (@map G H (B -&gt; C)
        (((B -&gt; C) -&gt; (A -&gt; B) -&gt; A -&gt; C) * (B -&gt; C))
        (@pair ((B -&gt; C) -&gt; (A -&gt; B) -&gt; A -&gt; C)
           (B -&gt; C) (@compose A B C)) f) ‚äó g ‚äó a) =
@map G H ((B -&gt; C) * ((A -&gt; B) * A)) C
  ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
   ‚àò @map_snd (B -&gt; C) ((A -&gt; B) * A) B
       (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)) (f ‚äó (g ‚äó a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk158" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk158">compose near f on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G (B -&gt; C)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G (A -&gt; B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (((A -&gt; B) -&gt; A -&gt; C) * (A -&gt; B) * A) C
  ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
   ‚àò @map_fst A (((A -&gt; B) -&gt; A -&gt; C) * (A -&gt; B))
       (A -&gt; C) (<span class="kr">fun</span> &#39;(f, a) =&gt; f a))
  ((@map G H
      (((B -&gt; C) -&gt; (A -&gt; B) -&gt; A -&gt; C) * (B -&gt; C))
      ((A -&gt; B) -&gt; A -&gt; C) (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
    ‚àò @map G H (B -&gt; C)
        (((B -&gt; C) -&gt; (A -&gt; B) -&gt; A -&gt; C) * (B -&gt; C))
        (@pair ((B -&gt; C) -&gt; (A -&gt; B) -&gt; A -&gt; C)
           (B -&gt; C) (@compose A B C))) f ‚äó g ‚äó a) =
@map G H ((B -&gt; C) * ((A -&gt; B) * A)) C
  ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
   ‚àò @map_snd (B -&gt; C) ((A -&gt; B) * A) B
       (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)) (f ‚äó (g ‚äó a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk159" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk159"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G (B -&gt; C)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G (A -&gt; B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (((A -&gt; B) -&gt; A -&gt; C) * (A -&gt; B) * A) C
  ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
   ‚àò @map_fst A (((A -&gt; B) -&gt; A -&gt; C) * (A -&gt; B))
       (A -&gt; C) (<span class="kr">fun</span> &#39;(f, a) =&gt; f a))
  (@map G H (B -&gt; C) ((A -&gt; B) -&gt; A -&gt; C)
     ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
      ‚àò @pair ((B -&gt; C) -&gt; (A -&gt; B) -&gt; A -&gt; C)
          (B -&gt; C) (@compose A B C)) f ‚äó g ‚äó a) =
@map G H ((B -&gt; C) * ((A -&gt; B) * A)) C
  ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
   ‚àò @map_snd (B -&gt; C) ((A -&gt; B) * A) B
       (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)) (f ‚äó (g ‚äó a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk15a" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk15a"><span class="nb">rewrite</span> &lt;- (app_assoc).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G (B -&gt; C)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G (A -&gt; B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (((A -&gt; B) -&gt; A -&gt; C) * (A -&gt; B) * A) C
  ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
   ‚àò @map_fst A (((A -&gt; B) -&gt; A -&gt; C) * (A -&gt; B))
       (A -&gt; C) (<span class="kr">fun</span> &#39;(f, a) =&gt; f a))
  (@map G H (B -&gt; C) ((A -&gt; B) -&gt; A -&gt; C)
     ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
      ‚àò @pair ((B -&gt; C) -&gt; (A -&gt; B) -&gt; A -&gt; C)
          (B -&gt; C) (@compose A B C)) f ‚äó g ‚äó a) =
@map G H ((B -&gt; C) * ((A -&gt; B) * A)) C
  ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
   ‚àò @map_snd (B -&gt; C) ((A -&gt; B) * A) B
       (<span class="kr">fun</span> &#39;(f, a) =&gt; f a))
  (@map G H ((B -&gt; C) * (A -&gt; B) * A)
     ((B -&gt; C) * ((A -&gt; B) * A)) Œ± (f ‚äó g ‚äó a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk15b" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk15b">compose near (f ‚äó g ‚äó a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G (B -&gt; C)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G (A -&gt; B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (((A -&gt; B) -&gt; A -&gt; C) * (A -&gt; B) * A) C
  ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
   ‚àò @map_fst A (((A -&gt; B) -&gt; A -&gt; C) * (A -&gt; B))
       (A -&gt; C) (<span class="kr">fun</span> &#39;(f, a) =&gt; f a))
  (@map G H (B -&gt; C) ((A -&gt; B) -&gt; A -&gt; C)
     ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
      ‚àò @pair ((B -&gt; C) -&gt; (A -&gt; B) -&gt; A -&gt; C)
          (B -&gt; C) (@compose A B C)) f ‚äó g ‚äó a) =
(@map G H ((B -&gt; C) * ((A -&gt; B) * A)) C
   ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
    ‚àò @map_snd (B -&gt; C) ((A -&gt; B) * A) B
        (<span class="kr">fun</span> &#39;(f, a) =&gt; f a))
 ‚àò @map G H ((B -&gt; C) * (A -&gt; B) * A)
     ((B -&gt; C) * ((A -&gt; B) * A)) Œ±) (f ‚äó g ‚äó a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk15c" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk15c"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G (B -&gt; C)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G (A -&gt; B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (((A -&gt; B) -&gt; A -&gt; C) * (A -&gt; B) * A) C
  ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
   ‚àò @map_fst A (((A -&gt; B) -&gt; A -&gt; C) * (A -&gt; B))
       (A -&gt; C) (<span class="kr">fun</span> &#39;(f, a) =&gt; f a))
  (@map G H (B -&gt; C) ((A -&gt; B) -&gt; A -&gt; C)
     ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
      ‚àò @pair ((B -&gt; C) -&gt; (A -&gt; B) -&gt; A -&gt; C)
          (B -&gt; C) (@compose A B C)) f ‚äó g ‚äó a) =
@map G H ((B -&gt; C) * (A -&gt; B) * A) C
  ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
   ‚àò @map_snd (B -&gt; C) ((A -&gt; B) * A) B
       (<span class="kr">fun</span> &#39;(f, a) =&gt; f a) ‚àò Œ±) (f ‚äó g ‚äó a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk15d" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk15d"><span class="nb">rewrite</span> &lt;- (app_assoc_inv G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G (B -&gt; C)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G (A -&gt; B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (((A -&gt; B) -&gt; A -&gt; C) * (A -&gt; B) * A) C
  ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
   ‚àò @map_fst A (((A -&gt; B) -&gt; A -&gt; C) * (A -&gt; B))
       (A -&gt; C) (<span class="kr">fun</span> &#39;(f, a) =&gt; f a))
  (@map G H (((A -&gt; B) -&gt; A -&gt; C) * ((A -&gt; B) * A))
     (((A -&gt; B) -&gt; A -&gt; C) * (A -&gt; B) * A) Œ±^-<span class="mi">1</span>
     (@map G H (B -&gt; C) ((A -&gt; B) -&gt; A -&gt; C)
        ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
         ‚àò @pair ((B -&gt; C) -&gt; (A -&gt; B) -&gt; A -&gt; C)
             (B -&gt; C) (@compose A B C)) f ‚äó (g ‚äó a))) =
@map G H ((B -&gt; C) * (A -&gt; B) * A) C
  ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
   ‚àò @map_snd (B -&gt; C) ((A -&gt; B) * A) B
       (<span class="kr">fun</span> &#39;(f, a) =&gt; f a) ‚àò Œ±) (f ‚äó g ‚äó a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk15e" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk15e"><span class="nb">rewrite</span> (app_mult_natural_1 G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G (B -&gt; C)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G (A -&gt; B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (((A -&gt; B) -&gt; A -&gt; C) * (A -&gt; B) * A) C
  ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
   ‚àò @map_fst A (((A -&gt; B) -&gt; A -&gt; C) * (A -&gt; B))
       (A -&gt; C) (<span class="kr">fun</span> &#39;(f, a) =&gt; f a))
  (@map G H ((B -&gt; C) * ((A -&gt; B) * A))
     (((A -&gt; B) -&gt; A -&gt; C) * (A -&gt; B) * A)
     (Œ±^-<span class="mi">1</span>
      ‚àò @map_fst ((A -&gt; B) * A) (B -&gt; C)
          ((A -&gt; B) -&gt; A -&gt; C)
          ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
           ‚àò @pair ((B -&gt; C) -&gt; (A -&gt; B) -&gt; A -&gt; C)
               (B -&gt; C) (@compose A B C)))
     (f ‚äó (g ‚äó a))) =
@map G H ((B -&gt; C) * (A -&gt; B) * A) C
  ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
   ‚àò @map_snd (B -&gt; C) ((A -&gt; B) * A) B
       (<span class="kr">fun</span> &#39;(f, a) =&gt; f a) ‚àò Œ±) (f ‚äó g ‚äó a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk15f" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk15f"><span class="nb">rewrite</span> &lt;- (app_assoc).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G (B -&gt; C)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G (A -&gt; B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (((A -&gt; B) -&gt; A -&gt; C) * (A -&gt; B) * A) C
  ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
   ‚àò @map_fst A (((A -&gt; B) -&gt; A -&gt; C) * (A -&gt; B))
       (A -&gt; C) (<span class="kr">fun</span> &#39;(f, a) =&gt; f a))
  (@map G H ((B -&gt; C) * ((A -&gt; B) * A))
     (((A -&gt; B) -&gt; A -&gt; C) * (A -&gt; B) * A)
     (Œ±^-<span class="mi">1</span>
      ‚àò @map_fst ((A -&gt; B) * A) (B -&gt; C)
          ((A -&gt; B) -&gt; A -&gt; C)
          ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
           ‚àò @pair ((B -&gt; C) -&gt; (A -&gt; B) -&gt; A -&gt; C)
               (B -&gt; C) (@compose A B C)))
     (@map G H ((B -&gt; C) * (A -&gt; B) * A)
        ((B -&gt; C) * ((A -&gt; B) * A)) Œ± (f ‚äó g ‚äó a))) =
@map G H ((B -&gt; C) * (A -&gt; B) * A) C
  ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
   ‚àò @map_snd (B -&gt; C) ((A -&gt; B) * A) B
       (<span class="kr">fun</span> &#39;(f, a) =&gt; f a) ‚àò Œ±) (f ‚äó g ‚äó a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk160" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk160">compose near (f ‚äó g ‚äó a) on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G (B -&gt; C)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G (A -&gt; B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (((A -&gt; B) -&gt; A -&gt; C) * (A -&gt; B) * A) C
  ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
   ‚àò @map_fst A (((A -&gt; B) -&gt; A -&gt; C) * (A -&gt; B))
       (A -&gt; C) (<span class="kr">fun</span> &#39;(f, a) =&gt; f a))
  ((@map G H ((B -&gt; C) * ((A -&gt; B) * A))
      (((A -&gt; B) -&gt; A -&gt; C) * (A -&gt; B) * A)
      (Œ±^-<span class="mi">1</span>
       ‚àò @map_fst ((A -&gt; B) * A) (B -&gt; C)
           ((A -&gt; B) -&gt; A -&gt; C)
           ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
            ‚àò @pair ((B -&gt; C) -&gt; (A -&gt; B) -&gt; A -&gt; C)
                (B -&gt; C) (@compose A B C)))
    ‚àò @map G H ((B -&gt; C) * (A -&gt; B) * A)
        ((B -&gt; C) * ((A -&gt; B) * A)) Œ±) (f ‚äó g ‚äó a)) =
@map G H ((B -&gt; C) * (A -&gt; B) * A) C
  ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
   ‚àò @map_snd (B -&gt; C) ((A -&gt; B) * A) B
       (<span class="kr">fun</span> &#39;(f, a) =&gt; f a) ‚àò Œ±) (f ‚äó g ‚äó a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk161" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk161"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G (B -&gt; C)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G (A -&gt; B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (((A -&gt; B) -&gt; A -&gt; C) * (A -&gt; B) * A) C
  ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
   ‚àò @map_fst A (((A -&gt; B) -&gt; A -&gt; C) * (A -&gt; B))
       (A -&gt; C) (<span class="kr">fun</span> &#39;(f, a) =&gt; f a))
  (@map G H ((B -&gt; C) * (A -&gt; B) * A)
     (((A -&gt; B) -&gt; A -&gt; C) * (A -&gt; B) * A)
     (Œ±^-<span class="mi">1</span>
      ‚àò @map_fst ((A -&gt; B) * A) (B -&gt; C)
          ((A -&gt; B) -&gt; A -&gt; C)
          ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
           ‚àò @pair ((B -&gt; C) -&gt; (A -&gt; B) -&gt; A -&gt; C)
               (B -&gt; C) (@compose A B C)) ‚àò Œ±)
     (f ‚äó g ‚äó a)) =
@map G H ((B -&gt; C) * (A -&gt; B) * A) C
  ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
   ‚àò @map_snd (B -&gt; C) ((A -&gt; B) * A) B
       (<span class="kr">fun</span> &#39;(f, a) =&gt; f a) ‚àò Œ±) (f ‚äó g ‚äó a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk162" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk162">compose near (f ‚äó g ‚äó a) on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G (B -&gt; C)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G (A -&gt; B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(@map G H (((A -&gt; B) -&gt; A -&gt; C) * (A -&gt; B) * A) C
   ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
    ‚àò @map_fst A (((A -&gt; B) -&gt; A -&gt; C) * (A -&gt; B))
        (A -&gt; C) (<span class="kr">fun</span> &#39;(f, a) =&gt; f a))
 ‚àò @map G H ((B -&gt; C) * (A -&gt; B) * A)
     (((A -&gt; B) -&gt; A -&gt; C) * (A -&gt; B) * A)
     (Œ±^-<span class="mi">1</span>
      ‚àò @map_fst ((A -&gt; B) * A) (B -&gt; C)
          ((A -&gt; B) -&gt; A -&gt; C)
          ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
           ‚àò @pair ((B -&gt; C) -&gt; (A -&gt; B) -&gt; A -&gt; C)
               (B -&gt; C) (@compose A B C)) ‚àò Œ±))
  (f ‚äó g ‚äó a) =
@map G H ((B -&gt; C) * (A -&gt; B) * A) C
  ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
   ‚àò @map_snd (B -&gt; C) ((A -&gt; B) * A) B
       (<span class="kr">fun</span> &#39;(f, a) =&gt; f a) ‚àò Œ±) (f ‚äó g ‚äó a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk163" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk163"><span class="kp">repeat</span> <span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G (B -&gt; C)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G (A -&gt; B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H ((B -&gt; C) * (A -&gt; B) * A) C
  ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
   ‚àò @map_fst A (((A -&gt; B) -&gt; A -&gt; C) * (A -&gt; B))
       (A -&gt; C) (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
   ‚àò (Œ±^-<span class="mi">1</span>
      ‚àò @map_fst ((A -&gt; B) * A) (B -&gt; C)
          ((A -&gt; B) -&gt; A -&gt; C)
          ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
           ‚àò @pair ((B -&gt; C) -&gt; (A -&gt; B) -&gt; A -&gt; C)
               (B -&gt; C) (@compose A B C)) ‚àò Œ±))
  (f ‚äó g ‚äó a) =
@map G H ((B -&gt; C) * (A -&gt; B) * A) C
  ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
   ‚àò @map_snd (B -&gt; C) ((A -&gt; B) * A) B
       (<span class="kr">fun</span> &#39;(f, a) =&gt; f a) ‚àò Œ±) (f ‚äó g ‚äó a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk164" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk164">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G (B -&gt; C)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G (A -&gt; B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
‚àò @map_fst A (((A -&gt; B) -&gt; A -&gt; C) * (A -&gt; B))
    (A -&gt; C) (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
‚àò (Œ±^-<span class="mi">1</span>
   ‚àò @map_fst ((A -&gt; B) * A) (B -&gt; C)
       ((A -&gt; B) -&gt; A -&gt; C)
       ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
        ‚àò @pair ((B -&gt; C) -&gt; (A -&gt; B) -&gt; A -&gt; C)
            (B -&gt; C) (@compose A B C)) ‚àò Œ±) =
(<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
‚àò @map_snd (B -&gt; C) ((A -&gt; B) * A) B
    (<span class="kr">fun</span> &#39;(f, a) =&gt; f a) ‚àò Œ±</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> ext [[x y] z].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">ApplicativeFunctor_ap</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Convenience laws for &lt;&lt;ap&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">ApplicativeFunctor_ap_utility</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{Applicative G}
     {A B C D : <span class="kt">Type</span>}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Fuse &lt;&lt;pure&gt;&gt; into &lt;&lt;map&gt;&gt; *)</span> <span class="c">(*ap5*)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk165" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk165"><span class="kn">Corollary</span> <span class="nf">pure_ap_map</span> : <span class="kr">forall</span> (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : B -&gt; C) (<span class="nv">a</span> : G A),
      pure g &lt;‚ãÜ&gt; map f a = map (g ‚àò f) a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : B -&gt; C) (<span class="nv">a</span> : G A),
@pure G H0 (B -&gt; C) g &lt;‚ãÜ&gt; @map G H A B f a =
@map G H A C (g ‚àò f) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk166" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk166"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : B -&gt; C) (<span class="nv">a</span> : G A),
@pure G H0 (B -&gt; C) g &lt;‚ãÜ&gt; @map G H A B f a =
@map G H A C (g ‚àò f) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk167" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk167"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@pure G H0 (B -&gt; C) g &lt;‚ãÜ&gt; @map G H A B f a =
@map G H A C (g ‚àò f) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk168" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk168"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> map_to_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@pure G H0 (B -&gt; C) g &lt;‚ãÜ&gt;
(@pure G H0 (A -&gt; B) f &lt;‚ãÜ&gt; a) =
@pure G H0 (A -&gt; C) (g ‚àò f) &lt;‚ãÜ&gt; a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk169" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk169"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@pure G H0 ((B -&gt; C) -&gt; (A -&gt; B) -&gt; A -&gt; C)
  (@compose A B C) &lt;‚ãÜ&gt; @pure G H0 (B -&gt; C) g &lt;‚ãÜ&gt;
@pure G H0 (A -&gt; B) f &lt;‚ãÜ&gt; a =
@pure G H0 (A -&gt; C) (g ‚àò f) &lt;‚ãÜ&gt; a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk16a" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk16a"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@pure G H0 (A -&gt; C) (g ‚àò f) &lt;‚ãÜ&gt; a =
@pure G H0 (A -&gt; C) (g ‚àò f) &lt;‚ãÜ&gt; a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Push an &lt;&lt;map&gt;&gt; under an &lt;&lt;ap&gt;&gt; *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk16b" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk16b"><span class="kn">Corollary</span> <span class="nf">map_ap</span> : <span class="kr">forall</span> (<span class="nv">f</span> : G (A -&gt; B)) (<span class="nv">g</span> : B -&gt; C) (<span class="nv">a</span> : G A),
      map g (f &lt;‚ãÜ&gt; a) = map (compose g) f &lt;‚ãÜ&gt; a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : G (A -&gt; B)) (<span class="nv">g</span> : B -&gt; C) (<span class="nv">a</span> : G A),
@map G H B C g (f &lt;‚ãÜ&gt; a) =
@map G H (A -&gt; B) (A -&gt; C) (@compose A B C g) f &lt;‚ãÜ&gt; a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk16c" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk16c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : G (A -&gt; B)) (<span class="nv">g</span> : B -&gt; C) (<span class="nv">a</span> : G A),
@map G H B C g (f &lt;‚ãÜ&gt; a) =
@map G H (A -&gt; B) (A -&gt; C) (@compose A B C g) f &lt;‚ãÜ&gt; a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk16d" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk16d"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G (A -&gt; B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H B C g (f &lt;‚ãÜ&gt; a) =
@map G H (A -&gt; B) (A -&gt; C) (@compose A B C g) f &lt;‚ãÜ&gt; a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk16e" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk16e"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> map_to_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G (A -&gt; B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@pure G H0 (B -&gt; C) g &lt;‚ãÜ&gt; (f &lt;‚ãÜ&gt; a) =
@pure G H0 ((A -&gt; B) -&gt; A -&gt; C) (@compose A B C g) &lt;‚ãÜ&gt;
f &lt;‚ãÜ&gt; a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk16f" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk16f"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G (A -&gt; B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@pure G H0 ((B -&gt; C) -&gt; (A -&gt; B) -&gt; A -&gt; C)
  (@compose A B C) &lt;‚ãÜ&gt; @pure G H0 (B -&gt; C) g &lt;‚ãÜ&gt; f &lt;‚ãÜ&gt;
a =
@pure G H0 ((A -&gt; B) -&gt; A -&gt; C) (@compose A B C g) &lt;‚ãÜ&gt;
f &lt;‚ãÜ&gt; a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk170" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk170"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G (A -&gt; B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@pure G H0 ((A -&gt; B) -&gt; A -&gt; C) (@compose A B C g) &lt;‚ãÜ&gt;
f &lt;‚ãÜ&gt; a =
@pure G H0 ((A -&gt; B) -&gt; A -&gt; C) (@compose A B C g) &lt;‚ãÜ&gt;
f &lt;‚ãÜ&gt; a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk171" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk171"><span class="kn">Theorem</span> <span class="nf">map_ap2</span> : <span class="kr">forall</span> (<span class="nv">g</span> : B -&gt; C),
    compose (map g) ‚àò ap G (A := A) = ap G ‚àò map (compose g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">g</span> : B -&gt; C,
@compose (G A) (G B) (G C) (@map G H B C g)
‚àò @ap G H H1 A B =
@ap G H H1 A C
‚àò @map G H (A -&gt; B) (A -&gt; C) (@compose A B C g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk172" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk172"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">g</span> : B -&gt; C,
@compose (G A) (G B) (G C) (@map G H B C g)
‚àò @ap G H H1 A B =
@ap G H H1 A C
‚àò @map G H (A -&gt; B) (A -&gt; C) (@compose A B C g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk173" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk173"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@compose (G A) (G B) (G C) (@map G H B C g)
‚àò @ap G H H1 A B =
@ap G H H1 A C
‚àò @map G H (A -&gt; B) (A -&gt; C) (@compose A B C g)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk174" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk174">ext f a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G (A -&gt; B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(@compose (G A) (G B) (G C) (@map G H B C g)
 ‚àò @ap G H H1 A B) f a =
(@ap G H H1 A C
 ‚àò @map G H (A -&gt; B) (A -&gt; C) (@compose A B C g)) f a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk175" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk175"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G (A -&gt; B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H B C g (f &lt;‚ãÜ&gt; a) =
@map G H (A -&gt; B) (A -&gt; C) (<span class="kr">fun</span> <span class="nv">f</span> : A -&gt; B =&gt; g ‚óã f) f &lt;‚ãÜ&gt;
a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk176" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk176"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G (A -&gt; B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (A -&gt; B) (A -&gt; C) (@compose A B C g) f &lt;‚ãÜ&gt; a =
@map G H (A -&gt; B) (A -&gt; C) (<span class="kr">fun</span> <span class="nv">f</span> : A -&gt; B =&gt; g ‚óã f) f &lt;‚ãÜ&gt;
a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Bring an &lt;&lt;map&gt;&gt; from right of an &lt;&lt;ap&gt;&gt; to left *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk177" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk177"><span class="kn">Corollary</span> <span class="nf">ap_map</span> : <span class="kr">forall</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>} (<span class="nv">x</span> : G (A -&gt; B)) (<span class="nv">y</span> : G C) (<span class="nv">f</span> : C -&gt; A),
      (map (precompose f) x &lt;‚ãÜ&gt; y) = x &lt;‚ãÜ&gt; map f y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G (A -&gt; B)) (<span class="nv">y</span> : G C)
  (<span class="nv">f</span> : C -&gt; A),
@map G H (A -&gt; B) (C -&gt; B) (@precompose C A B f) x &lt;‚ãÜ&gt;
y = x &lt;‚ãÜ&gt; @map G H C A f y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk178" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk178"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G (A -&gt; B)) (<span class="nv">y</span> : G C)
  (<span class="nv">f</span> : C -&gt; A),
@map G H (A -&gt; B) (C -&gt; B) (@precompose C A B f) x &lt;‚ãÜ&gt;
y = x &lt;‚ãÜ&gt; @map G H C A f y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk179" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk179"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C, D, A0, B0, C0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G (A0 -&gt; B0)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G C0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>C0 -&gt; A0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (A0 -&gt; B0) (C0 -&gt; B0)
  (@precompose C0 A0 B0 f) x &lt;‚ãÜ&gt; y =
x &lt;‚ãÜ&gt; @map G H C0 A0 f y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk17a" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk17a"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> map_to_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C, D, A0, B0, C0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G (A0 -&gt; B0)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G C0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>C0 -&gt; A0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@pure G H0 ((A0 -&gt; B0) -&gt; C0 -&gt; B0)
  (@precompose C0 A0 B0 f) &lt;‚ãÜ&gt; x &lt;‚ãÜ&gt; y =
x &lt;‚ãÜ&gt; (@pure G H0 (C0 -&gt; A0) f &lt;‚ãÜ&gt; y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk17b" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk17b"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C, D, A0, B0, C0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G (A0 -&gt; B0)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G C0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>C0 -&gt; A0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@pure G H0 ((A0 -&gt; B0) -&gt; C0 -&gt; B0)
  (@precompose C0 A0 B0 f) &lt;‚ãÜ&gt; x &lt;‚ãÜ&gt; y =
@pure G H0 ((A0 -&gt; B0) -&gt; (C0 -&gt; A0) -&gt; C0 -&gt; B0)
  (@compose C0 A0 B0) &lt;‚ãÜ&gt; x &lt;‚ãÜ&gt;
@pure G H0 (C0 -&gt; A0) f &lt;‚ãÜ&gt; y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk17c" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk17c"><span class="nb">rewrite</span> ap3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C, D, A0, B0, C0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G (A0 -&gt; B0)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G C0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>C0 -&gt; A0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@pure G H0 ((A0 -&gt; B0) -&gt; C0 -&gt; B0)
  (@precompose C0 A0 B0 f) &lt;‚ãÜ&gt; x &lt;‚ãÜ&gt; y =
@pure G H0 (((C0 -&gt; A0) -&gt; C0 -&gt; B0) -&gt; C0 -&gt; B0)
  (<span class="kr">fun</span> <span class="nv">f0</span> : (C0 -&gt; A0) -&gt; C0 -&gt; B0 =&gt; f0 f) &lt;‚ãÜ&gt;
(@pure G H0 ((A0 -&gt; B0) -&gt; (C0 -&gt; A0) -&gt; C0 -&gt; B0)
   (@compose C0 A0 B0) &lt;‚ãÜ&gt; x) &lt;‚ãÜ&gt; y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk17d" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk17d"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C, D, A0, B0, C0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G (A0 -&gt; B0)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G C0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>C0 -&gt; A0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@pure G H0 ((A0 -&gt; B0) -&gt; C0 -&gt; B0)
  (@precompose C0 A0 B0 f) &lt;‚ãÜ&gt; x &lt;‚ãÜ&gt; y =
@pure G H0
  ((((C0 -&gt; A0) -&gt; C0 -&gt; B0) -&gt; C0 -&gt; B0) -&gt;
   ((A0 -&gt; B0) -&gt; (C0 -&gt; A0) -&gt; C0 -&gt; B0) -&gt;
   (A0 -&gt; B0) -&gt; C0 -&gt; B0)
  (@compose (A0 -&gt; B0) ((C0 -&gt; A0) -&gt; C0 -&gt; B0)
     (C0 -&gt; B0)) &lt;‚ãÜ&gt;
@pure G H0 (((C0 -&gt; A0) -&gt; C0 -&gt; B0) -&gt; C0 -&gt; B0)
  (<span class="kr">fun</span> <span class="nv">f0</span> : (C0 -&gt; A0) -&gt; C0 -&gt; B0 =&gt; f0 f) &lt;‚ãÜ&gt;
@pure G H0 ((A0 -&gt; B0) -&gt; (C0 -&gt; A0) -&gt; C0 -&gt; B0)
  (@compose C0 A0 B0) &lt;‚ãÜ&gt; x &lt;‚ãÜ&gt; y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk17e" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk17e"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C, D, A0, B0, C0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G (A0 -&gt; B0)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G C0</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>C0 -&gt; A0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@pure G H0 ((A0 -&gt; B0) -&gt; C0 -&gt; B0)
  (@precompose C0 A0 B0 f) &lt;‚ãÜ&gt; x &lt;‚ãÜ&gt; y =
@pure G H0 ((A0 -&gt; B0) -&gt; C0 -&gt; B0)
  ((<span class="kr">fun</span> <span class="nv">f0</span> : (C0 -&gt; A0) -&gt; C0 -&gt; B0 =&gt; f0 f)
   ‚àò @compose C0 A0 B0) &lt;‚ãÜ&gt; x &lt;‚ãÜ&gt; y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk17f" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk17f"><span class="kn">Corollary</span> <span class="nf">ap_curry</span> : <span class="kr">forall</span> (<span class="nv">a</span> : G A) (<span class="nv">b</span>: G B) (<span class="nv">f</span> : A -&gt; B -&gt; C),
      map (uncurry f) (a ‚äó b) = pure f &lt;‚ãÜ&gt; a &lt;‚ãÜ&gt; b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : G A) (<span class="nv">b</span> : G B) (<span class="nv">f</span> : A -&gt; B -&gt; C),
@map G H (A * B) C (@uncurry A B C f) (a ‚äó b) =
@pure G H0 (A -&gt; B -&gt; C) f &lt;‚ãÜ&gt; a &lt;‚ãÜ&gt; b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk180" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk180"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : G A) (<span class="nv">b</span> : G B) (<span class="nv">f</span> : A -&gt; B -&gt; C),
@map G H (A * B) C (@uncurry A B C f) (a ‚äó b) =
@pure G H0 (A -&gt; B -&gt; C) f &lt;‚ãÜ&gt; a &lt;‚ãÜ&gt; b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk181" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk181"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (A * B) C (@uncurry A B C f) (a ‚äó b) =
@pure G H0 (A -&gt; B -&gt; C) f &lt;‚ãÜ&gt; a &lt;‚ãÜ&gt; b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk182" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk182"><span class="nb">unfold</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (A * B) C (@uncurry A B C f) (a ‚äó b) =
@map G H ((B -&gt; C) * B) C (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
  (@map G H ((A -&gt; B -&gt; C) * A) (B -&gt; C)
     (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
     (@pure G H0 (A -&gt; B -&gt; C) f ‚äó a) ‚äó b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk183" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk183"><span class="nb">rewrite</span> (app_mult_natural_l G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (A * B) C (@uncurry A B C f) (a ‚äó b) =
@map G H ((B -&gt; C) * B) C (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
  (@map G H ((A -&gt; B -&gt; C) * A * B) ((B -&gt; C) * B)
     (@map_fst B ((A -&gt; B -&gt; C) * A) (B -&gt; C)
        (<span class="kr">fun</span> &#39;(f, a) =&gt; f a))
     (@pure G H0 (A -&gt; B -&gt; C) f ‚äó a ‚äó b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk184" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk184">compose near (pure f ‚äó a ‚äó b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (A * B) C (@uncurry A B C f) (a ‚äó b) =
(@map G H ((B -&gt; C) * B) C (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
 ‚àò @map G H ((A -&gt; B -&gt; C) * A * B) ((B -&gt; C) * B)
     (@map_fst B ((A -&gt; B -&gt; C) * A) (B -&gt; C)
        (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)))
  (@pure G H0 (A -&gt; B -&gt; C) f ‚äó a ‚äó b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk185" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk185"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (A * B) C (@uncurry A B C f) (a ‚äó b) =
@map G H ((A -&gt; B -&gt; C) * A * B) C
  ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
   ‚àò @map_fst B ((A -&gt; B -&gt; C) * A) (B -&gt; C)
       (<span class="kr">fun</span> &#39;(f, a) =&gt; f a))
  (@pure G H0 (A -&gt; B -&gt; C) f ‚äó a ‚äó b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk186" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk186"><span class="nb">rewrite</span> &lt;- (app_assoc_inv G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (A * B) C (@uncurry A B C f) (a ‚äó b) =
@map G H ((A -&gt; B -&gt; C) * A * B) C
  ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
   ‚àò @map_fst B ((A -&gt; B -&gt; C) * A) (B -&gt; C)
       (<span class="kr">fun</span> &#39;(f, a) =&gt; f a))
  (@map G H ((A -&gt; B -&gt; C) * (A * B))
     ((A -&gt; B -&gt; C) * A * B) Œ±^-<span class="mi">1</span>
     (@pure G H0 (A -&gt; B -&gt; C) f ‚äó (a ‚äó b)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk187" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk187">compose near ((pure f ‚äó (a ‚äó b))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (A * B) C (@uncurry A B C f) (a ‚äó b) =
(@map G H ((A -&gt; B -&gt; C) * A * B) C
   ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
    ‚àò @map_fst B ((A -&gt; B -&gt; C) * A) (B -&gt; C)
        (<span class="kr">fun</span> &#39;(f, a) =&gt; f a))
 ‚àò @map G H ((A -&gt; B -&gt; C) * (A * B))
     ((A -&gt; B -&gt; C) * A * B) Œ±^-<span class="mi">1</span>)
  (@pure G H0 (A -&gt; B -&gt; C) f ‚äó (a ‚äó b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk188" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk188"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (A * B) C (@uncurry A B C f) (a ‚äó b) =
@map G H ((A -&gt; B -&gt; C) * (A * B)) C
  ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
   ‚àò @map_fst B ((A -&gt; B -&gt; C) * A) (B -&gt; C)
       (<span class="kr">fun</span> &#39;(f, a) =&gt; f a) ‚àò Œ±^-<span class="mi">1</span>)
  (@pure G H0 (A -&gt; B -&gt; C) f ‚äó (a ‚äó b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk189" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk189"><span class="nb">rewrite</span> triangle_3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (A * B) C (@uncurry A B C f) (a ‚äó b) =
@map G H ((A -&gt; B -&gt; C) * (A * B)) C
  ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
   ‚àò @map_fst B ((A -&gt; B -&gt; C) * A) (B -&gt; C)
       (<span class="kr">fun</span> &#39;(f, a) =&gt; f a) ‚àò Œ±^-<span class="mi">1</span>)
  (@strength G H (A -&gt; B -&gt; C) (A * B) (f, a ‚äó b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk18a" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk18a"><span class="nb">unfold</span> strength.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (A * B) C (@uncurry A B C f) (a ‚äó b) =
@map G H ((A -&gt; B -&gt; C) * (A * B)) C
  ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
   ‚àò @map_fst B ((A -&gt; B -&gt; C) * A) (B -&gt; C)
       (<span class="kr">fun</span> &#39;(f, a) =&gt; f a) ‚àò Œ±^-<span class="mi">1</span>)
  (@map G H (A * B) ((A -&gt; B -&gt; C) * (A * B))
     (@pair (A -&gt; B -&gt; C) (A * B) f) (a ‚äó b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk18b" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk18b">compose near (a ‚äó b) on <span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (A * B) C (@uncurry A B C f) (a ‚äó b) =
(@map G H ((A -&gt; B -&gt; C) * (A * B)) C
   ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
    ‚àò @map_fst B ((A -&gt; B -&gt; C) * A) (B -&gt; C)
        (<span class="kr">fun</span> &#39;(f, a) =&gt; f a) ‚àò Œ±^-<span class="mi">1</span>)
 ‚àò @map G H (A * B) ((A -&gt; B -&gt; C) * (A * B))
     (@pair (A -&gt; B -&gt; C) (A * B) f)) (a ‚äó b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk18c" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk18c"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (A * B) C (@uncurry A B C f) (a ‚äó b) =
@map G H (A * B) C
  ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
   ‚àò @map_fst B ((A -&gt; B -&gt; C) * A) (B -&gt; C)
       (<span class="kr">fun</span> &#39;(f, a) =&gt; f a) ‚àò Œ±^-<span class="mi">1</span>
   ‚àò @pair (A -&gt; B -&gt; C) (A * B) f) (a ‚äó b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk18d" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk18d">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@uncurry A B C f =
(<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
‚àò @map_fst B ((A -&gt; B -&gt; C) * A) (B -&gt; C)
    (<span class="kr">fun</span> &#39;(f, a) =&gt; f a) ‚àò Œ±^-<span class="mi">1</span>
‚àò @pair (A -&gt; B -&gt; C) (A * B) f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk18e" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk18e">ext [a&#39; b&#39;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@uncurry A B C f (a&#39;, b&#39;) =
((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
 ‚àò @map_fst B ((A -&gt; B -&gt; C) * A) (B -&gt; C)
     (<span class="kr">fun</span> &#39;(f, a) =&gt; f a) ‚àò Œ±^-<span class="mi">1</span>
 ‚àò @pair (A -&gt; B -&gt; C) (A * B) f) (a&#39;, b&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">ApplicativeFunctor_ap_utility</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Composition of functors and &lt;&lt;ap&gt;&gt; / &lt;&lt; &lt;‚ãÜ&gt; &gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">ap_compose</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    (<span class="nv">G1</span> <span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    `{Applicative G1}
    `{Applicative G2}
    {A B : <span class="kt">Type</span>}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk18f" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk18f"><span class="kn">Theorem</span> <span class="nf">ap_compose1</span> : <span class="kr">forall</span> (<span class="nv">f</span> : G2 (G1 (A -&gt; B))) (<span class="nv">a</span> : G2 (G1 A)),
      ap (G2 ‚àò G1) f a =
      pure (ap G1) &lt;‚ãÜ&gt; f &lt;‚ãÜ&gt; a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G1 H H0 H1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>@Applicative G2 H3 H4 H5</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : G2 (G1 (A -&gt; B))) (<span class="nv">a</span> : G2 (G1 A)),
f &lt;‚ãÜ&gt; a =
@pure G2 H4 (G1 (A -&gt; B) -&gt; G1 A -&gt; G1 B)
  (@ap G1 H H1 A B) &lt;‚ãÜ&gt; f &lt;‚ãÜ&gt; a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk190" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk190"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G1 H H0 H1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>@Applicative G2 H3 H4 H5</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : G2 (G1 (A -&gt; B))) (<span class="nv">a</span> : G2 (G1 A)),
f &lt;‚ãÜ&gt; a =
@pure G2 H4 (G1 (A -&gt; B) -&gt; G1 A -&gt; G1 B)
  (@ap G1 H H1 A B) &lt;‚ãÜ&gt; f &lt;‚ãÜ&gt; a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk191" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk191"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G1 H H0 H1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>@Applicative G2 H3 H4 H5</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G2 (G1 (A -&gt; B))</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f &lt;‚ãÜ&gt; a =
@pure G2 H4 (G1 (A -&gt; B) -&gt; G1 A -&gt; G1 B)
  (@ap G1 H H1 A B) &lt;‚ãÜ&gt; f &lt;‚ãÜ&gt; a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk192" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk192"><span class="nb">unfold</span> ap <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G1 H H0 H1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>@Applicative G2 H3 H4 H5</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G2 (G1 (A -&gt; B))</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map (G2 ‚àò G1) (@Map_compose G2 G1 H H3)
  ((A -&gt; B) * A) B (<span class="kr">fun</span> &#39;(f, a) =&gt; f a) (f ‚äó a) =
@pure G2 H4 (G1 (A -&gt; B) -&gt; G1 A -&gt; G1 B)
  (@ap G1 H H1 A B) &lt;‚ãÜ&gt; f &lt;‚ãÜ&gt; a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk193" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk193">unfold_ops @Map_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G1 H H0 H1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>@Applicative G2 H3 H4 H5</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G2 (G1 (A -&gt; B))</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G2 H3 (G1 ((A -&gt; B) * A)) (G1 B)
  (@map G1 H ((A -&gt; B) * A) B (<span class="kr">fun</span> &#39;(f, a) =&gt; f a))
  (f ‚äó a) =
@pure G2 H4 (G1 (A -&gt; B) -&gt; G1 A -&gt; G1 B)
  (@ap G1 H H1 A B) &lt;‚ãÜ&gt; f &lt;‚ãÜ&gt; a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk194" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk194">unfold_ops @Mult_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G1 H H0 H1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>@Applicative G2 H3 H4 H5</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G2 (G1 (A -&gt; B))</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G2 H3 (G1 ((A -&gt; B) * A)) (G1 B)
  (@map G1 H ((A -&gt; B) * A) B (<span class="kr">fun</span> &#39;(f, a) =&gt; f a))
  (@map G2 H3 (G1 (A -&gt; B) * G1 A) (G1 ((A -&gt; B) * A))
     (@mult G1 H1 (A -&gt; B) A)
     (@fst (G2 (G1 (A -&gt; B))) (G2 (G1 A)) (f, a)
      ‚äó @snd (G2 (G1 (A -&gt; B))) (G2 (G1 A)) (f, a))) =
@pure G2 H4 (G1 (A -&gt; B) -&gt; G1 A -&gt; G1 B)
  (@ap G1 H H1 A B) &lt;‚ãÜ&gt; f &lt;‚ãÜ&gt; a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk195" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk195"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G1 H H0 H1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>@Applicative G2 H3 H4 H5</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G2 (G1 (A -&gt; B))</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G2 H3 (G1 ((A -&gt; B) * A)) (G1 B)
  (@map G1 H ((A -&gt; B) * A) B (<span class="kr">fun</span> &#39;(f, a) =&gt; f a))
  (@map G2 H3 (G1 (A -&gt; B) * G1 A) (G1 ((A -&gt; B) * A))
     (@mult G1 H1 (A -&gt; B) A) (f ‚äó a)) =
@pure G2 H4 (G1 (A -&gt; B) -&gt; G1 A -&gt; G1 B)
  (@ap G1 H H1 A B) &lt;‚ãÜ&gt; f &lt;‚ãÜ&gt; a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk196" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk196"><span class="nb">rewrite</span> &lt;- map_to_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G1 H H0 H1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>@Applicative G2 H3 H4 H5</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G2 (G1 (A -&gt; B))</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G2 H3 (G1 ((A -&gt; B) * A)) (G1 B)
  (@map G1 H ((A -&gt; B) * A) B (<span class="kr">fun</span> &#39;(f, a) =&gt; f a))
  (@map G2 H3 (G1 (A -&gt; B) * G1 A) (G1 ((A -&gt; B) * A))
     (@mult G1 H1 (A -&gt; B) A) (f ‚äó a)) =
@map G2 H3 (G1 (A -&gt; B)) (G1 A -&gt; G1 B)
  (@ap G1 H H1 A B) f &lt;‚ãÜ&gt; a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk197" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk197">compose near (f ‚äó a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G1 H H0 H1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>@Applicative G2 H3 H4 H5</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G2 (G1 (A -&gt; B))</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(@map G2 H3 (G1 ((A -&gt; B) * A)) (G1 B)
   (@map G1 H ((A -&gt; B) * A) B (<span class="kr">fun</span> &#39;(f, a) =&gt; f a))
 ‚àò @map G2 H3 (G1 (A -&gt; B) * G1 A) (G1 ((A -&gt; B) * A))
     (@mult G1 H1 (A -&gt; B) A)) (f ‚äó a) =
@map G2 H3 (G1 (A -&gt; B)) (G1 A -&gt; G1 B)
  (@ap G1 H H1 A B) f &lt;‚ãÜ&gt; a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk198" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk198"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G1 H H0 H1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>@Applicative G2 H3 H4 H5</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G2 (G1 (A -&gt; B))</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G2 H3 (G1 (A -&gt; B) * G1 A) (G1 B)
  (@map G1 H ((A -&gt; B) * A) B (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
   ‚àò @mult G1 H1 (A -&gt; B) A) (f ‚äó a) =
@map G2 H3 (G1 (A -&gt; B)) (G1 A -&gt; G1 B)
  (@ap G1 H H1 A B) f &lt;‚ãÜ&gt; a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk199" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk199"><span class="nb">unfold</span> ap <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G1 H H0 H1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>@Applicative G2 H3 H4 H5</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G2 (G1 (A -&gt; B))</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G2 H3 (G1 (A -&gt; B) * G1 A) (G1 B)
  (@map G1 H ((A -&gt; B) * A) B (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
   ‚àò @mult G1 H1 (A -&gt; B) A) (f ‚äó a) =
@map G2 H3 ((G1 A -&gt; G1 B) * G1 A) (G1 B)
  (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
  (@map G2 H3 (G1 (A -&gt; B)) (G1 A -&gt; G1 B)
     (@ap G1 H H1 A B) f ‚äó a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk19a" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk19a"><span class="nb">rewrite</span> (app_mult_natural_l G2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G1 H H0 H1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>@Applicative G2 H3 H4 H5</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G2 (G1 (A -&gt; B))</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G2 H3 (G1 (A -&gt; B) * G1 A) (G1 B)
  (@map G1 H ((A -&gt; B) * A) B (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
   ‚àò @mult G1 H1 (A -&gt; B) A) (f ‚äó a) =
@map G2 H3 ((G1 A -&gt; G1 B) * G1 A) (G1 B)
  (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
  (@map G2 H3 (G1 (A -&gt; B) * G1 A)
     ((G1 A -&gt; G1 B) * G1 A)
     (@map_fst (G1 A) (G1 (A -&gt; B)) (G1 A -&gt; G1 B)
        (@ap G1 H H1 A B)) (f ‚äó a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk19b" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk19b">compose near (f ‚äó a) on <span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G1 H H0 H1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>@Applicative G2 H3 H4 H5</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G2 (G1 (A -&gt; B))</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G2 H3 (G1 (A -&gt; B) * G1 A) (G1 B)
  (@map G1 H ((A -&gt; B) * A) B (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
   ‚àò @mult G1 H1 (A -&gt; B) A) (f ‚äó a) =
(@map G2 H3 ((G1 A -&gt; G1 B) * G1 A) (G1 B)
   (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
 ‚àò @map G2 H3 (G1 (A -&gt; B) * G1 A)
     ((G1 A -&gt; G1 B) * G1 A)
     (@map_fst (G1 A) (G1 (A -&gt; B)) (G1 A -&gt; G1 B)
        (@ap G1 H H1 A B))) (f ‚äó a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk19c" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk19c"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G1 H H0 H1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>@Applicative G2 H3 H4 H5</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G2 (G1 (A -&gt; B))</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G2 H3 (G1 (A -&gt; B) * G1 A) (G1 B)
  (@map G1 H ((A -&gt; B) * A) B (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
   ‚àò @mult G1 H1 (A -&gt; B) A) (f ‚äó a) =
@map G2 H3 (G1 (A -&gt; B) * G1 A) (G1 B)
  ((<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
   ‚àò @map_fst (G1 A) (G1 (A -&gt; B)) (G1 A -&gt; G1 B)
       (@ap G1 H H1 A B)) (f ‚äó a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk19d" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk19d">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G1 H H0 H1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>@Applicative G2 H3 H4 H5</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G2 (G1 (A -&gt; B))</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G1 H ((A -&gt; B) * A) B (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
‚àò @mult G1 H1 (A -&gt; B) A =
(<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
‚àò @map_fst (G1 A) (G1 (A -&gt; B)) (G1 A -&gt; G1 B)
    (@ap G1 H H1 A B)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> ext [G1f G1a].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk19e" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk19e"><span class="kn">Theorem</span> <span class="nf">ap_compose2</span> : <span class="kr">forall</span> (<span class="nv">f</span>: G2 (G1 (A -&gt; B))) (<span class="nv">a</span> : G2 (G1 A)),
      ap (G2 ‚àò G1) f a =
      map (ap G1) f &lt;‚ãÜ&gt; a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G1 H H0 H1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>@Applicative G2 H3 H4 H5</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : G2 (G1 (A -&gt; B))) (<span class="nv">a</span> : G2 (G1 A)),
f &lt;‚ãÜ&gt; a =
@map G2 H3 (G1 (A -&gt; B)) (G1 A -&gt; G1 B)
  (@ap G1 H H1 A B) f &lt;‚ãÜ&gt; a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk19f" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk19f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G1 H H0 H1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>@Applicative G2 H3 H4 H5</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : G2 (G1 (A -&gt; B))) (<span class="nv">a</span> : G2 (G1 A)),
f &lt;‚ãÜ&gt; a =
@map G2 H3 (G1 (A -&gt; B)) (G1 A -&gt; G1 B)
  (@ap G1 H H1 A B) f &lt;‚ãÜ&gt; a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1a0" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1a0"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G1 H H0 H1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>@Applicative G2 H3 H4 H5</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G2 (G1 (A -&gt; B))</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f &lt;‚ãÜ&gt; a =
@map G2 H3 (G1 (A -&gt; B)) (G1 A -&gt; G1 B)
  (@ap G1 H H1 A B) f &lt;‚ãÜ&gt; a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1a1" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1a1"><span class="nb">rewrite</span> ap_compose1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G1 H H0 H1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>@Applicative G2 H3 H4 H5</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G2 (G1 (A -&gt; B))</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G2 (G1 A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@pure G2 H4 (G1 (A -&gt; B) -&gt; G1 A -&gt; G1 B)
  (@ap G1 H H1 A B) &lt;‚ãÜ&gt; f &lt;‚ãÜ&gt; a =
@map G2 H3 (G1 (A -&gt; B)) (G1 A -&gt; G1 B)
  (@ap G1 H H1 A B) f &lt;‚ãÜ&gt; a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> map_to_ap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

<span class="c">(*</span>
<span class="c">  Theorem ap_compose3 :</span>
<span class="c">    ap (G2 ‚àò G1) (A := A) (B := B) =</span>
<span class="c">      ap G2 ‚àò map G2 (ap G1).</span>
<span class="c">  Proof.</span>
<span class="c">    intros. ext f a.</span>
<span class="c">    rewrite (ap_compose1).</span>
<span class="c">    now rewrite &lt;- map_to_ap.</span>
<span class="c">  Qed.</span>

<span class="c">  Theorem ap_compose_new : forall `{Applicative G1} `{Applicative G2},</span>
<span class="c">    forall (A B : Type) (x : G1 (G2 A))(f : A -&gt; B),</span>
<span class="c">      P (G1 ‚àò G2) f &lt;‚ãÜ&gt; x =</span>
<span class="c">        P G1 (ap G2 (P G2 f)) &lt;‚ãÜ&gt; x.</span>
<span class="c">  Proof.</span>
<span class="c">    intros. rewrite (ap_compose1 G2 G1).</span>
<span class="c">    unfold_ops @Pure_compose.</span>
<span class="c">    rewrite ap2.</span>
<span class="c">    reflexivity.</span>
<span class="c">  Qed.</span>
<span class="c"> *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">ap_compose</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Notations *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">Notations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;x ‚äó y&quot;</span> := (mult (x, y)) (<span class="kn">at level</span> <span class="mi">50</span>, <span class="kn">left associativity</span>) : tealeaves_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;Gf &lt;‚ãÜ&gt; Ga&quot;</span> := (ap _ Gf Ga) (<span class="kn">at level</span> <span class="mi">50</span>, <span class="kn">left associativity</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Notations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Notations *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Tealeaves <span class="kn">Require Import</span>
  Classes.Monoid.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Monoid.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">with_monoid</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    (<span class="nv">M</span> : <span class="kt">Type</span>)
    `{Applicative G}
    `{Monoid M}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Monoid_op_applicative</span> : Monoid_op (G M) :=
    <span class="kr">fun</span> <span class="nv">m1</span> <span class="nv">m2</span> =&gt; map (F := G) (uncurry monoid_op) (m1 ‚äó m2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Monoid_unit_applicative</span> : Monoid_unit (G M) :=
    pure (F := G) ∆µ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1a2" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1a2">#[export] <span class="kn">Instance</span> <span class="nf">Monoid_applicative</span> : Monoid (G M).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@Monoid (G M) Monoid_op_applicative
  Monoid_unit_applicative</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1a3" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1a3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@Monoid (G M) Monoid_op_applicative
  Monoid_unit_applicative</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1a4" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1a4"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G M, (x ‚óè y) ‚óè z = x ‚óè (y ‚óè z)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="applicative-v-chk1a5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br></div><label class="goal-separator" for="applicative-v-chk1a5"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G M, x ‚óè ∆µ = x</div></blockquote><input class="alectryon-extra-goal-toggle" id="applicative-v-chk1a6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br></div><label class="goal-separator" for="applicative-v-chk1a6"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G M, ∆µ ‚óè x = x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1a7" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1a7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G M, (x ‚óè y) ‚óè z = x ‚óè (y ‚óè z)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1a8" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1a8"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x ‚óè y) ‚óè z = x ‚óè (y ‚óè z)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1a9" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1a9"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x ‚óè y) ‚óè z = x ‚óè (y ‚óè z)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1aa" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1aa">unfold_ops @Monoid_op_applicative.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (M * M) M (@uncurry M M M (@monoid_op M op))
  (@map G H (M * M) M
     (@uncurry M M M (@monoid_op M op)) (x ‚äó y) ‚äó z) =
@map G H (M * M) M (@uncurry M M M (@monoid_op M op))
  (x
   ‚äó @map G H (M * M) M
       (@uncurry M M M (@monoid_op M op)) (y ‚äó z))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1ab" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1ab"><span class="nb">rewrite</span> (app_mult_natural_l G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (M * M) M (@uncurry M M M (@monoid_op M op))
  (@map G H (M * M * M) (M * M)
     (@map_fst M (M * M) M
        (@uncurry M M M (@monoid_op M op)))
     (x ‚äó y ‚äó z)) =
@map G H (M * M) M (@uncurry M M M (@monoid_op M op))
  (x
   ‚äó @map G H (M * M) M
       (@uncurry M M M (@monoid_op M op)) (y ‚äó z))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1ac" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1ac">compose near (x ‚äó y ‚äó z) on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(@map G H (M * M) M (@uncurry M M M (@monoid_op M op))
 ‚àò @map G H (M * M * M) (M * M)
     (@map_fst M (M * M) M
        (@uncurry M M M (@monoid_op M op))))
  (x ‚äó y ‚äó z) =
@map G H (M * M) M (@uncurry M M M (@monoid_op M op))
  (x
   ‚äó @map G H (M * M) M
       (@uncurry M M M (@monoid_op M op)) (y ‚äó z))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1ad" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1ad"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (M * M * M) M
  (@uncurry M M M (@monoid_op M op)
   ‚àò @map_fst M (M * M) M
       (@uncurry M M M (@monoid_op M op))) (x ‚äó y ‚äó z) =
@map G H (M * M) M (@uncurry M M M (@monoid_op M op))
  (x
   ‚äó @map G H (M * M) M
       (@uncurry M M M (@monoid_op M op)) (y ‚äó z))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1ae" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1ae"><span class="nb">rewrite</span> (app_mult_natural_r G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (M * M * M) M
  (@uncurry M M M (@monoid_op M op)
   ‚àò @map_fst M (M * M) M
       (@uncurry M M M (@monoid_op M op))) (x ‚äó y ‚äó z) =
@map G H (M * M) M (@uncurry M M M (@monoid_op M op))
  (@map G H (M * (M * M)) (M * M)
     (@map_snd M (M * M) M
        (@uncurry M M M (@monoid_op M op)))
     (x ‚äó (y ‚äó z)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1af" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1af"><span class="nb">rewrite</span> &lt;- (app_assoc).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (M * M * M) M
  (@uncurry M M M (@monoid_op M op)
   ‚àò @map_fst M (M * M) M
       (@uncurry M M M (@monoid_op M op))) (x ‚äó y ‚äó z) =
@map G H (M * M) M (@uncurry M M M (@monoid_op M op))
  (@map G H (M * (M * M)) (M * M)
     (@map_snd M (M * M) M
        (@uncurry M M M (@monoid_op M op)))
     (@map G H (M * M * M) (M * (M * M)) Œ± (x ‚äó y ‚äó z)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1b0" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1b0">compose near (x ‚äó y ‚äó z) on <span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (M * M * M) M
  (@uncurry M M M (@monoid_op M op)
   ‚àò @map_fst M (M * M) M
       (@uncurry M M M (@monoid_op M op))) (x ‚äó y ‚äó z) =
@map G H (M * M) M (@uncurry M M M (@monoid_op M op))
  ((@map G H (M * (M * M)) (M * M)
      (@map_snd M (M * M) M
         (@uncurry M M M (@monoid_op M op)))
    ‚àò @map G H (M * M * M) (M * (M * M)) Œ±)
     (x ‚äó y ‚äó z))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1b1" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1b1"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (M * M * M) M
  (@uncurry M M M (@monoid_op M op)
   ‚àò @map_fst M (M * M) M
       (@uncurry M M M (@monoid_op M op))) (x ‚äó y ‚äó z) =
@map G H (M * M) M (@uncurry M M M (@monoid_op M op))
  (@map G H (M * M * M) (M * M)
     (@map_snd M (M * M) M
        (@uncurry M M M (@monoid_op M op)) ‚àò Œ±)
     (x ‚äó y ‚äó z))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1b2" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1b2">compose near (x ‚äó y ‚äó z) on <span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (M * M * M) M
  (@uncurry M M M (@monoid_op M op)
   ‚àò @map_fst M (M * M) M
       (@uncurry M M M (@monoid_op M op))) (x ‚äó y ‚äó z) =
(@map G H (M * M) M (@uncurry M M M (@monoid_op M op))
 ‚àò @map G H (M * M * M) (M * M)
     (@map_snd M (M * M) M
        (@uncurry M M M (@monoid_op M op)) ‚àò Œ±))
  (x ‚äó y ‚äó z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1b3" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1b3"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (M * M * M) M
  (@uncurry M M M (@monoid_op M op)
   ‚àò @map_fst M (M * M) M
       (@uncurry M M M (@monoid_op M op))) (x ‚äó y ‚äó z) =
@map G H (M * M * M) M
  (@uncurry M M M (@monoid_op M op)
   ‚àò (@map_snd M (M * M) M
        (@uncurry M M M (@monoid_op M op)) ‚àò Œ±))
  (x ‚äó y ‚äó z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1b4" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1b4">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@uncurry M M M (@monoid_op M op)
‚àò @map_fst M (M * M) M
    (@uncurry M M M (@monoid_op M op)) =
@uncurry M M M (@monoid_op M op)
‚àò (@map_snd M (M * M) M
     (@uncurry M M M (@monoid_op M op)) ‚àò Œ±)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1b5" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1b5">ext [[m1 m2] m3].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G M</span></span></span><br><span><var>m1, m2, m3</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(@uncurry M M M (@monoid_op M op)
 ‚àò @map_fst M (M * M) M
     (@uncurry M M M (@monoid_op M op))) (m1, m2, m3) =
(@uncurry M M M (@monoid_op M op)
 ‚àò (@map_snd M (M * M) M
      (@uncurry M M M (@monoid_op M op)) ‚àò Œ±))
  (m1, m2, m3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1b6" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1b6"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G M</span></span></span><br><span><var>m1, m2, m3</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(m1 ‚óè m2) ‚óè @id M m3 = @id M m1 ‚óè (m2 ‚óè m3)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1b7" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1b7">simpl_monoid.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G M</span></span></span><br><span><var>m1, m2, m3</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">m1 ‚óè (m2 ‚óè @id M m3) = @id M m1 ‚óè (m2 ‚óè m3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1b8" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1b8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G M, x ‚óè ∆µ = x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1b9" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1b9"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ‚óè ∆µ = x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1ba" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1ba">unfold_ops @Monoid_op_applicative.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (M * M) M (@uncurry M M M (@monoid_op M op))
  (x ‚äó ∆µ) = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1bb" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1bb">unfold_ops @Monoid_unit_applicative.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (M * M) M (@uncurry M M M (@monoid_op M op))
  (x ‚äó @pure G H0 M ∆µ) = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1bc" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1bc"><span class="nb">rewrite</span> ap_curry.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@pure G H0 (M -&gt; M -&gt; M) (@monoid_op M op) &lt;‚ãÜ&gt; x &lt;‚ãÜ&gt;
@pure G H0 M ∆µ = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1bd" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1bd"><span class="nb">rewrite</span> &lt;- map_to_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H M (M -&gt; M) (@monoid_op M op) x &lt;‚ãÜ&gt;
@pure G H0 M ∆µ = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1be" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1be"><span class="nb">rewrite</span> ap3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@pure G H0 ((M -&gt; M) -&gt; M) (<span class="kr">fun</span> <span class="nv">f</span> : M -&gt; M =&gt; f ∆µ) &lt;‚ãÜ&gt;
@map G H M (M -&gt; M) (@monoid_op M op) x = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1bf" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1bf"><span class="nb">rewrite</span> pure_ap_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H M M
  ((<span class="kr">fun</span> <span class="nv">f</span> : M -&gt; M =&gt; f ∆µ) ‚àò @monoid_op M op) x = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1c0" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1c0"><span class="nb">change</span> x <span class="kr">with</span> (id x) <span class="nb">at</span> <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H M M
  ((<span class="kr">fun</span> <span class="nv">f</span> : M -&gt; M =&gt; f ∆µ) ‚àò @monoid_op M op) x =
@id (G M) x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1c1" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1c1"><span class="nb">rewrite</span> &lt;- (fun_map_id).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H M M
  ((<span class="kr">fun</span> <span class="nv">f</span> : M -&gt; M =&gt; f ∆µ) ‚àò @monoid_op M op) x =
@map G H M M (@id M) x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1c2" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1c2">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">f</span> : M -&gt; M =&gt; f ∆µ) ‚àò @monoid_op M op = @id M</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1c3" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1c3">ext m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G M</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((<span class="kr">fun</span> <span class="nv">f</span> : M -&gt; M =&gt; f ∆µ) ‚àò @monoid_op M op) m =
@id M m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1c4" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1c4"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G M</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">m ‚óè ∆µ = @id M m</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> monoid_id_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1c5" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1c5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G M, ∆µ ‚óè x = x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1c6" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1c6"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">∆µ ‚óè x = x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1c7" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1c7">unfold_ops @Monoid_op_applicative.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (M * M) M (@uncurry M M M (@monoid_op M op))
  (∆µ ‚äó x) = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1c8" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1c8">unfold_ops @Monoid_unit_applicative.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (M * M) M (@uncurry M M M (@monoid_op M op))
  (@pure G H0 M ∆µ ‚äó x) = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1c9" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1c9"><span class="nb">rewrite</span> ap_curry.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@pure G H0 (M -&gt; M -&gt; M) (@monoid_op M op) &lt;‚ãÜ&gt;
@pure G H0 M ∆µ &lt;‚ãÜ&gt; x = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1ca" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1ca"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@pure G H0 (M -&gt; M) (@monoid_op M op ∆µ) &lt;‚ãÜ&gt; x = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1cb" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1cb"><span class="nb">rewrite</span> &lt;- map_to_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H M M (@monoid_op M op ∆µ) x = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1cc" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1cc"><span class="nb">change</span> x <span class="kr">with</span> (id x) <span class="nb">at</span> <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H M M (@monoid_op M op ∆µ) x = @id (G M) x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1cd" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1cd"><span class="nb">rewrite</span> &lt;- (fun_map_id).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H M M (@monoid_op M op ∆µ) x =
@map G H M M (@id M) x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1ce" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1ce">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@monoid_op M op ∆µ = @id M</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1cf" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1cf">ext m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G M</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">∆µ ‚óè m = @id M m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1d0" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1d0"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid M op unit0</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G M</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">∆µ ‚óè m = @id M m</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> monoid_id_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">with_monoid</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">with_hom</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{Applicative G}
    (M1 M2 : <span class="kt">Type</span>)
    `{Monoid_Morphism M1 M2 œï}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1d1" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1d1">#[export] <span class="kn">Instance</span> <span class="nf">Monoid_hom_applicative</span> :
    Monoid_Morphism (G M1) (G M2) (map (F := G) œï).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>M1, M2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>src_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M1</span></span></span><br><span><var>src_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M1</span></span></span><br><span><var>tgt_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M2</span></span></span><br><span><var>tgt_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>M1 -&gt; M2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid_Morphism M1 M2 src_op src_unit tgt_op
  tgt_unit œï</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@Monoid_Morphism (G M1) (G M2)
  (@Monoid_op_applicative G M1 H H1 src_op)
  (@Monoid_unit_applicative G M1 H0 src_unit)
  (@Monoid_op_applicative G M2 H H1 tgt_op)
  (@Monoid_unit_applicative G M2 H0 tgt_unit)
  (@map G H M1 M2 œï)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1d2" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1d2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>M1, M2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>src_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M1</span></span></span><br><span><var>src_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M1</span></span></span><br><span><var>tgt_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M2</span></span></span><br><span><var>tgt_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>M1 -&gt; M2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid_Morphism M1 M2 src_op src_unit tgt_op
  tgt_unit œï</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@Monoid_Morphism (G M1) (G M2)
  (@Monoid_op_applicative G M1 H H1 src_op)
  (@Monoid_unit_applicative G M1 H0 src_unit)
  (@Monoid_op_applicative G M2 H H1 tgt_op)
  (@Monoid_unit_applicative G M2 H0 tgt_unit)
  (@map G H M1 M2 œï)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1d3" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1d3"><span class="nb">inversion</span> H3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>M1, M2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>src_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M1</span></span></span><br><span><var>src_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M1</span></span></span><br><span><var>tgt_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M2</span></span></span><br><span><var>tgt_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>M1 -&gt; M2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid_Morphism M1 M2 src_op src_unit tgt_op
  tgt_unit œï</span></span></span><br><span><var>monmor_src</var><span class="hyp-type"><b>: </b><span>@Monoid M1 src_op src_unit</span></span></span><br><span><var>monmor_tgt</var><span class="hyp-type"><b>: </b><span>@Monoid M2 tgt_op tgt_unit</span></span></span><br><span><var>monmor_unit</var><span class="hyp-type"><b>: </b><span>œï ∆µ = ∆µ</span></span></span><br><span><var>monmor_op</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : M1,
œï (a1 ‚óè a2) = œï a1 ‚óè œï a2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@Monoid_Morphism (G M1) (G M2)
  (@Monoid_op_applicative G M1 H H1 src_op)
  (@Monoid_unit_applicative G M1 H0 src_unit)
  (@Monoid_op_applicative G M2 H H1 tgt_op)
  (@Monoid_unit_applicative G M2 H0 tgt_unit)
  (@map G H M1 M2 œï)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1d4" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1d4"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>M1, M2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>src_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M1</span></span></span><br><span><var>src_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M1</span></span></span><br><span><var>tgt_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M2</span></span></span><br><span><var>tgt_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>M1 -&gt; M2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid_Morphism M1 M2 src_op src_unit tgt_op
  tgt_unit œï</span></span></span><br><span><var>monmor_src</var><span class="hyp-type"><b>: </b><span>@Monoid M1 src_op src_unit</span></span></span><br><span><var>monmor_tgt</var><span class="hyp-type"><b>: </b><span>@Monoid M2 tgt_op tgt_unit</span></span></span><br><span><var>monmor_unit</var><span class="hyp-type"><b>: </b><span>œï ∆µ = ∆µ</span></span></span><br><span><var>monmor_op</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : M1,
œï (a1 ‚óè a2) = œï a1 ‚óè œï a2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@Monoid (G M1)
  (@Monoid_op_applicative G M1 H H1 src_op)
  (@Monoid_unit_applicative G M1 H0 src_unit)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="applicative-v-chk1d5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>M1, M2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>src_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M1</span></span></span><br><span><var>src_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M1</span></span></span><br><span><var>tgt_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M2</span></span></span><br><span><var>tgt_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>M1 -&gt; M2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid_Morphism M1 M2 src_op src_unit tgt_op
  tgt_unit œï</span></span></span><br><span><var>monmor_src</var><span class="hyp-type"><b>: </b><span>@Monoid M1 src_op src_unit</span></span></span><br><span><var>monmor_tgt</var><span class="hyp-type"><b>: </b><span>@Monoid M2 tgt_op tgt_unit</span></span></span><br><span><var>monmor_unit</var><span class="hyp-type"><b>: </b><span>œï ∆µ = ∆µ</span></span></span><br><span><var>monmor_op</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : M1,
œï (a1 ‚óè a2) = œï a1 ‚óè œï a2</span></span></span><br></div><label class="goal-separator" for="applicative-v-chk1d5"><hr></label><div class="goal-conclusion">@Monoid (G M2)
  (@Monoid_op_applicative G M2 H H1 tgt_op)
  (@Monoid_unit_applicative G M2 H0 tgt_unit)</div></blockquote><input class="alectryon-extra-goal-toggle" id="applicative-v-chk1d6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>M1, M2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>src_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M1</span></span></span><br><span><var>src_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M1</span></span></span><br><span><var>tgt_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M2</span></span></span><br><span><var>tgt_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>M1 -&gt; M2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid_Morphism M1 M2 src_op src_unit tgt_op
  tgt_unit œï</span></span></span><br><span><var>monmor_src</var><span class="hyp-type"><b>: </b><span>@Monoid M1 src_op src_unit</span></span></span><br><span><var>monmor_tgt</var><span class="hyp-type"><b>: </b><span>@Monoid M2 tgt_op tgt_unit</span></span></span><br><span><var>monmor_unit</var><span class="hyp-type"><b>: </b><span>œï ∆µ = ∆µ</span></span></span><br><span><var>monmor_op</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : M1,
œï (a1 ‚óè a2) = œï a1 ‚óè œï a2</span></span></span><br></div><label class="goal-separator" for="applicative-v-chk1d6"><hr></label><div class="goal-conclusion">@map G H M1 M2 œï ∆µ = ∆µ</div></blockquote><input class="alectryon-extra-goal-toggle" id="applicative-v-chk1d7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>M1, M2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>src_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M1</span></span></span><br><span><var>src_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M1</span></span></span><br><span><var>tgt_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M2</span></span></span><br><span><var>tgt_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>M1 -&gt; M2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid_Morphism M1 M2 src_op src_unit tgt_op
  tgt_unit œï</span></span></span><br><span><var>monmor_src</var><span class="hyp-type"><b>: </b><span>@Monoid M1 src_op src_unit</span></span></span><br><span><var>monmor_tgt</var><span class="hyp-type"><b>: </b><span>@Monoid M2 tgt_op tgt_unit</span></span></span><br><span><var>monmor_unit</var><span class="hyp-type"><b>: </b><span>œï ∆µ = ∆µ</span></span></span><br><span><var>monmor_op</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : M1,
œï (a1 ‚óè a2) = œï a1 ‚óè œï a2</span></span></span><br></div><label class="goal-separator" for="applicative-v-chk1d7"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : G M1,
@map G H M1 M2 œï (a1 ‚óè a2) =
@map G H M1 M2 œï a1 ‚óè @map G H M1 M2 œï a2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1d8" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1d8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>M1, M2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>src_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M1</span></span></span><br><span><var>src_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M1</span></span></span><br><span><var>tgt_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M2</span></span></span><br><span><var>tgt_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>M1 -&gt; M2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid_Morphism M1 M2 src_op src_unit tgt_op
  tgt_unit œï</span></span></span><br><span><var>monmor_src</var><span class="hyp-type"><b>: </b><span>@Monoid M1 src_op src_unit</span></span></span><br><span><var>monmor_tgt</var><span class="hyp-type"><b>: </b><span>@Monoid M2 tgt_op tgt_unit</span></span></span><br><span><var>monmor_unit</var><span class="hyp-type"><b>: </b><span>œï ∆µ = ∆µ</span></span></span><br><span><var>monmor_op</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : M1,
œï (a1 ‚óè a2) = œï a1 ‚óè œï a2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@Monoid (G M1)
  (@Monoid_op_applicative G M1 H H1 src_op)
  (@Monoid_unit_applicative G M1 H0 src_unit)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1d9" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1d9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>M1, M2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>src_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M1</span></span></span><br><span><var>src_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M1</span></span></span><br><span><var>tgt_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M2</span></span></span><br><span><var>tgt_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>M1 -&gt; M2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid_Morphism M1 M2 src_op src_unit tgt_op
  tgt_unit œï</span></span></span><br><span><var>monmor_src</var><span class="hyp-type"><b>: </b><span>@Monoid M1 src_op src_unit</span></span></span><br><span><var>monmor_tgt</var><span class="hyp-type"><b>: </b><span>@Monoid M2 tgt_op tgt_unit</span></span></span><br><span><var>monmor_unit</var><span class="hyp-type"><b>: </b><span>œï ∆µ = ∆µ</span></span></span><br><span><var>monmor_op</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : M1,
œï (a1 ‚óè a2) = œï a1 ‚óè œï a2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@Monoid (G M2)
  (@Monoid_op_applicative G M2 H H1 tgt_op)
  (@Monoid_unit_applicative G M2 H0 tgt_unit)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1da" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1da">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>M1, M2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>src_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M1</span></span></span><br><span><var>src_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M1</span></span></span><br><span><var>tgt_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M2</span></span></span><br><span><var>tgt_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>M1 -&gt; M2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid_Morphism M1 M2 src_op src_unit tgt_op
  tgt_unit œï</span></span></span><br><span><var>monmor_src</var><span class="hyp-type"><b>: </b><span>@Monoid M1 src_op src_unit</span></span></span><br><span><var>monmor_tgt</var><span class="hyp-type"><b>: </b><span>@Monoid M2 tgt_op tgt_unit</span></span></span><br><span><var>monmor_unit</var><span class="hyp-type"><b>: </b><span>œï ∆µ = ∆µ</span></span></span><br><span><var>monmor_op</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : M1,
œï (a1 ‚óè a2) = œï a1 ‚óè œï a2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H M1 M2 œï ∆µ = ∆µ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1db" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1db">unfold_ops @Monoid_unit_applicative.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>M1, M2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>src_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M1</span></span></span><br><span><var>src_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M1</span></span></span><br><span><var>tgt_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M2</span></span></span><br><span><var>tgt_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>M1 -&gt; M2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid_Morphism M1 M2 src_op src_unit tgt_op
  tgt_unit œï</span></span></span><br><span><var>monmor_src</var><span class="hyp-type"><b>: </b><span>@Monoid M1 src_op src_unit</span></span></span><br><span><var>monmor_tgt</var><span class="hyp-type"><b>: </b><span>@Monoid M2 tgt_op tgt_unit</span></span></span><br><span><var>monmor_unit</var><span class="hyp-type"><b>: </b><span>œï ∆µ = ∆µ</span></span></span><br><span><var>monmor_op</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : M1,
œï (a1 ‚óè a2) = œï a1 ‚óè œï a2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H M1 M2 œï (@pure G H0 M1 ∆µ) = @pure G H0 M2 ∆µ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1dc" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1dc"><span class="nb">rewrite</span> (app_pure_natural).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>M1, M2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>src_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M1</span></span></span><br><span><var>src_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M1</span></span></span><br><span><var>tgt_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M2</span></span></span><br><span><var>tgt_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>M1 -&gt; M2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid_Morphism M1 M2 src_op src_unit tgt_op
  tgt_unit œï</span></span></span><br><span><var>monmor_src</var><span class="hyp-type"><b>: </b><span>@Monoid M1 src_op src_unit</span></span></span><br><span><var>monmor_tgt</var><span class="hyp-type"><b>: </b><span>@Monoid M2 tgt_op tgt_unit</span></span></span><br><span><var>monmor_unit</var><span class="hyp-type"><b>: </b><span>œï ∆µ = ∆µ</span></span></span><br><span><var>monmor_op</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : M1,
œï (a1 ‚óè a2) = œï a1 ‚óè œï a2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@pure G H0 M2 (œï ∆µ) = @pure G H0 M2 ∆µ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> monmor_unit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1dd" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1dd">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>M1, M2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>src_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M1</span></span></span><br><span><var>src_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M1</span></span></span><br><span><var>tgt_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M2</span></span></span><br><span><var>tgt_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>M1 -&gt; M2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid_Morphism M1 M2 src_op src_unit tgt_op
  tgt_unit œï</span></span></span><br><span><var>monmor_src</var><span class="hyp-type"><b>: </b><span>@Monoid M1 src_op src_unit</span></span></span><br><span><var>monmor_tgt</var><span class="hyp-type"><b>: </b><span>@Monoid M2 tgt_op tgt_unit</span></span></span><br><span><var>monmor_unit</var><span class="hyp-type"><b>: </b><span>œï ∆µ = ∆µ</span></span></span><br><span><var>monmor_op</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : M1,
œï (a1 ‚óè a2) = œï a1 ‚óè œï a2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : G M1,
@map G H M1 M2 œï (a1 ‚óè a2) =
@map G H M1 M2 œï a1 ‚óè @map G H M1 M2 œï a2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1de" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1de"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>M1, M2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>src_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M1</span></span></span><br><span><var>src_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M1</span></span></span><br><span><var>tgt_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M2</span></span></span><br><span><var>tgt_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>M1 -&gt; M2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid_Morphism M1 M2 src_op src_unit tgt_op
  tgt_unit œï</span></span></span><br><span><var>monmor_src</var><span class="hyp-type"><b>: </b><span>@Monoid M1 src_op src_unit</span></span></span><br><span><var>monmor_tgt</var><span class="hyp-type"><b>: </b><span>@Monoid M2 tgt_op tgt_unit</span></span></span><br><span><var>monmor_unit</var><span class="hyp-type"><b>: </b><span>œï ∆µ = ∆µ</span></span></span><br><span><var>monmor_op</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : M1,
œï (a1 ‚óè a2) = œï a1 ‚óè œï a2</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>G M1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H M1 M2 œï (a1 ‚óè a2) =
@map G H M1 M2 œï a1 ‚óè @map G H M1 M2 œï a2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1df" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1df">unfold_ops @Monoid_op_applicative.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>M1, M2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>src_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M1</span></span></span><br><span><var>src_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M1</span></span></span><br><span><var>tgt_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M2</span></span></span><br><span><var>tgt_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>M1 -&gt; M2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid_Morphism M1 M2 src_op src_unit tgt_op
  tgt_unit œï</span></span></span><br><span><var>monmor_src</var><span class="hyp-type"><b>: </b><span>@Monoid M1 src_op src_unit</span></span></span><br><span><var>monmor_tgt</var><span class="hyp-type"><b>: </b><span>@Monoid M2 tgt_op tgt_unit</span></span></span><br><span><var>monmor_unit</var><span class="hyp-type"><b>: </b><span>œï ∆µ = ∆µ</span></span></span><br><span><var>monmor_op</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : M1,
œï (a1 ‚óè a2) = œï a1 ‚óè œï a2</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>G M1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H M1 M2 œï
  (@map G H (M1 * M1) M1
     (@uncurry M1 M1 M1 (@monoid_op M1 src_op))
     (a1 ‚äó a2)) =
@map G H (M2 * M2) M2
  (@uncurry M2 M2 M2 (@monoid_op M2 tgt_op))
  (@map G H M1 M2 œï a1 ‚äó @map G H M1 M2 œï a2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1e0" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1e0">compose near (a1 ‚äó a2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>M1, M2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>src_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M1</span></span></span><br><span><var>src_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M1</span></span></span><br><span><var>tgt_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M2</span></span></span><br><span><var>tgt_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>M1 -&gt; M2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid_Morphism M1 M2 src_op src_unit tgt_op
  tgt_unit œï</span></span></span><br><span><var>monmor_src</var><span class="hyp-type"><b>: </b><span>@Monoid M1 src_op src_unit</span></span></span><br><span><var>monmor_tgt</var><span class="hyp-type"><b>: </b><span>@Monoid M2 tgt_op tgt_unit</span></span></span><br><span><var>monmor_unit</var><span class="hyp-type"><b>: </b><span>œï ∆µ = ∆µ</span></span></span><br><span><var>monmor_op</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : M1,
œï (a1 ‚óè a2) = œï a1 ‚óè œï a2</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>G M1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(@map G H M1 M2 œï
 ‚àò @map G H (M1 * M1) M1
     (@uncurry M1 M1 M1 (@monoid_op M1 src_op)))
  (a1 ‚äó a2) =
@map G H (M2 * M2) M2
  (@uncurry M2 M2 M2 (@monoid_op M2 tgt_op))
  (@map G H M1 M2 œï a1 ‚äó @map G H M1 M2 œï a2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1e1" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1e1"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>M1, M2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>src_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M1</span></span></span><br><span><var>src_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M1</span></span></span><br><span><var>tgt_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M2</span></span></span><br><span><var>tgt_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>M1 -&gt; M2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid_Morphism M1 M2 src_op src_unit tgt_op
  tgt_unit œï</span></span></span><br><span><var>monmor_src</var><span class="hyp-type"><b>: </b><span>@Monoid M1 src_op src_unit</span></span></span><br><span><var>monmor_tgt</var><span class="hyp-type"><b>: </b><span>@Monoid M2 tgt_op tgt_unit</span></span></span><br><span><var>monmor_unit</var><span class="hyp-type"><b>: </b><span>œï ∆µ = ∆µ</span></span></span><br><span><var>monmor_op</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : M1,
œï (a1 ‚óè a2) = œï a1 ‚óè œï a2</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>G M1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (M1 * M1) M2
  (œï ‚àò @uncurry M1 M1 M1 (@monoid_op M1 src_op))
  (a1 ‚äó a2) =
@map G H (M2 * M2) M2
  (@uncurry M2 M2 M2 (@monoid_op M2 tgt_op))
  (@map G H M1 M2 œï a1 ‚äó @map G H M1 M2 œï a2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1e2" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1e2"><span class="nb">rewrite</span> (app_mult_natural).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>M1, M2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>src_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M1</span></span></span><br><span><var>src_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M1</span></span></span><br><span><var>tgt_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M2</span></span></span><br><span><var>tgt_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>M1 -&gt; M2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid_Morphism M1 M2 src_op src_unit tgt_op
  tgt_unit œï</span></span></span><br><span><var>monmor_src</var><span class="hyp-type"><b>: </b><span>@Monoid M1 src_op src_unit</span></span></span><br><span><var>monmor_tgt</var><span class="hyp-type"><b>: </b><span>@Monoid M2 tgt_op tgt_unit</span></span></span><br><span><var>monmor_unit</var><span class="hyp-type"><b>: </b><span>œï ∆µ = ∆µ</span></span></span><br><span><var>monmor_op</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : M1,
œï (a1 ‚óè a2) = œï a1 ‚óè œï a2</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>G M1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (M1 * M1) M2
  (œï ‚àò @uncurry M1 M1 M1 (@monoid_op M1 src_op))
  (a1 ‚äó a2) =
@map G H (M2 * M2) M2
  (@uncurry M2 M2 M2 (@monoid_op M2 tgt_op))
  (@map G H (M1 * M1) (M2 * M2)
     (@map_tensor M1 M2 œï M1 M2 œï) (a1 ‚äó a2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1e3" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1e3">compose near (a1 ‚äó a2) on <span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>M1, M2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>src_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M1</span></span></span><br><span><var>src_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M1</span></span></span><br><span><var>tgt_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M2</span></span></span><br><span><var>tgt_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>M1 -&gt; M2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid_Morphism M1 M2 src_op src_unit tgt_op
  tgt_unit œï</span></span></span><br><span><var>monmor_src</var><span class="hyp-type"><b>: </b><span>@Monoid M1 src_op src_unit</span></span></span><br><span><var>monmor_tgt</var><span class="hyp-type"><b>: </b><span>@Monoid M2 tgt_op tgt_unit</span></span></span><br><span><var>monmor_unit</var><span class="hyp-type"><b>: </b><span>œï ∆µ = ∆µ</span></span></span><br><span><var>monmor_op</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : M1,
œï (a1 ‚óè a2) = œï a1 ‚óè œï a2</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>G M1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (M1 * M1) M2
  (œï ‚àò @uncurry M1 M1 M1 (@monoid_op M1 src_op))
  (a1 ‚äó a2) =
(@map G H (M2 * M2) M2
   (@uncurry M2 M2 M2 (@monoid_op M2 tgt_op))
 ‚àò @map G H (M1 * M1) (M2 * M2)
     (@map_tensor M1 M2 œï M1 M2 œï)) (a1 ‚äó a2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1e4" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1e4"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>M1, M2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>src_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M1</span></span></span><br><span><var>src_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M1</span></span></span><br><span><var>tgt_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M2</span></span></span><br><span><var>tgt_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>M1 -&gt; M2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid_Morphism M1 M2 src_op src_unit tgt_op
  tgt_unit œï</span></span></span><br><span><var>monmor_src</var><span class="hyp-type"><b>: </b><span>@Monoid M1 src_op src_unit</span></span></span><br><span><var>monmor_tgt</var><span class="hyp-type"><b>: </b><span>@Monoid M2 tgt_op tgt_unit</span></span></span><br><span><var>monmor_unit</var><span class="hyp-type"><b>: </b><span>œï ∆µ = ∆µ</span></span></span><br><span><var>monmor_op</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : M1,
œï (a1 ‚óè a2) = œï a1 ‚óè œï a2</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>G M1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@map G H (M1 * M1) M2
  (œï ‚àò @uncurry M1 M1 M1 (@monoid_op M1 src_op))
  (a1 ‚äó a2) =
@map G H (M1 * M1) M2
  (@uncurry M2 M2 M2 (@monoid_op M2 tgt_op)
   ‚àò @map_tensor M1 M2 œï M1 M2 œï) (a1 ‚äó a2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1e5" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1e5">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>M1, M2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>src_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M1</span></span></span><br><span><var>src_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M1</span></span></span><br><span><var>tgt_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M2</span></span></span><br><span><var>tgt_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>M1 -&gt; M2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid_Morphism M1 M2 src_op src_unit tgt_op
  tgt_unit œï</span></span></span><br><span><var>monmor_src</var><span class="hyp-type"><b>: </b><span>@Monoid M1 src_op src_unit</span></span></span><br><span><var>monmor_tgt</var><span class="hyp-type"><b>: </b><span>@Monoid M2 tgt_op tgt_unit</span></span></span><br><span><var>monmor_unit</var><span class="hyp-type"><b>: </b><span>œï ∆µ = ∆µ</span></span></span><br><span><var>monmor_op</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : M1,
œï (a1 ‚óè a2) = œï a1 ‚óè œï a2</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>G M1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï ‚àò @uncurry M1 M1 M1 (@monoid_op M1 src_op) =
@uncurry M2 M2 M2 (@monoid_op M2 tgt_op)
‚àò @map_tensor M1 M2 œï M1 M2 œï</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1e6" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1e6">ext [m1 m2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>M1, M2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>src_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M1</span></span></span><br><span><var>src_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M1</span></span></span><br><span><var>tgt_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M2</span></span></span><br><span><var>tgt_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>M1 -&gt; M2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid_Morphism M1 M2 src_op src_unit tgt_op
  tgt_unit œï</span></span></span><br><span><var>monmor_src</var><span class="hyp-type"><b>: </b><span>@Monoid M1 src_op src_unit</span></span></span><br><span><var>monmor_tgt</var><span class="hyp-type"><b>: </b><span>@Monoid M2 tgt_op tgt_unit</span></span></span><br><span><var>monmor_unit</var><span class="hyp-type"><b>: </b><span>œï ∆µ = ∆µ</span></span></span><br><span><var>monmor_op</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : M1,
œï (a1 ‚óè a2) = œï a1 ‚óè œï a2</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>G M1</span></span></span><br><span><var>m1, m2</var><span class="hyp-type"><b>: </b><span>M1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(œï ‚àò @uncurry M1 M1 M1 (@monoid_op M1 src_op))
  (m1, m2) =
(@uncurry M2 M2 M2 (@monoid_op M2 tgt_op)
 ‚àò @map_tensor M1 M2 œï M1 M2 œï) (m1, m2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1e7" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1e7"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>M1, M2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>src_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M1</span></span></span><br><span><var>src_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M1</span></span></span><br><span><var>tgt_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M2</span></span></span><br><span><var>tgt_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>M1 -&gt; M2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid_Morphism M1 M2 src_op src_unit tgt_op
  tgt_unit œï</span></span></span><br><span><var>monmor_src</var><span class="hyp-type"><b>: </b><span>@Monoid M1 src_op src_unit</span></span></span><br><span><var>monmor_tgt</var><span class="hyp-type"><b>: </b><span>@Monoid M2 tgt_op tgt_unit</span></span></span><br><span><var>monmor_unit</var><span class="hyp-type"><b>: </b><span>œï ∆µ = ∆µ</span></span></span><br><span><var>monmor_op</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : M1,
œï (a1 ‚óè a2) = œï a1 ‚óè œï a2</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>G M1</span></span></span><br><span><var>m1, m2</var><span class="hyp-type"><b>: </b><span>M1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (@uncurry M1 M1 M1 (@monoid_op M1 src_op) (m1, m2)) =
@uncurry M2 M2 M2 (@monoid_op M2 tgt_op)
  (@map_tensor M1 M2 œï M1 M2 œï (m1, m2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1e8" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1e8"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>M1, M2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>src_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M1</span></span></span><br><span><var>src_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M1</span></span></span><br><span><var>tgt_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M2</span></span></span><br><span><var>tgt_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>M1 -&gt; M2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid_Morphism M1 M2 src_op src_unit tgt_op
  tgt_unit œï</span></span></span><br><span><var>monmor_src</var><span class="hyp-type"><b>: </b><span>@Monoid M1 src_op src_unit</span></span></span><br><span><var>monmor_tgt</var><span class="hyp-type"><b>: </b><span>@Monoid M2 tgt_op tgt_unit</span></span></span><br><span><var>monmor_unit</var><span class="hyp-type"><b>: </b><span>œï ∆µ = ∆µ</span></span></span><br><span><var>monmor_op</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : M1,
œï (a1 ‚óè a2) = œï a1 ‚óè œï a2</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>G M1</span></span></span><br><span><var>m1, m2</var><span class="hyp-type"><b>: </b><span>M1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (m1 ‚óè m2) = œï m1 ‚óè œï m2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicative-v-chk1e9" style="display: none" type="checkbox"><label class="alectryon-input" for="applicative-v-chk1e9"><span class="nb">rewrite</span> monmor_op.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>@Applicative G H H0 H1</span></span></span><br><span><var>M1, M2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>src_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M1</span></span></span><br><span><var>src_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M1</span></span></span><br><span><var>tgt_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M2</span></span></span><br><span><var>tgt_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>M1 -&gt; M2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>@Monoid_Morphism M1 M2 src_op src_unit tgt_op
  tgt_unit œï</span></span></span><br><span><var>monmor_src</var><span class="hyp-type"><b>: </b><span>@Monoid M1 src_op src_unit</span></span></span><br><span><var>monmor_tgt</var><span class="hyp-type"><b>: </b><span>@Monoid M2 tgt_op tgt_unit</span></span></span><br><span><var>monmor_unit</var><span class="hyp-type"><b>: </b><span>œï ∆µ = ∆µ</span></span></span><br><span><var>monmor_op</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : M1,
œï (a1 ‚óè a2) = œï a1 ‚óè œï a2</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>G M1</span></span></span><br><span><var>m1, m2</var><span class="hyp-type"><b>: </b><span>M1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï m1 ‚óè œï m2 = œï m1 ‚óè œï m2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">with_hom</span>.</span></span></pre>
</div>
</div></body>
</html>
