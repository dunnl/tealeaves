<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<title>SystemF_Targeted.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.16.0+0.16.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Tealeaves <span class="kn">Require Export</span>
  Examples.SystemF.Syntax
  Simplification.Tests.Support
  Simplification.MBinddt
  Simplification.Tests.SystemF_Binddt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Generalizable Variables</span> <span class="nf">G</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Arguments</span> mbinddt {ix} {W}%type_scope {T} U%function_scope
  {MBind} {F}%function_scope {H H0 H1 A B} _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Generalizable Variables</span> <span class="nf">A</span> B C F W T U K M.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">local_lemmas_needed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    (<span class="nv">U</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
      `{MultiDecoratedTraversablePreModule W T U}
      `{! MultiDecoratedTraversableMonad W T}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk0"><span class="kn">Lemma</span> <span class="nf">kbindd_to_mbindd</span>: <span class="kr">forall</span> <span class="nv">A</span> (<span class="nv">k</span>: K) (<span class="nv">f</span>: W * A -&gt; T k A),
      kbindd U k f =  mbindd U (btgd k f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule W T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  W T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">k</span> : K) (<span class="nv">f</span> : W * A -&gt; T k A),
kbindd U k f = mbindd U (btgd k f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule W T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  W T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">k</span> : K) (<span class="nv">f</span> : W * A -&gt; T k A),
kbindd U k f = mbindd U (btgd k f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk2"><span class="kn">Lemma</span> <span class="nf">kbind_to_mbind</span>: <span class="kr">forall</span> <span class="nv">A</span> (<span class="nv">k</span>: K) (<span class="nv">f</span>: A -&gt; T k A),
      kbind U k f =  mbind U (btg k f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule W T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  W T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">k</span> : K) (<span class="nv">f</span> : A -&gt; T k A),
kbind U k f = mbind U (btg k f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule W T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  W T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">k</span> : K) (<span class="nv">f</span> : A -&gt; T k A),
kbind U k f = mbind U (btg k f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk4"><span class="kn">Lemma</span> <span class="nf">btgd_compose_incr</span>: <span class="kr">forall</span> <span class="nv">A</span> (<span class="nv">k</span>: K) (<span class="nv">f</span>: W * A -&gt; SystemF k A) <span class="nv">w</span>,
      btgd k f ‚óª allK (incr w) =
        btgd k (f ‚¶ø w).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule W T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  W T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">k</span> : K) (<span class="nv">f</span> : W * A -&gt; SystemF k A)
  (<span class="nv">w</span> : W), btgd k f ‚óª allK (incr w) = btgd k (f ‚¶ø w)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule W T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  W T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">k</span> : K) (<span class="nv">f</span> : W * A -&gt; SystemF k A)
  (<span class="nv">w</span> : W), btgd k f ‚óª allK (incr w) = btgd k (f ‚¶ø w)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk6"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule W T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  W T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; SystemF k A</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">btgd k f ‚óª allK (incr w) = btgd k (f ‚¶ø w)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk7">ext j.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule W T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  W T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; SystemF k A</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(btgd k f ‚óª allK (incr w)) j = btgd k (f ‚¶ø w) j</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk8"><span class="nb">unfold</span> allK, const.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule W T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  W T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; SystemF k A</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(btgd k f ‚óª (<span class="kr">fun</span> <span class="nv">_</span> : K =&gt; incr w)) j =
btgd k (f ‚¶ø w) j</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk9"><span class="nb">unfold</span> vec_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule W T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  W T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; SystemF k A</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">btgd k f j ‚àò incr w = btgd k (f ‚¶ø w) j</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chka"><span class="nb">compare</span> values k <span class="kn">and</span> j.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule W T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  W T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; SystemF j A</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>DESTR_EQs</var><span class="hyp-type"><b>: </b><span>j = j</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">btgd j f j ‚àò incr w = btgd j (f ‚¶ø w) j</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="systemf-targeted-v-chkb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule W T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  W T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; SystemF k A</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>k &lt;&gt; j</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>j &lt;&gt; k</span></span></span><br></div><label class="goal-separator" for="systemf-targeted-v-chkb"><hr></label><div class="goal-conclusion">btgd k f j ‚àò incr w = btgd k (f ‚¶ø w) j</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chkc">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule W T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  W T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; SystemF j A</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>DESTR_EQs</var><span class="hyp-type"><b>: </b><span>j = j</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">btgd j f j ‚àò incr w = btgd j (f ‚¶ø w) j</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chkd"><span class="nb">autorewrite with</span> tea_tgt_eq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule W T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  W T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; SystemF j A</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>DESTR_EQs</var><span class="hyp-type"><b>: </b><span>j = j</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f ‚àò incr w = f ‚¶ø w</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chke">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule W T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  W T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; SystemF k A</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>k &lt;&gt; j</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>j &lt;&gt; k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">btgd k f j ‚àò incr w = btgd k (f ‚¶ø w) j</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chkf">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule W T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  W T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; SystemF k A</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>k &lt;&gt; j</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>j &lt;&gt; k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">btgd k f j ‚àò incr w = btgd k (f ‚¶ø w) j</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk10"><span class="nb">autorewrite with</span> tea_tgt_neq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule W T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  W T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; SystemF k A</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>k &lt;&gt; j</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>j &lt;&gt; k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mret SystemF j ‚àò extract ‚àò incr w =
mret SystemF j ‚àò extract</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk11">reassociate -&gt; on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule W T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  W T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; SystemF k A</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>k &lt;&gt; j</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>j &lt;&gt; k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mret SystemF j ‚àò (extract ‚àò incr w) =
mret SystemF j ‚àò extract</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk12"><span class="nb">rewrite</span> extract_incr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule W T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  W T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; SystemF k A</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>k &lt;&gt; j</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>j &lt;&gt; k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mret SystemF j ‚àò extract = mret SystemF j ‚àò extract</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk13"><span class="kn">Lemma</span> <span class="nf">tgtdt_compose_incr</span> `{Applicative G}:
    <span class="kr">forall</span> <span class="nv">A</span> (<span class="nv">k</span>: K) (<span class="nv">f</span>: W * A -&gt; G A) <span class="nv">w</span>,
      tgtdt k f ‚óª allK (incr w) =
        tgtdt k (f ‚¶ø w).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule W T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  W T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">k</span> : K) (<span class="nv">f</span> : W * A -&gt; G A) (<span class="nv">w</span> : W),
tgtdt k f ‚óª allK (incr w) = tgtdt k (f ‚¶ø w)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk14"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule W T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  W T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">k</span> : K) (<span class="nv">f</span> : W * A -&gt; G A) (<span class="nv">w</span> : W),
tgtdt k f ‚óª allK (incr w) = tgtdt k (f ‚¶ø w)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk15"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule W T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  W T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G A</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tgtdt k f ‚óª allK (incr w) = tgtdt k (f ‚¶ø w)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk16">ext j.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule W T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  W T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G A</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(tgtdt k f ‚óª allK (incr w)) j = tgtdt k (f ‚¶ø w) j</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk17"><span class="nb">unfold</span> allK, const.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule W T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  W T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G A</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(tgtdt k f ‚óª (<span class="kr">fun</span> <span class="nv">_</span> : K =&gt; incr w)) j =
tgtdt k (f ‚¶ø w) j</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk18"><span class="nb">unfold</span> vec_compose, compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule W T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  W T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G A</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tgtdt k f j ‚óã incr w = tgtdt k (f ‚¶ø w) j</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk19"><span class="nb">unfold</span> tgtdt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule W T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  W T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G A</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">a</span> : W * A =&gt;
 <span class="kr">let</span>
 &#39;(w, a0) := incr w a <span class="kr">in</span>
  <span class="kr">if</span> k == j <span class="kr">then</span> f (w, a0) <span class="kr">else</span> pure a0) =
(<span class="kr">fun</span> &#39;(w0, a) =&gt;
 <span class="kr">if</span> k == j <span class="kr">then</span> (f ‚¶ø w) (w0, a) <span class="kr">else</span> pure a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk1a">ext [w&#39; a].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ix</var><span class="hyp-type"><b>: </b><span>Index</span></span></span><br><span><var>W</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>K -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MReturn0</var><span class="hyp-type"><b>: </b><span>MReturn T</span></span></span><br><span><var>MBind0</var><span class="hyp-type"><b>: </b><span>MBind W T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : K, MBind W T (T k)</span></span></span><br><span><var>mn_op</var><span class="hyp-type"><b>: </b><span>Monoid_op W</span></span></span><br><span><var>mn_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit W</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversablePreModule W T U</span></span></span><br><span><var>MultiDecoratedTraversableMonad0</var><span class="hyp-type"><b>: </b><span>MultiDecoratedTraversableMonad
  W T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>W * A -&gt; G A</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>w'</var><span class="hyp-type"><b>: </b><span>W</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">let</span>
 &#39;(w, a) := incr w (w&#39;, a) <span class="kr">in</span>
  <span class="kr">if</span> k == j <span class="kr">then</span> f (w, a) <span class="kr">else</span> pure a) =
(<span class="kr">if</span> k == j <span class="kr">then</span> (f ‚¶ø w) (w&#39;, a) <span class="kr">else</span> pure a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">compare</span> values k <span class="kn">and</span> j.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">local_lemmas_needed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_kbindd_pre_refold_hook</span> :=
  <span class="nb">rewrite</span> ?(btgd_compose_incr).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_kbindd_post_refold_hook</span> :=
  <span class="kp">idtac</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_kbindd</span> :=
  <span class="nb">rewrite</span> <span class="nl">?kbindd_to_mbindd</span>;
  simplify_mbindd;
   simplify_kbindd_pre_refold_hook;
  <span class="nb">rewrite</span> &lt;- <span class="nl">?kbindd_to_mbindd</span>;
  simplify_kbindd_post_refold_hook.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** &lt;&lt;kbindd&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">rw_kbindd</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    (<span class="nv">A</span> : <span class="kt">Type</span>)
      (<span class="nv">k</span> : K2)
      (<span class="nv">f</span> : list K2 * A -&gt; SystemF k A).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">tactic_being_tested</span> ::= simplify_kbindd.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk1b"><span class="kn">Lemma</span> <span class="nf">kbindd_type_rw1</span> : <span class="kr">forall</span> <span class="nv">c</span>,
      kbindd typ k f (ty_c c) = ty_c c.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; SystemF k A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : base_typ, kbindd typ k f (ty_c c) = ty_c c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk1c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; SystemF k A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : base_typ, kbindd typ k f (ty_c c) = ty_c c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk1d"><span class="kn">Lemma</span> <span class="nf">kbindd_type_rw2_neq</span> : <span class="kr">forall</span> (<span class="nv">a</span> : A),
      k &lt;&gt; ktyp -&gt;
      kbindd typ k f (ty_v a) = ty_v a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; SystemF k A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
k &lt;&gt; ktyp -&gt; kbindd typ k f (ty_v a) = ty_v a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk1e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; SystemF k A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
k &lt;&gt; ktyp -&gt; kbindd typ k f (ty_v a) = ty_v a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk1f"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; SystemF k A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>k &lt;&gt; ktyp</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">kbindd typ k f (ty_v a) = ty_v a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk20">simplify_kbindd.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; SystemF k A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>k &lt;&gt; ktyp</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">btgd k f ktyp ([], a) = ty_v a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> btgd_neq; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(*</span>
<span class="c">    Lemma kbindd_type_neq_rw2_eq : forall (a : A) (Heq: k = ktyp),</span>
<span class="c">        kbindd typ k f (ty_v a) = rew Heq in (f ([], a)).</span>
<span class="c">    Proof.</span>
<span class="c">      intros.</span>
<span class="c">      simplify_kbindd.</span>
<span class="c">      subst.</span>
<span class="c">      rewrite btgd_eq. auto.</span>
<span class="c">    Qed.</span>
<span class="c">   *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk21"><span class="kn">Lemma</span> <span class="nf">kbindd_type_rw3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : typ A),
      kbindd typ k f (ty_ar t1 t2) =
        ty_ar (kbindd typ k f t1) (kbindd typ k f t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; SystemF k A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : typ A,
kbindd typ k f (ty_ar t1 t2) =
ty_ar (kbindd typ k f t1) (kbindd typ k f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk22"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; SystemF k A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : typ A,
kbindd typ k f (ty_ar t1 t2) =
ty_ar (kbindd typ k f t1) (kbindd typ k f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk23"><span class="kn">Lemma</span> <span class="nf">kbindd_type_rw4</span> : <span class="kr">forall</span> (<span class="nv">body</span> : typ A),
      kbindd typ k f (ty_univ body) =
        ty_univ (kbindd typ k (f ‚¶ø [ktyp]) body).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; SystemF k A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ A,
kbindd typ k f (ty_univ body) =
ty_univ (kbindd typ k (f ‚¶ø [ktyp]) body)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk24"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; SystemF k A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ A,
kbindd typ k f (ty_univ body) =
ty_univ (kbindd typ k (f ‚¶ø [ktyp]) body)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk25"><span class="kn">Lemma</span> <span class="nf">kbindd_term_rw1_neq</span> : <span class="kr">forall</span> (<span class="nv">a</span> : A),
      k &lt;&gt; ktrm -&gt;
      kbindd term k f (tm_var a) = tm_var a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; SystemF k A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
k &lt;&gt; ktrm -&gt; kbindd term k f (tm_var a) = tm_var a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk26"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; SystemF k A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
k &lt;&gt; ktrm -&gt; kbindd term k f (tm_var a) = tm_var a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk27"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; SystemF k A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>k &lt;&gt; ktrm</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">kbindd term k f (tm_var a) = tm_var a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk28">simplify_kbindd.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; SystemF k A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>k &lt;&gt; ktrm</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">btgd k f ktrm ([], a) = tm_var a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> btgd_neq; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk29"><span class="kn">Lemma</span> <span class="nf">kbindd_term_rw2</span> : <span class="kr">forall</span> (<span class="nv">œÑ</span> : typ A) (<span class="nv">t</span> : term A),
      kbindd term k f (tm_abs œÑ t) =
        tm_abs (kbindd typ k f œÑ) (kbindd term k (f ‚¶ø [ktrm]) t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; SystemF k A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ A) (<span class="nv">t</span> : term A),
kbindd term k f (tm_abs œÑ t) =
tm_abs (kbindd typ k f œÑ)
  (kbindd term k (f ‚¶ø [ktrm]) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk2a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; SystemF k A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ A) (<span class="nv">t</span> : term A),
kbindd term k f (tm_abs œÑ t) =
tm_abs (kbindd typ k f œÑ)
  (kbindd term k (f ‚¶ø [ktrm]) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk2b"><span class="kn">Lemma</span> <span class="nf">kbindd_term_rw3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term A),
      kbindd term k f (tm_app t1 t2) =
        tm_app (kbindd term k f t1) (kbindd term k f t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; SystemF k A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term A,
kbindd term k f (tm_app t1 t2) =
tm_app (kbindd term k f t1) (kbindd term k f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk2c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; SystemF k A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term A,
kbindd term k f (tm_app t1 t2) =
tm_app (kbindd term k f t1) (kbindd term k f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk2d"><span class="kn">Lemma</span> <span class="nf">kbindd_term_rw4</span> : <span class="kr">forall</span> (<span class="nv">t</span> : term A),
      kbindd term k f (tm_tab t) =
        tm_tab (kbindd term k (f ‚¶ø [ktyp]) t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; SystemF k A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term A,
kbindd term k f (tm_tab t) =
tm_tab (kbindd term k (f ‚¶ø [ktyp]) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk2e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; SystemF k A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term A,
kbindd term k f (tm_tab t) =
tm_tab (kbindd term k (f ‚¶ø [ktyp]) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk2f"><span class="kn">Lemma</span> <span class="nf">kbindd_term_rw5</span> : <span class="kr">forall</span> (<span class="nv">t</span>: term A) (<span class="nv">œÑ</span> : typ A),
      kbindd term k f (tm_tap t œÑ) =
        tm_tap (kbindd term k f t) (kbindd typ k f œÑ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; SystemF k A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term A) (<span class="nv">œÑ</span> : typ A),
kbindd term k f (tm_tap t œÑ) =
tm_tap (kbindd term k f t) (kbindd typ k f œÑ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk30"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; SystemF k A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term A) (<span class="nv">œÑ</span> : typ A),
kbindd term k f (tm_tap t œÑ) =
tm_tap (kbindd term k f t) (kbindd typ k f œÑ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">rw_kbindd</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_kbind_pre_refold_hook</span> :=
  <span class="nb">rewrite</span> ?(btgd_compose_incr).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_kbind_post_refold_hook</span> :=
  <span class="kp">idtac</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_kbind</span> :=
  <span class="nb">rewrite</span> <span class="nl">?kbind_to_mbind</span>;
  simplify_mbind;
  simplify_kbind_pre_refold_hook;
  <span class="nb">rewrite</span> &lt;- <span class="nl">?kbind_to_mbind</span>;
  simplify_kbind_post_refold_hook.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** &lt;&lt;kbind&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">rw_kbind</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    (<span class="nv">A</span> : <span class="kt">Type</span>)
      (<span class="nv">k</span> : K2)
      (<span class="nv">f</span> : A -&gt; SystemF k A).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">tactic_being_tested</span> ::= simplify_kbind.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk31"><span class="kn">Lemma</span> <span class="nf">kbind_type_rw1</span> : <span class="kr">forall</span> <span class="nv">c</span>,
      kbind typ k f (ty_c c) = ty_c c.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; SystemF k A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : base_typ, kbind typ k f (ty_c c) = ty_c c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk32"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; SystemF k A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : base_typ, kbind typ k f (ty_c c) = ty_c c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk33"><span class="kn">Lemma</span> <span class="nf">kbind_type_rw2_neq</span> : <span class="kr">forall</span> (<span class="nv">a</span> : A),
      k &lt;&gt; ktyp -&gt;
      kbind typ k f (ty_v a) = ty_v a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; SystemF k A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
k &lt;&gt; ktyp -&gt; kbind typ k f (ty_v a) = ty_v a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk34"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; SystemF k A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
k &lt;&gt; ktyp -&gt; kbind typ k f (ty_v a) = ty_v a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk35"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; SystemF k A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>k &lt;&gt; ktyp</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">kbind typ k f (ty_v a) = ty_v a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk36"><span class="nb">rewrite</span> <span class="nl">?kbind_to_mbind</span>;
  simplify_mbind;
  simplify_kbind_pre_refold_hook;
  <span class="nb">rewrite</span> &lt;- <span class="nl">?kbind_to_mbind</span>;
  simplify_kbind_post_refold_hook.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; SystemF k A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>k &lt;&gt; ktyp</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">btg k f ktyp a = ty_v a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">try</span> <span class="nb">rewrite</span> btg_neq; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk37"><span class="kn">Lemma</span> <span class="nf">kbind_type_rw3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : typ A),
      kbind typ k f (ty_ar t1 t2) =
        ty_ar (kbind typ k f t1) (kbind typ k f t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; SystemF k A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : typ A,
kbind typ k f (ty_ar t1 t2) =
ty_ar (kbind typ k f t1) (kbind typ k f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk38"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; SystemF k A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : typ A,
kbind typ k f (ty_ar t1 t2) =
ty_ar (kbind typ k f t1) (kbind typ k f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk39"><span class="kn">Lemma</span> <span class="nf">kbind_type_rw4</span> : <span class="kr">forall</span> (<span class="nv">body</span> : typ A),
      kbind typ k f (ty_univ body) =
        ty_univ (kbind typ k f body).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; SystemF k A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ A,
kbind typ k f (ty_univ body) =
ty_univ (kbind typ k f body)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk3a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; SystemF k A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ A,
kbind typ k f (ty_univ body) =
ty_univ (kbind typ k f body)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk3b"><span class="kn">Lemma</span> <span class="nf">kbind_term_rw1_neq</span> : <span class="kr">forall</span> (<span class="nv">a</span> : A),
      k &lt;&gt; ktrm -&gt;
      kbind term k f (tm_var a) = tm_var a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; SystemF k A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
k &lt;&gt; ktrm -&gt; kbind term k f (tm_var a) = tm_var a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk3c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; SystemF k A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
k &lt;&gt; ktrm -&gt; kbind term k f (tm_var a) = tm_var a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk3d"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; SystemF k A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>k &lt;&gt; ktrm</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">kbind term k f (tm_var a) = tm_var a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk3e">simplify_kbind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; SystemF k A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>k &lt;&gt; ktrm</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">btg k f ktrm a = tm_var a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">try</span> <span class="nb">rewrite</span> btg_neq; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk3f"><span class="kn">Lemma</span> <span class="nf">kbind_term_rw2</span> : <span class="kr">forall</span> (<span class="nv">œÑ</span> : typ A) (<span class="nv">t</span> : term A),
      kbind term k f (tm_abs œÑ t) =
        tm_abs (kbind typ k f œÑ) (kbind term k f t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; SystemF k A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ A) (<span class="nv">t</span> : term A),
kbind term k f (tm_abs œÑ t) =
tm_abs (kbind typ k f œÑ) (kbind term k f t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk40"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; SystemF k A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ A) (<span class="nv">t</span> : term A),
kbind term k f (tm_abs œÑ t) =
tm_abs (kbind typ k f œÑ) (kbind term k f t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk41"><span class="kn">Lemma</span> <span class="nf">kbind_term_rw3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term A),
      kbind term k f (tm_app t1 t2) =
        tm_app (kbind term k f t1) (kbind term k f t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; SystemF k A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term A,
kbind term k f (tm_app t1 t2) =
tm_app (kbind term k f t1) (kbind term k f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk42"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; SystemF k A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term A,
kbind term k f (tm_app t1 t2) =
tm_app (kbind term k f t1) (kbind term k f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk43"><span class="kn">Lemma</span> <span class="nf">kbind_term_rw4</span> : <span class="kr">forall</span> (<span class="nv">t</span> : term A),
      kbind term k f (tm_tab t) =
        tm_tab (kbind term k f t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; SystemF k A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term A,
kbind term k f (tm_tab t) = tm_tab (kbind term k f t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk44"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; SystemF k A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term A,
kbind term k f (tm_tab t) = tm_tab (kbind term k f t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk45"><span class="kn">Lemma</span> <span class="nf">kbind_term_rw5</span> : <span class="kr">forall</span> (<span class="nv">t</span>: term A) (<span class="nv">œÑ</span> : typ A),
      kbind term k f (tm_tap t œÑ) =
        tm_tap (kbind term k f t) (kbind typ k f œÑ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; SystemF k A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term A) (<span class="nv">œÑ</span> : typ A),
kbind term k f (tm_tap t œÑ) =
tm_tap (kbind term k f t) (kbind typ k f œÑ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk46"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; SystemF k A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term A) (<span class="nv">œÑ</span> : typ A),
kbind term k f (tm_tap t œÑ) =
tm_tap (kbind term k f t) (kbind typ k f œÑ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">rw_kbind</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_kmapdt_pre_refold_hook</span> ix :=
  <span class="nb">rewrite</span> ?(tgtdt_compose_incr (ix := ix)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_kmapdt_post_refold_hook</span> :=
  <span class="kp">idtac</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_kmapdt</span> :=
  <span class="kr">match goal with</span>
  | |- <span class="kp">context</span>[kmapdt (W := <span class="nl">?W</span>) (T := <span class="nl">?T</span>) (ix := <span class="nl">?ix</span>)
                <span class="nl">?U</span> <span class="nl">?k</span> <span class="nl">?f</span> <span class="nl">?t</span>] =&gt;
      <span class="nb">rewrite</span> <span class="nl">?kmapdt_to_mmapdt</span>;
      simplify_mmapdt;
      simplify_kmapdt_pre_refold_hook ix;
      <span class="nb">rewrite</span> &lt;- <span class="nl">?kmapdt_to_mmapdt</span>;
      simplify_kmapdt_post_refold_hook
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** &lt;&lt;kmapdt&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">rw_kmapdt</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    (<span class="nv">A</span> : <span class="kt">Type</span>)
      `{Applicative G}
      (k : K2)
      (f : list K2 * A -&gt; G A).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">tactic_being_tested</span> ::= simplify_kmapdt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk47"><span class="kn">Lemma</span> <span class="nf">kmapdt_type_rw1</span> : <span class="kr">forall</span> <span class="nv">c</span>,
      kmapdt (G := G) typ k f (ty_c c) = pure (F := G) (ty_c c).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : base_typ,
kmapdt typ k f (ty_c c) = pure (ty_c c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk48"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : base_typ,
kmapdt typ k f (ty_c c) = pure (ty_c c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk49"><span class="kn">Lemma</span> <span class="nf">kmapdt_type_rw2_neq</span> : <span class="kr">forall</span> (<span class="nv">a</span> : A),
      k &lt;&gt; ktyp -&gt;
      kmapdt typ k f (ty_v a) = pure (ty_v a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
k &lt;&gt; ktyp -&gt; kmapdt typ k f (ty_v a) = pure (ty_v a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk4a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
k &lt;&gt; ktyp -&gt; kmapdt typ k f (ty_v a) = pure (ty_v a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk4b"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; G A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>k &lt;&gt; ktyp</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">kmapdt typ k f (ty_v a) = pure (ty_v a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk4c">simplify_kmapdt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; G A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>k &lt;&gt; ktyp</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (mret SystemF ktyp) &lt;‚ãÜ&gt; tgtdt k f ktyp ([], a) =
pure (ty_v a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(*</span>
<span class="c">    Lemma kmapdt_type_neq_rw2_eq : forall (a : A) (Heq: k = ktyp),</span>
<span class="c">        kmapdt typ k f (ty_v a) = rew Heq in (f ([], a)).</span>
<span class="c">    Proof.</span>
<span class="c">      intros.</span>
<span class="c">      simplify_kmapdt.</span>
<span class="c">      subst.</span>
<span class="c">      rewrite btgd_eq. auto.</span>
<span class="c">    Qed.</span>
<span class="c">   *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk4d"><span class="kn">Lemma</span> <span class="nf">kmapdt_type_rw3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : typ A),
      kmapdt typ k f (ty_ar t1 t2) =
        pure ty_ar &lt;‚ãÜ&gt; (kmapdt typ k f t1) &lt;‚ãÜ&gt; (kmapdt typ k f t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : typ A,
kmapdt typ k f (ty_ar t1 t2) =
pure ty_ar &lt;‚ãÜ&gt; kmapdt typ k f t1 &lt;‚ãÜ&gt; kmapdt typ k f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk4e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : typ A,
kmapdt typ k f (ty_ar t1 t2) =
pure ty_ar &lt;‚ãÜ&gt; kmapdt typ k f t1 &lt;‚ãÜ&gt; kmapdt typ k f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk4f"><span class="kn">Lemma</span> <span class="nf">kmapdt_type_rw4</span> : <span class="kr">forall</span> (<span class="nv">body</span> : typ A),
      kmapdt typ k f (ty_univ body) =
        pure ty_univ &lt;‚ãÜ&gt; (kmapdt typ k (f ‚¶ø [ktyp]) body).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ A,
kmapdt typ k f (ty_univ body) =
pure ty_univ &lt;‚ãÜ&gt; kmapdt typ k (f ‚¶ø [ktyp]) body</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk50"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ A,
kmapdt typ k f (ty_univ body) =
pure ty_univ &lt;‚ãÜ&gt; kmapdt typ k (f ‚¶ø [ktyp]) body</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(*</span>
<span class="c">  Lemma kmapdt_term_rw1_neq : forall (a : A),</span>
<span class="c">      k &lt;&gt; ktrm -&gt;</span>
<span class="c">      kmapdt term k f (tm_var a) = tm_var a.</span>
<span class="c">  Proof.</span>
<span class="c">    intros.</span>
<span class="c">    simplify_kmapdt.</span>
<span class="c">    rewrite btgd_neq; auto.</span>
<span class="c">  Qed.</span>
<span class="c">  *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk51"><span class="kn">Lemma</span> <span class="nf">kmapdt_term_rw2</span> : <span class="kr">forall</span> (<span class="nv">œÑ</span> : typ A) (<span class="nv">t</span> : term A),
      kmapdt term k f (tm_abs œÑ t) =
        pure tm_abs &lt;‚ãÜ&gt; (kmapdt typ k f œÑ)
          &lt;‚ãÜ&gt; (kmapdt term k (f ‚¶ø [ktrm]) t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ A) (<span class="nv">t</span> : term A),
kmapdt term k f (tm_abs œÑ t) =
pure tm_abs &lt;‚ãÜ&gt; kmapdt typ k f œÑ &lt;‚ãÜ&gt;
kmapdt term k (f ‚¶ø [ktrm]) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk52"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ A) (<span class="nv">t</span> : term A),
kmapdt term k f (tm_abs œÑ t) =
pure tm_abs &lt;‚ãÜ&gt; kmapdt typ k f œÑ &lt;‚ãÜ&gt;
kmapdt term k (f ‚¶ø [ktrm]) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk53"><span class="kn">Lemma</span> <span class="nf">kmapdt_term_rw3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term A),
      kmapdt term k f (tm_app t1 t2) =
        pure tm_app &lt;‚ãÜ&gt; (kmapdt term k f t1)
          &lt;‚ãÜ&gt; (kmapdt term k f t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term A,
kmapdt term k f (tm_app t1 t2) =
pure tm_app &lt;‚ãÜ&gt; kmapdt term k f t1 &lt;‚ãÜ&gt;
kmapdt term k f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk54"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term A,
kmapdt term k f (tm_app t1 t2) =
pure tm_app &lt;‚ãÜ&gt; kmapdt term k f t1 &lt;‚ãÜ&gt;
kmapdt term k f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk55"><span class="kn">Lemma</span> <span class="nf">kmapdt_term_rw4</span> : <span class="kr">forall</span> (<span class="nv">t</span> : term A),
      kmapdt term k f (tm_tab t) =
        pure tm_tab &lt;‚ãÜ&gt; (kmapdt term k (f ‚¶ø [ktyp]) t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term A,
kmapdt term k f (tm_tab t) =
pure tm_tab &lt;‚ãÜ&gt; kmapdt term k (f ‚¶ø [ktyp]) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk56"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term A,
kmapdt term k f (tm_tab t) =
pure tm_tab &lt;‚ãÜ&gt; kmapdt term k (f ‚¶ø [ktyp]) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk57"><span class="kn">Lemma</span> <span class="nf">kmapdt_term_rw5</span> : <span class="kr">forall</span> (<span class="nv">t</span>: term A) (<span class="nv">œÑ</span> : typ A),
      kmapdt term k f (tm_tap t œÑ) =
        pure tm_tap &lt;‚ãÜ&gt; (kmapdt term k f t) &lt;‚ãÜ&gt; (kmapdt typ k f œÑ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term A) (<span class="nv">œÑ</span> : typ A),
kmapdt term k f (tm_tap t œÑ) =
pure tm_tap &lt;‚ãÜ&gt; kmapdt term k f t &lt;‚ãÜ&gt; kmapdt typ k f œÑ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk58"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term A) (<span class="nv">œÑ</span> : typ A),
kmapdt term k f (tm_tap t œÑ) =
pure tm_tap &lt;‚ãÜ&gt; kmapdt term k f t &lt;‚ãÜ&gt; kmapdt typ k f œÑ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">rw_kmapdt</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_foldMapkd_pre_refold_hook</span> ix :=
  <span class="kp">idtac</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_foldMapkd_post_refold_hook</span> M :=
  <span class="kp">repeat</span> simplify_applicative_const;
  <span class="kp">repeat</span> simplify_monoid_units;
  <span class="nb">change</span> (@const <span class="kt">Type</span> <span class="kt">Type</span> M <span class="nl">?anything</span>) <span class="kr">with</span> M.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_foldMapkd</span> :=
  <span class="kr">match goal with</span>
  | |- <span class="kp">context</span>[foldMapkd (W := <span class="nl">?W</span>) (T := <span class="nl">?T</span>) (ix := <span class="nl">?ix</span>)
                        (M := <span class="nl">?M</span>)
                <span class="nl">?U</span> <span class="nl">?k</span> <span class="nl">?f</span> <span class="nl">?t</span>] =&gt;
  <span class="nb">rewrite</span> ?(foldMapkd_to_kmapdt U (M := M));
  simplify_kmapdt;
  simplify_foldMapkd_pre_refold_hook ix;
  <span class="nb">rewrite</span> &lt;- ?(foldMapkd_to_kmapdt U (M := M));
  <span class="nb">rewrite</span> &lt;- ?(foldMapkd_to_kmapdt _ (M := M));
  <span class="c">(* ^ This is used because &quot;_&quot; might not match the U *)</span>
  simplify_foldMapkd_post_refold_hook M
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** &lt;&lt;foldMapkd&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">rw_foldMapkd</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    (<span class="nv">A</span> : <span class="kt">Type</span>)
      `{Monoid M}
      (k : K2)
      (f : list K2 * A -&gt; M).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">tactic_being_tested</span> ::= simplify_foldMapkd.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk59"><span class="kn">Lemma</span> <span class="nf">foldMapkd_type_rw1</span> : <span class="kr">forall</span> <span class="nv">c</span>,
      foldMapkd typ k f (ty_c c) = ∆µ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : base_typ, foldMapkd typ k f (ty_c c) = ∆µ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk5a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : base_typ, foldMapkd typ k f (ty_c c) = ∆µ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk5b"><span class="kn">Lemma</span> <span class="nf">foldMapkd_type_rw2_neq</span> : <span class="kr">forall</span> (<span class="nv">a</span> : A),
      k &lt;&gt; ktyp -&gt;
      foldMapkd typ k f (ty_v a) = pure (ty_v a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
k &lt;&gt; ktyp -&gt;
foldMapkd typ k f (ty_v a) = pure (ty_v a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk5c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
k &lt;&gt; ktyp -&gt;
foldMapkd typ k f (ty_v a) = pure (ty_v a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk5d"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; M</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>k &lt;&gt; ktyp</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMapkd typ k f (ty_v a) = pure (ty_v a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk5e">simplify_foldMapkd.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; M</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>k &lt;&gt; ktyp</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> EqDec_eq_of_EqDec Keq k ktyp <span class="kr">then</span> f ([], a) <span class="kr">else</span> ∆µ) =
pure (ty_v a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(*</span>
<span class="c">    Lemma foldMapkd_type_neq_rw2_eq : forall (a : A) (Heq: k = ktyp),</span>
<span class="c">        foldMapkd typ k f (ty_v a) = rew Heq in (f ([], a)).</span>
<span class="c">    Proof.</span>
<span class="c">      intros.</span>
<span class="c">      simplify_foldMapkd.</span>
<span class="c">      subst.</span>
<span class="c">      rewrite btgd_eq. auto.</span>
<span class="c">    Qed.</span>
<span class="c">   *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk5f"><span class="kn">Lemma</span> <span class="nf">foldMapkd_type_rw3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : typ A),
      foldMapkd typ k f (ty_ar t1 t2) =
        foldMapkd typ k f t1 ‚óè foldMapkd typ k f t2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : typ A,
foldMapkd typ k f (ty_ar t1 t2) =
foldMapkd typ k f t1 ‚óè foldMapkd typ k f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk60"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : typ A,
foldMapkd typ k f (ty_ar t1 t2) =
foldMapkd typ k f t1 ‚óè foldMapkd typ k f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk61"><span class="kn">Lemma</span> <span class="nf">foldMapkd_type_rw4</span> : <span class="kr">forall</span> (<span class="nv">body</span> : typ A),
      foldMapkd typ k f (ty_univ body) =
        foldMapkd typ k (f ‚¶ø [ktyp]) body.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ A,
foldMapkd typ k f (ty_univ body) =
foldMapkd typ k (f ‚¶ø [ktyp]) body</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk62"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ A,
foldMapkd typ k f (ty_univ body) =
foldMapkd typ k (f ‚¶ø [ktyp]) body</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(*</span>
<span class="c">  Lemma foldMapkd_term_rw1_neq : forall (a : A),</span>
<span class="c">      k &lt;&gt; ktrm -&gt;</span>
<span class="c">      foldMapkd term k f (tm_var a) = tm_var a.</span>
<span class="c">  Proof.</span>
<span class="c">    intros.</span>
<span class="c">    simplify_foldMapkd.</span>
<span class="c">    rewrite btgd_neq; auto.</span>
<span class="c">  Qed.</span>
<span class="c">  *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk63"><span class="kn">Lemma</span> <span class="nf">foldMapkd_term_rw2</span> : <span class="kr">forall</span> (<span class="nv">œÑ</span> : typ A) (<span class="nv">t</span> : term A),
      foldMapkd term k f (tm_abs œÑ t) =
        foldMapkd typ k f œÑ ‚óè foldMapkd term k (f ‚¶ø [ktrm]) t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ A) (<span class="nv">t</span> : term A),
foldMapkd term k f (tm_abs œÑ t) =
foldMapkd typ k f œÑ ‚óè foldMapkd term k (f ‚¶ø [ktrm]) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk64"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ A) (<span class="nv">t</span> : term A),
foldMapkd term k f (tm_abs œÑ t) =
foldMapkd typ k f œÑ ‚óè foldMapkd term k (f ‚¶ø [ktrm]) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk65"><span class="kn">Lemma</span> <span class="nf">foldMapkd_term_rw3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term A),
      foldMapkd term k f (tm_app t1 t2) =
        foldMapkd term k f t1 ‚óè foldMapkd term k f t2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term A,
foldMapkd term k f (tm_app t1 t2) =
foldMapkd term k f t1 ‚óè foldMapkd term k f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk66"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term A,
foldMapkd term k f (tm_app t1 t2) =
foldMapkd term k f t1 ‚óè foldMapkd term k f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk67"><span class="kn">Lemma</span> <span class="nf">foldMapkd_term_rw4</span> : <span class="kr">forall</span> (<span class="nv">t</span> : term A),
      foldMapkd term k f (tm_tab t) =
        foldMapkd term k (f ‚¶ø [ktyp]) t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term A,
foldMapkd term k f (tm_tab t) =
foldMapkd term k (f ‚¶ø [ktyp]) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk68"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term A,
foldMapkd term k f (tm_tab t) =
foldMapkd term k (f ‚¶ø [ktyp]) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk69"><span class="kn">Lemma</span> <span class="nf">foldMapkd_term_rw5</span> : <span class="kr">forall</span> (<span class="nv">t</span>: term A) (<span class="nv">œÑ</span> : typ A),
      foldMapkd term k f (tm_tap t œÑ) =
        foldMapkd term k f t ‚óè foldMapkd typ k f œÑ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term A) (<span class="nv">œÑ</span> : typ A),
foldMapkd term k f (tm_tap t œÑ) =
foldMapkd term k f t ‚óè foldMapkd typ k f œÑ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk6a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term A) (<span class="nv">œÑ</span> : typ A),
foldMapkd term k f (tm_tap t œÑ) =
foldMapkd term k f t ‚óè foldMapkd typ k f œÑ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">rw_foldMapkd</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_Forallkd_pre_refold_hook</span> :=
  <span class="kp">idtac</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_Forallkd_post_refold_hook</span> :=
  unfold_ops @Monoid_op_and;
  unfold_ops @Monoid_unit_true.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_Forallkd</span> :=
  <span class="kr">match goal with</span>
  | |- <span class="kp">context</span>[Forallkd (W := <span class="nl">?W</span>) (T := <span class="nl">?T</span>) (ix := <span class="nl">?ix</span>)
                <span class="nl">?U</span> <span class="nl">?k</span> <span class="nl">?f</span> <span class="nl">?t</span>] =&gt;
  <span class="nb">rewrite</span> <span class="nl">?Forallkd_to_foldMapkd</span>;
  simplify_foldMapkd;
  simplify_Forallkd_pre_refold_hook;
  <span class="nb">rewrite</span> &lt;- <span class="nl">?Forallkd_to_foldMapkd</span>;
  simplify_Forallkd_post_refold_hook
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** &lt;&lt;Forallkd&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">rw_Forallkd</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    (<span class="nv">A</span> : <span class="kt">Type</span>)
      `{Monoid M}
      (k : K2)
      (f : list K2 * A -&gt; <span class="kt">Prop</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">tactic_being_tested</span> ::= simplify_Forallkd.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk6b"><span class="kn">Lemma</span> <span class="nf">Forallkd_type_rw1</span> : <span class="kr">forall</span> <span class="nv">c</span>,
      Forallkd typ k f (ty_c c) = ∆µ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : base_typ, Forallkd typ k f (ty_c c) = ∆µ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk6c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : base_typ, Forallkd typ k f (ty_c c) = ∆µ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk6d"><span class="kn">Lemma</span> <span class="nf">Forallkd_type_rw2_neq</span> : <span class="kr">forall</span> (<span class="nv">a</span> : A),
      k &lt;&gt; ktyp -&gt;
      Forallkd typ k f (ty_v a) = <span class="kt">True</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
k &lt;&gt; ktyp -&gt; Forallkd typ k f (ty_v a) = <span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk6e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
k &lt;&gt; ktyp -&gt; Forallkd typ k f (ty_v a) = <span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk6f"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>k &lt;&gt; ktyp</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forallkd typ k f (ty_v a) = <span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk70">simplify_Forallkd.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>k &lt;&gt; ktyp</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> EqDec_eq_of_EqDec Keq k ktyp
 <span class="kr">then</span> f ([], a)
 <span class="kr">else</span> <span class="kt">True</span>) = <span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(*</span>
<span class="c">    Lemma Forallkd_type_neq_rw2_eq : forall (a : A) (Heq: k = ktyp),</span>
<span class="c">        Forallkd typ k f (ty_v a) = rew Heq in (f ([], a)).</span>
<span class="c">    Proof.</span>
<span class="c">      intros.</span>
<span class="c">      simplify_Forallkd.</span>
<span class="c">      subst.</span>
<span class="c">      rewrite btgd_eq. auto.</span>
<span class="c">    Qed.</span>
<span class="c">   *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk71"><span class="kn">Lemma</span> <span class="nf">Forallkd_type_rw3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : typ A),
      Forallkd typ k f (ty_ar t1 t2) =
        (Forallkd typ k f t1 /\ Forallkd typ k f t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : typ A,
Forallkd typ k f (ty_ar t1 t2) =
(Forallkd typ k f t1 /\ Forallkd typ k f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk72"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : typ A,
Forallkd typ k f (ty_ar t1 t2) =
(Forallkd typ k f t1 /\ Forallkd typ k f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk73"><span class="kn">Lemma</span> <span class="nf">Forallkd_type_rw4</span> : <span class="kr">forall</span> (<span class="nv">body</span> : typ A),
      Forallkd typ k f (ty_univ body) =
        Forallkd typ k (f ‚¶ø [ktyp]) body.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ A,
Forallkd typ k f (ty_univ body) =
Forallkd typ k (f ‚¶ø [ktyp]) body</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk74"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ A,
Forallkd typ k f (ty_univ body) =
Forallkd typ k (f ‚¶ø [ktyp]) body</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(*</span>
<span class="c">  Lemma Forallkd_term_rw1_neq : forall (a : A),</span>
<span class="c">      k &lt;&gt; ktrm -&gt;</span>
<span class="c">      Forallkd term k f (tm_var a) = tm_var a.</span>
<span class="c">  Proof.</span>
<span class="c">    intros.</span>
<span class="c">    simplify_Forallkd.</span>
<span class="c">    rewrite btgd_neq; auto.</span>
<span class="c">  Qed.</span>
<span class="c">  *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk75"><span class="kn">Lemma</span> <span class="nf">Forallkd_term_rw2</span> : <span class="kr">forall</span> (<span class="nv">œÑ</span> : typ A) (<span class="nv">t</span> : term A),
      Forallkd term k f (tm_abs œÑ t) =
        (Forallkd typ k f œÑ /\ Forallkd term k (f ‚¶ø [ktrm]) t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ A) (<span class="nv">t</span> : term A),
Forallkd term k f (tm_abs œÑ t) =
(Forallkd typ k f œÑ /\ Forallkd term k (f ‚¶ø [ktrm]) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk76"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ A) (<span class="nv">t</span> : term A),
Forallkd term k f (tm_abs œÑ t) =
(Forallkd typ k f œÑ /\ Forallkd term k (f ‚¶ø [ktrm]) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk77"><span class="kn">Lemma</span> <span class="nf">Forallkd_term_rw3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term A),
      Forallkd term k f (tm_app t1 t2) =
        (Forallkd term k f t1 /\ Forallkd term k f t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term A,
Forallkd term k f (tm_app t1 t2) =
(Forallkd term k f t1 /\ Forallkd term k f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk78"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term A,
Forallkd term k f (tm_app t1 t2) =
(Forallkd term k f t1 /\ Forallkd term k f t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk79"><span class="kn">Lemma</span> <span class="nf">Forallkd_term_rw4</span> : <span class="kr">forall</span> (<span class="nv">t</span> : term A),
      Forallkd term k f (tm_tab t) =
        Forallkd term k (f ‚¶ø [ktyp]) t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term A,
Forallkd term k f (tm_tab t) =
Forallkd term k (f ‚¶ø [ktyp]) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk7a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term A,
Forallkd term k f (tm_tab t) =
Forallkd term k (f ‚¶ø [ktyp]) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk7b"><span class="kn">Lemma</span> <span class="nf">Forallkd_term_rw5</span> : <span class="kr">forall</span> (<span class="nv">t</span>: term A) (<span class="nv">œÑ</span> : typ A),
      Forallkd term k f (tm_tap t œÑ) =
        (Forallkd term k f t /\ Forallkd typ k f œÑ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term A) (<span class="nv">œÑ</span> : typ A),
Forallkd term k f (tm_tap t œÑ) =
(Forallkd term k f t /\ Forallkd typ k f œÑ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk7c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list K2 * A -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term A) (<span class="nv">œÑ</span> : typ A),
Forallkd term k f (tm_tap t œÑ) =
(Forallkd term k f t /\ Forallkd typ k f œÑ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">rw_Forallkd</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_foldMapk_pre_refold_hook</span> ix :=
  <span class="kp">repeat</span> push_preincr_into_fn.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_foldMapk_post_refold_hook</span> M :=
  <span class="kp">idtac</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simplify_foldMapk</span> :=
  <span class="kr">match goal with</span>
  | |- <span class="kp">context</span>[foldMapk (W := <span class="nl">?W</span>) (T := <span class="nl">?T</span>) (ix := <span class="nl">?ix</span>)
                        (M := <span class="nl">?M</span>)
                <span class="nl">?U</span> <span class="nl">?k</span> <span class="nl">?f</span> <span class="nl">?t</span>] =&gt;
  <span class="nb">rewrite</span> ?(foldMapk_to_foldMapkd (ix := ix) U (M := M));
  simplify_foldMapkd;
  simplify_foldMapk_pre_refold_hook ix;
  <span class="nb">rewrite</span> &lt;- ?(foldMapk_to_foldMapkd _ (M := M));
  simplify_foldMapk_post_refold_hook M
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** &lt;&lt;foldMapk&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">rw_foldMapk</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    (<span class="nv">A</span> : <span class="kt">Type</span>)
      `{Monoid M}
      (k : K2)
      (f : A -&gt; M).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">tactic_being_tested</span> ::= simplify_foldMapk.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk7d"><span class="kn">Lemma</span> <span class="nf">foldMapk_type_rw1</span> : <span class="kr">forall</span> <span class="nv">c</span>,
      foldMapk typ k f (ty_c c) = ∆µ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : base_typ, foldMapk typ k f (ty_c c) = ∆µ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk7e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : base_typ, foldMapk typ k f (ty_c c) = ∆µ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk7f"><span class="kn">Lemma</span> <span class="nf">foldMapk_type_rw2_neq</span> : <span class="kr">forall</span> (<span class="nv">a</span> : A),
      k &lt;&gt; ktyp -&gt;
      foldMapk typ k f (ty_v a) = ∆µ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
k &lt;&gt; ktyp -&gt; foldMapk typ k f (ty_v a) = ∆µ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk80"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
k &lt;&gt; ktyp -&gt; foldMapk typ k f (ty_v a) = ∆µ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk81"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>k &lt;&gt; ktyp</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMapk typ k f (ty_v a) = ∆µ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk82">simplify_foldMapk.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>k &lt;&gt; ktyp</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> EqDec_eq_of_EqDec Keq k ktyp
 <span class="kr">then</span> (f ‚àò extract) ([], a)
 <span class="kr">else</span> ∆µ) = ∆µ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk83"><span class="kn">Lemma</span> <span class="nf">foldMapk_type_rw3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : typ A),
      foldMapk typ k f (ty_ar t1 t2) =
        foldMapk typ k f t1 ‚óè foldMapk typ k f t2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : typ A,
foldMapk typ k f (ty_ar t1 t2) =
foldMapk typ k f t1 ‚óè foldMapk typ k f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk84"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : typ A,
foldMapk typ k f (ty_ar t1 t2) =
foldMapk typ k f t1 ‚óè foldMapk typ k f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk85"><span class="kn">Lemma</span> <span class="nf">foldMapk_type_rw4</span> : <span class="kr">forall</span> (<span class="nv">body</span> : typ A),
      foldMapk typ k f (ty_univ body) =
        foldMapk typ k f body.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ A,
foldMapk typ k f (ty_univ body) =
foldMapk typ k f body</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk86"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">body</span> : typ A,
foldMapk typ k f (ty_univ body) =
foldMapk typ k f body</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk87"><span class="kn">Lemma</span> <span class="nf">foldMapk_term_rw2</span> : <span class="kr">forall</span> (<span class="nv">œÑ</span> : typ A) (<span class="nv">t</span> : term A),
      foldMapk term k f (tm_abs œÑ t) =
        foldMapk typ k f œÑ ‚óè foldMapk term k f t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ A) (<span class="nv">t</span> : term A),
foldMapk term k f (tm_abs œÑ t) =
foldMapk typ k f œÑ ‚óè foldMapk term k f t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk88"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">œÑ</span> : typ A) (<span class="nv">t</span> : term A),
foldMapk term k f (tm_abs œÑ t) =
foldMapk typ k f œÑ ‚óè foldMapk term k f t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk89"><span class="kn">Lemma</span> <span class="nf">foldMapk_term_rw3</span> : <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span> : term A),
      foldMapk term k f (tm_app t1 t2) =
        foldMapk term k f t1 ‚óè foldMapk term k f t2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term A,
foldMapk term k f (tm_app t1 t2) =
foldMapk term k f t1 ‚óè foldMapk term k f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk8a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term A,
foldMapk term k f (tm_app t1 t2) =
foldMapk term k f t1 ‚óè foldMapk term k f t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk8b"><span class="kn">Lemma</span> <span class="nf">foldMapk_term_rw4</span> : <span class="kr">forall</span> (<span class="nv">t</span> : term A),
      foldMapk term k f (tm_tab t) =
        foldMapk term k f t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term A,
foldMapk term k f (tm_tab t) = foldMapk term k f t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk8c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : term A,
foldMapk term k f (tm_tab t) = foldMapk term k f t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk8d"><span class="kn">Lemma</span> <span class="nf">foldMapk_term_rw5</span> : <span class="kr">forall</span> (<span class="nv">t</span>: term A) (<span class="nv">œÑ</span> : typ A),
      foldMapk term k f (tm_tap t œÑ) =
        foldMapk term k f t ‚óè foldMapk typ k f œÑ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term A) (<span class="nv">œÑ</span> : typ A),
foldMapk term k f (tm_tap t œÑ) =
foldMapk term k f t ‚óè foldMapk typ k f œÑ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="systemf-targeted-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="systemf-targeted-v-chk8e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>K2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : term A) (<span class="nv">œÑ</span> : typ A),
foldMapk term k f (tm_tap t œÑ) =
foldMapk term k f t ‚óè foldMapk typ k f œÑ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">test_simplification.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">rw_foldMapk</span>.</span></span></pre>
</div>
</div></body>
</html>
