<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<title>LibTactics.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.16.0+0.16.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="sd">(** * LibTactics: A Collection of Handy General-Purpose Tactics *)</span>

<span class="c">(* Chapter maintained by Arthur Chargueraud *)</span>

<span class="sd">(** This file contains a set of tactics that extends the set of builtin</span>
<span class="sd">    tactics provided with the standard distribution of Coq. It intends</span>
<span class="sd">    to overcome a number of limitations of the standard set of tactics,</span>
<span class="sd">    and thereby to help user to write shorter and more robust scripts.</span>

<span class="sd">    Hopefully, Coq tactics will be improved as time goes by, and this</span>
<span class="sd">    file should ultimately be useless. In the meanwhile, serious Coq</span>
<span class="sd">    users will probably find it very useful.</span>

<span class="sd">    The present file contains the implementation and the detailed</span>
<span class="sd">    documentation of those tactics. The SF reader need not read this</span>
<span class="sd">    file; instead, he/she is encouraged to read the chapter named</span>
<span class="sd">    UseTactics.v, which is gentle introduction to the most useful</span>
<span class="sd">    tactics from the LibTactic library.</span>
<span class="sd">*)</span>

<span class="sd">(** The main features offered are:</span>
<span class="sd">       - More convenient syntax for naming hypotheses, with tactics for</span>
<span class="sd">         introduction and inversion that take as input only the name of</span>
<span class="sd">         hypotheses of type [Prop], rather than the name of all variables.</span>
<span class="sd">       - Tactics providing true support for manipulating N-ary conjunctions,</span>
<span class="sd">         disjunctions and existentials, hidding the fact that the underlying</span>
<span class="sd">         implementation is based on binary propositions.</span>
<span class="sd">       - Convenient support for automation: tactics followed with the symbol</span>
<span class="sd">         &quot;~&quot; or &quot;*&quot; will call automation on the generated subgoals.</span>
<span class="sd">         The symbol &quot;~&quot; stands for [auto] and &quot;*&quot; for [intuition eauto].</span>
<span class="sd">         These bindings can be customized.</span>
<span class="sd">       - Forward-chaining tactics are provided to instantiate lemmas</span>
<span class="sd">         either with variable or hypotheses or a mix of both.</span>
<span class="sd">       - A more powerful implementation of [apply] is provided (it is based</span>
<span class="sd">         on [refine] and thus behaves better with respect to conversion).</span>
<span class="sd">       - An improved inversion tactic which substitutes equalities on variables</span>
<span class="sd">         generated by the standard inversion mecanism. Moreover, it supports</span>
<span class="sd">         the elimination of dependently-typed equalities (requires axiom [K],</span>
<span class="sd">         which is a weak form of Proof Irrelevance).</span>
<span class="sd">       - Tactics for saving time when writing proofs, with tactics to</span>
<span class="sd">         asserts hypotheses or sub-goals, and improved tactics for</span>
<span class="sd">         clearing, renaming, and sorting hypotheses. *)</span>

<span class="sd">(** External credits:</span>
<span class="sd">  - thanks to Xavier Leroy for providing the idea of tactic [forward]</span>
<span class="sd">  - thanks to Georges Gonthier for the implementation trick in [rapply]</span>
<span class="sd">*)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Set Implicit Arguments</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Lists.List.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Declare Scope</span> ltac_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* begin hide *)</span>

<span class="c">(* ################################################################# *)</span>
<span class="sd">(** * Fixing Stdlib *)</span>

<span class="c">(* Very important to remove hint trans_eq_bool from LibBool,</span>
<span class="c">   otherwise eauto slows down dramatically:</span>
<span class="c">  Lemma test : forall b, b = false.</span>
<span class="c">  time eauto 7. (* takes over 4 seconds to fail! *) *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Remove Hints</span> Bool.trans_eq_bool : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ################################################################# *)</span>
<span class="sd">(** * Tools for Programming with Ltac *)</span>

<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Identity Continuation *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">idcont</span> tt :=
  <span class="kp">idtac</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Untyped Arguments for Tactics *)</span>

<span class="sd">(** Any Coq value can be boxed into the type [Boxer]. This is</span>
<span class="sd">    useful to use Coq computations for implementing tactics. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">Boxer</span> : <span class="kt">Type</span> :=
  | boxer : <span class="kr">forall</span> (<span class="nv">A</span>:<span class="kt">Type</span>), A -&gt; Boxer.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Optional Arguments for Tactics  *)</span>

<span class="sd">(** [ltac_no_arg] is a constant that can be used to simulate</span>
<span class="sd">    optional arguments in tactic definitions.</span>
<span class="sd">    Use [mytactic ltac_no_arg] on the tactic invokation,</span>
<span class="sd">    and use [match arg with ltac_no_arg =&gt; ..] or</span>
<span class="sd">    [match type of arg with ltac_No_arg  =&gt; ..] to</span>
<span class="sd">    test whether an argument was provided. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">ltac_No_arg</span> : <span class="kt">Set</span> :=
  | ltac_no_arg : ltac_No_arg.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Wildcard Arguments for Tactics  *)</span>

<span class="sd">(** [ltac_wild] is a constant that can be used to simulate</span>
<span class="sd">    wildcard arguments in tactic definitions. Notation is [__]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">ltac_Wild</span> : <span class="kt">Set</span> :=
  | ltac_wild : ltac_Wild.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;__&#39;&quot;</span> := ltac_wild : ltac_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [ltac_wilds] is another constant that is typically used to</span>
<span class="sd">    simulate a sequence of [N] wildcards, with [N] chosen</span>
<span class="sd">    appropriately depending on the context. Notation is [___]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">ltac_Wilds</span> : <span class="kt">Set</span> :=
  | ltac_wilds : ltac_Wilds.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;___&#39;&quot;</span> := ltac_wilds : ltac_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> ltac_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Position Markers *)</span>

<span class="sd">(** [ltac_Mark] and [ltac_mark] are dummy definitions used as sentinel</span>
<span class="sd">    by tactics, to mark a certain position in the context or in the goal. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">ltac_Mark</span> : <span class="kt">Type</span> :=
  | ltac_mark : ltac_Mark.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [gen_until_mark] repeats [generalize] on hypotheses from the</span>
<span class="sd">    context, starting from the bottom and stopping as soon as reaching</span>
<span class="sd">    an hypothesis of type [Mark]. If fails if [Mark] does not</span>
<span class="sd">    appear in the context. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">gen_until_mark</span> :=
  <span class="kr">match goal with</span> H: <span class="nl">?T</span> |- _ =&gt;
  <span class="kr">match</span> T <span class="kr">with</span>
  | ltac_Mark =&gt; <span class="nb">clear</span> H
  | _ =&gt; <span class="nb">generalize</span> H; <span class="nb">clear</span> H; gen_until_mark
  <span class="kr">end</span> <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [gen_until_mark_with_processing F] is similar to [gen_until_mark]</span>
<span class="sd">    except that it calls [F] on each hypothesis immediately before</span>
<span class="sd">    generalizing it. This is useful for processing the hypotheses. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">gen_until_mark_with_processing</span> cont :=
  <span class="kr">match goal with</span> H: <span class="nl">?T</span> |- _ =&gt;
  <span class="kr">match</span> T <span class="kr">with</span>
  | ltac_Mark =&gt; <span class="nb">clear</span> H
  | _ =&gt; cont H; <span class="nb">generalize</span> H; <span class="nb">clear</span> H;
         gen_until_mark_with_processing cont
  <span class="kr">end</span> <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [intro_until_mark] repeats [intro] until reaching an hypothesis of</span>
<span class="sd">    type [Mark]. It throws away the hypothesis [Mark].</span>
<span class="sd">    It fails if [Mark] does not appear as an hypothesis in the</span>
<span class="sd">    goal. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">intro_until_mark</span> :=
  <span class="kr">match goal with</span>
  | |- (ltac_Mark -&gt; _) =&gt; <span class="nb">intros</span> _
  | _ =&gt; <span class="nb">intro</span>; intro_until_mark
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** List of Arguments for Tactics  *)</span>

<span class="sd">(** A datatype of type [list Boxer] is used to manipulate list of</span>
<span class="sd">    Coq values in ltac. Notation is [&gt;&gt; v1 v2 ... vN] for building</span>
<span class="sd">    a list containing the values [v1] through [vN]. *)</span>
<span class="c">(* Note: could attempt the use of a recursive notation *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;&gt;&gt;&#39;&quot;</span> :=
  (@nil Boxer)
  (<span class="kn">at level</span> <span class="mi">0</span>)
  : ltac_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;&gt;&gt;&#39; v1&quot;</span> :=
  ((boxer v1)::nil)
  (<span class="kn">at level</span> <span class="mi">0</span>, v1 <span class="kn">at level</span> <span class="mi">0</span>)
  : ltac_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;&gt;&gt;&#39; v1 v2&quot;</span> :=
  ((boxer v1)::(boxer v2)::nil)
  (<span class="kn">at level</span> <span class="mi">0</span>, v1 <span class="kn">at level</span> <span class="mi">0</span>, v2 <span class="kn">at level</span> <span class="mi">0</span>)
  : ltac_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;&gt;&gt;&#39; v1 v2 v3&quot;</span> :=
  ((boxer v1)::(boxer v2)::(boxer v3)::nil)
  (<span class="kn">at level</span> <span class="mi">0</span>, v1 <span class="kn">at level</span> <span class="mi">0</span>, v2 <span class="kn">at level</span> <span class="mi">0</span>, v3 <span class="kn">at level</span> <span class="mi">0</span>)
  : ltac_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;&gt;&gt;&#39; v1 v2 v3 v4&quot;</span> :=
  ((boxer v1)::(boxer v2)::(boxer v3)::(boxer v4)::nil)
  (<span class="kn">at level</span> <span class="mi">0</span>, v1 <span class="kn">at level</span> <span class="mi">0</span>, v2 <span class="kn">at level</span> <span class="mi">0</span>, v3 <span class="kn">at level</span> <span class="mi">0</span>,
   v4 <span class="kn">at level</span> <span class="mi">0</span>)
  : ltac_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;&gt;&gt;&#39; v1 v2 v3 v4 v5&quot;</span> :=
  ((boxer v1)::(boxer v2)::(boxer v3)::(boxer v4)::(boxer v5)::nil)
  (<span class="kn">at level</span> <span class="mi">0</span>, v1 <span class="kn">at level</span> <span class="mi">0</span>, v2 <span class="kn">at level</span> <span class="mi">0</span>, v3 <span class="kn">at level</span> <span class="mi">0</span>,
   v4 <span class="kn">at level</span> <span class="mi">0</span>, v5 <span class="kn">at level</span> <span class="mi">0</span>)
  : ltac_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;&gt;&gt;&#39; v1 v2 v3 v4 v5 v6&quot;</span> :=
  ((boxer v1)::(boxer v2)::(boxer v3)::(boxer v4)::(boxer v5)
   ::(boxer v6)::nil)
  (<span class="kn">at level</span> <span class="mi">0</span>, v1 <span class="kn">at level</span> <span class="mi">0</span>, v2 <span class="kn">at level</span> <span class="mi">0</span>, v3 <span class="kn">at level</span> <span class="mi">0</span>,
   v4 <span class="kn">at level</span> <span class="mi">0</span>, v5 <span class="kn">at level</span> <span class="mi">0</span>, v6 <span class="kn">at level</span> <span class="mi">0</span>)
  : ltac_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;&gt;&gt;&#39; v1 v2 v3 v4 v5 v6 v7&quot;</span> :=
  ((boxer v1)::(boxer v2)::(boxer v3)::(boxer v4)::(boxer v5)
   ::(boxer v6)::(boxer v7)::nil)
  (<span class="kn">at level</span> <span class="mi">0</span>, v1 <span class="kn">at level</span> <span class="mi">0</span>, v2 <span class="kn">at level</span> <span class="mi">0</span>, v3 <span class="kn">at level</span> <span class="mi">0</span>,
   v4 <span class="kn">at level</span> <span class="mi">0</span>, v5 <span class="kn">at level</span> <span class="mi">0</span>, v6 <span class="kn">at level</span> <span class="mi">0</span>, v7 <span class="kn">at level</span> <span class="mi">0</span>)
  : ltac_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;&gt;&gt;&#39; v1 v2 v3 v4 v5 v6 v7 v8&quot;</span> :=
  ((boxer v1)::(boxer v2)::(boxer v3)::(boxer v4)::(boxer v5)
   ::(boxer v6)::(boxer v7)::(boxer v8)::nil)
  (<span class="kn">at level</span> <span class="mi">0</span>, v1 <span class="kn">at level</span> <span class="mi">0</span>, v2 <span class="kn">at level</span> <span class="mi">0</span>, v3 <span class="kn">at level</span> <span class="mi">0</span>,
   v4 <span class="kn">at level</span> <span class="mi">0</span>, v5 <span class="kn">at level</span> <span class="mi">0</span>, v6 <span class="kn">at level</span> <span class="mi">0</span>, v7 <span class="kn">at level</span> <span class="mi">0</span>,
   v8 <span class="kn">at level</span> <span class="mi">0</span>)
  : ltac_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;&gt;&gt;&#39; v1 v2 v3 v4 v5 v6 v7 v8 v9&quot;</span> :=
  ((boxer v1)::(boxer v2)::(boxer v3)::(boxer v4)::(boxer v5)
   ::(boxer v6)::(boxer v7)::(boxer v8)::(boxer v9)::nil)
  (<span class="kn">at level</span> <span class="mi">0</span>, v1 <span class="kn">at level</span> <span class="mi">0</span>, v2 <span class="kn">at level</span> <span class="mi">0</span>, v3 <span class="kn">at level</span> <span class="mi">0</span>,
   v4 <span class="kn">at level</span> <span class="mi">0</span>, v5 <span class="kn">at level</span> <span class="mi">0</span>, v6 <span class="kn">at level</span> <span class="mi">0</span>, v7 <span class="kn">at level</span> <span class="mi">0</span>,
   v8 <span class="kn">at level</span> <span class="mi">0</span>, v9 <span class="kn">at level</span> <span class="mi">0</span>)
  : ltac_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;&gt;&gt;&#39; v1 v2 v3 v4 v5 v6 v7 v8 v9 v10&quot;</span> :=
  ((boxer v1)::(boxer v2)::(boxer v3)::(boxer v4)::(boxer v5)
   ::(boxer v6)::(boxer v7)::(boxer v8)::(boxer v9)::(boxer v10)::nil)
  (<span class="kn">at level</span> <span class="mi">0</span>, v1 <span class="kn">at level</span> <span class="mi">0</span>, v2 <span class="kn">at level</span> <span class="mi">0</span>, v3 <span class="kn">at level</span> <span class="mi">0</span>,
   v4 <span class="kn">at level</span> <span class="mi">0</span>, v5 <span class="kn">at level</span> <span class="mi">0</span>, v6 <span class="kn">at level</span> <span class="mi">0</span>, v7 <span class="kn">at level</span> <span class="mi">0</span>,
   v8 <span class="kn">at level</span> <span class="mi">0</span>, v9 <span class="kn">at level</span> <span class="mi">0</span>, v10 <span class="kn">at level</span> <span class="mi">0</span>)
  : ltac_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;&gt;&gt;&#39; v1 v2 v3 v4 v5 v6 v7 v8 v9 v10 v11&quot;</span> :=
  ((boxer v1)::(boxer v2)::(boxer v3)::(boxer v4)::(boxer v5)
   ::(boxer v6)::(boxer v7)::(boxer v8)::(boxer v9)::(boxer v10)
   ::(boxer v11)::nil)
  (<span class="kn">at level</span> <span class="mi">0</span>, v1 <span class="kn">at level</span> <span class="mi">0</span>, v2 <span class="kn">at level</span> <span class="mi">0</span>, v3 <span class="kn">at level</span> <span class="mi">0</span>,
   v4 <span class="kn">at level</span> <span class="mi">0</span>, v5 <span class="kn">at level</span> <span class="mi">0</span>, v6 <span class="kn">at level</span> <span class="mi">0</span>, v7 <span class="kn">at level</span> <span class="mi">0</span>,
   v8 <span class="kn">at level</span> <span class="mi">0</span>, v9 <span class="kn">at level</span> <span class="mi">0</span>, v10 <span class="kn">at level</span> <span class="mi">0</span>, v11 <span class="kn">at level</span> <span class="mi">0</span>)
  : ltac_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;&gt;&gt;&#39; v1 v2 v3 v4 v5 v6 v7 v8 v9 v10 v11 v12&quot;</span> :=
  ((boxer v1)::(boxer v2)::(boxer v3)::(boxer v4)::(boxer v5)
   ::(boxer v6)::(boxer v7)::(boxer v8)::(boxer v9)::(boxer v10)
   ::(boxer v11)::(boxer v12)::nil)
  (<span class="kn">at level</span> <span class="mi">0</span>, v1 <span class="kn">at level</span> <span class="mi">0</span>, v2 <span class="kn">at level</span> <span class="mi">0</span>, v3 <span class="kn">at level</span> <span class="mi">0</span>,
   v4 <span class="kn">at level</span> <span class="mi">0</span>, v5 <span class="kn">at level</span> <span class="mi">0</span>, v6 <span class="kn">at level</span> <span class="mi">0</span>, v7 <span class="kn">at level</span> <span class="mi">0</span>,
   v8 <span class="kn">at level</span> <span class="mi">0</span>, v9 <span class="kn">at level</span> <span class="mi">0</span>, v10 <span class="kn">at level</span> <span class="mi">0</span>, v11 <span class="kn">at level</span> <span class="mi">0</span>,
   v12 <span class="kn">at level</span> <span class="mi">0</span>)
  : ltac_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;&gt;&gt;&#39; v1 v2 v3 v4 v5 v6 v7 v8 v9 v10 v11 v12 v13&quot;</span> :=
  ((boxer v1)::(boxer v2)::(boxer v3)::(boxer v4)::(boxer v5)
   ::(boxer v6)::(boxer v7)::(boxer v8)::(boxer v9)::(boxer v10)
   ::(boxer v11)::(boxer v12)::(boxer v13)::nil)
  (<span class="kn">at level</span> <span class="mi">0</span>, v1 <span class="kn">at level</span> <span class="mi">0</span>, v2 <span class="kn">at level</span> <span class="mi">0</span>, v3 <span class="kn">at level</span> <span class="mi">0</span>,
   v4 <span class="kn">at level</span> <span class="mi">0</span>, v5 <span class="kn">at level</span> <span class="mi">0</span>, v6 <span class="kn">at level</span> <span class="mi">0</span>, v7 <span class="kn">at level</span> <span class="mi">0</span>,
   v8 <span class="kn">at level</span> <span class="mi">0</span>, v9 <span class="kn">at level</span> <span class="mi">0</span>, v10 <span class="kn">at level</span> <span class="mi">0</span>, v11 <span class="kn">at level</span> <span class="mi">0</span>,
   v12 <span class="kn">at level</span> <span class="mi">0</span>, v13 <span class="kn">at level</span> <span class="mi">0</span>)
  : ltac_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The tactic [list_boxer_of] inputs a term [E] and returns a term</span>
<span class="sd">    of type &quot;list boxer&quot;, according to the following rules:</span>
<span class="sd">    - if [E] is already of type &quot;list Boxer&quot;, then it returns [E];</span>
<span class="sd">    - otherwise, it returns the list [(boxer E)::nil]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">list_boxer_of</span> E :=
  <span class="kr">match</span> <span class="kp">type of</span> E <span class="kr">with</span>
  | List.list Boxer =&gt; <span class="kp">constr</span>:(E)
  | _ =&gt; <span class="kp">constr</span>:((boxer E)::nil)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Databases of Lemmas  *)</span>

<span class="sd">(** Use the hint facility to implement a database mapping</span>
<span class="sd">    terms to terms. To declare a new database, use a definition:</span>
<span class="sd">    [Definition mydatabase := True.]</span>

<span class="sd">    Then, to map [mykey] to [myvalue], write the hint:</span>
<span class="sd">    [Hint Extern 1 (Register mydatabase mykey) =&gt; Provide myvalue.]</span>

<span class="sd">    Finally, to query the value associated with a key, run the</span>
<span class="sd">    tactic [ltac_database_get mydatabase mykey]. This will leave</span>
<span class="sd">    at the head of the goal the term [myvalue]. It can then be</span>
<span class="sd">    named and exploited using [intro]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">Ltac_database_token</span> : <span class="kt">Prop</span> := ltac_database_token.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ltac_database</span> (<span class="nv">D</span>:Boxer) (<span class="nv">T</span>:Boxer) (<span class="nv">A</span>:Boxer) := Ltac_database_token.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;Register&#39; D T&quot;</span> := (ltac_database (boxer D) (boxer T) _)
  (<span class="kn">at level</span> <span class="mi">69</span>, D <span class="kn">at level</span> <span class="mi">0</span>, T <span class="kn">at level</span> <span class="mi">0</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk0"><span class="kn">Lemma</span> <span class="nf">ltac_database_provide</span> : <span class="kr">forall</span> (<span class="nv">A</span>:Boxer) (<span class="nv">D</span>:Boxer) (<span class="nv">T</span>:Boxer),
  ltac_database D T A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">D</span> <span class="nv">T</span> : Boxer, ltac_database D T A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk1"><span class="kn">Proof using</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">D</span> <span class="nv">T</span> : Boxer, ltac_database D T A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">split</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">Provide</span> T := <span class="nb">apply</span> (@ltac_database_provide (boxer T)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">ltac_database_get</span> D T :=
  <span class="kr">let</span> <span class="nv">A</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span> <span class="nb">evar</span> (A:Boxer);
  <span class="kr">let</span> <span class="nv">H</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span>
  <span class="nb">assert</span> (H : ltac_database (boxer D) (boxer T) A);
  [ <span class="nb">subst</span> A; <span class="nb">auto</span>
  | <span class="nb">subst</span> A; <span class="kr">match</span> <span class="kp">type of</span> H <span class="kr">with</span> ltac_database _ _ (boxer <span class="nl">?L</span>) =&gt;
               <span class="nb">generalize</span> L <span class="kr">end</span>; <span class="nb">clear</span> H ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Note for a possible alternative implementation of the ltac_database_token:</span>
<span class="c">   Inductive Ltac_database : Type :=</span>
<span class="c">     | ltac_database : forall A, A -&gt; Ltac_database.</span>
<span class="c">   Implicit Arguments ltac_database [A].</span>
<span class="c">*)</span>

<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** On-the-Fly Removal of Hypotheses *)</span>

<span class="sd">(** In a list of arguments [&gt;&gt; H1 H2 .. HN] passed to a tactic</span>
<span class="sd">    such as [lets] or [applys] or [forwards] or [specializes],</span>
<span class="sd">    the term [rm], an identity function, can be placed in front</span>
<span class="sd">    of the name of an hypothesis to be deleted. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">rm</span> (<span class="nv">A</span>:<span class="kt">Type</span>) (<span class="nv">X</span>:A) := X.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [rm_term E] removes one hypothesis that admits the same</span>
<span class="sd">    type as [E]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">rm_term</span> E :=
  <span class="kr">let</span> <span class="nv">T</span> := <span class="kp">type of</span> E <span class="kr">in</span>
  <span class="kr">match goal with</span> H: T |- _ =&gt; <span class="kp">try</span> <span class="nb">clear</span> H <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [rm_inside E] calls [rm_term Ei] for any subterm</span>
<span class="sd">    of the form [rm Ei] found in E *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">rm_inside</span> E :=
  <span class="kr">let</span> <span class="nv">go</span> <span class="nv">E</span> := rm_inside E <span class="kr">in</span>
  <span class="kr">match</span> E <span class="kr">with</span>
  | rm <span class="nl">?X</span> =&gt; rm_term X
  | <span class="nl">?X1</span> <span class="nl">?X2</span> =&gt;
     go X1; go X2
  | <span class="nl">?X1</span> <span class="nl">?X2</span> <span class="nl">?X3</span> =&gt;
     go X1; go X2; go X3
  | <span class="nl">?X1</span> <span class="nl">?X2</span> <span class="nl">?X3</span> <span class="nl">?X4</span> =&gt;
     go X1; go X2; go X3; go X4
  | <span class="nl">?X1</span> <span class="nl">?X2</span> <span class="nl">?X3</span> <span class="nl">?X4</span> <span class="nl">?X5</span> =&gt;
     go X1; go X2; go X3; go X4; go X5
  | <span class="nl">?X1</span> <span class="nl">?X2</span> <span class="nl">?X3</span> <span class="nl">?X4</span> <span class="nl">?X5</span> <span class="nl">?X6</span> =&gt;
     go X1; go X2; go X3; go X4; go X5; go X6
  | <span class="nl">?X1</span> <span class="nl">?X2</span> <span class="nl">?X3</span> <span class="nl">?X4</span> <span class="nl">?X5</span> <span class="nl">?X6</span> <span class="nl">?X7</span> =&gt;
     go X1; go X2; go X3; go X4; go X5; go X6; go X7
  | <span class="nl">?X1</span> <span class="nl">?X2</span> <span class="nl">?X3</span> <span class="nl">?X4</span> <span class="nl">?X5</span> <span class="nl">?X6</span> <span class="nl">?X7</span> <span class="nl">?X8</span> =&gt;
     go X1; go X2; go X3; go X4; go X5; go X6; go X7; go X8
  | <span class="nl">?X1</span> <span class="nl">?X2</span> <span class="nl">?X3</span> <span class="nl">?X4</span> <span class="nl">?X5</span> <span class="nl">?X6</span> <span class="nl">?X7</span> <span class="nl">?X8</span> <span class="nl">?X9</span> =&gt;
     go X1; go X2; go X3; go X4; go X5; go X6; go X7; go X8; go X9
  | <span class="nl">?X1</span> <span class="nl">?X2</span> <span class="nl">?X3</span> <span class="nl">?X4</span> <span class="nl">?X5</span> <span class="nl">?X6</span> <span class="nl">?X7</span> <span class="nl">?X8</span> <span class="nl">?X9</span> <span class="nl">?X10</span> =&gt;
     go X1; go X2; go X3; go X4; go X5; go X6; go X7; go X8; go X9; go X10
  | _ =&gt; <span class="kp">idtac</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** For faster performance, one may deactivate [rm_inside] by</span>
<span class="sd">    replacing the body of this definition with [idtac]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">fast_rm_inside</span> E :=
  rm_inside E.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Numbers as Arguments *)</span>

<span class="sd">(** When tactic takes a natural number as argument, it may be</span>
<span class="sd">    parsed either as a natural number or as a relative number.</span>
<span class="sd">    In order for tactics to convert their arguments into natural numbers,</span>
<span class="sd">    we provide a conversion tactic.</span>

<span class="sd">    Note: the tactic [number_to_nat] is extended in [LibInt] to</span>
<span class="sd">    take into account the [Z] type. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require</span> Coq.Numbers.BinNums Coq.ZArith.BinInt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ltac_int_to_nat</span> (<span class="nv">x</span>:BinInt.Z) : nat :=
  <span class="kr">match</span> x <span class="kr">with</span>
  | BinInt.Z0 =&gt; <span class="mi">0</span>%nat
  | BinInt.Zpos p =&gt; BinPos.nat_of_P p
  | BinInt.Zneg p =&gt; <span class="mi">0</span>%nat
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">number_to_nat</span> N :=
  <span class="kr">match</span> <span class="kp">type of</span> N <span class="kr">with</span>
  | nat =&gt; <span class="kp">constr</span>:(N)
  | BinInt.Z =&gt; <span class="kr">let</span> <span class="nv">N&#39;</span> := <span class="kp">constr</span>:(ltac_int_to_nat N) <span class="kr">in</span> <span class="kp">eval</span> <span class="nb">compute</span> <span class="kr">in</span> N&#39;
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [ltac_pattern E at K] is the same as [pattern E at K] except that</span>
<span class="sd">    [K] is a Coq number (nat or Z) rather than a Ltac integer. Syntax</span>
<span class="sd">    [ltac_pattern E as K in H] is also available. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;ltac_pattern&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;at&quot;</span> <span class="kp">constr</span>(K) :=
  <span class="kr">match</span> number_to_nat K <span class="kr">with</span>
  | <span class="mi">1</span> =&gt; <span class="nb">pattern</span> E <span class="nb">at</span> <span class="mi">1</span>
  | <span class="mi">2</span> =&gt; <span class="nb">pattern</span> E <span class="nb">at</span> <span class="mi">2</span>
  | <span class="mi">3</span> =&gt; <span class="nb">pattern</span> E <span class="nb">at</span> <span class="mi">3</span>
  | <span class="mi">4</span> =&gt; <span class="nb">pattern</span> E <span class="nb">at</span> <span class="mi">4</span>
  | <span class="mi">5</span> =&gt; <span class="nb">pattern</span> E <span class="nb">at</span> <span class="mi">5</span>
  | <span class="mi">6</span> =&gt; <span class="nb">pattern</span> E <span class="nb">at</span> <span class="mi">6</span>
  | <span class="mi">7</span> =&gt; <span class="nb">pattern</span> E <span class="nb">at</span> <span class="mi">7</span>
  | <span class="mi">8</span> =&gt; <span class="nb">pattern</span> E <span class="nb">at</span> <span class="mi">8</span>
  | _ =&gt; <span class="kp">fail</span> <span class="s2">&quot;ltac_pattern: arity not supported&quot;</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;ltac_pattern&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;at&quot;</span> <span class="kp">constr</span>(K) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  <span class="kr">match</span> number_to_nat K <span class="kr">with</span>
  | <span class="mi">1</span> =&gt; <span class="nb">pattern</span> E <span class="nb">at</span> <span class="mi">1</span> <span class="kr">in</span> H
  | <span class="mi">2</span> =&gt; <span class="nb">pattern</span> E <span class="nb">at</span> <span class="mi">2</span> <span class="kr">in</span> H
  | <span class="mi">3</span> =&gt; <span class="nb">pattern</span> E <span class="nb">at</span> <span class="mi">3</span> <span class="kr">in</span> H
  | <span class="mi">4</span> =&gt; <span class="nb">pattern</span> E <span class="nb">at</span> <span class="mi">4</span> <span class="kr">in</span> H
  | <span class="mi">5</span> =&gt; <span class="nb">pattern</span> E <span class="nb">at</span> <span class="mi">5</span> <span class="kr">in</span> H
  | <span class="mi">6</span> =&gt; <span class="nb">pattern</span> E <span class="nb">at</span> <span class="mi">6</span> <span class="kr">in</span> H
  | <span class="mi">7</span> =&gt; <span class="nb">pattern</span> E <span class="nb">at</span> <span class="mi">7</span> <span class="kr">in</span> H
  | <span class="mi">8</span> =&gt; <span class="nb">pattern</span> E <span class="nb">at</span> <span class="mi">8</span> <span class="kr">in</span> H
  | _ =&gt; <span class="kp">fail</span> <span class="s2">&quot;ltac_pattern: arity not supported&quot;</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [ltac_set (x := E) at K] is the same as [set (x := E) at K] except</span>
<span class="sd">    that [K] is a Coq number (nat or Z) rather than a Ltac integer. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;ltac_set&quot;</span> <span class="s2">&quot;(&quot;</span> <span class="kn">ident</span>(X) <span class="s2">&quot;:=&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;)&quot;</span> <span class="s2">&quot;at&quot;</span> <span class="kp">constr</span>(K) :=
  <span class="kr">match</span> number_to_nat K <span class="kr">with</span>
  | <span class="mi">1</span>%nat =&gt; <span class="nb">set</span> (X := E) <span class="nb">at</span> <span class="mi">1</span>
  | <span class="mi">2</span>%nat =&gt; <span class="nb">set</span> (X := E) <span class="nb">at</span> <span class="mi">2</span>
  | <span class="mi">3</span>%nat =&gt; <span class="nb">set</span> (X := E) <span class="nb">at</span> <span class="mi">3</span>
  | <span class="mi">4</span>%nat =&gt; <span class="nb">set</span> (X := E) <span class="nb">at</span> <span class="mi">4</span>
  | <span class="mi">5</span>%nat =&gt; <span class="nb">set</span> (X := E) <span class="nb">at</span> <span class="mi">5</span>
  | <span class="mi">6</span>%nat =&gt; <span class="nb">set</span> (X := E) <span class="nb">at</span> <span class="mi">6</span>
  | <span class="mi">7</span>%nat =&gt; <span class="nb">set</span> (X := E) <span class="nb">at</span> <span class="mi">7</span>
  | <span class="mi">8</span>%nat =&gt; <span class="nb">set</span> (X := E) <span class="nb">at</span> <span class="mi">8</span>
  | <span class="mi">9</span>%nat =&gt; <span class="nb">set</span> (X := E) <span class="nb">at</span> <span class="mi">9</span>
  | <span class="mi">10</span>%nat =&gt; <span class="nb">set</span> (X := E) <span class="nb">at</span> <span class="mi">10</span>
  | <span class="mi">11</span>%nat =&gt; <span class="nb">set</span> (X := E) <span class="nb">at</span> <span class="mi">11</span>
  | <span class="mi">12</span>%nat =&gt; <span class="nb">set</span> (X := E) <span class="nb">at</span> <span class="mi">12</span>
  | <span class="mi">13</span>%nat =&gt; <span class="nb">set</span> (X := E) <span class="nb">at</span> <span class="mi">13</span>
  | _ =&gt; <span class="kp">fail</span> <span class="s2">&quot;ltac_set: arity not supported&quot;</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Testing Tactics *)</span>

<span class="sd">(** [show tac] executes a tactic [tac] that produces a result,</span>
<span class="sd">    and then display its result. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;show&quot;</span> tactic(tac) :=
  <span class="kr">let</span> <span class="nv">R</span> := tac <span class="kr">in</span> <span class="nb">pose</span> R.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [dup N] produces [N] copies of the current goal. It is useful</span>
<span class="sd">    for building examples on which to illustrate behaviour of tactics.</span>
<span class="sd">    [dup] is short for [dup 2]. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk2"><span class="kn">Lemma</span> <span class="nf">dup_lemma</span> : <span class="kr">forall</span> <span class="nv">P</span>, P -&gt; P -&gt; P.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P</span> : <span class="kt">Type</span>, P -&gt; P -&gt; P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk3"><span class="kn">Proof using</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P</span> : <span class="kt">Type</span>, P -&gt; P -&gt; P</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">dup_tactic</span> N :=
  <span class="kr">match</span> number_to_nat N <span class="kr">with</span>
  | <span class="mi">0</span> =&gt; <span class="kp">idtac</span>
  | S <span class="mi">0</span> =&gt; <span class="kp">idtac</span>
  | S <span class="nl">?N&#39;</span> =&gt; <span class="nb">apply</span> dup_lemma; [ | dup_tactic N&#39; ]
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;dup&quot;</span> <span class="kp">constr</span>(N) :=
  dup_tactic N.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;dup&quot;</span> :=
  dup <span class="mi">2</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Testing evars and non-evars *)</span>

<span class="sd">(** [is_not_evar E] succeeds only if [E] is not an evar;</span>
<span class="sd">    it fails otherwise. It thus implements the negation of [is_evar] *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">is_not_evar</span> E :=
  <span class="kp">first</span> [ <span class="nb">is_evar</span> E; <span class="kp">fail</span> <span class="mi">1</span>
        | <span class="kp">idtac</span> ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [is_evar_as_bool E] evaluates to [true] if [E] is an evar</span>
<span class="sd">    and to [false] otherwise. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">is_evar_as_bool</span> E :=
  <span class="kp">constr</span>:(<span class="kp">ltac</span>:(<span class="kp">first</span>
    [ <span class="nb">is_evar</span> E; <span class="bp">exact</span> true
    | <span class="bp">exact</span> false ])).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [has_no_evar E] succeeds if [E] contains no evars. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">has_no_evar</span> E :=
  <span class="kp">first</span> [ <span class="nb">has_evar</span> E; <span class="kp">fail</span> <span class="mi">1</span> | <span class="kp">idtac</span> ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Check No Evar in Goal *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">check_noevar</span> M :=
  <span class="kp">first</span> [ <span class="nb">has_evar</span> M; <span class="kp">fail</span> <span class="mi">2</span> | <span class="kp">idtac</span> ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">check_noevar_hyp</span> H :=
  <span class="kr">let</span> <span class="nv">T</span> := <span class="kp">type of</span> H <span class="kr">in</span> check_noevar T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">check_noevar_goal</span> :=
  <span class="kr">match goal with</span> |- <span class="nl">?G</span> =&gt; check_noevar G <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Helper Function for Introducing Evars *)</span>

<span class="sd">(** [with_evar T (fun M =&gt; tac)] creates a new evar that can</span>
<span class="sd">    be used in the tactic [tac] under the name [M]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">with_evar_base</span> T cont :=
  <span class="kr">let</span> <span class="nv">x</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span> <span class="nb">evar</span> (x:T); cont x; <span class="nb">subst</span> x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;with_evar&quot;</span> <span class="kp">constr</span>(T) tactic(cont) :=
  with_evar_base T cont.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Tagging of Hypotheses *)</span>

<span class="sd">(** [get_last_hyp tt] is a function that returns the last hypothesis</span>
<span class="sd">    at the bottom of the context. It is useful to obtain the default</span>
<span class="sd">    name associated with the hypothesis, e.g.</span>
<span class="sd">    [intro; let H := get_last_hyp tt in let H&#39; := fresh &quot;P&quot; H in ...] *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">get_last_hyp</span> tt :=
  <span class="kr">match goal with</span> H: _ |- _ =&gt; <span class="kp">constr</span>:(H) <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** More Tagging of Hypotheses *)</span>

<span class="sd">(** [ltac_tag_subst] is a specific marker for hypotheses</span>
<span class="sd">    which is used to tag hypotheses that are equalities to</span>
<span class="sd">    be substituted. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ltac_tag_subst</span> (<span class="nv">A</span>:<span class="kt">Type</span>) (<span class="nv">x</span>:A) := x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [ltac_to_generalize] is a specific marker for hypotheses</span>
<span class="sd">    to be generalized. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ltac_to_generalize</span> (<span class="nv">A</span>:<span class="kt">Type</span>) (<span class="nv">x</span>:A) := x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">gen_to_generalize</span> :=
  <span class="kp">repeat</span> <span class="kr">match goal with</span>
    H: ltac_to_generalize _ |- _ =&gt; <span class="nb">generalize</span> H; <span class="nb">clear</span> H <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">mark_to_generalize</span> H :=
  <span class="kr">let</span> <span class="nv">T</span> := <span class="kp">type of</span> H <span class="kr">in</span>
  <span class="nb">change</span> T <span class="kr">with</span> (ltac_to_generalize T) <span class="kr">in</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Deconstructing Terms *)</span>

<span class="sd">(** [get_head E] is a tactic that returns the head constant of the</span>
<span class="sd">    term [E], ie, when applied to a term of the form [P x1 ... xN]</span>
<span class="sd">    it returns [P]. If [E] is not an application, it returns [E].</span>
<span class="sd">    Warning: the tactic seems to loop in some cases when the goal is</span>
<span class="sd">    a product and one uses the result of this function. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">get_head</span> E :=
  <span class="kr">match</span> E <span class="kr">with</span>
  | <span class="nl">?E&#39;</span> <span class="nl">?x</span> =&gt; get_head E&#39;
  | _ =&gt; <span class="kp">constr</span>:(E)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [get_fun_arg E] is a tactic that decomposes an application</span>
<span class="sd">  term [E], ie, when applied to a term of the form [X1 ... XN]</span>
<span class="sd">  it returns a pair made of [X1 .. X(N-1)] and [XN]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">get_fun_arg</span> E :=
  <span class="kr">match</span> E <span class="kr">with</span>
  | <span class="nl">?X1</span> <span class="nl">?X2</span> <span class="nl">?X3</span> <span class="nl">?X4</span> <span class="nl">?X5</span> <span class="nl">?X6</span> <span class="nl">?X7</span> <span class="nl">?X</span> =&gt; <span class="kp">constr</span>:((X1 X2 X3 X4 X5 X6 X7,X))
  | <span class="nl">?X1</span> <span class="nl">?X2</span> <span class="nl">?X3</span> <span class="nl">?X4</span> <span class="nl">?X5</span> <span class="nl">?X6</span> <span class="nl">?X</span> =&gt; <span class="kp">constr</span>:((X1 X2 X3 X4 X5 X6,X))
  | <span class="nl">?X1</span> <span class="nl">?X2</span> <span class="nl">?X3</span> <span class="nl">?X4</span> <span class="nl">?X5</span> <span class="nl">?X</span> =&gt; <span class="kp">constr</span>:((X1 X2 X3 X4 X5,X))
  | <span class="nl">?X1</span> <span class="nl">?X2</span> <span class="nl">?X3</span> <span class="nl">?X4</span> <span class="nl">?X</span> =&gt; <span class="kp">constr</span>:((X1 X2 X3 X4,X))
  | <span class="nl">?X1</span> <span class="nl">?X2</span> <span class="nl">?X3</span> <span class="nl">?X</span> =&gt; <span class="kp">constr</span>:((X1 X2 X3,X))
  | <span class="nl">?X1</span> <span class="nl">?X2</span> <span class="nl">?X</span> =&gt; <span class="kp">constr</span>:((X1 X2,X))
  | <span class="nl">?X1</span> <span class="nl">?X</span> =&gt; <span class="kp">constr</span>:((X1,X))
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Action at Occurence and Action Not at Occurence *)</span>

<span class="sd">(** [ltac_action_at K of E do Tac] isolates the [K]-th occurence of [E] in the</span>
<span class="sd">    goal, setting it in the form [P E] for some named pattern [P],</span>
<span class="sd">    then calls tactic [Tac], and finally unfolds [P]. Syntax</span>
<span class="sd">    [ltac_action_at K of E in H do Tac] is also available. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;ltac_action_at&quot;</span> <span class="kp">constr</span>(K) <span class="s2">&quot;of&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;do&quot;</span> tactic(Tac) :=
  <span class="kr">let</span> <span class="nv">p</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span> ltac_pattern E <span class="nb">at</span> K;
  <span class="kr">match goal with</span> |- <span class="nl">?P</span> _ =&gt; <span class="nb">set</span> (p:=P) <span class="kr">end</span>;
  Tac; <span class="nb">unfold</span> p; <span class="nb">clear</span> p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;ltac_action_at&quot;</span> <span class="kp">constr</span>(K) <span class="s2">&quot;of&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> hyp(H) <span class="s2">&quot;do&quot;</span> tactic(Tac) :=
  <span class="kr">let</span> <span class="nv">p</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span> ltac_pattern E <span class="nb">at</span> K <span class="kr">in</span> H;
  <span class="kr">match</span> <span class="kp">type of</span> H <span class="kr">with</span> <span class="nl">?P</span> _ =&gt; <span class="nb">set</span> (p:=P) <span class="kr">in</span> H <span class="kr">end</span>;
  Tac; <span class="nb">unfold</span> p <span class="kr">in</span> H; <span class="nb">clear</span> p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [protects E do Tac] temporarily assigns a name to the expression [E]</span>
<span class="sd">    so that the execution of tactic [Tac] will not modify [E]. This is</span>
<span class="sd">    useful for instance to restrict the action of [simpl]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;protects&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;do&quot;</span> tactic(Tac) :=
  <span class="c">(* let x := fresh &quot;TEMP&quot; in sets_eq x: E; T; subst x. *)</span>
  <span class="kr">let</span> <span class="nv">x</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span> <span class="kr">let</span> <span class="nv">H</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span>
  <span class="nb">set</span> (X := E) <span class="kr">in</span> *; <span class="nb">assert</span> (H : X = E) <span class="bp">by</span> <span class="bp">reflexivity</span>;
  <span class="nb">clearbody</span> X; Tac; <span class="nb">subst</span> x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;protects&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;do&quot;</span> tactic(Tac) <span class="s2">&quot;/&quot;</span> :=
  protects E <span class="kp">do</span> Tac.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** An Alias for [eq] *)</span>

<span class="sd">(** [eq&#39;] is an alias for [eq] to be used for equalities in</span>
<span class="sd">    inductive definitions, so that they don&#39;t get mixed with</span>
<span class="sd">    equalities generated by [inversion]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">eq&#39;</span> := @eq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Hint Unfold</span> eq&#39; : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;x &#39;=&#39;&#39; y&quot;</span> := (@eq&#39; _ x y)
  (<span class="kn">at level</span> <span class="mi">70</span>, y <span class="kn">at next level</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ################################################################# *)</span>
<span class="sd">(** * Common Tactics for Simplifying Goals Like [intuition] *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">jauto_set_hyps</span> :=
  <span class="kp">repeat</span> <span class="kr">match goal with</span> H: <span class="nl">?T</span> |- _ =&gt;
    <span class="kr">match</span> T <span class="kr">with</span>
    | _ /\ _ =&gt; <span class="nb">destruct</span> H
    | <span class="kr">exists</span> <span class="nv">a</span>, _ =&gt; <span class="nb">destruct</span> H
    | _ =&gt; <span class="nb">generalize</span> H; <span class="nb">clear</span> H
    <span class="kr">end</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">jauto_set_goal</span> :=
  <span class="kp">repeat</span> <span class="kr">match goal with</span>
  | |- <span class="kr">exists</span> <span class="nv">a</span>, _ =&gt; <span class="nb">esplit</span>
  | |- _ /\ _ =&gt; <span class="nb">split</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">jauto_set</span> :=
  <span class="nb">intros</span>; jauto_set_hyps;
  <span class="nb">intros</span>; jauto_set_goal;
  <span class="nb">unfold</span> not <span class="kr">in</span> *.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

<span class="c">(* ################################################################# *)</span>
<span class="sd">(** * Backward and Forward Chaining *)</span>

<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Application *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">old_refine</span> f :=
  <span class="nb">refine</span> f. <span class="c">(* ; shelve_unifiable. *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [rapply] is a tactic similar to [eapply] except that it is</span>
<span class="sd">    based on the [refine] tactics, and thus is strictly more</span>
<span class="sd">    powerful (at least in theory :). In short, it is able to perform</span>
<span class="sd">    on-the-fly conversions when required for arguments to match,</span>
<span class="sd">    and it is able to instantiate existentials when required. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rapply&quot;</span> <span class="kp">constr</span>(t) :=
  <span class="kp">first</span>  <span class="c">(* --Note: the @ are not useful *)</span>
  [ <span class="bp">eexact</span> (@t)
  | old_refine (@t)
  | old_refine (@t _)
  | old_refine (@t _ _)
  | old_refine (@t _ _ _)
  | old_refine (@t _ _ _ _)
  | old_refine (@t _ _ _ _ _)
  | old_refine (@t _ _ _ _ _ _)
  | old_refine (@t _ _ _ _ _ _ _)
  | old_refine (@t _ _ _ _ _ _ _ _)
  | old_refine (@t _ _ _ _ _ _ _ _ _)
  | old_refine (@t _ _ _ _ _ _ _ _ _ _)
  | old_refine (@t _ _ _ _ _ _ _ _ _ _ _)
  | old_refine (@t _ _ _ _ _ _ _ _ _ _ _ _)
  | old_refine (@t _ _ _ _ _ _ _ _ _ _ _ _ _)
  | old_refine (@t _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  | old_refine (@t _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** No-typeclass refine apply, TEMPORARY for Coq &lt; 8.11. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">nrapply</span> H :=
  <span class="kp">first</span>
  [ <span class="nb">notypeclasses refine</span> (H)
  | <span class="nb">notypeclasses refine</span> (H _)
  | <span class="nb">notypeclasses refine</span> (H _ _)
  | <span class="nb">notypeclasses refine</span> (H _ _ _)
  | <span class="nb">notypeclasses refine</span> (H _ _ _ _)
  | <span class="nb">notypeclasses refine</span> (H _ _ _ _ _)
  | <span class="nb">notypeclasses refine</span> (H _ _ _ _ _ _)
  | <span class="nb">notypeclasses refine</span> (H _ _ _ _ _ _ _)
  | <span class="nb">notypeclasses refine</span> (H _ _ _ _ _ _ _ _)
  | <span class="nb">notypeclasses refine</span> (H _ _ _ _ _ _ _ _ _)
  | <span class="nb">notypeclasses refine</span> (H _ _ _ _ _ _ _ _ _ _)
  | <span class="nb">notypeclasses refine</span> (H _ _ _ _ _ _ _ _ _ _ _)
  | <span class="nb">notypeclasses refine</span> (H _ _ _ _ _ _ _ _ _ _ _ _)
  | <span class="nb">notypeclasses refine</span> (H _ _ _ _ _ _ _ _ _ _ _ _ _)
  | <span class="nb">notypeclasses refine</span> (H _ _ _ _ _ _ _ _ _ _ _ _ _ _) ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The tactics [applys_N T], where [N] is a natural number,</span>
<span class="sd">    provides a more efficient way of using [applys T]. It avoids</span>
<span class="sd">    trying out all possible arities, by specifying explicitely</span>
<span class="sd">    the arity of function [T]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rapply_0&quot;</span> <span class="kp">constr</span>(t) :=
  old_refine (@t).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rapply_1&quot;</span> <span class="kp">constr</span>(t) :=
  old_refine (@t _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rapply_2&quot;</span> <span class="kp">constr</span>(t) :=
  old_refine (@t _ _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rapply_3&quot;</span> <span class="kp">constr</span>(t) :=
  old_refine (@t _ _ _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rapply_4&quot;</span> <span class="kp">constr</span>(t) :=
  old_refine (@t _ _ _ _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rapply_5&quot;</span> <span class="kp">constr</span>(t) :=
  old_refine (@t _ _ _ _ _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rapply_6&quot;</span> <span class="kp">constr</span>(t) :=
  old_refine (@t _ _ _ _ _ _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rapply_7&quot;</span> <span class="kp">constr</span>(t) :=
  old_refine (@t _ _ _ _ _ _ _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rapply_8&quot;</span> <span class="kp">constr</span>(t) :=
  old_refine (@t _ _ _ _ _ _ _ _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rapply_9&quot;</span> <span class="kp">constr</span>(t) :=
  old_refine (@t _ _ _ _ _ _ _ _ _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rapply_10&quot;</span> <span class="kp">constr</span>(t) :=
  old_refine (@t _ _ _ _ _ _ _ _ _ _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [lets_base H E] adds an hypothesis [H : T] to the context, where [T] is</span>
<span class="sd">    the type of term [E]. If [H] is an introduction pattern, it will</span>
<span class="sd">    destruct [H] according to the pattern. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">lets_base</span> I E := <span class="nb">generalize</span> E; <span class="nb">intros</span> I.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [applys_to H E] transform the type of hypothesis [H] by</span>
<span class="sd">    replacing it by the result of the application of the term</span>
<span class="sd">    [E] to [H]. Intuitively, it is equivalent to [lets H: (E H)]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;applys_to&quot;</span> hyp(H) <span class="kp">constr</span>(E) :=
  <span class="kr">let</span> <span class="nv">H&#39;</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span> <span class="nb">rename</span> H <span class="nb">into</span> H&#39;;
  (<span class="kp">first</span> [ <span class="kr">let</span><span class="nv">s_base</span> <span class="nv">H</span> (<span class="nv">E</span> <span class="nv">H&#39;</span>)
         | <span class="kr">let</span><span class="nv">s_base</span> <span class="nv">H</span> (<span class="nv">E</span> <span class="nv">_</span> <span class="nv">H&#39;</span>)
         | <span class="kr">let</span><span class="nv">s_base</span> <span class="nv">H</span> (<span class="nv">E</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">H&#39;</span>)
         | <span class="kr">let</span><span class="nv">s_base</span> <span class="nv">H</span> (<span class="nv">E</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">H&#39;</span>)
         | <span class="kr">let</span><span class="nv">s_base</span> <span class="nv">H</span> (<span class="nv">E</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">H&#39;</span>)
         | <span class="kr">let</span><span class="nv">s_base</span> <span class="nv">H</span> (<span class="nv">E</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">H&#39;</span>)
         | <span class="kr">let</span><span class="nv">s_base</span> <span class="nv">H</span> (<span class="nv">E</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">H&#39;</span>)
         | <span class="kr">let</span><span class="nv">s_base</span> <span class="nv">H</span> (<span class="nv">E</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">H&#39;</span>)
         | <span class="kr">let</span><span class="nv">s_base</span> <span class="nv">H</span> (<span class="nv">E</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">H&#39;</span>)
         | <span class="kr">let</span><span class="nv">s_base</span> <span class="nv">H</span> (<span class="nv">E</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">H&#39;</span>) ]
  ); <span class="nb">clear</span> H&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [applys_to H1,...,HN E] applys [E] to several hypotheses *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;applys_to&quot;</span> hyp(H1) <span class="s2">&quot;,&quot;</span> hyp(H2) <span class="kp">constr</span>(E) :=
  applys_to H1 E; applys_to H2 E.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;applys_to&quot;</span> hyp(H1) <span class="s2">&quot;,&quot;</span> hyp(H2) <span class="s2">&quot;,&quot;</span> hyp(H3) <span class="kp">constr</span>(E) :=
  applys_to H1 E; applys_to H2 E; applys_to H3 E.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;applys_to&quot;</span> hyp(H1) <span class="s2">&quot;,&quot;</span> hyp(H2) <span class="s2">&quot;,&quot;</span> hyp(H3) <span class="s2">&quot;,&quot;</span> hyp(H4) <span class="kp">constr</span>(E) :=
  applys_to H1 E; applys_to H2 E; applys_to H3 E; applys_to H4 E.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [constructors] calls [constructor] or [econstructor]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;constructors&quot;</span> :=
  <span class="kp">first</span> [ <span class="nb">constructor</span> | <span class="nb">econstructor</span> ]; <span class="nb">unfold</span> eq&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Assertions *)</span>

<span class="sd">(** [asserts H: T] is another syntax for [assert (H : T)], which</span>
<span class="sd">    also works with introduction patterns. For instance, one can write:</span>
<span class="sd">    [asserts [x P] (exists n, n = 3)], or</span>
<span class="sd">    [asserts [H|H] (n = 0 \/ n = 1)]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;asserts&quot;</span> simple_intropattern(I) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(T) :=
  <span class="kr">let</span> <span class="nv">H</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span> <span class="nb">assert</span> (H : T);
  [ | <span class="nb">generalize</span> H; <span class="nb">clear</span> H; <span class="nb">intros</span> I ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [asserts H1 .. HN: T] is a shorthand for</span>
<span class="sd">    [asserts [H1 [H2 [.. HN]]]: T]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;asserts&quot;</span> simple_intropattern(I1)
 simple_intropattern(I2) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(T) :=
  asserts [I1 I2]: T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;asserts&quot;</span> simple_intropattern(I1)
 simple_intropattern(I2) simple_intropattern(I3) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(T) :=
  asserts [I1 [I2 I3]]: T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;asserts&quot;</span> simple_intropattern(I1)
 simple_intropattern(I2) simple_intropattern(I3)
 simple_intropattern(I4) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(T) :=
  asserts [I1 [I2 [I3 I4]]]: T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;asserts&quot;</span> simple_intropattern(I1)
 simple_intropattern(I2) simple_intropattern(I3)
 simple_intropattern(I4) simple_intropattern(I5) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(T) :=
  asserts [I1 [I2 [I3 [I4 I5]]]]: T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;asserts&quot;</span> simple_intropattern(I1)
 simple_intropattern(I2) simple_intropattern(I3)
 simple_intropattern(I4) simple_intropattern(I5)
 simple_intropattern(I6) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(T) :=
  asserts [I1 [I2 [I3 [I4 [I5 I6]]]]]: T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [asserts: T] is [asserts H: T] with [H] being chosen automatically. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;asserts&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(T) :=
  <span class="kr">let</span> <span class="nv">H</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span> asserts H : T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [cuts H: T] is the same as [asserts H: T] except that the two subgoals</span>
<span class="sd">    generated are swapped: the subgoal [T] comes second. Note that contrary</span>
<span class="sd">    to [cut], it introduces the hypothesis. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cuts&quot;</span> simple_intropattern(I) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(T) :=
  <span class="nb">cut</span> (T); [ <span class="nb">intros</span> I | <span class="kp">idtac</span> ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [cuts: T] is [cuts H: T] with [H] being chosen automatically. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cuts&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(T) :=
  <span class="kr">let</span> <span class="nv">H</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span> cuts H: T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [cuts H1 .. HN: T] is a shorthand for</span>
<span class="sd">    [cuts \[H1 \[H2 \[.. HN\]\]\]\]: T]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cuts&quot;</span> simple_intropattern(I1)
 simple_intropattern(I2) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(T) :=
  cuts [I1 I2]: T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cuts&quot;</span> simple_intropattern(I1)
 simple_intropattern(I2) simple_intropattern(I3) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(T) :=
  cuts [I1 [I2 I3]]: T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cuts&quot;</span> simple_intropattern(I1)
 simple_intropattern(I2) simple_intropattern(I3)
 simple_intropattern(I4) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(T) :=
  cuts [I1 [I2 [I3 I4]]]: T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cuts&quot;</span> simple_intropattern(I1)
 simple_intropattern(I2) simple_intropattern(I3)
 simple_intropattern(I4) simple_intropattern(I5) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(T) :=
  cuts [I1 [I2 [I3 [I4 I5]]]]: T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cuts&quot;</span> simple_intropattern(I1)
 simple_intropattern(I2) simple_intropattern(I3)
 simple_intropattern(I4) simple_intropattern(I5)
 simple_intropattern(I6) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(T) :=
  cuts [I1 [I2 [I3 [I4 [I5 I6]]]]]: T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Instantiation and Forward-Chaining *)</span>

<span class="sd">(** The instantiation tactics are used to instantiate a lemma [E]</span>
<span class="sd">    (whose type is a product) on some arguments. The type of [E] is</span>
<span class="sd">    made of implications and universal quantifications, e.g.</span>
<span class="sd">    [forall x, P x -&gt; forall y z, Q x y z -&gt; R z].</span>

<span class="sd">    The first possibility is to provide arguments in order: first [x],</span>
<span class="sd">    then a proof of [P x], then [y] etc... In this mode, called &quot;Args&quot;,</span>
<span class="sd">    all the arguments are to be provided. If a wildcard is provided</span>
<span class="sd">    (written [__]), then an existential variable will be introduced in</span>
<span class="sd">    place of the argument.</span>

<span class="sd">    It is very convenient to give some arguments the lemma should be</span>
<span class="sd">    instantiated on, and let the tactic find out automatically where</span>
<span class="sd">    underscores should be insterted. Underscore arguments [__] are</span>
<span class="sd">    interpret as follows: an underscore means that we want to skip the</span>
<span class="sd">    argument that has the same type as the next real argument provided</span>
<span class="sd">    (real means not an underscore). If there is no real argument after</span>
<span class="sd">    underscore, then the underscore is used for the first possible argument.</span>

<span class="sd">    The general syntax is [tactic (&gt;&gt; E1 .. EN)] where [tactic] is</span>
<span class="sd">    the name of the tactic (possibly with some arguments) and [Ei]</span>
<span class="sd">    are the arguments. Moreover, some tactics accept the syntax</span>
<span class="sd">    [tactic E1 .. EN] as short for [tactic (&gt;&gt; E1 .. EN)] for</span>
<span class="sd">    values of [N] up to 5.</span>

<span class="sd">    Finally, if the argument [EN] given is a triple-underscore [___],</span>
<span class="sd">    then it is equivalent to providing a list of wildcards, with</span>
<span class="sd">    the appropriate number of wildcards. This means that all</span>
<span class="sd">    the remaining arguments of the lemma will be instantiated.</span>
<span class="sd">    Definitions in the conclusion are not unfolded in this case. *)</span>

<span class="c">(* Underlying implementation *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">app_assert</span> t P cont :=
  <span class="kr">let</span> <span class="nv">H</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span>
  <span class="nb">assert</span> (H : P); [ | cont(t H); <span class="nb">clear</span> H ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">app_evar</span> t A cont :=
  <span class="kr">let</span> <span class="nv">x</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span>
  <span class="nb">evar</span> (x:A);
  <span class="kr">let</span> <span class="nv">t&#39;</span> := <span class="kp">constr</span>:(t x) <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">t&#39;&#39;</span> := (<span class="kp">eval</span> <span class="nb">unfold</span> x <span class="kr">in</span> t&#39;) <span class="kr">in</span>
  <span class="nb">subst</span> x; cont t&#39;&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">app_arg</span> t P v cont :=
  <span class="kr">let</span> <span class="nv">H</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span>
  <span class="nb">assert</span> (H : P); [ <span class="nb">apply</span> v | cont(t H); <span class="kp">try</span> <span class="nb">clear</span> H ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">build_app_alls</span> t final :=
  <span class="kr">let rec</span> <span class="nv">go</span> <span class="nv">t</span> :=
    <span class="kr">match</span> <span class="kp">type of</span> t <span class="kr">with</span>
    | <span class="nl">?P</span> -&gt; <span class="nl">?Q</span> =&gt; app_assert t P go
    | <span class="kr">forall</span> <span class="nv">_</span>:<span class="nl">?A</span>, _ =&gt; app_evar t A go
    | _ =&gt; final t
    <span class="kr">end</span> <span class="kr">in</span>
  go t.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">boxerlist_next_type</span> vs :=
  <span class="kr">match</span> vs <span class="kr">with</span>
  | nil =&gt; <span class="kp">constr</span>:(ltac_wild)
  | (boxer ltac_wild)::<span class="nl">?vs&#39;</span> =&gt; boxerlist_next_type vs&#39;
  | (boxer ltac_wilds)::_ =&gt; <span class="kp">constr</span>:(ltac_wild)
  | (@boxer <span class="nl">?T</span> _)::_ =&gt; <span class="kp">constr</span>:(T)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Note: refuse to instantiate a dependent hypothesis with a proposition;</span>
<span class="c">    refuse to instantiate an argument of type Type with one that</span>
<span class="c">    does not have the type Type.</span>
<span class="c">*)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">build_app_hnts</span> t vs final :=
  <span class="kr">let rec</span> <span class="nv">go</span> <span class="nv">t</span> <span class="nv">vs</span> :=
    <span class="kr">match</span> vs <span class="kr">with</span>
    | nil =&gt; <span class="kp">first</span> [ final t | <span class="kp">fail</span> <span class="mi">1</span> ]
    | (boxer ltac_wilds)::_ =&gt; <span class="kp">first</span> [ build_app_alls t final | <span class="kp">fail</span> <span class="mi">1</span> ]
    | (boxer <span class="nl">?v</span>)::<span class="nl">?vs&#39;</span> =&gt;
      <span class="kr">let</span> <span class="nv">cont</span> <span class="nv">t&#39;</span> := go t&#39; vs <span class="kr">in</span>
      <span class="kr">let</span> <span class="nv">cont&#39;</span> <span class="nv">t&#39;</span> := go t&#39; vs&#39; <span class="kr">in</span>
      <span class="kr">let</span> <span class="nv">T</span> := <span class="kp">type of</span> t <span class="kr">in</span>
      <span class="kr">let</span> <span class="nv">T</span> := <span class="kp">eval</span> <span class="nb">hnf</span> <span class="kr">in</span> T <span class="kr">in</span>
      <span class="kr">match</span> v <span class="kr">with</span>
      | ltac_wild =&gt;
         <span class="kp">first</span> [ <span class="kr">let</span> <span class="nv">U</span> := boxerlist_next_type vs&#39; <span class="kr">in</span>
           <span class="kr">match</span> U <span class="kr">with</span>
           | ltac_wild =&gt;
             <span class="kr">match</span> T <span class="kr">with</span>
             | <span class="nl">?P</span> -&gt; <span class="nl">?Q</span> =&gt; <span class="kp">first</span> [ app_assert t P cont&#39; | <span class="kp">fail</span> <span class="mi">3</span> ]
             | <span class="kr">forall</span> <span class="nv">_</span>:<span class="nl">?A</span>, _ =&gt; <span class="kp">first</span> [ app_evar t A cont&#39; | <span class="kp">fail</span> <span class="mi">3</span> ]
             <span class="kr">end</span>
           | _ =&gt;
             <span class="kr">match</span> T <span class="kr">with</span>  <span class="c">(* should test T for unifiability *)</span>
             | U -&gt; <span class="nl">?Q</span> =&gt; <span class="kp">first</span> [ app_assert t U cont&#39; | <span class="kp">fail</span> <span class="mi">3</span> ]
             | <span class="kr">forall</span> <span class="nv">_</span>:U, _ =&gt; <span class="kp">first</span> [ app_evar t U cont&#39; | <span class="kp">fail</span> <span class="mi">3</span> ]
             | <span class="nl">?P</span> -&gt; <span class="nl">?Q</span> =&gt; <span class="kp">first</span> [ app_assert t P cont | <span class="kp">fail</span> <span class="mi">3</span> ]
             | <span class="kr">forall</span> <span class="nv">_</span>:<span class="nl">?A</span>, _ =&gt; <span class="kp">first</span> [ app_evar t A cont | <span class="kp">fail</span> <span class="mi">3</span> ]
             <span class="kr">end</span>
           <span class="kr">end</span>
         | <span class="kp">fail</span> <span class="mi">2</span> ]
      | _ =&gt;
          <span class="kr">match</span> T <span class="kr">with</span>
          | <span class="nl">?P</span> -&gt; <span class="nl">?Q</span> =&gt; <span class="kp">first</span> [ app_arg t P v cont&#39;
                              | app_assert t P cont
                              | <span class="kp">fail</span> <span class="mi">3</span> ]
           | <span class="kr">forall</span> <span class="nv">_</span>:<span class="kt">Type</span>, _ =&gt;
              <span class="kr">match</span> <span class="kp">type of</span> v <span class="kr">with</span>
              | <span class="kt">Type</span> =&gt; <span class="kp">first</span> [ cont&#39; (t v)
                              | app_evar t <span class="kt">Type</span> cont
                              | <span class="kp">fail</span> <span class="mi">3</span> ]
              | _ =&gt; <span class="kp">first</span> [ app_evar t <span class="kt">Type</span> cont
                           | <span class="kp">fail</span> <span class="mi">3</span> ]
              <span class="kr">end</span>
          | <span class="kr">forall</span> <span class="nv">_</span>:<span class="nl">?A</span>, _ =&gt;
             <span class="kr">let</span> <span class="nv">V</span> := <span class="kp">type of</span> v <span class="kr">in</span>
             <span class="kr">match</span> <span class="kp">type of</span> V <span class="kr">with</span>
             | <span class="kt">Prop</span> =&gt;  <span class="kp">first</span> [ app_evar t A cont
                              | <span class="kp">fail</span> <span class="mi">3</span> ]
             | _ =&gt; <span class="kp">first</span> [ cont&#39; (t v)
                          | app_evar t A cont
                          | <span class="kp">fail</span> <span class="mi">3</span> ]
             <span class="kr">end</span>
          <span class="kr">end</span>
      <span class="kr">end</span>
    <span class="kr">end</span> <span class="kr">in</span>
  go t vs.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** newer version : support for typeclasses *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">app_typeclass</span> t cont :=
  <span class="kr">let</span> <span class="nv">t&#39;</span> := <span class="kp">constr</span>:(t _) <span class="kr">in</span>
  cont t&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">build_app_alls</span> t final ::=
  <span class="kr">let rec</span> <span class="nv">go</span> <span class="nv">t</span> :=
    <span class="kr">match</span> <span class="kp">type of</span> t <span class="kr">with</span>
    | <span class="nl">?P</span> -&gt; <span class="nl">?Q</span> =&gt; app_assert t P go
    | <span class="kr">forall</span> <span class="nv">_</span>:<span class="nl">?A</span>, _ =&gt;
        <span class="kp">first</span> [ app_evar t A go
              | app_typeclass t go
              | <span class="kp">fail</span> <span class="mi">3</span> ]
    | _ =&gt; final t
    <span class="kr">end</span> <span class="kr">in</span>
  go t.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">build_app_hnts</span> t vs final ::=
  <span class="kr">let rec</span> <span class="nv">go</span> <span class="nv">t</span> <span class="nv">vs</span> :=
    <span class="kr">match</span> vs <span class="kr">with</span>
    | nil =&gt; <span class="kp">first</span> [ final t | <span class="kp">fail</span> <span class="mi">1</span> ]
    | (boxer ltac_wilds)::_ =&gt; <span class="kp">first</span> [ build_app_alls t final | <span class="kp">fail</span> <span class="mi">1</span> ]
    | (boxer <span class="nl">?v</span>)::<span class="nl">?vs&#39;</span> =&gt;
      <span class="kr">let</span> <span class="nv">cont</span> <span class="nv">t&#39;</span> := go t&#39; vs <span class="kr">in</span>
      <span class="kr">let</span> <span class="nv">cont&#39;</span> <span class="nv">t&#39;</span> := go t&#39; vs&#39; <span class="kr">in</span>
      <span class="kr">let</span> <span class="nv">T</span> := <span class="kp">type of</span> t <span class="kr">in</span>
      <span class="kr">let</span> <span class="nv">T</span> := <span class="kp">eval</span> <span class="nb">hnf</span> <span class="kr">in</span> T <span class="kr">in</span>
      <span class="kr">match</span> v <span class="kr">with</span>
      | ltac_wild =&gt;
         <span class="kp">first</span> [ <span class="kr">let</span> <span class="nv">U</span> := boxerlist_next_type vs&#39; <span class="kr">in</span>
           <span class="kr">match</span> U <span class="kr">with</span>
           | ltac_wild =&gt;
             <span class="kr">match</span> T <span class="kr">with</span>
             | <span class="nl">?P</span> -&gt; <span class="nl">?Q</span> =&gt; <span class="kp">first</span> [ app_assert t P cont&#39; | <span class="kp">fail</span> <span class="mi">3</span> ]
             | <span class="kr">forall</span> <span class="nv">_</span>:<span class="nl">?A</span>, _ =&gt; <span class="kp">first</span> [ app_typeclass t cont&#39;
                                       | app_evar t A cont&#39;
                                       | <span class="kp">fail</span> <span class="mi">3</span> ]
             <span class="kr">end</span>
           | _ =&gt;
             <span class="kr">match</span> T <span class="kr">with</span>  <span class="c">(* should test T for unifiability *)</span>
             | U -&gt; <span class="nl">?Q</span> =&gt; <span class="kp">first</span> [ app_assert t U cont&#39; | <span class="kp">fail</span> <span class="mi">3</span> ]
             | <span class="kr">forall</span> <span class="nv">_</span>:U, _ =&gt; <span class="kp">first</span>
                 [ app_typeclass t cont&#39;
                 | app_evar t U cont&#39;
                 | <span class="kp">fail</span> <span class="mi">3</span> ]
             | <span class="nl">?P</span> -&gt; <span class="nl">?Q</span> =&gt; <span class="kp">first</span> [ app_assert t P cont | <span class="kp">fail</span> <span class="mi">3</span> ]
             | <span class="kr">forall</span> <span class="nv">_</span>:<span class="nl">?A</span>, _ =&gt; <span class="kp">first</span>
                 [ app_typeclass t cont
                 | app_evar t A cont
                 | <span class="kp">fail</span> <span class="mi">3</span> ]
             <span class="kr">end</span>
           <span class="kr">end</span>
         | <span class="kp">fail</span> <span class="mi">2</span> ]
      | _ =&gt;
          <span class="kr">match</span> T <span class="kr">with</span>
          | <span class="nl">?P</span> -&gt; <span class="nl">?Q</span> =&gt; <span class="kp">first</span> [ app_arg t P v cont&#39;
                              | app_assert t P cont
                              | <span class="kp">fail</span> <span class="mi">3</span> ]
           | <span class="kr">forall</span> <span class="nv">_</span>:<span class="kt">Type</span>, _ =&gt;
              <span class="kr">match</span> <span class="kp">type of</span> v <span class="kr">with</span>
              | <span class="kt">Type</span> =&gt; <span class="kp">first</span> [ cont&#39; (t v)
                              | app_evar t <span class="kt">Type</span> cont
                              | <span class="kp">fail</span> <span class="mi">3</span> ]
              | _ =&gt; <span class="kp">first</span> [ app_evar t <span class="kt">Type</span> cont
                           | <span class="kp">fail</span> <span class="mi">3</span> ]
              <span class="kr">end</span>
          | <span class="kr">forall</span> <span class="nv">_</span>:<span class="nl">?A</span>, _ =&gt;
             <span class="kr">let</span> <span class="nv">V</span> := <span class="kp">type of</span> v <span class="kr">in</span>
             <span class="kr">match</span> <span class="kp">type of</span> V <span class="kr">with</span>
             | <span class="kt">Prop</span> =&gt; <span class="kp">first</span> [ app_typeclass t cont
                              | app_evar t A cont
                              | <span class="kp">fail</span> <span class="mi">3</span> ]
             | _ =&gt; <span class="kp">first</span> [ cont&#39; (t v)
                          | app_typeclass t cont
                          | app_evar t A cont
                          | <span class="kp">fail</span> <span class="mi">3</span> ]
             <span class="kr">end</span>
          <span class="kr">end</span>
      <span class="kr">end</span>
    <span class="kr">end</span> <span class="kr">in</span>
  go t vs.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* --Note: use local function for first [...] *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">build_app</span> args final :=
  <span class="kp">first</span> [
    <span class="kr">match</span> args <span class="kr">with</span> (@boxer <span class="nl">?T</span> <span class="nl">?t</span>)::<span class="nl">?vs</span> =&gt;
      <span class="kr">let</span> <span class="nv">t</span> := <span class="kp">constr</span>:(t:T) <span class="kr">in</span>
      build_app_hnts t vs final;
      fast_rm_inside args
    <span class="kr">end</span>
  | <span class="kp">fail</span> <span class="mi">1</span> <span class="s2">&quot;Instantiation fails for:&quot;</span> args].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">unfold_head_until_product</span> T :=
  <span class="kp">eval</span> <span class="nb">hnf</span> <span class="kr">in</span> T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">args_unfold_head_if_not_product</span> args :=
  <span class="kr">match</span> args <span class="kr">with</span> (@boxer <span class="nl">?T</span> <span class="nl">?t</span>)::<span class="nl">?vs</span> =&gt;
    <span class="kr">let</span> <span class="nv">T&#39;</span> := unfold_head_until_product T <span class="kr">in</span>
    <span class="kp">constr</span>:((@boxer T&#39; t)::vs)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">args_unfold_head_if_not_product_but_params</span> args :=
  <span class="kr">match</span> args <span class="kr">with</span>
  | (boxer <span class="nl">?t</span>)::(boxer <span class="nl">?v</span>)::<span class="nl">?vs</span> =&gt;
     args_unfold_head_if_not_product args
  | _ =&gt; <span class="kp">constr</span>:(args)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [lets H: (&gt;&gt; E0 E1 .. EN)] will instantiate lemma [E0]</span>
<span class="sd">    on the arguments [Ei] (which may be wildcards [__]),</span>
<span class="sd">    and name [H] the resulting term. [H] may be an introduction</span>
<span class="sd">    pattern, or a sequence of introduction patterns [I1 I2 IN],</span>
<span class="sd">    or empty.</span>
<span class="sd">    Syntax [lets H: E0 E1 .. EN] is also available. If the last</span>
<span class="sd">    argument [EN] is [___] (triple-underscore), then all</span>
<span class="sd">    arguments of [H] will be instantiated. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">lets_build</span> I Ei :=
  <span class="kr">let</span> <span class="nv">args</span> := list_boxer_of Ei <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">args</span> := args_unfold_head_if_not_product_but_params args <span class="kr">in</span>
<span class="c">(*    let Ei&#39;&#39;&#39; := args_unfold_head_if_not_product Ei&#39;&#39; in*)</span>
  build_app args <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">R</span> =&gt; <span class="kr">let</span><span class="nv">s_base</span> <span class="nv">I</span> <span class="nv">R</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> simple_intropattern(I) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="kr">let</span><span class="nv">s_build</span> <span class="nv">I</span> <span class="nv">E</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="kr">let</span> <span class="nv">H</span> := <span class="kp">fresh</span> <span class="kr">in</span> <span class="kr">let</span><span class="nv">s</span> <span class="nv">H</span>: E.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) :=
  <span class="kr">let</span><span class="nv">s</span>: (&gt;&gt; E0 A1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) :=
  <span class="kr">let</span><span class="nv">s</span>: (&gt;&gt; E0 A1 A2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) :=
  <span class="kr">let</span><span class="nv">s</span>: (&gt;&gt; E0 A1 A2 A3).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) <span class="kp">constr</span>(A4) :=
  <span class="kr">let</span><span class="nv">s</span>: (&gt;&gt; E0 A1 A2 A3 A4).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) <span class="kp">constr</span>(A4) <span class="kp">constr</span>(A5) :=
  <span class="kr">let</span><span class="nv">s</span>: (&gt;&gt; E0 A1 A2 A3 A4 A5).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* DEPRECATED syntax [lets I1 I2] *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> simple_intropattern(I1) simple_intropattern(I2)
 <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="kr">let</span><span class="nv">s</span> [I1 I2]: E.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> simple_intropattern(I1) simple_intropattern(I2)
 simple_intropattern(I3) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="kr">let</span><span class="nv">s</span> [I1 [I2 I3]]: E.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> simple_intropattern(I1) simple_intropattern(I2)
 simple_intropattern(I3) simple_intropattern(I4) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="kr">let</span><span class="nv">s</span> [I1 [I2 [I3 I4]]]: E.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> simple_intropattern(I1) simple_intropattern(I2)
 simple_intropattern(I3) simple_intropattern(I4) simple_intropattern(I5)
 <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="kr">let</span><span class="nv">s</span> [I1 [I2 [I3 [I4 I5]]]]: E.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> simple_intropattern(I) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) :=
  <span class="kr">let</span><span class="nv">s</span> <span class="nv">I</span>: (&gt;&gt; E0 A1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> simple_intropattern(I) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) :=
  <span class="kr">let</span><span class="nv">s</span> <span class="nv">I</span>: (&gt;&gt; E0 A1 A2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> simple_intropattern(I) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) :=
  <span class="kr">let</span><span class="nv">s</span> <span class="nv">I</span>: (&gt;&gt; E0 A1 A2 A3).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> simple_intropattern(I) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) <span class="kp">constr</span>(A4) :=
  <span class="kr">let</span><span class="nv">s</span> <span class="nv">I</span>: (&gt;&gt; E0 A1 A2 A3 A4).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> simple_intropattern(I) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) <span class="kp">constr</span>(A4) <span class="kp">constr</span>(A5) :=
  <span class="kr">let</span><span class="nv">s</span> <span class="nv">I</span>: (&gt;&gt; E0 A1 A2 A3 A4 A5).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> simple_intropattern(I1) simple_intropattern(I2) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) :=
  <span class="kr">let</span><span class="nv">s</span> [I1 I2]: E0 A1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> simple_intropattern(I1) simple_intropattern(I2) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) :=
  <span class="kr">let</span><span class="nv">s</span> [I1 I2]: E0 A1 A2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> simple_intropattern(I1) simple_intropattern(I2) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) :=
  <span class="kr">let</span><span class="nv">s</span> [I1 I2]: E0 A1 A2 A3.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> simple_intropattern(I1) simple_intropattern(I2) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) <span class="kp">constr</span>(A4) :=
  <span class="kr">let</span><span class="nv">s</span> [I1 I2]: E0 A1 A2 A3 A4.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> simple_intropattern(I1) simple_intropattern(I2) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) <span class="kp">constr</span>(A4) <span class="kp">constr</span>(A5) :=
  <span class="kr">let</span><span class="nv">s</span> [I1 I2]: E0 A1 A2 A3 A4 A5.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [forwards H: (&gt;&gt; E0 E1 .. EN)] is short for</span>
<span class="sd">    [forwards H: (&gt;&gt; E0 E1 .. EN ___)].</span>
<span class="sd">    The arguments [Ei] can be wildcards [__] (except [E0]).</span>
<span class="sd">    [H] may be an introduction pattern, or a sequence of</span>
<span class="sd">    introduction pattern, or empty.</span>
<span class="sd">    Syntax [forwards H: E0 E1 .. EN] is also available. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">forwards_build_app_arg</span> Ei :=
  <span class="kr">let</span> <span class="nv">args</span> := list_boxer_of Ei <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">args</span> := (<span class="kp">eval</span> <span class="nb">simpl</span> <span class="kr">in</span> (args ++ ((boxer ___)::nil))) <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">args</span> := args_unfold_head_if_not_product args <span class="kr">in</span>
  args.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">forwards_then</span> Ei cont :=
  <span class="kr">let</span> <span class="nv">args</span> := forwards_build_app_arg Ei <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">args</span> := args_unfold_head_if_not_product_but_params args <span class="kr">in</span>
  build_app args cont.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;forwards&quot;</span> simple_intropattern(I) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(Ei) :=
  <span class="kr">let</span> <span class="nv">args</span> := forwards_build_app_arg Ei <span class="kr">in</span>
  <span class="kr">let</span><span class="nv">s</span> <span class="nv">I</span>: args.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;forwards&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="kr">let</span> <span class="nv">H</span> := <span class="kp">fresh</span> <span class="kr">in</span> forwards H: E.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;forwards&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) :=
  forwards: (&gt;&gt; E0 A1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;forwards&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) :=
  forwards: (&gt;&gt; E0 A1 A2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;forwards&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) :=
  forwards: (&gt;&gt; E0 A1 A2 A3).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;forwards&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) <span class="kp">constr</span>(A4) :=
  forwards: (&gt;&gt; E0 A1 A2 A3 A4).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;forwards&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) <span class="kp">constr</span>(A4) <span class="kp">constr</span>(A5) :=
  forwards: (&gt;&gt; E0 A1 A2 A3 A4 A5).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* --DEPRECATED syntax *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;forwards&quot;</span> simple_intropattern(I1) simple_intropattern(I2)
 <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  forwards [I1 I2]: E.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;forwards&quot;</span> simple_intropattern(I1) simple_intropattern(I2)
 simple_intropattern(I3) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  forwards [I1 [I2 I3]]: E.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;forwards&quot;</span> simple_intropattern(I1) simple_intropattern(I2)
 simple_intropattern(I3) simple_intropattern(I4) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  forwards [I1 [I2 [I3 I4]]]: E.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;forwards&quot;</span> simple_intropattern(I1) simple_intropattern(I2)
 simple_intropattern(I3) simple_intropattern(I4) simple_intropattern(I5)
 <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  forwards [I1 [I2 [I3 [I4 I5]]]]: E.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;forwards&quot;</span> simple_intropattern(I) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) :=
  forwards I: (&gt;&gt; E0 A1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;forwards&quot;</span> simple_intropattern(I) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) :=
  forwards I: (&gt;&gt; E0 A1 A2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;forwards&quot;</span> simple_intropattern(I) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) :=
  forwards I: (&gt;&gt; E0 A1 A2 A3).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;forwards&quot;</span> simple_intropattern(I) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) <span class="kp">constr</span>(A4) :=
  forwards I: (&gt;&gt; E0 A1 A2 A3 A4).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;forwards&quot;</span> simple_intropattern(I) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) <span class="kp">constr</span>(A4) <span class="kp">constr</span>(A5) :=
  forwards I: (&gt;&gt; E0 A1 A2 A3 A4 A5).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [forwards_nounfold I: E] is like [forwards I: E] but does not</span>
<span class="sd">    unfold the head constant of [E] if there is no visible quantification</span>
<span class="sd">    or hypothesis in [E]. It is meant to be used mainly by tactics. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;forwards_nounfold&quot;</span> simple_intropattern(I) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(Ei) :=
  <span class="kr">let</span> <span class="nv">args</span> := list_boxer_of Ei <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">args</span> := (<span class="kp">eval</span> <span class="nb">simpl</span> <span class="kr">in</span> (args ++ ((boxer ___)::nil))) <span class="kr">in</span>
  build_app args <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">R</span> =&gt; <span class="kr">let</span><span class="nv">s_base</span> <span class="nv">I</span> <span class="nv">R</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [forwards_nounfold_then E ltac:(fun K =&gt; ..)]</span>
<span class="sd">    is like [forwards: E] but it provides the resulting term</span>
<span class="sd">    to a continuation, under the name [K]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">forwards_nounfold_then</span> Ei cont :=
  <span class="kr">let</span> <span class="nv">args</span> := list_boxer_of Ei <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">args</span> := (<span class="kp">eval</span> <span class="nb">simpl</span> <span class="kr">in</span> (args ++ ((boxer ___)::nil))) <span class="kr">in</span>
  build_app args cont.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [applys (&gt;&gt; E0 E1 .. EN)] instantiates lemma [E0]</span>
<span class="sd">    on the arguments [Ei] (which may be wildcards [__]),</span>
<span class="sd">    and apply the resulting term to the current goal,</span>
<span class="sd">    using the tactic [applys] defined earlier on.</span>
<span class="sd">    [applys E0 E1 E2 .. EN] is also available. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">applys_build</span> Ei :=
  <span class="kr">let</span> <span class="nv">args</span> := list_boxer_of Ei <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">args</span> := args_unfold_head_if_not_product_but_params args <span class="kr">in</span>
  build_app args <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">R</span> =&gt;
   <span class="kp">first</span> [ <span class="nb">apply</span> R | <span class="nb">eapply</span> R | rapply R ]).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">applys_base</span> E :=
  <span class="kr">match</span> <span class="kp">type of</span> E <span class="kr">with</span>
  | list Boxer =&gt; applys_build E
  | _ =&gt; <span class="kp">first</span> [ rapply E | applys_build E ]
  <span class="kr">end</span>; fast_rm_inside E.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;applys&quot;</span> <span class="kp">constr</span>(E) :=
  applys_base E.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;applys&quot;</span> <span class="kp">constr</span>(E0) <span class="kp">constr</span>(A1) :=
  applys (&gt;&gt; E0 A1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;applys&quot;</span> <span class="kp">constr</span>(E0) <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) :=
  applys (&gt;&gt; E0 A1 A2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;applys&quot;</span> <span class="kp">constr</span>(E0) <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) :=
  applys (&gt;&gt; E0 A1 A2 A3).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;applys&quot;</span> <span class="kp">constr</span>(E0) <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) <span class="kp">constr</span>(A4) :=
  applys (&gt;&gt; E0 A1 A2 A3 A4).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;applys&quot;</span> <span class="kp">constr</span>(E0) <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) <span class="kp">constr</span>(A4) <span class="kp">constr</span>(A5) :=
  applys (&gt;&gt; E0 A1 A2 A3 A4 A5).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [fapplys (&gt;&gt; E0 E1 .. EN)] instantiates lemma [E0]</span>
<span class="sd">    on the arguments [Ei] and on the argument [___] meaning</span>
<span class="sd">    that all evars should be explicitly instantiated,</span>
<span class="sd">    and apply the resulting term to the current goal.</span>
<span class="sd">    [fapplys E0 E1 E2 .. EN] is also available. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">fapplys_build</span> Ei :=
  <span class="kr">let</span> <span class="nv">args</span> := list_boxer_of Ei <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">args</span> := (<span class="kp">eval</span> <span class="nb">simpl</span> <span class="kr">in</span> (args ++ ((boxer ___)::nil))) <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">args</span> := args_unfold_head_if_not_product_but_params args <span class="kr">in</span>
  build_app args <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">R</span> =&gt; <span class="nb">apply</span> R).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;fapplys&quot;</span> <span class="kp">constr</span>(E0) :=
  <span class="kr">match</span> <span class="kp">type of</span> E0 <span class="kr">with</span>
  | list Boxer =&gt; fapplys_build E0
  | _ =&gt; fapplys_build (&gt;&gt; E0)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;fapplys&quot;</span> <span class="kp">constr</span>(E0) <span class="kp">constr</span>(A1) :=
  fapplys (&gt;&gt; E0 A1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;fapplys&quot;</span> <span class="kp">constr</span>(E0) <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) :=
  fapplys (&gt;&gt; E0 A1 A2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;fapplys&quot;</span> <span class="kp">constr</span>(E0) <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) :=
  fapplys (&gt;&gt; E0 A1 A2 A3).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;fapplys&quot;</span> <span class="kp">constr</span>(E0) <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) <span class="kp">constr</span>(A4) :=
  fapplys (&gt;&gt; E0 A1 A2 A3 A4).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;fapplys&quot;</span> <span class="kp">constr</span>(E0) <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) <span class="kp">constr</span>(A4) <span class="kp">constr</span>(A5) :=
  fapplys (&gt;&gt; E0 A1 A2 A3 A4 A5).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [specializes H (&gt;&gt; E1 E2 .. EN)] will instantiate hypothesis [H]</span>
<span class="sd">    on the arguments [Ei] (which may be wildcards [__]). If the last</span>
<span class="sd">    argument [EN] is [___] (triple-underscore), then all arguments of</span>
<span class="sd">    [H] get instantiated. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">specializes_build</span> H Ei :=
  <span class="kr">let</span> <span class="nv">H&#39;</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span> <span class="nb">rename</span> H <span class="nb">into</span> H&#39;;
  <span class="kr">let</span> <span class="nv">args</span> := list_boxer_of Ei <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">args</span> := <span class="kp">constr</span>:((boxer H&#39;)::args) <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">args</span> := args_unfold_head_if_not_product args <span class="kr">in</span>
  build_app args <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">R</span> =&gt; <span class="kr">let</span><span class="nv">s</span> <span class="nv">H</span>: R);
  <span class="nb">clear</span> H&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">specializes_base</span> H Ei :=
  specializes_build H Ei; fast_rm_inside Ei.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;specializes&quot;</span> hyp(H) :=
  specializes_base H (___).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;specializes&quot;</span> hyp(H) <span class="kp">constr</span>(A) :=
  specializes_base H A.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;specializes&quot;</span> hyp(H) <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) :=
  specializes H (&gt;&gt; A1 A2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;specializes&quot;</span> hyp(H) <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) :=
  specializes H (&gt;&gt; A1 A2 A3).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;specializes&quot;</span> hyp(H) <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) <span class="kp">constr</span>(A4) :=
  specializes H (&gt;&gt; A1 A2 A3 A4).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;specializes&quot;</span> hyp(H) <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) <span class="kp">constr</span>(A4) <span class="kp">constr</span>(A5) :=
  specializes H (&gt;&gt; A1 A2 A3 A4 A5).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [specializes_vars H] is equivalent to [specializes H __ .. __]</span>
<span class="sd">    with as many double underscore as the number of dependent arguments</span>
<span class="sd">    visible from the type of [H]. Note that no unfolding is currently</span>
<span class="sd">    being performed (this behavior might change in the future).</span>
<span class="sd">    The current implementation is restricted to the case where</span>
<span class="sd">    [H] is an existing hypothesis -- Note: this could be generalized. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">specializes_var_base</span> H :=
  <span class="kr">match</span> <span class="kp">type of</span> H <span class="kr">with</span>
  | <span class="nl">?P</span> -&gt; <span class="nl">?Q</span> =&gt; <span class="kp">fail</span> <span class="mi">1</span>
  | <span class="kr">forall</span> <span class="nv">_</span>:_, _ =&gt; specializes H __
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">specializes_vars_base</span> H :=
  <span class="kp">repeat</span> (specializes_var_base H).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;specializes_var&quot;</span> hyp(H) :=
  specializes_var_base H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;specializes_vars&quot;</span> hyp(H) :=
  specializes_vars_base H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Experimental Tactics for Application *)</span>

<span class="sd">(** [fapply] is a version of [apply] based on [forwards]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;fapply&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="kr">let</span> <span class="nv">H</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span> forwards H: E;
  <span class="kp">first</span> [ <span class="nb">apply</span> H | <span class="nb">eapply</span> H | rapply H | <span class="nb">hnf</span>; <span class="nb">apply</span> H
        | <span class="nb">hnf</span>; <span class="nb">eapply</span> H | applys H ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">   <span class="c">(* Note: is applys redundant with rapply ? *)</span>

<span class="sd">(** [sapply] stands for &quot;super apply&quot;. It tries</span>
<span class="sd">    [apply], [eapply], [applys] and [fapply],</span>
<span class="sd">    and also tries to head-normalize the goal first. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;sapply&quot;</span> <span class="kp">constr</span>(H) :=
  <span class="kp">first</span> [ <span class="nb">apply</span> H | <span class="nb">eapply</span> H | rapply H | applys H
        | <span class="nb">hnf</span>; <span class="nb">apply</span> H | <span class="nb">hnf</span>; <span class="nb">eapply</span> H | <span class="nb">hnf</span>; applys H
        | fapply H ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Adding Assumptions *)</span>

<span class="sd">(** [lets_simpl H: E] is the same as [lets H: E] excepts that it</span>
<span class="sd">    calls [simpl] on the hypothesis H.</span>
<span class="sd">    [lets_simpl: E] is also provided. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets_simpl&quot;</span> <span class="kn">ident</span>(H) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="kr">let</span><span class="nv">s</span> <span class="nv">H</span>: E; <span class="kp">try</span> <span class="nb">simpl</span> <span class="kr">in</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets_simpl&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(T) :=
  <span class="kr">let</span> <span class="nv">H</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span> <span class="kr">let</span><span class="nv">s_simpl</span> <span class="nv">H</span>: T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [lets_hnf H: E] is the same as [lets H: E] excepts that it</span>
<span class="sd">    calls [hnf] to set the definition in head normal form.</span>
<span class="sd">    [lets_hnf: E] is also provided. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets_hnf&quot;</span> <span class="kn">ident</span>(H) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="kr">let</span><span class="nv">s</span> <span class="nv">H</span>: E; <span class="nb">hnf</span> <span class="kr">in</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets_hnf&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(T) :=
  <span class="kr">let</span> <span class="nv">H</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span> <span class="kr">let</span><span class="nv">s_hnf</span> <span class="nv">H</span>: T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [puts X: E] is a synonymous for [pose (X := E)].</span>
<span class="sd">    Alternative syntax is [puts: E]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;puts&quot;</span> <span class="kn">ident</span>(X) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="nb">pose</span> (X := E).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;puts&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="kr">let</span> <span class="nv">X</span> := <span class="kp">fresh</span> <span class="s2">&quot;X&quot;</span> <span class="kr">in</span> <span class="nb">pose</span> (X := E).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Application of Tautologies *)</span>

<span class="sd">(** [logic E], where [E] is a fact, is equivalent to</span>
<span class="sd">    [assert H:E; [tauto | eapply H; clear H]]. It is useful for instance</span>
<span class="sd">    to prove a conjunction [A /\ B] by showing first [A] and then [A -&gt; B],</span>
<span class="sd">    through the command [logic (foral A B, A -&gt; (A -&gt; B) -&gt; A /\ B)] *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">logic_base</span> E cont :=
  <span class="nb">assert</span> (H:E); [ cont tt | <span class="nb">eapply</span> H; <span class="nb">clear</span> H ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;logic&quot;</span> <span class="kp">constr</span>(E) :=
  logic_base E <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="bp">tauto</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Application Modulo Equalities *)</span>

<span class="sd">(** The tactic [equates] replaces a goal of the form</span>
<span class="sd">    [P x y z] with a goal of the form [P x ?a z] and a</span>
<span class="sd">    subgoal [?a = y]. The introduction of the evar [?a] makes</span>
<span class="sd">    it possible to apply lemmas that would not apply to the</span>
<span class="sd">    original goal, for example a lemma of the form</span>
<span class="sd">    [forall n m, P n n m], because [x] and [y] might be equal</span>
<span class="sd">    but not convertible.</span>

<span class="sd">    Usage is [equates i1 ... ik], where the indices are the</span>
<span class="sd">    positions of the arguments to be replaced by evars,</span>
<span class="sd">    counting from the right-hand side. If [0] is given as</span>
<span class="sd">    argument, then the entire goal is replaced by an evar. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">equatesLemma</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variables</span> (<span class="nv">A0</span> <span class="nv">A1</span> : <span class="kt">Type</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variables</span> (<span class="nv">A2</span> : <span class="kr">forall</span> (<span class="nv">x1</span> : A1), <span class="kt">Type</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variables</span> (<span class="nv">A3</span> : <span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1), <span class="kt">Type</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variables</span> (<span class="nv">A4</span> : <span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2), <span class="kt">Type</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variables</span> (<span class="nv">A5</span> : <span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2) (<span class="nv">x4</span> : A4 x3), <span class="kt">Type</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variables</span> (<span class="nv">A6</span> : <span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2) (<span class="nv">x4</span> : A4 x3) (<span class="nv">x5</span> : A5 x4), <span class="kt">Type</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk4"><span class="kn">Lemma</span> <span class="nf">equates_0</span> : <span class="kr">forall</span> (<span class="nv">P</span> <span class="nv">Q</span>:<span class="kt">Prop</span>),
  P -&gt; P = Q -&gt; Q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A0, A1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>A1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x1</span> : A1, A2 x1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A4</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1), A3 x2 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A5</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2),
A4 x3 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A6</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2)
  (<span class="nv">x4</span> : A4 x3), A5 x4 -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>, P -&gt; P = Q -&gt; Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk5"><span class="kn">Proof using</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A0, A1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>A1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x1</span> : A1, A2 x1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A4</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1), A3 x2 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A5</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2),
A4 x3 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A6</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2)
  (<span class="nv">x4</span> : A4 x3), A5 x4 -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>, P -&gt; P = Q -&gt; Q</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk6"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A0, A1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>A1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x1</span> : A1, A2 x1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A4</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1), A3 x2 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A5</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2),
A4 x3 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A6</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2)
  (<span class="nv">x4</span> : A4 x3), A5 x4 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P = Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk7"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A0, A1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>A1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x1</span> : A1, A2 x1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A4</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1), A3 x2 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A5</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2),
A4 x3 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A6</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2)
  (<span class="nv">x4</span> : A4 x3), A5 x4 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk8"><span class="kn">Lemma</span> <span class="nf">equates_1</span> :
  <span class="kr">forall</span> (<span class="nv">P</span>:A0-&gt;<span class="kt">Prop</span>) <span class="nv">x1</span> <span class="nv">y1</span>,
  P y1 -&gt; x1 = y1 -&gt; P x1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A0, A1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>A1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x1</span> : A1, A2 x1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A4</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1), A3 x2 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A5</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2),
A4 x3 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A6</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2)
  (<span class="nv">x4</span> : A4 x3), A5 x4 -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">P</span> : A0 -&gt; <span class="kt">Prop</span>) (<span class="nv">x1</span> <span class="nv">y1</span> : A0),
P y1 -&gt; x1 = y1 -&gt; P x1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk9"><span class="kn">Proof using</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A0, A1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>A1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x1</span> : A1, A2 x1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A4</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1), A3 x2 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A5</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2),
A4 x3 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A6</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2)
  (<span class="nv">x4</span> : A4 x3), A5 x4 -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">P</span> : A0 -&gt; <span class="kt">Prop</span>) (<span class="nv">x1</span> <span class="nv">y1</span> : A0),
P y1 -&gt; x1 = y1 -&gt; P x1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chka"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A0, A1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>A1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x1</span> : A1, A2 x1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A4</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1), A3 x2 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A5</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2),
A4 x3 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A6</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2)
  (<span class="nv">x4</span> : A4 x3), A5 x4 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A0 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x1, y1</var><span class="hyp-type"><b>: </b><span>A0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P y1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>x1 = y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P x1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chkb"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A0, A1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>A1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x1</span> : A1, A2 x1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A4</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1), A3 x2 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A5</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2),
A4 x3 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A6</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2)
  (<span class="nv">x4</span> : A4 x3), A5 x4 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A0 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>A0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P y1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chkc"><span class="kn">Lemma</span> <span class="nf">equates_2</span> :
  <span class="kr">forall</span> <span class="nv">y1</span> (<span class="nv">P</span>:A0-&gt;<span class="kr">forall</span>(<span class="nv">x1</span>:A1),<span class="kt">Prop</span>) <span class="nv">x1</span> <span class="nv">x2</span>,
  P y1 x2 -&gt; x1 = y1 -&gt; P x1 x2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A0, A1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>A1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x1</span> : A1, A2 x1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A4</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1), A3 x2 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A5</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2),
A4 x3 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A6</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2)
  (<span class="nv">x4</span> : A4 x3), A5 x4 -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">y1</span> : A0) (<span class="nv">P</span> : A0 -&gt; A1 -&gt; <span class="kt">Prop</span>) (<span class="nv">x1</span> : A0)
  (<span class="nv">x2</span> : A1), P y1 x2 -&gt; x1 = y1 -&gt; P x1 x2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chkd"><span class="kn">Proof using</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A0, A1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>A1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x1</span> : A1, A2 x1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A4</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1), A3 x2 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A5</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2),
A4 x3 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A6</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2)
  (<span class="nv">x4</span> : A4 x3), A5 x4 -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">y1</span> : A0) (<span class="nv">P</span> : A0 -&gt; A1 -&gt; <span class="kt">Prop</span>) (<span class="nv">x1</span> : A0)
  (<span class="nv">x2</span> : A1), P y1 x2 -&gt; x1 = y1 -&gt; P x1 x2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chke"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A0, A1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>A1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x1</span> : A1, A2 x1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A4</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1), A3 x2 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A5</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2),
A4 x3 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A6</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2)
  (<span class="nv">x4</span> : A4 x3), A5 x4 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>A0</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A0 -&gt; A1 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x1</var><span class="hyp-type"><b>: </b><span>A0</span></span></span><br><span><var>x2</var><span class="hyp-type"><b>: </b><span>A1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P y1 x2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>x1 = y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P x1 x2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chkf"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A0, A1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>A1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x1</span> : A1, A2 x1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A4</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1), A3 x2 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A5</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2),
A4 x3 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A6</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2)
  (<span class="nv">x4</span> : A4 x3), A5 x4 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>A0</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A0 -&gt; A1 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x2</var><span class="hyp-type"><b>: </b><span>A1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P y1 x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P y1 x2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk10"><span class="kn">Lemma</span> <span class="nf">equates_3</span> :
  <span class="kr">forall</span> <span class="nv">y1</span> (<span class="nv">P</span>:A0-&gt;<span class="kr">forall</span>(<span class="nv">x1</span>:A1)(<span class="nv">x2</span>:A2 x1),<span class="kt">Prop</span>) <span class="nv">x1</span> <span class="nv">x2</span> <span class="nv">x3</span>,
  P y1 x2 x3 -&gt; x1 = y1 -&gt; P x1 x2 x3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A0, A1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>A1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x1</span> : A1, A2 x1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A4</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1), A3 x2 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A5</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2),
A4 x3 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A6</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2)
  (<span class="nv">x4</span> : A4 x3), A5 x4 -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">y1</span> : A0)
  (<span class="nv">P</span> : A0 -&gt; <span class="kr">forall</span> <span class="nv">x1</span> : A1, A2 x1 -&gt; <span class="kt">Prop</span>) (<span class="nv">x1</span> : A0)
  (<span class="nv">x2</span> : A1) (<span class="nv">x3</span> : A2 x2),
P y1 x2 x3 -&gt; x1 = y1 -&gt; P x1 x2 x3</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk11"><span class="kn">Proof using</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A0, A1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>A1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x1</span> : A1, A2 x1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A4</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1), A3 x2 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A5</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2),
A4 x3 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A6</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2)
  (<span class="nv">x4</span> : A4 x3), A5 x4 -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">y1</span> : A0)
  (<span class="nv">P</span> : A0 -&gt; <span class="kr">forall</span> <span class="nv">x1</span> : A1, A2 x1 -&gt; <span class="kt">Prop</span>) (<span class="nv">x1</span> : A0)
  (<span class="nv">x2</span> : A1) (<span class="nv">x3</span> : A2 x2),
P y1 x2 x3 -&gt; x1 = y1 -&gt; P x1 x2 x3</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk12"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A0, A1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>A1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x1</span> : A1, A2 x1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A4</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1), A3 x2 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A5</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2),
A4 x3 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A6</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2)
  (<span class="nv">x4</span> : A4 x3), A5 x4 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>A0</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A0 -&gt; <span class="kr">forall</span> <span class="nv">x1</span> : A1, A2 x1 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x1</var><span class="hyp-type"><b>: </b><span>A0</span></span></span><br><span><var>x2</var><span class="hyp-type"><b>: </b><span>A1</span></span></span><br><span><var>x3</var><span class="hyp-type"><b>: </b><span>A2 x2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P y1 x2 x3</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>x1 = y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P x1 x2 x3</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk13"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A0, A1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>A1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x1</span> : A1, A2 x1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A4</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1), A3 x2 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A5</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2),
A4 x3 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A6</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2)
  (<span class="nv">x4</span> : A4 x3), A5 x4 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>A0</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A0 -&gt; <span class="kr">forall</span> <span class="nv">x1</span> : A1, A2 x1 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x2</var><span class="hyp-type"><b>: </b><span>A1</span></span></span><br><span><var>x3</var><span class="hyp-type"><b>: </b><span>A2 x2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P y1 x2 x3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P y1 x2 x3</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk14"><span class="kn">Lemma</span> <span class="nf">equates_4</span> :
  <span class="kr">forall</span> <span class="nv">y1</span> (<span class="nv">P</span>:A0-&gt;<span class="kr">forall</span>(<span class="nv">x1</span>:A1)(<span class="nv">x2</span>:A2 x1)(<span class="nv">x3</span>:A3 x2),<span class="kt">Prop</span>) <span class="nv">x1</span> <span class="nv">x2</span> <span class="nv">x3</span> <span class="nv">x4</span>,
  P y1 x2 x3 x4 -&gt; x1 = y1 -&gt; P x1 x2 x3 x4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A0, A1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>A1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x1</span> : A1, A2 x1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A4</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1), A3 x2 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A5</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2),
A4 x3 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A6</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2)
  (<span class="nv">x4</span> : A4 x3), A5 x4 -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">y1</span> : A0)
  (<span class="nv">P</span> : A0 -&gt;
       <span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1), A3 x2 -&gt; <span class="kt">Prop</span>)
  (<span class="nv">x1</span> : A0) (<span class="nv">x2</span> : A1) (<span class="nv">x3</span> : A2 x2) (<span class="nv">x4</span> : A3 x3),
P y1 x2 x3 x4 -&gt; x1 = y1 -&gt; P x1 x2 x3 x4</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk15"><span class="kn">Proof using</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A0, A1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>A1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x1</span> : A1, A2 x1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A4</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1), A3 x2 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A5</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2),
A4 x3 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A6</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2)
  (<span class="nv">x4</span> : A4 x3), A5 x4 -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">y1</span> : A0)
  (<span class="nv">P</span> : A0 -&gt;
       <span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1), A3 x2 -&gt; <span class="kt">Prop</span>)
  (<span class="nv">x1</span> : A0) (<span class="nv">x2</span> : A1) (<span class="nv">x3</span> : A2 x2) (<span class="nv">x4</span> : A3 x3),
P y1 x2 x3 x4 -&gt; x1 = y1 -&gt; P x1 x2 x3 x4</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk16"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A0, A1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>A1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x1</span> : A1, A2 x1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A4</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1), A3 x2 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A5</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2),
A4 x3 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A6</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2)
  (<span class="nv">x4</span> : A4 x3), A5 x4 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>A0</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A0 -&gt; <span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1), A3 x2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x1</var><span class="hyp-type"><b>: </b><span>A0</span></span></span><br><span><var>x2</var><span class="hyp-type"><b>: </b><span>A1</span></span></span><br><span><var>x3</var><span class="hyp-type"><b>: </b><span>A2 x2</span></span></span><br><span><var>x4</var><span class="hyp-type"><b>: </b><span>A3 x3</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P y1 x2 x3 x4</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>x1 = y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P x1 x2 x3 x4</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk17"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A0, A1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>A1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x1</span> : A1, A2 x1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A4</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1), A3 x2 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A5</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2),
A4 x3 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A6</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2)
  (<span class="nv">x4</span> : A4 x3), A5 x4 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>A0</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A0 -&gt; <span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1), A3 x2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x2</var><span class="hyp-type"><b>: </b><span>A1</span></span></span><br><span><var>x3</var><span class="hyp-type"><b>: </b><span>A2 x2</span></span></span><br><span><var>x4</var><span class="hyp-type"><b>: </b><span>A3 x3</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P y1 x2 x3 x4</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P y1 x2 x3 x4</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk18"><span class="kn">Lemma</span> <span class="nf">equates_5</span> :
  <span class="kr">forall</span> <span class="nv">y1</span> (<span class="nv">P</span>:A0-&gt;<span class="kr">forall</span>(<span class="nv">x1</span>:A1)(<span class="nv">x2</span>:A2 x1)(<span class="nv">x3</span>:A3 x2)(<span class="nv">x4</span>:A4 x3),<span class="kt">Prop</span>) <span class="nv">x1</span> <span class="nv">x2</span> <span class="nv">x3</span> <span class="nv">x4</span> <span class="nv">x5</span>,
  P y1 x2 x3 x4 x5 -&gt; x1 = y1 -&gt; P x1 x2 x3 x4 x5.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A0, A1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>A1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x1</span> : A1, A2 x1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A4</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1), A3 x2 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A5</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2),
A4 x3 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A6</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2)
  (<span class="nv">x4</span> : A4 x3), A5 x4 -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">y1</span> : A0)
  (<span class="nv">P</span> : A0 -&gt;
       <span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2),
       A4 x3 -&gt; <span class="kt">Prop</span>) (<span class="nv">x1</span> : A0) (<span class="nv">x2</span> : A1) (<span class="nv">x3</span> : A2 x2)
  (<span class="nv">x4</span> : A3 x3) (<span class="nv">x5</span> : A4 x4),
P y1 x2 x3 x4 x5 -&gt; x1 = y1 -&gt; P x1 x2 x3 x4 x5</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk19"><span class="kn">Proof using</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A0, A1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>A1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x1</span> : A1, A2 x1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A4</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1), A3 x2 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A5</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2),
A4 x3 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A6</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2)
  (<span class="nv">x4</span> : A4 x3), A5 x4 -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">y1</span> : A0)
  (<span class="nv">P</span> : A0 -&gt;
       <span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2),
       A4 x3 -&gt; <span class="kt">Prop</span>) (<span class="nv">x1</span> : A0) (<span class="nv">x2</span> : A1) (<span class="nv">x3</span> : A2 x2)
  (<span class="nv">x4</span> : A3 x3) (<span class="nv">x5</span> : A4 x4),
P y1 x2 x3 x4 x5 -&gt; x1 = y1 -&gt; P x1 x2 x3 x4 x5</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk1a"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A0, A1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>A1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x1</span> : A1, A2 x1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A4</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1), A3 x2 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A5</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2),
A4 x3 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A6</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2)
  (<span class="nv">x4</span> : A4 x3), A5 x4 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>A0</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A0 -&gt;
<span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2),
A4 x3 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x1</var><span class="hyp-type"><b>: </b><span>A0</span></span></span><br><span><var>x2</var><span class="hyp-type"><b>: </b><span>A1</span></span></span><br><span><var>x3</var><span class="hyp-type"><b>: </b><span>A2 x2</span></span></span><br><span><var>x4</var><span class="hyp-type"><b>: </b><span>A3 x3</span></span></span><br><span><var>x5</var><span class="hyp-type"><b>: </b><span>A4 x4</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P y1 x2 x3 x4 x5</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>x1 = y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P x1 x2 x3 x4 x5</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk1b"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A0, A1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>A1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x1</span> : A1, A2 x1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A4</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1), A3 x2 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A5</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2),
A4 x3 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A6</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2)
  (<span class="nv">x4</span> : A4 x3), A5 x4 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>A0</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A0 -&gt;
<span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2),
A4 x3 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x2</var><span class="hyp-type"><b>: </b><span>A1</span></span></span><br><span><var>x3</var><span class="hyp-type"><b>: </b><span>A2 x2</span></span></span><br><span><var>x4</var><span class="hyp-type"><b>: </b><span>A3 x3</span></span></span><br><span><var>x5</var><span class="hyp-type"><b>: </b><span>A4 x4</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P y1 x2 x3 x4 x5</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P y1 x2 x3 x4 x5</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk1c"><span class="kn">Lemma</span> <span class="nf">equates_6</span> :
  <span class="kr">forall</span> <span class="nv">y1</span> (<span class="nv">P</span>:A0-&gt;<span class="kr">forall</span>(<span class="nv">x1</span>:A1)(<span class="nv">x2</span>:A2 x1)(<span class="nv">x3</span>:A3 x2)(<span class="nv">x4</span>:A4 x3)(<span class="nv">x5</span>:A5 x4),<span class="kt">Prop</span>)
  <span class="nv">x1</span> <span class="nv">x2</span> <span class="nv">x3</span> <span class="nv">x4</span> <span class="nv">x5</span> <span class="nv">x6</span>,
  P y1 x2 x3 x4 x5 x6 -&gt; x1 = y1 -&gt; P x1 x2 x3 x4 x5 x6.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A0, A1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>A1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x1</span> : A1, A2 x1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A4</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1), A3 x2 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A5</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2),
A4 x3 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A6</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2)
  (<span class="nv">x4</span> : A4 x3), A5 x4 -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">y1</span> : A0)
  (<span class="nv">P</span> : A0 -&gt;
       <span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2)
         (<span class="nv">x4</span> : A4 x3), A5 x4 -&gt; <span class="kt">Prop</span>) (<span class="nv">x1</span> : A0)
  (<span class="nv">x2</span> : A1) (<span class="nv">x3</span> : A2 x2) (<span class="nv">x4</span> : A3 x3) (<span class="nv">x5</span> : A4 x4)
  (<span class="nv">x6</span> : A5 x5),
P y1 x2 x3 x4 x5 x6 -&gt; x1 = y1 -&gt; P x1 x2 x3 x4 x5 x6</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk1d"><span class="kn">Proof using</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A0, A1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>A1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x1</span> : A1, A2 x1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A4</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1), A3 x2 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A5</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2),
A4 x3 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A6</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2)
  (<span class="nv">x4</span> : A4 x3), A5 x4 -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">y1</span> : A0)
  (<span class="nv">P</span> : A0 -&gt;
       <span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2)
         (<span class="nv">x4</span> : A4 x3), A5 x4 -&gt; <span class="kt">Prop</span>) (<span class="nv">x1</span> : A0)
  (<span class="nv">x2</span> : A1) (<span class="nv">x3</span> : A2 x2) (<span class="nv">x4</span> : A3 x3) (<span class="nv">x5</span> : A4 x4)
  (<span class="nv">x6</span> : A5 x5),
P y1 x2 x3 x4 x5 x6 -&gt; x1 = y1 -&gt; P x1 x2 x3 x4 x5 x6</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk1e"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A0, A1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>A1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x1</span> : A1, A2 x1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A4</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1), A3 x2 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A5</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2),
A4 x3 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A6</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2)
  (<span class="nv">x4</span> : A4 x3), A5 x4 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>A0</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A0 -&gt;
<span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2)
  (<span class="nv">x4</span> : A4 x3), A5 x4 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x1</var><span class="hyp-type"><b>: </b><span>A0</span></span></span><br><span><var>x2</var><span class="hyp-type"><b>: </b><span>A1</span></span></span><br><span><var>x3</var><span class="hyp-type"><b>: </b><span>A2 x2</span></span></span><br><span><var>x4</var><span class="hyp-type"><b>: </b><span>A3 x3</span></span></span><br><span><var>x5</var><span class="hyp-type"><b>: </b><span>A4 x4</span></span></span><br><span><var>x6</var><span class="hyp-type"><b>: </b><span>A5 x5</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P y1 x2 x3 x4 x5 x6</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>x1 = y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P x1 x2 x3 x4 x5 x6</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk1f"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A0, A1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A2</var><span class="hyp-type"><b>: </b><span>A1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x1</span> : A1, A2 x1 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A4</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1), A3 x2 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A5</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2),
A4 x3 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A6</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2)
  (<span class="nv">x4</span> : A4 x3), A5 x4 -&gt; <span class="kt">Type</span></span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>A0</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A0 -&gt;
<span class="kr">forall</span> (<span class="nv">x1</span> : A1) (<span class="nv">x2</span> : A2 x1) (<span class="nv">x3</span> : A3 x2)
  (<span class="nv">x4</span> : A4 x3), A5 x4 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x2</var><span class="hyp-type"><b>: </b><span>A1</span></span></span><br><span><var>x3</var><span class="hyp-type"><b>: </b><span>A2 x2</span></span></span><br><span><var>x4</var><span class="hyp-type"><b>: </b><span>A3 x3</span></span></span><br><span><var>x5</var><span class="hyp-type"><b>: </b><span>A4 x4</span></span></span><br><span><var>x6</var><span class="hyp-type"><b>: </b><span>A5 x5</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P y1 x2 x3 x4 x5 x6</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P y1 x2 x3 x4 x5 x6</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">equatesLemma</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">equates_lemma</span> n :=
  <span class="kr">match</span> number_to_nat n <span class="kr">with</span>
  | <span class="mi">0</span> =&gt; <span class="kp">constr</span>:(equates_0)
  | <span class="mi">1</span> =&gt; <span class="kp">constr</span>:(equates_1)
  | <span class="mi">2</span> =&gt; <span class="kp">constr</span>:(equates_2)
  | <span class="mi">3</span> =&gt; <span class="kp">constr</span>:(equates_3)
  | <span class="mi">4</span> =&gt; <span class="kp">constr</span>:(equates_4)
  | <span class="mi">5</span> =&gt; <span class="kp">constr</span>:(equates_5)
  | <span class="mi">6</span> =&gt; <span class="kp">constr</span>:(equates_6)
  | _ =&gt; <span class="kp">fail</span> <span class="mi">100</span> <span class="s2">&quot;equates tactic only support up to arity 6&quot;</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">equates_one</span> n :=
  <span class="kr">let</span> <span class="nv">L</span> := equates_lemma n <span class="kr">in</span>
  <span class="nb">eapply</span> L.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">equates_several</span> E cont :=
  <span class="kr">let</span> <span class="nv">all_pos</span> := <span class="kr">match</span> <span class="kp">type of</span> E <span class="kr">with</span>
    | List.list Boxer =&gt; <span class="kp">constr</span>:(E)
    | _ =&gt; <span class="kp">constr</span>:((boxer E)::nil)
    <span class="kr">end</span> <span class="kr">in</span>
  <span class="kr">let rec</span> <span class="nv">go</span> <span class="nv">pos</span> :=
     <span class="kr">match</span> pos <span class="kr">with</span>
     | nil =&gt; cont tt
     | (boxer <span class="nl">?n</span>)::<span class="nl">?pos&#39;</span> =&gt; equates_one n; [ <span class="kp">idtac</span>; go pos&#39; | ]
     <span class="kr">end</span> <span class="kr">in</span>
  go all_pos.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;equates&quot;</span> <span class="kp">constr</span>(E) :=
  equates_several E <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="kp">idtac</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;equates&quot;</span> <span class="kp">constr</span>(n1) <span class="kp">constr</span>(n2) :=
  equates (&gt;&gt; n1 n2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;equates&quot;</span> <span class="kp">constr</span>(n1) <span class="kp">constr</span>(n2) <span class="kp">constr</span>(n3) :=
  equates (&gt;&gt; n1 n2 n3).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;equates&quot;</span> <span class="kp">constr</span>(n1) <span class="kp">constr</span>(n2) <span class="kp">constr</span>(n3) <span class="kp">constr</span>(n4) :=
  equates (&gt;&gt; n1 n2 n3 n4).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [applys_eq H i1 .. iK] is the same as</span>
<span class="sd">    [equates i1 .. iK] followed by [applys H]</span>
<span class="sd">    on the first subgoal.</span>

<span class="sd">    DEPRECATED: use [applys_eq H] instead. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;applys_eq&quot;</span> <span class="kp">constr</span>(H) <span class="kp">constr</span>(E) :=
  equates_several E <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">_</span> =&gt; sapply H).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;applys_eq&quot;</span> <span class="kp">constr</span>(H) <span class="kp">constr</span>(n1) <span class="kp">constr</span>(n2) :=
  applys_eq H (&gt;&gt; n1 n2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;applys_eq&quot;</span> <span class="kp">constr</span>(H) <span class="kp">constr</span>(n1) <span class="kp">constr</span>(n2) <span class="kp">constr</span>(n3) :=
  applys_eq H (&gt;&gt; n1 n2 n3).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;applys_eq&quot;</span> <span class="kp">constr</span>(H) <span class="kp">constr</span>(n1) <span class="kp">constr</span>(n2) <span class="kp">constr</span>(n3) <span class="kp">constr</span>(n4) :=
  applys_eq H (&gt;&gt; n1 n2 n3 n4).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [applys_eq H] helps proving a goal of the form [P x1 .. xN]</span>
<span class="sd">    from an hypothesis [H] that concludes [P y1 .. yN], where the</span>
<span class="sd">    arguments [xi] and [yi] may or may not be convertible.</span>
<span class="sd">    Equalities are produced for all arguments that don&#39;t unify.</span>

<span class="sd">    The tactic invokes [equates] on all arguments, then calls</span>
<span class="sd">    [applys K], and attempts [reflexivity] on the side equalities. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk20"><span class="kn">Lemma</span> <span class="nf">applys_eq_init</span> : <span class="kr">forall</span> (<span class="nv">P</span> <span class="nv">Q</span>:<span class="kt">Prop</span>),
  P = Q -&gt;
  Q -&gt;
  P.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>, P = Q -&gt; Q -&gt; P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk21"><span class="kn">Proof using</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>, P = Q -&gt; Q -&gt; P</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk22"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P = Q</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk23"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk24"><span class="kn">Lemma</span> <span class="nf">applys_eq_step_dep</span> : <span class="kr">forall</span> <span class="nv">B</span> (<span class="nv">P</span> <span class="nv">Q</span>: (<span class="kr">forall</span> <span class="nv">A</span>, A-&gt;B)) (<span class="nv">T</span>:<span class="kt">Type</span>),
  P = Q -&gt;
  P T = Q T.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, A -&gt; B)
  (<span class="nv">T</span> : <span class="kt">Type</span>), P = Q -&gt; P T = Q T</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk25"><span class="kn">Proof using</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, A -&gt; B)
  (<span class="nv">T</span> : <span class="kt">Type</span>), P = Q -&gt; P T = Q T</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk26"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, A -&gt; B</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P = Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P T = Q T</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk27"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, A -&gt; B</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q T = Q T</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk28"><span class="kn">Lemma</span> <span class="nf">applys_eq_step</span> : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> (<span class="nv">P</span> <span class="nv">Q</span>:A-&gt;B) <span class="nv">x</span> <span class="nv">y</span>,
  P = Q -&gt;
  x = y -&gt;
  P x = Q y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">P</span> <span class="nv">Q</span> : A -&gt; B) (<span class="nv">x</span> <span class="nv">y</span> : A),
P = Q -&gt; x = y -&gt; P x = Q y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk29"><span class="kn">Proof using</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">P</span> <span class="nv">Q</span> : A -&gt; B) (<span class="nv">x</span> <span class="nv">y</span> : A),
P = Q -&gt; x = y -&gt; P x = Q y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk2a"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P = Q</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P x = Q y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk2b"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q y = Q y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">applys_eq_loop</span> tt :=
  <span class="kr">match goal with</span>
  | |- <span class="nl">?P</span> <span class="nl">?x</span> =&gt;
      <span class="kp">first</span> [ <span class="nb">eapply</span> applys_eq_step; [ applys_eq_loop tt | ]
            | <span class="nb">eapply</span> applys_eq_step_dep; applys_eq_loop tt ]
  | _ =&gt; <span class="bp">reflexivity</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">applys_eq_core</span> H :=
  <span class="nb">eapply</span> applys_eq_init;
  [ applys_eq_loop tt | applys H ];
  <span class="kp">try</span> <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;applys_eq&quot;</span> <span class="kp">constr</span>(H) :=
  applys_eq_core H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Absurd Goals *)</span>

<span class="sd">(** [false_goal] replaces any goal by the goal [False].</span>
<span class="sd">    Contrary to the tactic [false] (below), it does not try to do</span>
<span class="sd">    anything else *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;false_goal&quot;</span> :=
  <span class="nb">elimtype</span> <span class="kt">False</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [false_post] is the underlying tactic used to prove goals</span>
<span class="sd">    of the form [False]. In the default implementation, it proves</span>
<span class="sd">    the goal if the context contains [False] or an hypothesis of the</span>
<span class="sd">    form [C x1 .. xN  =  D y1 .. yM], or if the [congruence] tactic</span>
<span class="sd">    finds a proof of [x &lt;&gt; x] for some [x]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">false_post</span> :=
  <span class="kp">solve</span> [ <span class="bp">assumption</span> | <span class="bp">discriminate</span> | <span class="bp">congruence</span> ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [false] replaces any goal by the goal [False], and calls [false_post] *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;false&quot;</span> :=
  false_goal; <span class="kp">try</span> false_post.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [tryfalse] tries to solve a goal by contradiction, and leaves</span>
<span class="sd">    the goal unchanged if it cannot solve it.</span>
<span class="sd">    It is equivalent to [try solve \[ false \]]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;tryfalse&quot;</span> :=
  <span class="kp">try</span> <span class="kp">solve</span> [ false ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [false E] tries to exploit lemma [E] to prove the goal false.</span>
<span class="sd">    [false E1 .. EN] is equivalent to [false (&gt;&gt; E1 .. EN)],</span>
<span class="sd">    which tries to apply [applys (&gt;&gt; E1 .. EN)] and if it</span>
<span class="sd">    does not work then tries [forwards H: (&gt;&gt; E1 .. EN)]</span>
<span class="sd">    followed with [false] *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">false_then</span> E cont :=
  false_goal; <span class="kp">first</span>
  [ applys E; <span class="kp">idtac</span>
  | forwards_then E <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">M</span> =&gt;
      <span class="nb">pose</span> M; jauto_set_hyps; <span class="nb">intros</span>; false) ];
  cont tt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* Note: is [cont] needed? *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;false&quot;</span> <span class="kp">constr</span>(E) :=
  false_then E <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="kp">idtac</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;false&quot;</span> <span class="kp">constr</span>(E) <span class="kp">constr</span>(E1) :=
  false (&gt;&gt; E E1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;false&quot;</span> <span class="kp">constr</span>(E) <span class="kp">constr</span>(E1) <span class="kp">constr</span>(E2) :=
  false (&gt;&gt; E E1 E2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;false&quot;</span> <span class="kp">constr</span>(E) <span class="kp">constr</span>(E1) <span class="kp">constr</span>(E2) <span class="kp">constr</span>(E3) :=
  false (&gt;&gt; E E1 E2 E3).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;false&quot;</span> <span class="kp">constr</span>(E) <span class="kp">constr</span>(E1) <span class="kp">constr</span>(E2) <span class="kp">constr</span>(E3) <span class="kp">constr</span>(E4) :=
  false (&gt;&gt; E E1 E2 E3 E4).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [false_invert H] proves a goal if it absurd after</span>
<span class="sd">    calling [inversion H] and [false] *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">false_invert_for</span> H :=
  <span class="kr">let</span> <span class="nv">M</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span> <span class="nb">pose</span> (M := H); <span class="nb">inversion</span> H; false.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;false_invert&quot;</span> <span class="kp">constr</span>(H) :=
  <span class="kp">try</span> <span class="kp">solve</span> [ false_invert_for H | false ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [false_invert] proves any goal provided there is at least</span>
<span class="sd">    one hypothesis [H] in the context (or as a universally quantified</span>
<span class="sd">    hypothesis visible at the head of the goal) that can be proved absurd by calling</span>
<span class="sd">    [inversion H]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">false_invert_iter</span> :=
  <span class="kr">match goal with</span> H:_ |- _ =&gt;
    <span class="kp">solve</span> [ <span class="nb">inversion</span> H; false
          | <span class="nb">clear</span> H; false_invert_iter
          | <span class="kp">fail</span> <span class="mi">2</span> ] <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;false_invert&quot;</span> :=
  <span class="nb">intros</span>; <span class="kp">solve</span> [ false_invert_iter | false ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [tryfalse_invert H] and [tryfalse_invert] are like the</span>
<span class="sd">    above but leave the goal unchanged if they don&#39;t solve it. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;tryfalse_invert&quot;</span> <span class="kp">constr</span>(H) :=
  <span class="kp">try</span> (false_invert H).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;tryfalse_invert&quot;</span> :=
  <span class="kp">try</span> false_invert.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [false_neq_self_hyp] proves any goal if the context</span>
<span class="sd">    contains an hypothesis of the form [E &lt;&gt; E]. It is</span>
<span class="sd">    a restricted and optimized version of [false]. It is</span>
<span class="sd">    intended to be used by other tactics only. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">false_neq_self_hyp</span> :=
  <span class="kr">match goal with</span> H: <span class="nl">?x</span> &lt;&gt; <span class="nl">?x</span> |- _ =&gt;
    false_goal; <span class="nb">apply</span> H; <span class="bp">reflexivity</span> <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

<span class="c">(* ################################################################# *)</span>
<span class="sd">(** * Introduction and Generalization *)</span>

<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Introduction *)</span>

<span class="sd">(** [introv] is used to name only non-dependent hypothesis.</span>
<span class="sd"> - If [introv] is called on a goal of the form [forall x, H],</span>
<span class="sd">   it should introduce all the variables quantified with a</span>
<span class="sd">   [forall] at the head of the goal, but it does not introduce</span>
<span class="sd">   hypotheses that preceed an arrow constructor, like in [P -&gt; Q].</span>
<span class="sd"> - If [introv] is called on a goal that is not of the form</span>
<span class="sd">   [forall x, H] nor [P -&gt; Q], the tactic unfolds definitions</span>
<span class="sd">   until the goal takes the form [forall x, H] or [P -&gt; Q].</span>
<span class="sd">   If unfolding definitions does not produces a goal of this form,</span>
<span class="sd">   then the tactic [introv] does nothing at all. *)</span>

<span class="c">(* [introv_rec] introduces all visible variables.</span>
<span class="c">   It does not try to unfold any definition. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">introv_rec</span> :=
  <span class="kr">match goal with</span>
  | |- <span class="nl">?P</span> -&gt; <span class="nl">?Q</span> =&gt; <span class="kp">idtac</span>
  | |- <span class="kr">forall</span> <span class="nv">_</span>, _ =&gt; <span class="nb">intro</span>; introv_rec
  | |- _ =&gt; <span class="kp">idtac</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* [introv_noarg] forces the goal to be a [forall] or an [-&gt;],</span>
<span class="c">   and then calls [introv_rec] to introduces variables</span>
<span class="c">   (possibly none, in which case [introv] is the same as [hnf]).</span>
<span class="c">   If the goal is not a product, then it does not do anything. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">introv_noarg</span> :=
  <span class="kr">match goal with</span>
  | |- <span class="nl">?P</span> -&gt; <span class="nl">?Q</span> =&gt; <span class="kp">idtac</span>
  | |- <span class="kr">forall</span> <span class="nv">_</span>, _ =&gt; introv_rec
  | |- <span class="nl">?G</span> =&gt; <span class="nb">hnf</span>;
     <span class="kr">match goal with</span>
     | |- <span class="nl">?P</span> -&gt; <span class="nl">?Q</span> =&gt; <span class="kp">idtac</span>
     | |- <span class="kr">forall</span> <span class="nv">_</span>, _ =&gt; introv_rec
     <span class="kr">end</span>
  | |- _ =&gt; <span class="kp">idtac</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(* simpler yet perhaps less efficient imlementation *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">introv_noarg_not_optimized</span> :=
    <span class="nb">intro</span>; <span class="kr">match goal with</span> H:_|-_ =&gt; <span class="nb">revert</span> H <span class="kr">end</span>; introv_rec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* [introv_arg H] introduces one non-dependent hypothesis</span>
<span class="c">   under the name [H], after introducing the variables</span>
<span class="c">   quantified with a [forall] that preceeds this hypothesis.</span>
<span class="c">   This tactic fails if there does not exist a hypothesis</span>
<span class="c">   to be introduced. *)</span>
<span class="c">(* Note: __ in introv means &quot;intros&quot; *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">introv_arg</span> H :=
  <span class="nb">hnf</span>; <span class="kr">match goal with</span>
  | |- <span class="nl">?P</span> -&gt; <span class="nl">?Q</span> =&gt; <span class="nb">intros</span> H
  | |- <span class="kr">forall</span> <span class="nv">_</span>, _ =&gt; <span class="nb">intro</span>; introv_arg H
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* [introv I1 .. IN] iterates [introv Ik] *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;introv&quot;</span> :=
  introv_noarg.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;introv&quot;</span> simple_intropattern(I1) :=
  introv_arg I1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;introv&quot;</span> simple_intropattern(I1) simple_intropattern(I2) :=
  introv I1; introv I2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;introv&quot;</span> simple_intropattern(I1) simple_intropattern(I2)
 simple_intropattern(I3) :=
  introv I1; introv I2 I3.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;introv&quot;</span> simple_intropattern(I1) simple_intropattern(I2)
 simple_intropattern(I3) simple_intropattern(I4) :=
  introv I1; introv I2 I3 I4.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;introv&quot;</span> simple_intropattern(I1) simple_intropattern(I2)
 simple_intropattern(I3) simple_intropattern(I4) simple_intropattern(I5) :=
  introv I1; introv I2 I3 I4 I5.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;introv&quot;</span> simple_intropattern(I1) simple_intropattern(I2)
 simple_intropattern(I3) simple_intropattern(I4) simple_intropattern(I5)
 simple_intropattern(I6) :=
  introv I1; introv I2 I3 I4 I5 I6.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;introv&quot;</span> simple_intropattern(I1) simple_intropattern(I2)
 simple_intropattern(I3) simple_intropattern(I4) simple_intropattern(I5)
 simple_intropattern(I6) simple_intropattern(I7) :=
  introv I1; introv I2 I3 I4 I5 I6 I7.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;introv&quot;</span> simple_intropattern(I1) simple_intropattern(I2)
 simple_intropattern(I3) simple_intropattern(I4) simple_intropattern(I5)
 simple_intropattern(I6) simple_intropattern(I7) simple_intropattern(I8) :=
  introv I1; introv I2 I3 I4 I5 I6 I7 I8.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;introv&quot;</span> simple_intropattern(I1) simple_intropattern(I2)
 simple_intropattern(I3) simple_intropattern(I4) simple_intropattern(I5)
 simple_intropattern(I6) simple_intropattern(I7) simple_intropattern(I8)
 simple_intropattern(I9) :=
  introv I1; introv I2 I3 I4 I5 I6 I7 I8 I9.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;introv&quot;</span> simple_intropattern(I1) simple_intropattern(I2)
 simple_intropattern(I3) simple_intropattern(I4) simple_intropattern(I5)
 simple_intropattern(I6) simple_intropattern(I7) simple_intropattern(I8)
 simple_intropattern(I9) simple_intropattern(I10) :=
  introv I1; introv I2 I3 I4 I5 I6 I7 I8 I9 I10.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [intros_all] repeats [intro] as long as possible. Contrary to [intros],</span>
<span class="sd">    it unfolds any definition on the way. Remark that it also unfolds the</span>
<span class="sd">    definition of negation, so applying [intros_all] to a goal of the form</span>
<span class="sd">    [forall x, P x -&gt; ~Q] will introduce [x] and [P x] and [Q], and will</span>
<span class="sd">    leave [False] in the goal. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;intros_all&quot;</span> :=
  <span class="kp">repeat</span> <span class="nb">intro</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [intros_hnf] introduces an hypothesis and sets in head normal form *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;intro_hnf&quot;</span> :=
  <span class="nb">intro</span>; <span class="kr">match goal with</span> H: _ |- _ =&gt; <span class="nb">hnf</span> <span class="kr">in</span> H <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Introduction using [=&gt;] and [=&gt;&gt;] *)</span>

<span class="c">(* [=&gt; I1 .. IN] is the same as [intros I1 .. IN] *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">ltac_intros_post</span> := <span class="kp">idtac</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;=&gt;&quot;</span> :=
  <span class="nb">intros</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;=&gt;&quot;</span> simple_intropattern(I1) :=
  <span class="nb">intros</span> I1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;=&gt;&quot;</span> simple_intropattern(I1) simple_intropattern(I2) :=
  <span class="nb">intros</span> I1 I2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;=&gt;&quot;</span> simple_intropattern(I1) simple_intropattern(I2)
 simple_intropattern(I3) :=
  <span class="nb">intros</span> I1 I2 I3.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;=&gt;&quot;</span> simple_intropattern(I1) simple_intropattern(I2)
 simple_intropattern(I3) simple_intropattern(I4) :=
  <span class="nb">intros</span> I1 I2 I3 I4.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;=&gt;&quot;</span> simple_intropattern(I1) simple_intropattern(I2)
 simple_intropattern(I3) simple_intropattern(I4) simple_intropattern(I5) :=
  <span class="nb">intros</span> I1 I2 I3 I4 I5.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;=&gt;&quot;</span> simple_intropattern(I1) simple_intropattern(I2)
 simple_intropattern(I3) simple_intropattern(I4) simple_intropattern(I5)
 simple_intropattern(I6) :=
  <span class="nb">intros</span> I1 I2 I3 I4 I5 I6.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;=&gt;&quot;</span> simple_intropattern(I1) simple_intropattern(I2)
 simple_intropattern(I3) simple_intropattern(I4) simple_intropattern(I5)
 simple_intropattern(I6) simple_intropattern(I7) :=
  <span class="nb">intros</span> I1 I2 I3 I4 I5 I6 I7.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;=&gt;&quot;</span> simple_intropattern(I1) simple_intropattern(I2)
 simple_intropattern(I3) simple_intropattern(I4) simple_intropattern(I5)
 simple_intropattern(I6) simple_intropattern(I7) simple_intropattern(I8) :=
  <span class="nb">intros</span> I1 I2 I3 I4 I5 I6 I7 I8.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;=&gt;&quot;</span> simple_intropattern(I1) simple_intropattern(I2)
 simple_intropattern(I3) simple_intropattern(I4) simple_intropattern(I5)
 simple_intropattern(I6) simple_intropattern(I7) simple_intropattern(I8)
 simple_intropattern(I9) :=
  <span class="nb">intros</span> I1 I2 I3 I4 I5 I6 I7 I8 I9.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;=&gt;&quot;</span> simple_intropattern(I1) simple_intropattern(I2)
 simple_intropattern(I3) simple_intropattern(I4) simple_intropattern(I5)
 simple_intropattern(I6) simple_intropattern(I7) simple_intropattern(I8)
 simple_intropattern(I9) simple_intropattern(I10) :=
  <span class="nb">intros</span> I1 I2 I3 I4 I5 I6 I7 I8 I9 I10.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* [=&gt;&gt;] first introduces all non-dependent variables,</span>
<span class="c">   then behaves as [intros]. It unfolds the head of the goal using [hnf]</span>
<span class="c">   if there are not head visible quantifiers.</span>

<span class="c">   Remark: instances of [Inhab] are treated as non-dependent and</span>
<span class="c">   are introduced automatically. *)</span>

<span class="c">(* NOTE: this tactic is later redefined for supporting Inhab *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">intro_nondeps_aux_special_intro</span> G :=
  <span class="kp">fail</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">intro_nondeps_aux</span> is_already_hnf :=
  <span class="kr">match goal with</span>
  | |- (<span class="nl">?P</span> -&gt; <span class="nl">?Q</span>) =&gt; <span class="kp">idtac</span>
  | |- <span class="nl">?G</span> -&gt; _ =&gt; intro_nondeps_aux_special_intro G;
                  <span class="nb">intro</span>; intro_nondeps_aux true
  | |- (<span class="kr">forall</span> <span class="nv">_</span>,_) =&gt; <span class="nb">intros</span> ?; intro_nondeps_aux true
  | |- _ =&gt;
     <span class="kr">match</span> is_already_hnf <span class="kr">with</span>
     | true =&gt; <span class="kp">idtac</span>
     | false =&gt; <span class="nb">hnf</span>; intro_nondeps_aux true
     <span class="kr">end</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">intro_nondeps</span> tt := intro_nondeps_aux false.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;=&gt;&gt;&quot;</span> :=
  intro_nondeps tt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;=&gt;&gt;&quot;</span> simple_intropattern(I1) :=
  =&gt;&gt;; <span class="nb">intros</span> I1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;=&gt;&gt;&quot;</span> simple_intropattern(I1) simple_intropattern(I2) :=
  =&gt;&gt;; <span class="nb">intros</span> I1 I2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;=&gt;&gt;&quot;</span> simple_intropattern(I1) simple_intropattern(I2)
 simple_intropattern(I3) :=
  =&gt;&gt;; <span class="nb">intros</span> I1 I2 I3.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;=&gt;&gt;&quot;</span> simple_intropattern(I1) simple_intropattern(I2)
 simple_intropattern(I3) simple_intropattern(I4) :=
  =&gt;&gt;; <span class="nb">intros</span> I1 I2 I3 I4.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;=&gt;&gt;&quot;</span> simple_intropattern(I1) simple_intropattern(I2)
 simple_intropattern(I3) simple_intropattern(I4) simple_intropattern(I5) :=
  =&gt;&gt;; <span class="nb">intros</span> I1 I2 I3 I4 I5.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;=&gt;&gt;&quot;</span> simple_intropattern(I1) simple_intropattern(I2)
 simple_intropattern(I3) simple_intropattern(I4) simple_intropattern(I5)
 simple_intropattern(I6) :=
  =&gt;&gt;; <span class="nb">intros</span> I1 I2 I3 I4 I5 I6.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;=&gt;&gt;&quot;</span> simple_intropattern(I1) simple_intropattern(I2)
 simple_intropattern(I3) simple_intropattern(I4) simple_intropattern(I5)
 simple_intropattern(I6) simple_intropattern(I7) :=
  =&gt;&gt;; <span class="nb">intros</span> I1 I2 I3 I4 I5 I6 I7.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;=&gt;&gt;&quot;</span> simple_intropattern(I1) simple_intropattern(I2)
 simple_intropattern(I3) simple_intropattern(I4) simple_intropattern(I5)
 simple_intropattern(I6) simple_intropattern(I7) simple_intropattern(I8) :=
  =&gt;&gt;; <span class="nb">intros</span> I1 I2 I3 I4 I5 I6 I7 I8.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;=&gt;&gt;&quot;</span> simple_intropattern(I1) simple_intropattern(I2)
 simple_intropattern(I3) simple_intropattern(I4) simple_intropattern(I5)
 simple_intropattern(I6) simple_intropattern(I7) simple_intropattern(I8)
 simple_intropattern(I9) :=
  =&gt;&gt;; <span class="nb">intros</span> I1 I2 I3 I4 I5 I6 I7 I8 I9.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;=&gt;&gt;&quot;</span> simple_intropattern(I1) simple_intropattern(I2)
 simple_intropattern(I3) simple_intropattern(I4) simple_intropattern(I5)
 simple_intropattern(I6) simple_intropattern(I7) simple_intropattern(I8)
 simple_intropattern(I9) simple_intropattern(I10) :=
  =&gt;&gt;; <span class="nb">intros</span> I1 I2 I3 I4 I5 I6 I7 I8 I9 I10.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Generalization *)</span>

<span class="sd">(** [gen X1 .. XN] is a shorthand for calling [generalize dependent]</span>
<span class="sd">    successively on variables [XN]...[X1]. Note that the variables</span>
<span class="sd">    are generalized in reverse order, following the convention of</span>
<span class="sd">    the [generalize] tactic: it means that [X1] will be the first</span>
<span class="sd">    quantified variable in the resulting goal. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;gen&quot;</span> <span class="kn">ident</span>(X1) :=
  <span class="nb">generalize dependent</span> X1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;gen&quot;</span> <span class="kn">ident</span>(X1) <span class="kn">ident</span>(X2) :=
  gen X2; gen X1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;gen&quot;</span> <span class="kn">ident</span>(X1) <span class="kn">ident</span>(X2) <span class="kn">ident</span>(X3) :=
  gen X3; gen X2; gen X1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;gen&quot;</span> <span class="kn">ident</span>(X1) <span class="kn">ident</span>(X2) <span class="kn">ident</span>(X3) <span class="kn">ident</span>(X4)  :=
  gen X4; gen X3; gen X2; gen X1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;gen&quot;</span> <span class="kn">ident</span>(X1) <span class="kn">ident</span>(X2) <span class="kn">ident</span>(X3) <span class="kn">ident</span>(X4) <span class="kn">ident</span>(X5) :=
  gen X5; gen X4; gen X3; gen X2; gen X1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;gen&quot;</span> <span class="kn">ident</span>(X1) <span class="kn">ident</span>(X2) <span class="kn">ident</span>(X3) <span class="kn">ident</span>(X4) <span class="kn">ident</span>(X5)
 <span class="kn">ident</span>(X6) :=
  gen X6; gen X5; gen X4; gen X3; gen X2; gen X1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;gen&quot;</span> <span class="kn">ident</span>(X1) <span class="kn">ident</span>(X2) <span class="kn">ident</span>(X3) <span class="kn">ident</span>(X4) <span class="kn">ident</span>(X5)
 <span class="kn">ident</span>(X6) <span class="kn">ident</span>(X7) :=
  gen X7; gen X6; gen X5; gen X4; gen X3; gen X2; gen X1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;gen&quot;</span> <span class="kn">ident</span>(X1) <span class="kn">ident</span>(X2) <span class="kn">ident</span>(X3) <span class="kn">ident</span>(X4) <span class="kn">ident</span>(X5)
 <span class="kn">ident</span>(X6) <span class="kn">ident</span>(X7) <span class="kn">ident</span>(X8) :=
  gen X8; gen X7; gen X6; gen X5; gen X4; gen X3; gen X2; gen X1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;gen&quot;</span> <span class="kn">ident</span>(X1) <span class="kn">ident</span>(X2) <span class="kn">ident</span>(X3) <span class="kn">ident</span>(X4) <span class="kn">ident</span>(X5)
 <span class="kn">ident</span>(X6) <span class="kn">ident</span>(X7) <span class="kn">ident</span>(X8) <span class="kn">ident</span>(X9) :=
  gen X9; gen X8; gen X7; gen X6; gen X5; gen X4; gen X3; gen X2; gen X1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;gen&quot;</span> <span class="kn">ident</span>(X1) <span class="kn">ident</span>(X2) <span class="kn">ident</span>(X3) <span class="kn">ident</span>(X4) <span class="kn">ident</span>(X5)
 <span class="kn">ident</span>(X6) <span class="kn">ident</span>(X7) <span class="kn">ident</span>(X8) <span class="kn">ident</span>(X9) <span class="kn">ident</span>(X10) :=
  gen X10; gen X9; gen X8; gen X7; gen X6; gen X5; gen X4; gen X3; gen X2; gen X1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [generalizes X] is a shorthand for calling [generalize X; clear X].</span>
<span class="sd">    It is weaker than tactic [gen X] since it does not support</span>
<span class="sd">    dependencies. It is mainly intended for writing tactics. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;generalizes&quot;</span> hyp(X) :=
  <span class="nb">generalize</span> X; <span class="nb">clear</span> X.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;generalizes&quot;</span> hyp(X1) hyp(X2) :=
  generalizes X1; generalizes X2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;generalizes&quot;</span> hyp(X1) hyp(X2) hyp(X3) :=
  generalizes X1 X2; generalizes X3.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;generalizes&quot;</span> hyp(X1) hyp(X2) hyp(X3) hyp(X4) :=
  generalizes X1 X2 X3; generalizes X4.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Naming *)</span>

<span class="sd">(** [sets X: E] is the same as [set (X := E) in *], that is,</span>
<span class="sd">    it replaces all occurences of [E] by a fresh meta-variable [X]</span>
<span class="sd">    whose definition is [E]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;sets&quot;</span> <span class="kn">ident</span>(X) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="nb">set</span> (X := E) <span class="kr">in</span> *.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [def_to_eq E X H] applies when [X := E] is a local</span>
<span class="sd">    definition. It adds an assumption [H: X = E]</span>
<span class="sd">    and then clears the definition of [X].</span>
<span class="sd">    [def_to_eq_sym] is similar except that it generates</span>
<span class="sd">    the equality [H: E = X]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">def_to_eq</span> X HX E :=
  <span class="nb">assert</span> (HX : X = E) <span class="bp">by</span> <span class="bp">reflexivity</span>; <span class="nb">clearbody</span> X.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">def_to_eq_sym</span> X HX E :=
  <span class="nb">assert</span> (HX : E = X) <span class="bp">by</span> <span class="bp">reflexivity</span>; <span class="nb">clearbody</span> X.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [set_eq X H: E] generates the equality [H: X = E],</span>
<span class="sd">    for a fresh name [X], and replaces [E] by [X] in the</span>
<span class="sd">    current goal. Syntaxes [set_eq X: E] and</span>
<span class="sd">    [set_eq: E] are also available. Similarly,</span>
<span class="sd">    [set_eq &lt;- X H: E] generates the equality [H: E = X].</span>

<span class="sd">    [sets_eq X HX: E] does the same but replaces [E] by [X]</span>
<span class="sd">    everywhere in the goal. [sets_eq X HX: E in H] replaces in [H].</span>
<span class="sd">    [set_eq X HX: E in |-] performs no substitution at all. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;set_eq&quot;</span> <span class="kn">ident</span>(X) <span class="kn">ident</span>(HX) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="nb">set</span> (X := E); def_to_eq X HX E.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;set_eq&quot;</span> <span class="kn">ident</span>(X) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="kr">let</span> <span class="nv">HX</span> := <span class="kp">fresh</span> <span class="s2">&quot;EQ&quot;</span> X <span class="kr">in</span> set_eq X HX: E.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;set_eq&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="kr">let</span> <span class="nv">X</span> := <span class="kp">fresh</span> <span class="s2">&quot;X&quot;</span> <span class="kr">in</span> set_eq X: E.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;set_eq&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kn">ident</span>(X) <span class="kn">ident</span>(HX) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="nb">set</span> (X := E); def_to_eq_sym X HX E.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;set_eq&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kn">ident</span>(X) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="kr">let</span> <span class="nv">HX</span> := <span class="kp">fresh</span> <span class="s2">&quot;EQ&quot;</span> X <span class="kr">in</span> set_eq &lt;- X HX: E.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;set_eq&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="kr">let</span> <span class="nv">X</span> := <span class="kp">fresh</span> <span class="s2">&quot;X&quot;</span> <span class="kr">in</span> set_eq &lt;- X: E.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;sets_eq&quot;</span> <span class="kn">ident</span>(X) <span class="kn">ident</span>(HX) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="nb">set</span> (X := E) <span class="kr">in</span> *; def_to_eq X HX E.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;sets_eq&quot;</span> <span class="kn">ident</span>(X) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="kr">let</span> <span class="nv">HX</span> := <span class="kp">fresh</span> <span class="s2">&quot;EQ&quot;</span> X <span class="kr">in</span> sets_eq X HX: E.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;sets_eq&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="kr">let</span> <span class="nv">X</span> := <span class="kp">fresh</span> <span class="s2">&quot;X&quot;</span> <span class="kr">in</span> sets_eq X: E.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;sets_eq&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kn">ident</span>(X) <span class="kn">ident</span>(HX) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="nb">set</span> (X := E) <span class="kr">in</span> *; def_to_eq_sym X HX E.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;sets_eq&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kn">ident</span>(X) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="kr">let</span> <span class="nv">HX</span> := <span class="kp">fresh</span> <span class="s2">&quot;EQ&quot;</span> X <span class="kr">in</span> sets_eq &lt;- X HX: E.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;sets_eq&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="kr">let</span> <span class="nv">X</span> := <span class="kp">fresh</span> <span class="s2">&quot;X&quot;</span> <span class="kr">in</span> sets_eq &lt;- X: E.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;set_eq&quot;</span> <span class="kn">ident</span>(X) <span class="kn">ident</span>(HX) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  <span class="nb">set</span> (X := E) <span class="kr">in</span> H; def_to_eq X HX E.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;set_eq&quot;</span> <span class="kn">ident</span>(X) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  <span class="kr">let</span> <span class="nv">HX</span> := <span class="kp">fresh</span> <span class="s2">&quot;EQ&quot;</span> X <span class="kr">in</span> set_eq X HX: E <span class="kr">in</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;set_eq&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  <span class="kr">let</span> <span class="nv">X</span> := <span class="kp">fresh</span> <span class="s2">&quot;X&quot;</span> <span class="kr">in</span> set_eq X: E <span class="kr">in</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;set_eq&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kn">ident</span>(X) <span class="kn">ident</span>(HX) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  <span class="nb">set</span> (X := E) <span class="kr">in</span> H; def_to_eq_sym X HX E.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;set_eq&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kn">ident</span>(X) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  <span class="kr">let</span> <span class="nv">HX</span> := <span class="kp">fresh</span> <span class="s2">&quot;EQ&quot;</span> X <span class="kr">in</span> set_eq &lt;- X HX: E <span class="kr">in</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;set_eq&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  <span class="kr">let</span> <span class="nv">X</span> := <span class="kp">fresh</span> <span class="s2">&quot;X&quot;</span> <span class="kr">in</span> set_eq &lt;- X: E <span class="kr">in</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;set_eq&quot;</span> <span class="kn">ident</span>(X) <span class="kn">ident</span>(HX) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> <span class="s2">&quot;|-&quot;</span> :=
  <span class="nb">set</span> (X := E) <span class="kr">in</span> |-; def_to_eq X HX E.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;set_eq&quot;</span> <span class="kn">ident</span>(X) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> <span class="s2">&quot;|-&quot;</span> :=
  <span class="kr">let</span> <span class="nv">HX</span> := <span class="kp">fresh</span> <span class="s2">&quot;EQ&quot;</span> X <span class="kr">in</span> set_eq X HX: E <span class="kr">in</span> |-.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;set_eq&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> <span class="s2">&quot;|-&quot;</span> :=
  <span class="kr">let</span> <span class="nv">X</span> := <span class="kp">fresh</span> <span class="s2">&quot;X&quot;</span> <span class="kr">in</span> set_eq X: E <span class="kr">in</span> |-.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;set_eq&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kn">ident</span>(X) <span class="kn">ident</span>(HX) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> <span class="s2">&quot;|-&quot;</span> :=
  <span class="nb">set</span> (X := E) <span class="kr">in</span> |-; def_to_eq_sym X HX E.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;set_eq&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kn">ident</span>(X) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> <span class="s2">&quot;|-&quot;</span> :=
  <span class="kr">let</span> <span class="nv">HX</span> := <span class="kp">fresh</span> <span class="s2">&quot;EQ&quot;</span> X <span class="kr">in</span> set_eq &lt;- X HX: E <span class="kr">in</span> |-.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;set_eq&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> <span class="s2">&quot;|-&quot;</span> :=
  <span class="kr">let</span> <span class="nv">X</span> := <span class="kp">fresh</span> <span class="s2">&quot;X&quot;</span> <span class="kr">in</span> set_eq &lt;- X: E <span class="kr">in</span> |-.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [gen_eq X: E] is a tactic whose purpose is to introduce</span>
<span class="sd">    equalities so as to work around the limitation of the [induction]</span>
<span class="sd">    tactic which typically loses information. [gen_eq E as X] replaces</span>
<span class="sd">    all occurences of term [E] with a fresh variable [X] and the equality</span>
<span class="sd">    [X = E] as extra hypothesis to the current conclusion. In other words</span>
<span class="sd">    a conclusion [C] will be turned into [(X = E) -&gt; C].</span>
<span class="sd">    [gen_eq: E] and [gen_eq: E as X] are also accepted. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;gen_eq&quot;</span> <span class="kn">ident</span>(X) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="kr">let</span> <span class="nv">EQ</span> := <span class="kp">fresh</span> <span class="s2">&quot;EQ&quot;</span> X <span class="kr">in</span> sets_eq X EQ: E; <span class="nb">revert</span> EQ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;gen_eq&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="kr">let</span> <span class="nv">X</span> := <span class="kp">fresh</span> <span class="s2">&quot;X&quot;</span> <span class="kr">in</span> gen_eq X: E.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;gen_eq&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;as&quot;</span> <span class="kn">ident</span>(X) :=
  gen_eq X: E.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;gen_eq&quot;</span> <span class="kn">ident</span>(X1) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E1) <span class="s2">&quot;,&quot;</span>
  <span class="kn">ident</span>(X2) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E2) :=
  gen_eq X2: E2; gen_eq X1: E1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;gen_eq&quot;</span> <span class="kn">ident</span>(X1) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E1) <span class="s2">&quot;,&quot;</span>
  <span class="kn">ident</span>(X2) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E2) <span class="s2">&quot;,&quot;</span> <span class="kn">ident</span>(X3) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E3) :=
  gen_eq X3: E3; gen_eq X2: E2; gen_eq X1: E1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [sets_let X] finds the first let-expression in the goal</span>
<span class="sd">    and names its body [X]. [sets_eq_let X] is similar,</span>
<span class="sd">    except that it generates an explicit equality.</span>
<span class="sd">    Tactics [sets_let X in H] and [sets_eq_let X in H]</span>
<span class="sd">    allow specifying a particular hypothesis (by default,</span>
<span class="sd">    the first one that contains a [let] is considered).</span>

<span class="sd">    Known limitation: it does not seem possible to support</span>
<span class="sd">    naming of multiple let-in constructs inside a term, from ltac. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">sets_let_base</span> tac :=
  <span class="kr">match goal with</span>
  | |- <span class="kp">context</span>[<span class="kr">let</span> <span class="nv">_</span> := <span class="nl">?E</span> <span class="kr">in</span> _] =&gt; tac E; <span class="nb">cbv</span> zeta
  | H: <span class="kp">context</span>[<span class="kr">let</span> <span class="nv">_</span> := <span class="nl">?E</span> <span class="kr">in</span> _] |- _ =&gt; tac E; <span class="nb">cbv</span> zeta <span class="kr">in</span> H
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">sets_let_in_base</span> H tac :=
  <span class="kr">match</span> <span class="kp">type of</span> H <span class="kr">with</span> <span class="kp">context</span>[<span class="kr">let</span> <span class="nv">_</span> := <span class="nl">?E</span> <span class="kr">in</span> _] =&gt;
    tac E; <span class="nb">cbv</span> zeta <span class="kr">in</span> H <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;sets_let&quot;</span> <span class="kn">ident</span>(X) :=
  sets_let_base <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">E</span> =&gt; sets X: E).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;sets_let&quot;</span> <span class="kn">ident</span>(X) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  sets_let_in_base H <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">E</span> =&gt; sets X: E).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;sets_eq_let&quot;</span> <span class="kn">ident</span>(X) :=
  sets_let_base <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">E</span> =&gt; sets_eq X: E).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;sets_eq_let&quot;</span> <span class="kn">ident</span>(X) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  sets_let_in_base H <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">E</span> =&gt; sets_eq X: E).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ################################################################# *)</span>
<span class="sd">(** * Rewriting *)</span>

<span class="sd">(** [rewrites E] is similar to [rewrite] except that</span>
<span class="sd">    it supports the [rm] directives to clear hypotheses</span>
<span class="sd">    on the fly, and that it supports a list of arguments in the form</span>
<span class="sd">    [rewrites (&gt;&gt; E1 E2 E3)] to indicate that [forwards] should be</span>
<span class="sd">    invoked first before [rewrites] is called. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">rewrites_base</span> E cont :=
  <span class="kr">match</span> <span class="kp">type of</span> E <span class="kr">with</span>
  | List.list Boxer =&gt; forwards_then E cont
  | _ =&gt; cont E; fast_rm_inside E
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrites&quot;</span> <span class="kp">constr</span>(E) :=
  rewrites_base E <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">M</span> =&gt; <span class="nb">rewrite</span> M ).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrites&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  rewrites_base E <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">M</span> =&gt; <span class="nb">rewrite</span> M <span class="kr">in</span> H).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrites&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  rewrites_base E <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">M</span> =&gt; <span class="nb">rewrite</span> M <span class="kr">in</span> *).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrites&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kp">constr</span>(E) :=
  rewrites_base E <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">M</span> =&gt; <span class="nb">rewrite</span> &lt;- M ).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrites&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  rewrites_base E <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">M</span> =&gt; <span class="nb">rewrite</span> &lt;- M <span class="kr">in</span> H).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrites&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  rewrites_base E <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">M</span> =&gt; <span class="nb">rewrite</span> &lt;- M <span class="kr">in</span> *).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [erewrites E] is similar to [erewrite] except that</span>
<span class="sd">    it supports the [rm] directives to clear hypotheses</span>
<span class="sd">    on the fly, and that it supports a list of arguments in the form</span>
<span class="sd">    [rewrites (&gt;&gt; E1 E2 E3)] to indicate that [forwards] should be</span>
<span class="sd">    invoked first before [rewrites] is called. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;erewrites&quot;</span> <span class="kp">constr</span>(E) :=
  rewrites_base E <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">M</span> =&gt; <span class="nb">erewrite</span> M ).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;erewrites&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  rewrites_base E <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">M</span> =&gt; <span class="nb">erewrite</span> M <span class="kr">in</span> H).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;erewrites&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  rewrites_base E <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">M</span> =&gt; <span class="nb">erewrite</span> M <span class="kr">in</span> *).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;erewrites&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kp">constr</span>(E) :=
  rewrites_base E <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">M</span> =&gt; <span class="nb">erewrite</span> &lt;- M ).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;erewrites&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  rewrites_base E <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">M</span> =&gt; <span class="nb">erewrite</span> &lt;- M <span class="kr">in</span> H).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;erewrites&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  rewrites_base E <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">M</span> =&gt; <span class="nb">erewrite</span> &lt;- M <span class="kr">in</span> *).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* --Note: should we extend tactics below to use [rewrites]? *)</span>

<span class="sd">(** [rewrite_all E] iterates version of [rewrite E] as long as possible.</span>
<span class="sd">    Warning: this tactic can easily get into an infinite loop.</span>
<span class="sd">    Syntax for rewriting from right to left and/or into an hypothese</span>
<span class="sd">    is similar to the one of [rewrite]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrite_all&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="kp">repeat</span> <span class="nb">rewrite</span> E.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrite_all&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="kp">repeat</span> <span class="nb">rewrite</span> &lt;- E.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrite_all&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> <span class="kn">ident</span>(H) :=
  <span class="kp">repeat</span> <span class="nb">rewrite</span> E <span class="kr">in</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrite_all&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> <span class="kn">ident</span>(H) :=
  <span class="kp">repeat</span> <span class="nb">rewrite</span> &lt;- E <span class="kr">in</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrite_all&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  <span class="kp">repeat</span> <span class="nb">rewrite</span> E <span class="kr">in</span> *.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrite_all&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  <span class="kp">repeat</span> <span class="nb">rewrite</span> &lt;- E <span class="kr">in</span> *.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [asserts_rewrite E] asserts that an equality [E] holds (generating a</span>
<span class="sd">    corresponding subgoal) and rewrite it straight away in the current</span>
<span class="sd">    goal. It avoids giving a name to the equality and later clearing it.</span>
<span class="sd">    Syntax for rewriting from right to left and/or into an hypothese</span>
<span class="sd">    is similar to the one of [rewrite]. Note: the tactic [replaces]</span>
<span class="sd">    plays a similar role. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">asserts_rewrite_tactic</span> E action :=
  <span class="kr">let</span> <span class="nv">EQ</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span> (<span class="nb">assert</span> (EQ : E);
  [ <span class="kp">idtac</span> | action EQ; <span class="nb">clear</span> EQ ]).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;asserts_rewrite&quot;</span> <span class="kp">constr</span>(E) :=
  asserts_rewrite_tactic E <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">EQ</span> =&gt; <span class="nb">rewrite</span> EQ).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;asserts_rewrite&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kp">constr</span>(E) :=
  asserts_rewrite_tactic E <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">EQ</span> =&gt; <span class="nb">rewrite</span> &lt;- EQ).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;asserts_rewrite&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  asserts_rewrite_tactic E <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">EQ</span> =&gt; <span class="nb">rewrite</span> EQ <span class="kr">in</span> H).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;asserts_rewrite&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  asserts_rewrite_tactic E <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">EQ</span> =&gt; <span class="nb">rewrite</span> &lt;- EQ <span class="kr">in</span> H).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;asserts_rewrite&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  asserts_rewrite_tactic E <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">EQ</span> =&gt; <span class="nb">rewrite</span> EQ <span class="kr">in</span> *).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;asserts_rewrite&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  asserts_rewrite_tactic E <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">EQ</span> =&gt; <span class="nb">rewrite</span> &lt;- EQ <span class="kr">in</span> *).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [cuts_rewrite E] is the same as [asserts_rewrite E] except</span>
<span class="sd">    that subgoals are permuted. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">cuts_rewrite_tactic</span> E action :=
  <span class="kr">let</span> <span class="nv">EQ</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span> (cuts EQ: E;
  [ action EQ; <span class="nb">clear</span> EQ | <span class="kp">idtac</span> ]).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cuts_rewrite&quot;</span> <span class="kp">constr</span>(E) :=
  cuts_rewrite_tactic E <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">EQ</span> =&gt; <span class="nb">rewrite</span> EQ).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cuts_rewrite&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kp">constr</span>(E) :=
  cuts_rewrite_tactic E <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">EQ</span> =&gt; <span class="nb">rewrite</span> &lt;- EQ).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cuts_rewrite&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  cuts_rewrite_tactic E <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">EQ</span> =&gt; <span class="nb">rewrite</span> EQ <span class="kr">in</span> H).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cuts_rewrite&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  cuts_rewrite_tactic E <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">EQ</span> =&gt; <span class="nb">rewrite</span> &lt;- EQ <span class="kr">in</span> H).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [rewrite_except H EQ] rewrites equality [EQ] everywhere</span>
<span class="sd">    but in hypothesis [H]. Mainly useful for other tactics. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">rewrite_except</span> H EQ :=
  <span class="kr">let</span> <span class="nv">K</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span> <span class="kr">let</span> <span class="nv">T</span> := <span class="kp">type of</span> H <span class="kr">in</span>
  <span class="nb">set</span> (K := T) <span class="kr">in</span> H;
  <span class="nb">rewrite</span> EQ <span class="kr">in</span> *; <span class="nb">unfold</span> K <span class="kr">in</span> H; <span class="nb">clear</span> K.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [rewrites E at K] applies when [E] is of the form [T1 = T2]</span>
<span class="sd">    rewrites the equality [E] at the [K]-th occurence of [T1]</span>
<span class="sd">    in the current goal.</span>
<span class="sd">    Syntaxes [rewrites &lt;- E at K] and [rewrites E at K in H]</span>
<span class="sd">    are also available. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrites&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;at&quot;</span> <span class="kp">constr</span>(K) :=
  <span class="kr">match</span> <span class="kp">type of</span> E <span class="kr">with</span> <span class="nl">?T1</span> = <span class="nl">?T2</span> =&gt;
    ltac_action_at K of T1 <span class="kp">do</span> (rewrites E) <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrites&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;at&quot;</span> <span class="kp">constr</span>(K) :=
  <span class="kr">match</span> <span class="kp">type of</span> E <span class="kr">with</span> <span class="nl">?T1</span> = <span class="nl">?T2</span> =&gt;
    ltac_action_at K of T2 <span class="kp">do</span> (rewrites &lt;- E) <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrites&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;at&quot;</span> <span class="kp">constr</span>(K) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  <span class="kr">match</span> <span class="kp">type of</span> E <span class="kr">with</span> <span class="nl">?T1</span> = <span class="nl">?T2</span> =&gt;
    ltac_action_at K of T1 <span class="kr">in</span> H <span class="kp">do</span> (rewrites E <span class="kr">in</span> H) <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrites&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;at&quot;</span> <span class="kp">constr</span>(K) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  <span class="kr">match</span> <span class="kp">type of</span> E <span class="kr">with</span> <span class="nl">?T1</span> = <span class="nl">?T2</span> =&gt;
    ltac_action_at K of T2 <span class="kr">in</span> H <span class="kp">do</span> (rewrites &lt;- E <span class="kr">in</span> H) <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(**  ** Replace *)</span>

<span class="sd">(** [replaces E with F] is the same as [replace E with F] except that</span>
<span class="sd">    the equality [E = F] is generated as first subgoal. Syntax</span>
<span class="sd">    [replaces E with F in H] is also available. Note that contrary to</span>
<span class="sd">    [replace], [replaces] does not try to solve the equality</span>
<span class="sd">    by [assumption]. Note: [replaces E with F] is similar to</span>
<span class="sd">    [asserts_rewrite (E = F)]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;replaces&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;with&quot;</span> <span class="kp">constr</span>(F) :=
  <span class="kr">let</span> <span class="nv">T</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span> <span class="nb">assert</span> (T: E = F); [ | <span class="nb">replace</span> E <span class="kr">with</span> F; <span class="nb">clear</span> T ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;replaces&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;with&quot;</span> <span class="kp">constr</span>(F) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  <span class="kr">let</span> <span class="nv">T</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span> <span class="nb">assert</span> (T: E = F); [ | <span class="nb">replace</span> E <span class="kr">with</span> F <span class="kr">in</span> H; <span class="nb">clear</span> T ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [replaces E at K with F] replaces the [K]-th occurence of [E]</span>
<span class="sd">    with [F] in the current goal. Syntax [replaces E at K with F in H]</span>
<span class="sd">    is also available. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;replaces&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;at&quot;</span> <span class="kp">constr</span>(K) <span class="s2">&quot;with&quot;</span> <span class="kp">constr</span>(F) :=
  <span class="kr">let</span> <span class="nv">T</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span> <span class="nb">assert</span> (T: E = F); [ | rewrites T <span class="nb">at</span> K; <span class="nb">clear</span> T ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;replaces&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;at&quot;</span> <span class="kp">constr</span>(K) <span class="s2">&quot;with&quot;</span> <span class="kp">constr</span>(F) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  <span class="kr">let</span> <span class="nv">T</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span> <span class="nb">assert</span> (T: E = F); [ | rewrites T <span class="nb">at</span> K <span class="kr">in</span> H; <span class="nb">clear</span> T ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(**  ** Change *)</span>

<span class="sd">(** [changes] is like [change] except that it does not silently</span>
<span class="sd">   fail to perform its task. (Note that, [changes] is implemented</span>
<span class="sd">   using [rewrite], meaning that it might perform additional</span>
<span class="sd">   beta-reductions compared with the original [change] tactic. *)</span>
<span class="c">(* --Note: should we support &quot;changes (E1 = E2)&quot; *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;changes&quot;</span> <span class="kp">constr</span>(E1) <span class="s2">&quot;with&quot;</span> <span class="kp">constr</span>(E2) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  asserts_rewrite (E1 = E2) <span class="kr">in</span> H; [ <span class="bp">reflexivity</span> | ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;changes&quot;</span> <span class="kp">constr</span>(E1) <span class="s2">&quot;with&quot;</span> <span class="kp">constr</span>(E2) :=
  asserts_rewrite (E1 = E2); [ <span class="bp">reflexivity</span> | ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;changes&quot;</span> <span class="kp">constr</span>(E1) <span class="s2">&quot;with&quot;</span> <span class="kp">constr</span>(E2) <span class="s2">&quot;in&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  asserts_rewrite (E1 = E2) <span class="kr">in</span> *; [ <span class="bp">reflexivity</span> | ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Renaming *)</span>

<span class="sd">(** [renames X1 to Y1, ..., XN to YN] is a shorthand for a sequence of</span>
<span class="sd">    renaming operations [rename Xi into Yi]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;renames&quot;</span> <span class="kn">ident</span>(X1) <span class="s2">&quot;to&quot;</span> <span class="kn">ident</span>(Y1) :=
  <span class="nb">rename</span> X1 <span class="nb">into</span> Y1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;renames&quot;</span> <span class="kn">ident</span>(X1) <span class="s2">&quot;to&quot;</span> <span class="kn">ident</span>(Y1) <span class="s2">&quot;,&quot;</span>
 <span class="kn">ident</span>(X2) <span class="s2">&quot;to&quot;</span> <span class="kn">ident</span>(Y2) :=
  renames X1 to Y1; renames X2 to Y2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;renames&quot;</span> <span class="kn">ident</span>(X1) <span class="s2">&quot;to&quot;</span> <span class="kn">ident</span>(Y1) <span class="s2">&quot;,&quot;</span>
 <span class="kn">ident</span>(X2) <span class="s2">&quot;to&quot;</span> <span class="kn">ident</span>(Y2) <span class="s2">&quot;,&quot;</span> <span class="kn">ident</span>(X3) <span class="s2">&quot;to&quot;</span> <span class="kn">ident</span>(Y3) :=
  renames X1 to Y1; renames X2 to Y2, X3 to Y3.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;renames&quot;</span> <span class="kn">ident</span>(X1) <span class="s2">&quot;to&quot;</span> <span class="kn">ident</span>(Y1) <span class="s2">&quot;,&quot;</span>
 <span class="kn">ident</span>(X2) <span class="s2">&quot;to&quot;</span> <span class="kn">ident</span>(Y2) <span class="s2">&quot;,&quot;</span> <span class="kn">ident</span>(X3) <span class="s2">&quot;to&quot;</span> <span class="kn">ident</span>(Y3) <span class="s2">&quot;,&quot;</span>
 <span class="kn">ident</span>(X4) <span class="s2">&quot;to&quot;</span> <span class="kn">ident</span>(Y4) :=
  renames X1 to Y1; renames X2 to Y2, X3 to Y3, X4 to Y4.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;renames&quot;</span> <span class="kn">ident</span>(X1) <span class="s2">&quot;to&quot;</span> <span class="kn">ident</span>(Y1) <span class="s2">&quot;,&quot;</span>
 <span class="kn">ident</span>(X2) <span class="s2">&quot;to&quot;</span> <span class="kn">ident</span>(Y2) <span class="s2">&quot;,&quot;</span> <span class="kn">ident</span>(X3) <span class="s2">&quot;to&quot;</span> <span class="kn">ident</span>(Y3) <span class="s2">&quot;,&quot;</span>
 <span class="kn">ident</span>(X4) <span class="s2">&quot;to&quot;</span> <span class="kn">ident</span>(Y4) <span class="s2">&quot;,&quot;</span> <span class="kn">ident</span>(X5) <span class="s2">&quot;to&quot;</span> <span class="kn">ident</span>(Y5) :=
  renames X1 to Y1; renames X2 to Y2, X3 to Y3, X4 to Y4, X5 to Y5.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;renames&quot;</span> <span class="kn">ident</span>(X1) <span class="s2">&quot;to&quot;</span> <span class="kn">ident</span>(Y1) <span class="s2">&quot;,&quot;</span>
 <span class="kn">ident</span>(X2) <span class="s2">&quot;to&quot;</span> <span class="kn">ident</span>(Y2) <span class="s2">&quot;,&quot;</span> <span class="kn">ident</span>(X3) <span class="s2">&quot;to&quot;</span> <span class="kn">ident</span>(Y3) <span class="s2">&quot;,&quot;</span>
 <span class="kn">ident</span>(X4) <span class="s2">&quot;to&quot;</span> <span class="kn">ident</span>(Y4) <span class="s2">&quot;,&quot;</span> <span class="kn">ident</span>(X5) <span class="s2">&quot;to&quot;</span> <span class="kn">ident</span>(Y5) <span class="s2">&quot;,&quot;</span>
 <span class="kn">ident</span>(X6) <span class="s2">&quot;to&quot;</span> <span class="kn">ident</span>(Y6) :=
  renames X1 to Y1; renames X2 to Y2, X3 to Y3, X4 to Y4, X5 to Y5, X6 to Y6.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Unfolding *)</span>

<span class="sd">(** [unfolds] unfolds the head definition in the goal, i.e. if the</span>
<span class="sd">    goal has form [P x1 ... xN] then it calls [unfold P].</span>
<span class="sd">    If the goal is an equality, it tries to unfold the head constant</span>
<span class="sd">    on the left-hand side, and otherwise tries on the right-hand side.</span>
<span class="sd">    If the goal is a product, it calls [intros] first.</span>
<span class="sd">    -- warning: this tactic is overriden in LibReflect. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">apply_to_head_of</span> E cont :=
  <span class="kr">let</span> <span class="nv">go</span> <span class="nv">E</span> :=
    <span class="kr">let</span> <span class="nv">P</span> := get_head E <span class="kr">in</span> cont P <span class="kr">in</span>
  <span class="kr">match</span> E <span class="kr">with</span>
  | <span class="kr">forall</span> <span class="nv">_</span>,_ =&gt; <span class="nb">intros</span>; apply_to_head_of E cont
  | <span class="nl">?A</span> = <span class="nl">?B</span> =&gt; <span class="kp">first</span> [ go A | go B ]
  | <span class="nl">?A</span> =&gt; go A
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">unfolds_base</span> :=
  <span class="kr">match goal with</span> |- <span class="nl">?G</span> =&gt;
   apply_to_head_of G <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">P</span> =&gt; <span class="nb">unfold</span> P) <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;unfolds&quot;</span> :=
  unfolds_base.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [unfolds in H] unfolds the head definition of hypothesis [H], i.e. if</span>
<span class="sd">    [H] has type [P x1 ... xN] then it calls [unfold P in H]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">unfolds_in_base</span> H :=
  <span class="kr">match</span> <span class="kp">type of</span> H <span class="kr">with</span> <span class="nl">?G</span> =&gt;
   apply_to_head_of G <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">P</span> =&gt; <span class="nb">unfold</span> P <span class="kr">in</span> H) <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;unfolds&quot;</span> <span class="s2">&quot;in&quot;</span> hyp(H) :=
  unfolds_in_base H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [unfolds in H1,H2,..,HN] allows unfolding the head constant</span>
<span class="sd">    in several hypotheses at once. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;unfolds&quot;</span> <span class="s2">&quot;in&quot;</span> hyp(H1) hyp(H2) :=
  unfolds <span class="kr">in</span> H1; unfolds <span class="kr">in</span> H2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;unfolds&quot;</span> <span class="s2">&quot;in&quot;</span> hyp(H1) hyp(H2) hyp(H3) :=
  unfolds <span class="kr">in</span> H1; unfolds <span class="kr">in</span> H2 H3.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;unfolds&quot;</span> <span class="s2">&quot;in&quot;</span> hyp(H1) hyp(H2) hyp(H3) hyp(H4) :=
  unfolds <span class="kr">in</span> H1; unfolds <span class="kr">in</span> H2 H3 H4.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;unfolds&quot;</span> <span class="s2">&quot;in&quot;</span> hyp(H1) hyp(H2) hyp(H3) hyp(H4) hyp(H5) :=
  unfolds <span class="kr">in</span> H1; unfolds <span class="kr">in</span> H2 H3 H4 H5.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [unfolds P1,..,PN] is a shortcut for [unfold P1,..,PN in *]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;unfolds&quot;</span> <span class="kp">constr</span>(F1) :=
  <span class="nb">unfold</span> F1 <span class="kr">in</span> *.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;unfolds&quot;</span> <span class="kp">constr</span>(F1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F2) :=
  <span class="nb">unfold</span> F1,F2 <span class="kr">in</span> *.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;unfolds&quot;</span> <span class="kp">constr</span>(F1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F2)
 <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F3) :=
  <span class="nb">unfold</span> F1,F2,F3 <span class="kr">in</span> *.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;unfolds&quot;</span> <span class="kp">constr</span>(F1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F2)
 <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F3) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F4) :=
  <span class="nb">unfold</span> F1,F2,F3,F4 <span class="kr">in</span> *.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;unfolds&quot;</span> <span class="kp">constr</span>(F1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F2)
 <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F3) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F4) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F5) :=
  <span class="nb">unfold</span> F1,F2,F3,F4,F5 <span class="kr">in</span> *.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;unfolds&quot;</span> <span class="kp">constr</span>(F1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F2)
 <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F3) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F4) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F5) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F6) :=
  <span class="nb">unfold</span> F1,F2,F3,F4,F5,F6 <span class="kr">in</span> *.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;unfolds&quot;</span> <span class="kp">constr</span>(F1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F2)
 <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F3) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F4) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F5)
 <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F6) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F7) :=
  <span class="nb">unfold</span> F1,F2,F3,F4,F5,F6,F7 <span class="kr">in</span> *.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;unfolds&quot;</span> <span class="kp">constr</span>(F1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F2)
 <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F3) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F4) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F5)
 <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F6) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F7) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F8) :=
  <span class="nb">unfold</span> F1,F2,F3,F4,F5,F6,F7,F8 <span class="kr">in</span> *.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [folds P1,..,PN] is a shortcut for [fold P1 in *; ..; fold PN in *]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;folds&quot;</span> <span class="kp">constr</span>(H) :=
  <span class="nb">fold</span> H <span class="kr">in</span> *.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;folds&quot;</span> <span class="kp">constr</span>(H1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(H2) :=
  folds H1; folds H2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;folds&quot;</span> <span class="kp">constr</span>(H1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(H2) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(H3) :=
  folds H1; folds H2; folds H3.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;folds&quot;</span> <span class="kp">constr</span>(H1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(H2) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(H3)
 <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(H4) :=
  folds H1; folds H2; folds H3; folds H4.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;folds&quot;</span> <span class="kp">constr</span>(H1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(H2) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(H3)
 <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(H4) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(H5) :=
  folds H1; folds H2; folds H3; folds H4; folds H5.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Simplification *)</span>

<span class="sd">(** [simpls] is a shortcut for [simpl in *]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;simpls&quot;</span> :=
  <span class="nb">simpl</span> <span class="kr">in</span> *.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [simpls P1,..,PN] is a shortcut for</span>
<span class="sd">    [simpl P1 in *; ..; simpl PN in *]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;simpls&quot;</span> <span class="kp">constr</span>(F1) :=
  <span class="nb">simpl</span> F1 <span class="kr">in</span> *.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;simpls&quot;</span> <span class="kp">constr</span>(F1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F2) :=
  simpls F1; simpls F2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;simpls&quot;</span> <span class="kp">constr</span>(F1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F2)
 <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F3) :=
  simpls F1; simpls F2; simpls F3.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;simpls&quot;</span> <span class="kp">constr</span>(F1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F2)
 <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F3) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F4) :=
  simpls F1; simpls F2; simpls F3; simpls F4.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [unsimpl E] replaces all occurence of [X] by [E], where [X] is</span>
<span class="sd">   the result which the tactic [simpl] would give when applied to [E].</span>
<span class="sd">   It is useful to undo what [simpl] has simplified too far. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;unsimpl&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="kr">let</span> <span class="nv">F</span> := (<span class="kp">eval</span> <span class="nb">simpl</span> <span class="kr">in</span> E) <span class="kr">in</span> <span class="nb">change</span> F <span class="kr">with</span> E.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [unsimpl E in H] is similar to [unsimpl E] but it applies</span>
<span class="sd">    inside a particular hypothesis [H]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;unsimpl&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  <span class="kr">let</span> <span class="nv">F</span> := (<span class="kp">eval</span> <span class="nb">simpl</span> <span class="kr">in</span> E) <span class="kr">in</span> <span class="nb">change</span> F <span class="kr">with</span> E <span class="kr">in</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [unsimpl E in *] applies [unsimpl E] everywhere possible.</span>
<span class="sd">    [unsimpls E] is a synonymous. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;unsimpl&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  <span class="kr">let</span> <span class="nv">F</span> := (<span class="kp">eval</span> <span class="nb">simpl</span> <span class="kr">in</span> E) <span class="kr">in</span> <span class="nb">change</span> F <span class="kr">with</span> E <span class="kr">in</span> *.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;unsimpls&quot;</span> <span class="kp">constr</span>(E) :=
  unsimpl E <span class="kr">in</span> *.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [nosimpl t] protects the Coq term[t] against some forms of</span>
<span class="sd">    simplification. See Gonthier&#39;s work for details on this trick. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;nosimpl&#39; t&quot;</span> := (<span class="kr">match</span> tt <span class="kr">with</span> tt =&gt; t <span class="kr">end</span>)
  (<span class="kn">at level</span> <span class="mi">10</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Reduction *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;hnfs&quot;</span> := <span class="nb">hnf</span> <span class="kr">in</span> *.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Substitution *)</span>

<span class="sd">(** [substs] does the same as [subst], except that it does not fail</span>
<span class="sd">    when there are circular equalities in the context. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;substs&quot;</span> :=
  <span class="kp">repeat</span> (<span class="kr">match goal with</span> H: <span class="nl">?x</span> = <span class="nl">?y</span> |- _ =&gt;
            <span class="kp">first</span> [ <span class="nb">subst</span> x | <span class="nb">subst</span> y ] <span class="kr">end</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Implementation of [substs below], which allows to call</span>
<span class="sd">    [subst] on all the hypotheses that lie beyond a given</span>
<span class="sd">    position in the proof context. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">substs_below</span> limit :=
  <span class="kr">match goal with</span> H: <span class="nl">?T</span> |- _ =&gt;
  <span class="kr">match</span> T <span class="kr">with</span>
  | limit =&gt; <span class="kp">idtac</span>
  | <span class="nl">?x</span> = <span class="nl">?y</span> =&gt;
    <span class="kp">first</span> [ <span class="nb">subst</span> x; substs_below limit
          | <span class="nb">subst</span> y; substs_below limit
          | generalizes H; substs_below limit; <span class="nb">intro</span> ]
  <span class="kr">end</span> <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [substs below body E] applies [subst] on all equalities that appear</span>
<span class="sd">    in the context below the first hypothesis whose body is [E].</span>
<span class="sd">    If there is no such hypothesis in the context, it is equivalent</span>
<span class="sd">    to [subst]. For instance, if [H] is an hypothesis, then</span>
<span class="sd">    [substs below H] will substitute equalities below hypothesis [H]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;substs&quot;</span> <span class="s2">&quot;below&quot;</span> <span class="s2">&quot;body&quot;</span> <span class="kp">constr</span>(M) :=
  substs_below M.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [substs below H] applies [subst] on all equalities that appear</span>
<span class="sd">    in the context below the hypothesis named [H]. Note that</span>
<span class="sd">    the current implementation is technically incorrect since it</span>
<span class="sd">    will confuse different hypotheses with the same body. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;substs&quot;</span> <span class="s2">&quot;below&quot;</span> hyp(H) :=
  <span class="kr">match</span> <span class="kp">type of</span> H <span class="kr">with</span> <span class="nl">?M</span> =&gt; substs below body M <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [subst_hyp H] substitutes the equality contained in the</span>
<span class="sd">    first hypothesis from the context. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">intro_subst_hyp</span> := <span class="kp">fail</span>. <span class="c">(* definition further on *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [subst_hyp H] substitutes the equality contained in [H]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">subst_hyp_base</span> H :=
  <span class="kr">match</span> <span class="kp">type of</span> H <span class="kr">with</span>
  | (_,_,_,_,_) = (_,_,_,_,_) =&gt; <span class="nb">injection</span> H; <span class="nb">clear</span> H; <span class="kp">do</span> <span class="mi">4</span> intro_subst_hyp
  | (_,_,_,_) = (_,_,_,_) =&gt; <span class="nb">injection</span> H; <span class="nb">clear</span> H; <span class="kp">do</span> <span class="mi">4</span> intro_subst_hyp
  | (_,_,_) = (_,_,_) =&gt; <span class="nb">injection</span> H; <span class="nb">clear</span> H; <span class="kp">do</span> <span class="mi">3</span> intro_subst_hyp
  | (_,_) = (_,_) =&gt; <span class="nb">injection</span> H; <span class="nb">clear</span> H; <span class="kp">do</span> <span class="mi">2</span> intro_subst_hyp
  | <span class="nl">?x</span> = <span class="nl">?x</span> =&gt; <span class="nb">clear</span> H
  | <span class="nl">?x</span> = <span class="nl">?y</span> =&gt; <span class="kp">first</span> [ <span class="nb">subst</span> x | <span class="nb">subst</span> y ]
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;subst_hyp&quot;</span> hyp(H) := subst_hyp_base H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">intro_subst_hyp</span> ::=
  <span class="kr">let</span> <span class="nv">H</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span> <span class="nb">intros</span> H; subst_hyp H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [intro_subst] is a shorthand for [intro H; subst_hyp H]:</span>
<span class="sd">    it introduces and substitutes the equality at the head</span>
<span class="sd">    of the current goal. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;intro_subst&quot;</span> :=
  <span class="kr">let</span> <span class="nv">H</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span> <span class="nb">intros</span> H; subst_hyp H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [subst_local] substitutes all local definition from the context *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">subst_local</span> :=
  <span class="kp">repeat</span> <span class="kr">match goal with</span> H:=_ |- _ =&gt; <span class="nb">subst</span> H <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [subst_eq E] takes an equality [x = t] and replace [x]</span>
<span class="sd">    with [t] everywhere in the goal *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">subst_eq_base</span> E :=
  <span class="kr">let</span> <span class="nv">H</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span> <span class="kr">let</span><span class="nv">s</span> <span class="nv">H</span>: E; subst_hyp H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;subst_eq&quot;</span> <span class="kp">constr</span>(E) :=
  subst_eq_base E.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Tactics to Work with Proof Irrelevance *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Logic.ProofIrrelevance.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [pi_rewrite E] replaces [E] of type [Prop] with a fresh</span>
<span class="sd">    unification variable, and is thus a practical way to</span>
<span class="sd">    exploit proof irrelevance, without writing explicitly</span>
<span class="sd">    [rewrite (proof_irrelevance E E&#39;)]. Particularly useful</span>
<span class="sd">    when [E&#39;] is a big expression. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">pi_rewrite_base</span> E rewrite_tac :=
  <span class="kr">let</span> <span class="nv">E&#39;</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span> <span class="kr">let</span> <span class="nv">T</span> := <span class="kp">type of</span> E <span class="kr">in</span> <span class="nb">evar</span> (E&#39;:T);
  rewrite_tac (@proof_irrelevance _ E E&#39;); <span class="nb">subst</span> E&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;pi_rewrite&quot;</span> <span class="kp">constr</span>(E) :=
  pi_rewrite_base E <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">X</span> =&gt; <span class="nb">rewrite</span> X).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;pi_rewrite&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  pi_rewrite_base E <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">X</span> =&gt; <span class="nb">rewrite</span> X <span class="kr">in</span> H).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Proving Equalities *)</span>

<span class="sd">(** The tactic [fequal] enhances Coq&#39;s tactic [f_equal], which does not</span>
<span class="sd">    simplify equalities between tuples, nor between dependent pairs of</span>
<span class="sd">    the form [exist _ _] or [existT _ _]. For support of dependent pairs,</span>
<span class="sd">    the file [LibEqual] must be imported.</span>

<span class="sd">    Subgoals solvable by [reflexivity] are automatically discharged.</span>
<span class="sd">    See also the the variant [fequals], which discharges more subgoals. *)</span>

<span class="sd">(** Note: only [args_eq_2] is actually useful for the implementation of</span>
<span class="sd">    [fequal], if we rely on Coq&#39;s [f_equal] tactic for other arities.</span>
<span class="sd">    We provide these lemmas to show the pattern of lemmas to exploit</span>
<span class="sd">    for implementing [fequal] independently of [f_equal]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">FuncEq</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variables</span> (<span class="nv">A1</span> <span class="nv">A2</span> <span class="nv">A3</span> <span class="nv">A4</span> <span class="nv">A5</span> <span class="nv">A6</span> <span class="nv">A7</span> <span class="nv">B</span> : <span class="kt">Type</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk2c"><span class="kn">Lemma</span> <span class="nf">args_eq_1</span> : <span class="kr">forall</span> (<span class="nv">f</span>:A1-&gt;B) <span class="nv">x1</span> <span class="nv">y1</span>,
  x1 = y1 -&gt;
  f x1 = f y1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A1, A2, A3, A4, A5, A6, A7, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : A1 -&gt; B) (<span class="nv">x1</span> <span class="nv">y1</span> : A1),
x1 = y1 -&gt; f x1 = f y1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk2d"><span class="kn">Proof using</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A1, A2, A3, A4, A5, A6, A7, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : A1 -&gt; B) (<span class="nv">x1</span> <span class="nv">y1</span> : A1),
x1 = y1 -&gt; f x1 = f y1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk2e"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A1, A2, A3, A4, A5, A6, A7, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A1 -&gt; B</span></span></span><br><span><var>x1, y1</var><span class="hyp-type"><b>: </b><span>A1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x1 = y1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x1 = f y1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk2f"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A1, A2, A3, A4, A5, A6, A7, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A1 -&gt; B</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>A1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f y1 = f y1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk30"><span class="kn">Lemma</span> <span class="nf">args_eq_2</span> : <span class="kr">forall</span> (<span class="nv">f</span>:A1-&gt;A2-&gt;B) <span class="nv">x1</span> <span class="nv">y1</span> <span class="nv">x2</span> <span class="nv">y2</span>,
  x1 = y1 -&gt; x2 = y2 -&gt;
  f x1 x2 = f y1 y2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A1, A2, A3, A4, A5, A6, A7, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : A1 -&gt; A2 -&gt; B) (<span class="nv">x1</span> <span class="nv">y1</span> : A1) (<span class="nv">x2</span> <span class="nv">y2</span> : A2),
x1 = y1 -&gt; x2 = y2 -&gt; f x1 x2 = f y1 y2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk31"><span class="kn">Proof using</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A1, A2, A3, A4, A5, A6, A7, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : A1 -&gt; A2 -&gt; B) (<span class="nv">x1</span> <span class="nv">y1</span> : A1) (<span class="nv">x2</span> <span class="nv">y2</span> : A2),
x1 = y1 -&gt; x2 = y2 -&gt; f x1 x2 = f y1 y2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk32"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A1, A2, A3, A4, A5, A6, A7, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A1 -&gt; A2 -&gt; B</span></span></span><br><span><var>x1, y1</var><span class="hyp-type"><b>: </b><span>A1</span></span></span><br><span><var>x2, y2</var><span class="hyp-type"><b>: </b><span>A2</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x1 = y1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>x2 = y2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x1 x2 = f y1 y2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk33"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A1, A2, A3, A4, A5, A6, A7, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A1 -&gt; A2 -&gt; B</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>A1</span></span></span><br><span><var>y2</var><span class="hyp-type"><b>: </b><span>A2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f y1 y2 = f y1 y2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk34"><span class="kn">Lemma</span> <span class="nf">args_eq_3</span> : <span class="kr">forall</span> (<span class="nv">f</span>:A1-&gt;A2-&gt;A3-&gt;B) <span class="nv">x1</span> <span class="nv">y1</span> <span class="nv">x2</span> <span class="nv">y2</span> <span class="nv">x3</span> <span class="nv">y3</span>,
  x1 = y1 -&gt; x2 = y2 -&gt; x3 = y3 -&gt;
  f x1 x2 x3 = f y1 y2 y3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A1, A2, A3, A4, A5, A6, A7, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : A1 -&gt; A2 -&gt; A3 -&gt; B) (<span class="nv">x1</span> <span class="nv">y1</span> : A1)
  (<span class="nv">x2</span> <span class="nv">y2</span> : A2) (<span class="nv">x3</span> <span class="nv">y3</span> : A3),
x1 = y1 -&gt;
x2 = y2 -&gt; x3 = y3 -&gt; f x1 x2 x3 = f y1 y2 y3</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk35"><span class="kn">Proof using</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A1, A2, A3, A4, A5, A6, A7, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : A1 -&gt; A2 -&gt; A3 -&gt; B) (<span class="nv">x1</span> <span class="nv">y1</span> : A1)
  (<span class="nv">x2</span> <span class="nv">y2</span> : A2) (<span class="nv">x3</span> <span class="nv">y3</span> : A3),
x1 = y1 -&gt;
x2 = y2 -&gt; x3 = y3 -&gt; f x1 x2 x3 = f y1 y2 y3</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk36"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A1, A2, A3, A4, A5, A6, A7, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A1 -&gt; A2 -&gt; A3 -&gt; B</span></span></span><br><span><var>x1, y1</var><span class="hyp-type"><b>: </b><span>A1</span></span></span><br><span><var>x2, y2</var><span class="hyp-type"><b>: </b><span>A2</span></span></span><br><span><var>x3, y3</var><span class="hyp-type"><b>: </b><span>A3</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x1 = y1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>x2 = y2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>x3 = y3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x1 x2 x3 = f y1 y2 y3</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk37"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A1, A2, A3, A4, A5, A6, A7, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A1 -&gt; A2 -&gt; A3 -&gt; B</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>A1</span></span></span><br><span><var>y2</var><span class="hyp-type"><b>: </b><span>A2</span></span></span><br><span><var>y3</var><span class="hyp-type"><b>: </b><span>A3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f y1 y2 y3 = f y1 y2 y3</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk38"><span class="kn">Lemma</span> <span class="nf">args_eq_4</span> : <span class="kr">forall</span> (<span class="nv">f</span>:A1-&gt;A2-&gt;A3-&gt;A4-&gt;B) <span class="nv">x1</span> <span class="nv">y1</span> <span class="nv">x2</span> <span class="nv">y2</span> <span class="nv">x3</span> <span class="nv">y3</span> <span class="nv">x4</span> <span class="nv">y4</span>,
  x1 = y1 -&gt; x2 = y2 -&gt; x3 = y3 -&gt; x4 = y4 -&gt;
  f x1 x2 x3 x4 = f y1 y2 y3 y4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A1, A2, A3, A4, A5, A6, A7, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : A1 -&gt; A2 -&gt; A3 -&gt; A4 -&gt; B) (<span class="nv">x1</span> <span class="nv">y1</span> : A1)
  (<span class="nv">x2</span> <span class="nv">y2</span> : A2) (<span class="nv">x3</span> <span class="nv">y3</span> : A3) (<span class="nv">x4</span> <span class="nv">y4</span> : A4),
x1 = y1 -&gt;
x2 = y2 -&gt;
x3 = y3 -&gt; x4 = y4 -&gt; f x1 x2 x3 x4 = f y1 y2 y3 y4</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk39"><span class="kn">Proof using</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A1, A2, A3, A4, A5, A6, A7, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : A1 -&gt; A2 -&gt; A3 -&gt; A4 -&gt; B) (<span class="nv">x1</span> <span class="nv">y1</span> : A1)
  (<span class="nv">x2</span> <span class="nv">y2</span> : A2) (<span class="nv">x3</span> <span class="nv">y3</span> : A3) (<span class="nv">x4</span> <span class="nv">y4</span> : A4),
x1 = y1 -&gt;
x2 = y2 -&gt;
x3 = y3 -&gt; x4 = y4 -&gt; f x1 x2 x3 x4 = f y1 y2 y3 y4</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk3a"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A1, A2, A3, A4, A5, A6, A7, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A1 -&gt; A2 -&gt; A3 -&gt; A4 -&gt; B</span></span></span><br><span><var>x1, y1</var><span class="hyp-type"><b>: </b><span>A1</span></span></span><br><span><var>x2, y2</var><span class="hyp-type"><b>: </b><span>A2</span></span></span><br><span><var>x3, y3</var><span class="hyp-type"><b>: </b><span>A3</span></span></span><br><span><var>x4, y4</var><span class="hyp-type"><b>: </b><span>A4</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x1 = y1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>x2 = y2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>x3 = y3</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>x4 = y4</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x1 x2 x3 x4 = f y1 y2 y3 y4</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk3b"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A1, A2, A3, A4, A5, A6, A7, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A1 -&gt; A2 -&gt; A3 -&gt; A4 -&gt; B</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>A1</span></span></span><br><span><var>y2</var><span class="hyp-type"><b>: </b><span>A2</span></span></span><br><span><var>y3</var><span class="hyp-type"><b>: </b><span>A3</span></span></span><br><span><var>y4</var><span class="hyp-type"><b>: </b><span>A4</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f y1 y2 y3 y4 = f y1 y2 y3 y4</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk3c"><span class="kn">Lemma</span> <span class="nf">args_eq_5</span> : <span class="kr">forall</span> (<span class="nv">f</span>:A1-&gt;A2-&gt;A3-&gt;A4-&gt;A5-&gt;B) <span class="nv">x1</span> <span class="nv">y1</span> <span class="nv">x2</span> <span class="nv">y2</span> <span class="nv">x3</span> <span class="nv">y3</span> <span class="nv">x4</span> <span class="nv">y4</span> <span class="nv">x5</span> <span class="nv">y5</span>,
  x1 = y1 -&gt; x2 = y2 -&gt; x3 = y3 -&gt; x4 = y4 -&gt; x5 = y5 -&gt;
  f x1 x2 x3 x4 x5 = f y1 y2 y3 y4 y5.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A1, A2, A3, A4, A5, A6, A7, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : A1 -&gt; A2 -&gt; A3 -&gt; A4 -&gt; A5 -&gt; B)
  (<span class="nv">x1</span> <span class="nv">y1</span> : A1) (<span class="nv">x2</span> <span class="nv">y2</span> : A2) (<span class="nv">x3</span> <span class="nv">y3</span> : A3) (<span class="nv">x4</span> <span class="nv">y4</span> : A4)
  (<span class="nv">x5</span> <span class="nv">y5</span> : A5),
x1 = y1 -&gt;
x2 = y2 -&gt;
x3 = y3 -&gt;
x4 = y4 -&gt;
x5 = y5 -&gt; f x1 x2 x3 x4 x5 = f y1 y2 y3 y4 y5</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk3d"><span class="kn">Proof using</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A1, A2, A3, A4, A5, A6, A7, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : A1 -&gt; A2 -&gt; A3 -&gt; A4 -&gt; A5 -&gt; B)
  (<span class="nv">x1</span> <span class="nv">y1</span> : A1) (<span class="nv">x2</span> <span class="nv">y2</span> : A2) (<span class="nv">x3</span> <span class="nv">y3</span> : A3) (<span class="nv">x4</span> <span class="nv">y4</span> : A4)
  (<span class="nv">x5</span> <span class="nv">y5</span> : A5),
x1 = y1 -&gt;
x2 = y2 -&gt;
x3 = y3 -&gt;
x4 = y4 -&gt;
x5 = y5 -&gt; f x1 x2 x3 x4 x5 = f y1 y2 y3 y4 y5</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk3e"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A1, A2, A3, A4, A5, A6, A7, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A1 -&gt; A2 -&gt; A3 -&gt; A4 -&gt; A5 -&gt; B</span></span></span><br><span><var>x1, y1</var><span class="hyp-type"><b>: </b><span>A1</span></span></span><br><span><var>x2, y2</var><span class="hyp-type"><b>: </b><span>A2</span></span></span><br><span><var>x3, y3</var><span class="hyp-type"><b>: </b><span>A3</span></span></span><br><span><var>x4, y4</var><span class="hyp-type"><b>: </b><span>A4</span></span></span><br><span><var>x5, y5</var><span class="hyp-type"><b>: </b><span>A5</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x1 = y1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>x2 = y2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>x3 = y3</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>x4 = y4</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>x5 = y5</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x1 x2 x3 x4 x5 = f y1 y2 y3 y4 y5</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk3f"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A1, A2, A3, A4, A5, A6, A7, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A1 -&gt; A2 -&gt; A3 -&gt; A4 -&gt; A5 -&gt; B</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>A1</span></span></span><br><span><var>y2</var><span class="hyp-type"><b>: </b><span>A2</span></span></span><br><span><var>y3</var><span class="hyp-type"><b>: </b><span>A3</span></span></span><br><span><var>y4</var><span class="hyp-type"><b>: </b><span>A4</span></span></span><br><span><var>y5</var><span class="hyp-type"><b>: </b><span>A5</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f y1 y2 y3 y4 y5 = f y1 y2 y3 y4 y5</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk40"><span class="kn">Lemma</span> <span class="nf">args_eq_6</span> : <span class="kr">forall</span> (<span class="nv">f</span>:A1-&gt;A2-&gt;A3-&gt;A4-&gt;A5-&gt;A6-&gt;B) <span class="nv">x1</span> <span class="nv">y1</span> <span class="nv">x2</span> <span class="nv">y2</span> <span class="nv">x3</span> <span class="nv">y3</span> <span class="nv">x4</span> <span class="nv">y4</span> <span class="nv">x5</span> <span class="nv">y5</span> <span class="nv">x6</span> <span class="nv">y6</span>,
  x1 = y1 -&gt; x2 = y2 -&gt; x3 = y3 -&gt; x4 = y4 -&gt; x5 = y5 -&gt; x6 = y6 -&gt;
  f x1 x2 x3 x4 x5 x6 = f y1 y2 y3 y4 y5 y6.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A1, A2, A3, A4, A5, A6, A7, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : A1 -&gt; A2 -&gt; A3 -&gt; A4 -&gt; A5 -&gt; A6 -&gt; B)
  (<span class="nv">x1</span> <span class="nv">y1</span> : A1) (<span class="nv">x2</span> <span class="nv">y2</span> : A2) (<span class="nv">x3</span> <span class="nv">y3</span> : A3) (<span class="nv">x4</span> <span class="nv">y4</span> : A4)
  (<span class="nv">x5</span> <span class="nv">y5</span> : A5) (<span class="nv">x6</span> <span class="nv">y6</span> : A6),
x1 = y1 -&gt;
x2 = y2 -&gt;
x3 = y3 -&gt;
x4 = y4 -&gt;
x5 = y5 -&gt;
x6 = y6 -&gt; f x1 x2 x3 x4 x5 x6 = f y1 y2 y3 y4 y5 y6</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk41"><span class="kn">Proof using</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A1, A2, A3, A4, A5, A6, A7, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : A1 -&gt; A2 -&gt; A3 -&gt; A4 -&gt; A5 -&gt; A6 -&gt; B)
  (<span class="nv">x1</span> <span class="nv">y1</span> : A1) (<span class="nv">x2</span> <span class="nv">y2</span> : A2) (<span class="nv">x3</span> <span class="nv">y3</span> : A3) (<span class="nv">x4</span> <span class="nv">y4</span> : A4)
  (<span class="nv">x5</span> <span class="nv">y5</span> : A5) (<span class="nv">x6</span> <span class="nv">y6</span> : A6),
x1 = y1 -&gt;
x2 = y2 -&gt;
x3 = y3 -&gt;
x4 = y4 -&gt;
x5 = y5 -&gt;
x6 = y6 -&gt; f x1 x2 x3 x4 x5 x6 = f y1 y2 y3 y4 y5 y6</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk42"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A1, A2, A3, A4, A5, A6, A7, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A1 -&gt; A2 -&gt; A3 -&gt; A4 -&gt; A5 -&gt; A6 -&gt; B</span></span></span><br><span><var>x1, y1</var><span class="hyp-type"><b>: </b><span>A1</span></span></span><br><span><var>x2, y2</var><span class="hyp-type"><b>: </b><span>A2</span></span></span><br><span><var>x3, y3</var><span class="hyp-type"><b>: </b><span>A3</span></span></span><br><span><var>x4, y4</var><span class="hyp-type"><b>: </b><span>A4</span></span></span><br><span><var>x5, y5</var><span class="hyp-type"><b>: </b><span>A5</span></span></span><br><span><var>x6, y6</var><span class="hyp-type"><b>: </b><span>A6</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x1 = y1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>x2 = y2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>x3 = y3</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>x4 = y4</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>x5 = y5</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>x6 = y6</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x1 x2 x3 x4 x5 x6 = f y1 y2 y3 y4 y5 y6</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk43"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A1, A2, A3, A4, A5, A6, A7, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A1 -&gt; A2 -&gt; A3 -&gt; A4 -&gt; A5 -&gt; A6 -&gt; B</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>A1</span></span></span><br><span><var>y2</var><span class="hyp-type"><b>: </b><span>A2</span></span></span><br><span><var>y3</var><span class="hyp-type"><b>: </b><span>A3</span></span></span><br><span><var>y4</var><span class="hyp-type"><b>: </b><span>A4</span></span></span><br><span><var>y5</var><span class="hyp-type"><b>: </b><span>A5</span></span></span><br><span><var>y6</var><span class="hyp-type"><b>: </b><span>A6</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f y1 y2 y3 y4 y5 y6 = f y1 y2 y3 y4 y5 y6</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk44"><span class="kn">Lemma</span> <span class="nf">args_eq_7</span> : <span class="kr">forall</span> (<span class="nv">f</span>:A1-&gt;A2-&gt;A3-&gt;A4-&gt;A5-&gt;A6-&gt;A7-&gt;B) <span class="nv">x1</span> <span class="nv">y1</span> <span class="nv">x2</span> <span class="nv">y2</span> <span class="nv">x3</span> <span class="nv">y3</span> <span class="nv">x4</span> <span class="nv">y4</span> <span class="nv">x5</span> <span class="nv">y5</span> <span class="nv">x6</span> <span class="nv">y6</span> <span class="nv">x7</span> <span class="nv">y7</span>,
  x1 = y1 -&gt; x2 = y2 -&gt; x3 = y3 -&gt; x4 = y4 -&gt; x5 = y5 -&gt; x6 = y6 -&gt; x7 = y7 -&gt;
  f x1 x2 x3 x4 x5 x6 x7 = f y1 y2 y3 y4 y5 y6 y7.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A1, A2, A3, A4, A5, A6, A7, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
  (<span class="nv">f</span> : A1 -&gt; A2 -&gt; A3 -&gt; A4 -&gt; A5 -&gt; A6 -&gt; A7 -&gt; B)
  (<span class="nv">x1</span> <span class="nv">y1</span> : A1) (<span class="nv">x2</span> <span class="nv">y2</span> : A2) (<span class="nv">x3</span> <span class="nv">y3</span> : A3) (<span class="nv">x4</span> <span class="nv">y4</span> : A4)
  (<span class="nv">x5</span> <span class="nv">y5</span> : A5) (<span class="nv">x6</span> <span class="nv">y6</span> : A6) (<span class="nv">x7</span> <span class="nv">y7</span> : A7),
x1 = y1 -&gt;
x2 = y2 -&gt;
x3 = y3 -&gt;
x4 = y4 -&gt;
x5 = y5 -&gt;
x6 = y6 -&gt;
x7 = y7 -&gt;
f x1 x2 x3 x4 x5 x6 x7 = f y1 y2 y3 y4 y5 y6 y7</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk45"><span class="kn">Proof using</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A1, A2, A3, A4, A5, A6, A7, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
  (<span class="nv">f</span> : A1 -&gt; A2 -&gt; A3 -&gt; A4 -&gt; A5 -&gt; A6 -&gt; A7 -&gt; B)
  (<span class="nv">x1</span> <span class="nv">y1</span> : A1) (<span class="nv">x2</span> <span class="nv">y2</span> : A2) (<span class="nv">x3</span> <span class="nv">y3</span> : A3) (<span class="nv">x4</span> <span class="nv">y4</span> : A4)
  (<span class="nv">x5</span> <span class="nv">y5</span> : A5) (<span class="nv">x6</span> <span class="nv">y6</span> : A6) (<span class="nv">x7</span> <span class="nv">y7</span> : A7),
x1 = y1 -&gt;
x2 = y2 -&gt;
x3 = y3 -&gt;
x4 = y4 -&gt;
x5 = y5 -&gt;
x6 = y6 -&gt;
x7 = y7 -&gt;
f x1 x2 x3 x4 x5 x6 x7 = f y1 y2 y3 y4 y5 y6 y7</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk46"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A1, A2, A3, A4, A5, A6, A7, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A1 -&gt; A2 -&gt; A3 -&gt; A4 -&gt; A5 -&gt; A6 -&gt; A7 -&gt; B</span></span></span><br><span><var>x1, y1</var><span class="hyp-type"><b>: </b><span>A1</span></span></span><br><span><var>x2, y2</var><span class="hyp-type"><b>: </b><span>A2</span></span></span><br><span><var>x3, y3</var><span class="hyp-type"><b>: </b><span>A3</span></span></span><br><span><var>x4, y4</var><span class="hyp-type"><b>: </b><span>A4</span></span></span><br><span><var>x5, y5</var><span class="hyp-type"><b>: </b><span>A5</span></span></span><br><span><var>x6, y6</var><span class="hyp-type"><b>: </b><span>A6</span></span></span><br><span><var>x7, y7</var><span class="hyp-type"><b>: </b><span>A7</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x1 = y1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>x2 = y2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>x3 = y3</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>x4 = y4</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>x5 = y5</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>x6 = y6</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>x7 = y7</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x1 x2 x3 x4 x5 x6 x7 = f y1 y2 y3 y4 y5 y6 y7</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk47"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A1, A2, A3, A4, A5, A6, A7, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A1 -&gt; A2 -&gt; A3 -&gt; A4 -&gt; A5 -&gt; A6 -&gt; A7 -&gt; B</span></span></span><br><span><var>y1</var><span class="hyp-type"><b>: </b><span>A1</span></span></span><br><span><var>y2</var><span class="hyp-type"><b>: </b><span>A2</span></span></span><br><span><var>y3</var><span class="hyp-type"><b>: </b><span>A3</span></span></span><br><span><var>y4</var><span class="hyp-type"><b>: </b><span>A4</span></span></span><br><span><var>y5</var><span class="hyp-type"><b>: </b><span>A5</span></span></span><br><span><var>y6</var><span class="hyp-type"><b>: </b><span>A6</span></span></span><br><span><var>y7</var><span class="hyp-type"><b>: </b><span>A7</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f y1 y2 y3 y4 y5 y6 y7 = f y1 y2 y3 y4 y5 y6 y7</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">FuncEq</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">fequal_post</span> :=
  <span class="kp">try</span> <span class="kp">solve</span> [ <span class="bp">reflexivity</span> ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [fequal_support_for_exist], implemented in [LibEqual], is meant</span>
<span class="sd">   to simplify goals of the form [exist _ _ = exist _ _ ] and</span>
<span class="sd">   [existT _ _ = existT _ _], by exploiting proof irrelevance. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">fequal_support_for_exist</span> tt :=
  <span class="kp">fail</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** For a n-ary tuple, [fequal], unlike [f_equal] enforces a recursive call</span>
<span class="sd">    on the (n-1)-ary tuple associated with the right component. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">fequal_base</span> :=
  <span class="kr">match goal with</span>
  | |- (_,_,_) = (_,_,_) =&gt;  <span class="nb">apply</span> args_eq_2; [ fequal_base | ]
  | |- _ =&gt; <span class="kp">first</span>
            [ fequal_support_for_exist tt
            | <span class="nb">apply</span> args_eq_1
            | <span class="nb">apply</span> args_eq_2
            | <span class="nb">apply</span> args_eq_3
            | <span class="nb">apply</span> args_eq_4
            | <span class="nb">apply</span> args_eq_5
            | <span class="nb">apply</span> args_eq_6
            | <span class="nb">apply</span> args_eq_7
            | <span class="nb">f_equal</span> <span class="c">(* fallback to Coq [f_equal] *)</span> ]
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;fequal&quot;</span> :=
  fequal_base; fequal_post.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [fequals] is the same as [fequal] except that it tries and solve</span>
<span class="sd">    all trivial subgoals, using [reflexivity] and [congruence]</span>
<span class="sd">    (as well as the proof-irrelevance principle).</span>
<span class="sd">    [fequals] applies to goals of the form [f x1 .. xN = f y1 .. yN]</span>
<span class="sd">    and produces some subgoals of the form [xi = yi]). *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">fequals_post</span> :=
  <span class="kp">try</span> <span class="kp">solve</span> [ <span class="bp">reflexivity</span> | <span class="bp">congruence</span> | <span class="nb">apply</span> proof_irrelevance ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;fequals&quot;</span> :=
  fequal; fequals_post.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [fequals_rec] calls [fequals] recursively.</span>
<span class="sd">    It is equivalent to [repeat (progress fequals)]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;fequals_rec&quot;</span> :=
  <span class="kp">repeat</span> (<span class="kp">progress</span> fequals).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

<span class="c">(* ################################################################# *)</span>
<span class="sd">(** * Inversion *)</span>

<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Basic Inversion *)</span>

<span class="sd">(** [invert keep H] is same to [inversion H] except that it puts all the</span>
<span class="sd">    facts obtained in the goal. The keyword [keep] means that the</span>
<span class="sd">    hypothesis [H] should not be removed. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;invert&quot;</span> <span class="s2">&quot;keep&quot;</span> hyp(H) :=
  <span class="nb">pose</span> ltac_mark; <span class="nb">inversion</span> H; gen_until_mark.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [invert keep H as X1 .. XN] is the same as [inversion H as ...] except</span>
<span class="sd">    that only hypotheses which are not variable need to be named</span>
<span class="sd">    explicitely, in a similar fashion as [introv] is used to name</span>
<span class="sd">    only hypotheses. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;invert&quot;</span> <span class="s2">&quot;keep&quot;</span> hyp(H) <span class="s2">&quot;as&quot;</span> simple_intropattern(I1) :=
  invert keep H; introv I1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;invert&quot;</span> <span class="s2">&quot;keep&quot;</span> hyp(H) <span class="s2">&quot;as&quot;</span> simple_intropattern(I1)
 simple_intropattern(I2) :=
  invert keep H; introv I1 I2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;invert&quot;</span> <span class="s2">&quot;keep&quot;</span> hyp(H) <span class="s2">&quot;as&quot;</span> simple_intropattern(I1)
 simple_intropattern(I2) simple_intropattern(I3) :=
  invert keep H; introv I1 I2 I3.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [invert H] is same to [inversion H] except that it puts all the</span>
<span class="sd">    facts obtained in the goal and clears hypothesis [H].</span>
<span class="sd">    In other words, it is equivalent to [invert keep H; clear H]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;invert&quot;</span> hyp(H) :=
  invert keep H; <span class="nb">clear</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [invert H as X1 .. XN] is the same as [invert keep H as X1 .. XN]</span>
<span class="sd">    but it also clears hypothesis [H]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;invert_tactic&quot;</span> hyp(H) tactic(tac) :=
  <span class="kr">let</span> <span class="nv">H&#39;</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span> <span class="nb">rename</span> H <span class="nb">into</span> H&#39;; tac H&#39;; <span class="nb">clear</span> H&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;invert&quot;</span> hyp(H) <span class="s2">&quot;as&quot;</span> simple_intropattern(I1) :=
  invert_tactic H (<span class="kr">fun</span> <span class="nv">H</span> =&gt; invert keep H <span class="kr">as</span> I1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;invert&quot;</span> hyp(H) <span class="s2">&quot;as&quot;</span> simple_intropattern(I1)
 simple_intropattern(I2) :=
  invert_tactic H (<span class="kr">fun</span> <span class="nv">H</span> =&gt; invert keep H <span class="kr">as</span> I1 I2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;invert&quot;</span> hyp(H) <span class="s2">&quot;as&quot;</span> simple_intropattern(I1)
 simple_intropattern(I2) simple_intropattern(I3) :=
  invert_tactic H (<span class="kr">fun</span> <span class="nv">H</span> =&gt; invert keep H <span class="kr">as</span> I1 I2 I3).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Inversion with Substitution *)</span>

<span class="sd">(** Our inversion tactics is able to get rid of dependent equalities</span>
<span class="sd">    generated by [inversion], using proof irrelevance. *)</span>

<span class="c">(* --we do not import Eqdep because it imports nasty hints automatically</span>
<span class="c">    From TLC Require Import Eqdep. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Axiom</span> <span class="nv">inj_pair2</span> :  <span class="c">(* is in fact derivable from the axioms in LibAxiom.v *)</span>
  <span class="kr">forall</span> (<span class="nv">U</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : U -&gt; <span class="kt">Type</span>) (<span class="nv">p</span> : U) (<span class="nv">x</span> <span class="nv">y</span> : P p),
  existT P p x = existT P p y -&gt; x = y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(* Proof using. apply Eqdep.EqdepTheory.inj_pair2. Qed. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">inverts_tactic</span> H i1 i2 i3 i4 i5 i6 :=
  <span class="kr">let rec</span> <span class="nv">go</span> <span class="nv">i1</span> <span class="nv">i2</span> <span class="nv">i3</span> <span class="nv">i4</span> <span class="nv">i5</span> <span class="nv">i6</span> :=
    <span class="kr">match goal with</span>
    | |- (ltac_Mark -&gt; _) =&gt; <span class="nb">intros</span> _
    | |- (<span class="nl">?x</span> = <span class="nl">?y</span> -&gt; _) =&gt; <span class="kr">let</span> <span class="nv">H</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span> <span class="nb">intro</span> H;
                           <span class="kp">first</span> [ <span class="nb">subst</span> x | <span class="nb">subst</span> y ];
                           go i1 i2 i3 i4 i5 i6
    | |- (existT <span class="nl">?P</span> <span class="nl">?p</span> <span class="nl">?x</span> = existT <span class="nl">?P</span> <span class="nl">?p</span> <span class="nl">?y</span> -&gt; _) =&gt;
         <span class="kr">let</span> <span class="nv">H</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span> <span class="nb">intro</span> H;
         <span class="nb">generalize</span> (@inj_pair2 _ P p x y H);
         <span class="nb">clear</span> H; go i1 i2 i3 i4 i5 i6
    | |- (<span class="nl">?P</span> -&gt; <span class="nl">?Q</span>) =&gt; i1; go i2 i3 i4 i5 i6 <span class="kp">ltac</span>:(<span class="nb">intro</span>)
    | |- (<span class="kr">forall</span> <span class="nv">_</span>, _) =&gt; <span class="nb">intro</span>; go i1 i2 i3 i4 i5 i6
    <span class="kr">end</span> <span class="kr">in</span>
  <span class="nb">generalize</span> ltac_mark; invert keep H; go i1 i2 i3 i4 i5 i6;
  <span class="nb">unfold</span> eq&#39; <span class="kr">in</span> *.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [inverts keep H] is same to [invert keep H] except that it</span>
<span class="sd">    applies [subst] to all the equalities generated by the inversion. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inverts&quot;</span> <span class="s2">&quot;keep&quot;</span> hyp(H) :=
  inverts_tactic H <span class="kp">ltac</span>:(<span class="nb">intro</span>) <span class="kp">ltac</span>:(<span class="nb">intro</span>) <span class="kp">ltac</span>:(<span class="nb">intro</span>)
                   <span class="kp">ltac</span>:(<span class="nb">intro</span>) <span class="kp">ltac</span>:(<span class="nb">intro</span>) <span class="kp">ltac</span>:(<span class="nb">intro</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [inverts keep H as X1 .. XN] is the same as</span>
<span class="sd">    [invert keep H as X1 .. XN] except that it applies [subst] to all the</span>
<span class="sd">    equalities generated by the inversion *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inverts&quot;</span> <span class="s2">&quot;keep&quot;</span> hyp(H) <span class="s2">&quot;as&quot;</span> simple_intropattern(I1) :=
  inverts_tactic H <span class="kp">ltac</span>:(<span class="nb">intros</span> I1)
   <span class="kp">ltac</span>:(<span class="nb">intro</span>) <span class="kp">ltac</span>:(<span class="nb">intro</span>) <span class="kp">ltac</span>:(<span class="nb">intro</span>) <span class="kp">ltac</span>:(<span class="nb">intro</span>) <span class="kp">ltac</span>:(<span class="nb">intro</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inverts&quot;</span> <span class="s2">&quot;keep&quot;</span> hyp(H) <span class="s2">&quot;as&quot;</span> simple_intropattern(I1)
 simple_intropattern(I2) :=
  inverts_tactic H <span class="kp">ltac</span>:(<span class="nb">intros</span> I1) <span class="kp">ltac</span>:(<span class="nb">intros</span> I2)
   <span class="kp">ltac</span>:(<span class="nb">intro</span>) <span class="kp">ltac</span>:(<span class="nb">intro</span>) <span class="kp">ltac</span>:(<span class="nb">intro</span>) <span class="kp">ltac</span>:(<span class="nb">intro</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inverts&quot;</span> <span class="s2">&quot;keep&quot;</span> hyp(H) <span class="s2">&quot;as&quot;</span> simple_intropattern(I1)
 simple_intropattern(I2) simple_intropattern(I3) :=
  inverts_tactic H <span class="kp">ltac</span>:(<span class="nb">intros</span> I1) <span class="kp">ltac</span>:(<span class="nb">intros</span> I2) <span class="kp">ltac</span>:(<span class="nb">intros</span> I3)
   <span class="kp">ltac</span>:(<span class="nb">intro</span>) <span class="kp">ltac</span>:(<span class="nb">intro</span>) <span class="kp">ltac</span>:(<span class="nb">intro</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inverts&quot;</span> <span class="s2">&quot;keep&quot;</span> hyp(H) <span class="s2">&quot;as&quot;</span> simple_intropattern(I1)
 simple_intropattern(I2) simple_intropattern(I3) simple_intropattern(I4) :=
  inverts_tactic H <span class="kp">ltac</span>:(<span class="nb">intros</span> I1) <span class="kp">ltac</span>:(<span class="nb">intros</span> I2) <span class="kp">ltac</span>:(<span class="nb">intros</span> I3)
   <span class="kp">ltac</span>:(<span class="nb">intros</span> I4) <span class="kp">ltac</span>:(<span class="nb">intro</span>) <span class="kp">ltac</span>:(<span class="nb">intro</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inverts&quot;</span> <span class="s2">&quot;keep&quot;</span> hyp(H) <span class="s2">&quot;as&quot;</span> simple_intropattern(I1)
 simple_intropattern(I2) simple_intropattern(I3) simple_intropattern(I4)
 simple_intropattern(I5) :=
  inverts_tactic H <span class="kp">ltac</span>:(<span class="nb">intros</span> I1) <span class="kp">ltac</span>:(<span class="nb">intros</span> I2) <span class="kp">ltac</span>:(<span class="nb">intros</span> I3)
   <span class="kp">ltac</span>:(<span class="nb">intros</span> I4) <span class="kp">ltac</span>:(<span class="nb">intros</span> I5) <span class="kp">ltac</span>:(<span class="nb">intro</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inverts&quot;</span> <span class="s2">&quot;keep&quot;</span> hyp(H) <span class="s2">&quot;as&quot;</span> simple_intropattern(I1)
 simple_intropattern(I2) simple_intropattern(I3) simple_intropattern(I4)
 simple_intropattern(I5) simple_intropattern(I6) :=
  inverts_tactic H <span class="kp">ltac</span>:(<span class="nb">intros</span> I1) <span class="kp">ltac</span>:(<span class="nb">intros</span> I2) <span class="kp">ltac</span>:(<span class="nb">intros</span> I3)
   <span class="kp">ltac</span>:(<span class="nb">intros</span> I4) <span class="kp">ltac</span>:(<span class="nb">intros</span> I5) <span class="kp">ltac</span>:(<span class="nb">intros</span> I6).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [inverts H] is same to [inverts keep H] except that it</span>
<span class="sd">    clears hypothesis [H]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inverts&quot;</span> hyp(H) :=
  inverts keep H; <span class="kp">try</span> <span class="nb">clear</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [inverts H as X1 .. XN] is the same as [inverts keep H as X1 .. XN]</span>
<span class="sd">    but it also clears the hypothesis [H]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inverts_tactic&quot;</span> hyp(H) tactic(tac) :=
  <span class="kr">let</span> <span class="nv">H&#39;</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span> <span class="nb">rename</span> H <span class="nb">into</span> H&#39;; tac H&#39;; <span class="nb">clear</span> H&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inverts&quot;</span> hyp(H) <span class="s2">&quot;as&quot;</span> simple_intropattern(I1) :=
  invert_tactic H (<span class="kr">fun</span> <span class="nv">H</span> =&gt; inverts keep H <span class="kr">as</span> I1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inverts&quot;</span> hyp(H) <span class="s2">&quot;as&quot;</span> simple_intropattern(I1)
 simple_intropattern(I2) :=
  invert_tactic H (<span class="kr">fun</span> <span class="nv">H</span> =&gt; inverts keep H <span class="kr">as</span> I1 I2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inverts&quot;</span> hyp(H) <span class="s2">&quot;as&quot;</span> simple_intropattern(I1)
 simple_intropattern(I2) simple_intropattern(I3) :=
  invert_tactic H (<span class="kr">fun</span> <span class="nv">H</span> =&gt; inverts keep H <span class="kr">as</span> I1 I2 I3).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inverts&quot;</span> hyp(H) <span class="s2">&quot;as&quot;</span> simple_intropattern(I1)
 simple_intropattern(I2) simple_intropattern(I3) simple_intropattern(I4) :=
  invert_tactic H (<span class="kr">fun</span> <span class="nv">H</span> =&gt; inverts keep H <span class="kr">as</span> I1 I2 I3 I4).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inverts&quot;</span> hyp(H) <span class="s2">&quot;as&quot;</span> simple_intropattern(I1)
 simple_intropattern(I2) simple_intropattern(I3) simple_intropattern(I4)
 simple_intropattern(I5) :=
  invert_tactic H (<span class="kr">fun</span> <span class="nv">H</span> =&gt; inverts keep H <span class="kr">as</span> I1 I2 I3 I4 I5).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inverts&quot;</span> hyp(H) <span class="s2">&quot;as&quot;</span> simple_intropattern(I1)
 simple_intropattern(I2) simple_intropattern(I3) simple_intropattern(I4)
 simple_intropattern(I5) simple_intropattern(I6) :=
  invert_tactic H (<span class="kr">fun</span> <span class="nv">H</span> =&gt; inverts keep H <span class="kr">as</span> I1 I2 I3 I4 I5 I6).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [inverts H as] performs an inversion on hypothesis [H], substitutes</span>
<span class="sd">    generated equalities, and put in the goal the other freshly-created</span>
<span class="sd">    hypotheses, for the user to name explicitly.</span>
<span class="sd">    [inverts keep H as] is the same except that it does not clear [H].</span>
<span class="sd">    --Note: maybe reimplement [inverts] above using this one *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">inverts_as_tactic</span> H :=
  <span class="kr">let rec</span> <span class="nv">go</span> <span class="nv">tt</span> :=
    <span class="kr">match goal with</span>
    | |- (ltac_Mark -&gt; _) =&gt; <span class="nb">intros</span> _
    | |- (<span class="nl">?x</span> = <span class="nl">?y</span> -&gt; _) =&gt; <span class="kr">let</span> <span class="nv">H</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span> <span class="nb">intro</span> H;
                           <span class="kp">first</span> [ <span class="nb">subst</span> x | <span class="nb">subst</span> y ];
                           go tt
    | |- (existT <span class="nl">?P</span> <span class="nl">?p</span> <span class="nl">?x</span> = existT <span class="nl">?P</span> <span class="nl">?p</span> <span class="nl">?y</span> -&gt; _) =&gt;
         <span class="kr">let</span> <span class="nv">H</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span> <span class="nb">intro</span> H;
         <span class="nb">generalize</span> (@inj_pair2 _ P p x y H);
         <span class="nb">clear</span> H; go tt
    | |- (<span class="kr">forall</span> <span class="nv">_</span>, _) =&gt;
       <span class="nb">intro</span>; <span class="kr">let</span> <span class="nv">H</span> := get_last_hyp tt <span class="kr">in</span> mark_to_generalize H; go tt
    <span class="kr">end</span> <span class="kr">in</span>
  <span class="nb">pose</span> ltac_mark; <span class="nb">inversion</span> H;
  <span class="nb">generalize</span> ltac_mark; gen_until_mark;
  go tt; gen_to_generalize; unfolds ltac_to_generalize;
  <span class="nb">unfold</span> eq&#39; <span class="kr">in</span> *.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inverts&quot;</span> <span class="s2">&quot;keep&quot;</span> hyp(H) <span class="s2">&quot;as&quot;</span> :=
  inverts_as_tactic H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inverts&quot;</span> hyp(H) <span class="s2">&quot;as&quot;</span> :=
  inverts_as_tactic H; <span class="nb">clear</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inverts&quot;</span> hyp(H) <span class="s2">&quot;as&quot;</span> simple_intropattern(I1)
 simple_intropattern(I2) simple_intropattern(I3) simple_intropattern(I4)
 simple_intropattern(I5) simple_intropattern(I6) simple_intropattern(I7) :=
  inverts H <span class="kr">as</span>; introv I1 I2 I3 I4 I5 I6 I7.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inverts&quot;</span> hyp(H) <span class="s2">&quot;as&quot;</span> simple_intropattern(I1)
 simple_intropattern(I2) simple_intropattern(I3) simple_intropattern(I4)
 simple_intropattern(I5) simple_intropattern(I6) simple_intropattern(I7)
 simple_intropattern(I8) :=
  inverts H <span class="kr">as</span>; introv I1 I2 I3 I4 I5 I6 I7 I8.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [lets_inverts E as I1 .. IN] is intuitively equivalent to</span>
<span class="sd">    [inverts E], with the difference that it applies to any</span>
<span class="sd">    expression and not just to the name of an hypothesis. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">lets_inverts_base</span> E cont :=
  <span class="kr">let</span> <span class="nv">H</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span> <span class="kr">let</span><span class="nv">s</span> <span class="nv">H</span>: E; <span class="kp">try</span> cont H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets_inverts&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="kr">let</span><span class="nv">s_inverts_base</span> <span class="nv">E</span> <span class="nv">ltac</span>:(<span class="kr">fun</span> <span class="nv">H</span> =&gt; inverts H).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets_inverts&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;as&quot;</span> simple_intropattern(I1) :=
  <span class="kr">let</span><span class="nv">s_inverts_base</span> <span class="nv">E</span> <span class="nv">ltac</span>:(<span class="kr">fun</span> <span class="nv">H</span> =&gt; inverts H <span class="kr">as</span> I1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets_inverts&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;as&quot;</span> simple_intropattern(I1)
 simple_intropattern(I2) :=
  <span class="kr">let</span><span class="nv">s_inverts_base</span> <span class="nv">E</span> <span class="nv">ltac</span>:(<span class="kr">fun</span> <span class="nv">H</span> =&gt; inverts H <span class="kr">as</span> I1 I2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets_inverts&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;as&quot;</span> simple_intropattern(I1)
 simple_intropattern(I2) simple_intropattern(I3) :=
  <span class="kr">let</span><span class="nv">s_inverts_base</span> <span class="nv">E</span> <span class="nv">ltac</span>:(<span class="kr">fun</span> <span class="nv">H</span> =&gt; inverts H <span class="kr">as</span> I1 I2 I3).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets_inverts&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;as&quot;</span> simple_intropattern(I1)
 simple_intropattern(I2) simple_intropattern(I3) simple_intropattern(I4) :=
  <span class="kr">let</span><span class="nv">s_inverts_base</span> <span class="nv">E</span> <span class="nv">ltac</span>:(<span class="kr">fun</span> <span class="nv">H</span> =&gt; inverts H <span class="kr">as</span> I1 I2 I3 I4).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Injection with Substitution *)</span>

<span class="sd">(** Underlying implementation of [injects] *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">injects_tactic</span> H :=
  <span class="kr">let rec</span> <span class="nv">go</span> <span class="nv">_</span> :=
    <span class="kr">match goal with</span>
    | |- (ltac_Mark -&gt; _) =&gt; <span class="nb">intros</span> _
    | |- (<span class="nl">?x</span> = <span class="nl">?y</span> -&gt; _) =&gt; <span class="kr">let</span> <span class="nv">H</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span> <span class="nb">intro</span> H;
                           <span class="kp">first</span> [ <span class="nb">subst</span> x | <span class="nb">subst</span> y | <span class="kp">idtac</span> ];
                           go tt
    <span class="kr">end</span> <span class="kr">in</span>
  <span class="nb">generalize</span> ltac_mark; <span class="nb">injection</span> H; go tt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [injects keep H] takes an hypothesis [H] of the form</span>
<span class="sd">    [C a1 .. aN = C b1 .. bN] and substitute all equalities</span>
<span class="sd">    [ai = bi] that have been generated. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;injects&quot;</span> <span class="s2">&quot;keep&quot;</span> hyp(H) :=
  injects_tactic H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [injects H] is similar to [injects keep H] but clears</span>
<span class="sd">    the hypothesis [H]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;injects&quot;</span> hyp(H) :=
  injects_tactic H; <span class="nb">clear</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [inject H as X1 .. XN] is the same as [injection]</span>
<span class="sd">    followed by [intros X1 .. XN] *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inject&quot;</span> hyp(H) :=
  <span class="nb">injection</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inject&quot;</span> hyp(H) <span class="s2">&quot;as&quot;</span> <span class="kn">ident</span>(X1) :=
  <span class="nb">injection</span> H; <span class="nb">intros</span> X1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inject&quot;</span> hyp(H) <span class="s2">&quot;as&quot;</span> <span class="kn">ident</span>(X1) <span class="kn">ident</span>(X2) :=
  <span class="nb">injection</span> H; <span class="nb">intros</span> X1 X2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inject&quot;</span> hyp(H) <span class="s2">&quot;as&quot;</span> <span class="kn">ident</span>(X1) <span class="kn">ident</span>(X2) <span class="kn">ident</span>(X3) :=
  <span class="nb">injection</span> H; <span class="nb">intros</span> X1 X2 X3.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inject&quot;</span> hyp(H) <span class="s2">&quot;as&quot;</span> <span class="kn">ident</span>(X1) <span class="kn">ident</span>(X2) <span class="kn">ident</span>(X3)
 <span class="kn">ident</span>(X4) :=
  <span class="nb">injection</span> H; <span class="nb">intros</span> X1 X2 X3 X4.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inject&quot;</span> hyp(H) <span class="s2">&quot;as&quot;</span> <span class="kn">ident</span>(X1) <span class="kn">ident</span>(X2) <span class="kn">ident</span>(X3)
 <span class="kn">ident</span>(X4) <span class="kn">ident</span>(X5) :=
  <span class="nb">injection</span> H; <span class="nb">intros</span> X1 X2 X3 X4 X5.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Inversion and Injection with Substitution --rough implementation *)</span>

<span class="sd">(** The tactics [inversions] and [injections] provided in this section</span>
<span class="sd">    are similar to [inverts] and [injects] except that they perform</span>
<span class="sd">    substitution on all equalities from the context and not only</span>
<span class="sd">    the ones freshly generated. The counterpart is that they have</span>
<span class="sd">    simpler implementations.</span>

<span class="sd">    DEPRECATED: these tactics should no longer be used. *)</span>

<span class="sd">(** [inversions keep H] is the same as [inversions H] but it does</span>
<span class="sd">    not clear hypothesis [H]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inversions&quot;</span> <span class="s2">&quot;keep&quot;</span> hyp(H) :=
  <span class="nb">inversion</span> H; <span class="nb">subst</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [inversions H] is a shortcut for [inversion H] followed by [subst]</span>
<span class="sd">    and [clear H].</span>
<span class="sd">    It is a rough implementation of [inverts keep H] which behave</span>
<span class="sd">    badly when the proof context already contains equalities.</span>
<span class="sd">    It is provided in case the better implementation turns out to be</span>
<span class="sd">    too slow. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inversions&quot;</span> hyp(H) :=
  <span class="nb">inversion</span> H; <span class="nb">subst</span>; <span class="kp">try</span> <span class="nb">clear</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [injections keep H] is the same as [injection H] followed</span>
<span class="sd">    by [intros] and [subst]. It is a rough implementation of</span>
<span class="sd">    [injects keep H] which behave</span>
<span class="sd">    badly when the proof context already contains equalities,</span>
<span class="sd">    or when the goal starts with a forall or an implication. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;injections&quot;</span> <span class="s2">&quot;keep&quot;</span> hyp(H) :=
  <span class="nb">injection</span> H; <span class="nb">intros</span>; <span class="nb">subst</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [injections H] is the same as [injection H] followed</span>
<span class="sd">    by [clear H] and [intros] and [subst]. It is a rough</span>
<span class="sd">    implementation of [injects keep H] which behave</span>
<span class="sd">    badly when the proof context already contains equalities,</span>
<span class="sd">    or when the goal starts with a forall or an implication. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;injections&quot;</span> <span class="s2">&quot;keep&quot;</span> hyp(H) :=
  <span class="nb">injection</span> H; <span class="nb">clear</span> H; <span class="nb">intros</span>; <span class="nb">subst</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Case Analysis *)</span>

<span class="sd">(** [cases] is similar to [case_eq E] except that it generates the</span>
<span class="sd">    equality in the context and not in the goal, and generates the</span>
<span class="sd">    equality the other way round. The syntax [cases E as H]</span>
<span class="sd">    allows specifying the name [H] of that hypothesis. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cases&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;as&quot;</span> <span class="kn">ident</span>(H) :=
  <span class="kr">let</span> <span class="nv">X</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span>
  <span class="nb">set</span> (X := E) <span class="kr">in</span> *; def_to_eq_sym X H E;
  <span class="nb">destruct</span> X.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cases&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="kr">let</span> <span class="nv">H</span> := <span class="kp">fresh</span> <span class="s2">&quot;Eq&quot;</span> <span class="kr">in</span> cases E <span class="kr">as</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [case_if_post H] is to be defined later as a tactic to clean</span>
<span class="sd">    up hypothesis [H] and the goal.</span>
<span class="sd">    By defaults, it looks for obvious contradictions.</span>
<span class="sd">    Currently, this tactic is extended in LibReflect to clean up</span>
<span class="sd">    boolean propositions. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">case_if_post</span> H :=
  tryfalse.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [case_if] looks for a pattern of the form [if ?B then ?E1 else ?E2]</span>
<span class="sd">    in the goal, and perform a case analysis on [B] by calling</span>
<span class="sd">    [destruct B]. Subgoals containing a contradiction are discarded.</span>
<span class="sd">    [case_if] looks in the goal first, and otherwise in the</span>
<span class="sd">    first hypothesis that contains an [if] statement.</span>
<span class="sd">    [case_if in H] can be used to specify which hypothesis to consider.</span>
<span class="sd">    Syntaxes [case_if as Eq] and [case_if in H as Eq] allows to name</span>
<span class="sd">    the hypothesis coming from the case analysis. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">case_if_on_tactic_core</span> E Eq :=
  <span class="kr">match</span> <span class="kp">type of</span> E <span class="kr">with</span>
  | {_}+{_} =&gt; <span class="nb">destruct</span> E <span class="kr">as</span> [Eq | Eq]
  | _ =&gt; <span class="kr">let</span> <span class="nv">X</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span>
         sets_eq &lt;- X Eq: E;
         <span class="nb">destruct</span> X
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">case_if_on_tactic</span> E Eq :=
  case_if_on_tactic_core E Eq; case_if_post Eq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;case_if_on&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;as&quot;</span> simple_intropattern(Eq) :=
  case_if_on_tactic E Eq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;case_if&quot;</span> <span class="s2">&quot;as&quot;</span> simple_intropattern(Eq) :=
  <span class="kr">match goal with</span>
  | |- <span class="kp">context</span> [<span class="kr">if</span> <span class="nl">?B</span> <span class="kr">then</span> _ <span class="kr">else</span> _] =&gt; case_if_on B <span class="kr">as</span> Eq
  | K: <span class="kp">context</span> [<span class="kr">if</span> <span class="nl">?B</span> <span class="kr">then</span> _ <span class="kr">else</span> _] |- _ =&gt; case_if_on B <span class="kr">as</span> Eq
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;case_if&quot;</span> <span class="s2">&quot;in&quot;</span> hyp(H) <span class="s2">&quot;as&quot;</span> simple_intropattern(Eq) :=
  <span class="kr">match</span> <span class="kp">type of</span> H <span class="kr">with</span> <span class="kp">context</span> [<span class="kr">if</span> <span class="nl">?B</span> <span class="kr">then</span> _ <span class="kr">else</span> _] =&gt;
    case_if_on B <span class="kr">as</span> Eq <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;case_if&quot;</span> :=
  <span class="kr">let</span> <span class="nv">Eq</span> := <span class="kp">fresh</span> <span class="s2">&quot;C&quot;</span> <span class="kr">in</span> case_if <span class="kr">as</span> Eq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;case_if&quot;</span> <span class="s2">&quot;in&quot;</span> hyp(H) :=
  <span class="kr">let</span> <span class="nv">Eq</span> := <span class="kp">fresh</span> <span class="s2">&quot;C&quot;</span> <span class="kr">in</span> case_if <span class="kr">in</span> H <span class="kr">as</span> Eq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [cases_if] is similar to [case_if] with two main differences:</span>
<span class="sd">    if it creates an equality of the form [x = y] and then</span>
<span class="sd">    substitutes it in the goal *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">cases_if_on_tactic_core</span> E Eq :=
  <span class="kr">match</span> <span class="kp">type of</span> E <span class="kr">with</span>
  | {_}+{_} =&gt; <span class="nb">destruct</span> E <span class="kr">as</span> [Eq|Eq]; <span class="kp">try</span> subst_hyp Eq
  | _ =&gt; <span class="kr">let</span> <span class="nv">X</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span>
         sets_eq &lt;- X Eq: E;
         <span class="nb">destruct</span> X
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">cases_if_on_tactic</span> E Eq :=
  cases_if_on_tactic_core E Eq; tryfalse; case_if_post Eq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cases_if_on&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;as&quot;</span> simple_intropattern(Eq) :=
  cases_if_on_tactic E Eq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cases_if&quot;</span> <span class="s2">&quot;as&quot;</span> simple_intropattern(Eq) :=
  <span class="kr">match goal with</span>
  | |- <span class="kp">context</span> [<span class="kr">if</span> <span class="nl">?B</span> <span class="kr">then</span> _ <span class="kr">else</span> _] =&gt; cases_if_on B <span class="kr">as</span> Eq
  | K: <span class="kp">context</span> [<span class="kr">if</span> <span class="nl">?B</span> <span class="kr">then</span> _ <span class="kr">else</span> _] |- _ =&gt; cases_if_on B <span class="kr">as</span> Eq
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cases_if&quot;</span> <span class="s2">&quot;in&quot;</span> hyp(H) <span class="s2">&quot;as&quot;</span> simple_intropattern(Eq) :=
  <span class="kr">match</span> <span class="kp">type of</span> H <span class="kr">with</span> <span class="kp">context</span> [<span class="kr">if</span> <span class="nl">?B</span> <span class="kr">then</span> _ <span class="kr">else</span> _] =&gt;
    cases_if_on B <span class="kr">as</span> Eq <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cases_if&quot;</span> :=
  <span class="kr">let</span> <span class="nv">Eq</span> := <span class="kp">fresh</span> <span class="s2">&quot;C&quot;</span> <span class="kr">in</span> cases_if <span class="kr">as</span> Eq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cases_if&quot;</span> <span class="s2">&quot;in&quot;</span> hyp(H) :=
  <span class="kr">let</span> <span class="nv">Eq</span> := <span class="kp">fresh</span> <span class="s2">&quot;C&quot;</span> <span class="kr">in</span> cases_if <span class="kr">in</span> H <span class="kr">as</span> Eq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [case_ifs] is like [repeat case_if] *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">case_ifs_core</span> :=
  <span class="kp">repeat</span> case_if.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;case_ifs&quot;</span> :=
  case_ifs_core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [destruct_if] looks for a pattern of the form [if ?B then ?E1 else ?E2]</span>
<span class="sd">    in the goal, and perform a case analysis on [B] by calling</span>
<span class="sd">    [destruct B]. It looks in the goal first, and otherwise in the</span>
<span class="sd">    first hypothesis that contains an [if] statement. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">destruct_if_post</span> := tryfalse.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;destruct_if&quot;</span>
 <span class="s2">&quot;as&quot;</span> simple_intropattern(Eq1) simple_intropattern(Eq2) :=
  <span class="kr">match goal with</span>
  | |- <span class="kp">context</span> [<span class="kr">if</span> <span class="nl">?B</span> <span class="kr">then</span> _ <span class="kr">else</span> _] =&gt; <span class="nb">destruct</span> B <span class="kr">as</span> [Eq1|Eq2]
  | K: <span class="kp">context</span> [<span class="kr">if</span> <span class="nl">?B</span> <span class="kr">then</span> _ <span class="kr">else</span> _] |- _ =&gt; <span class="nb">destruct</span> B <span class="kr">as</span> [Eq1|Eq2]
  <span class="kr">end</span>;
  destruct_if_post.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;destruct_if&quot;</span> <span class="s2">&quot;in&quot;</span> hyp(H)
 <span class="s2">&quot;as&quot;</span> simple_intropattern(Eq1) simple_intropattern(Eq2) :=
  <span class="kr">match</span> <span class="kp">type of</span> H <span class="kr">with</span> <span class="kp">context</span> [<span class="kr">if</span> <span class="nl">?B</span> <span class="kr">then</span> _ <span class="kr">else</span> _] =&gt;
    <span class="nb">destruct</span> B <span class="kr">as</span> [Eq1|Eq2] <span class="kr">end</span>;
  destruct_if_post.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;destruct_if&quot;</span> <span class="s2">&quot;as&quot;</span> simple_intropattern(Eq) :=
  destruct_if <span class="kr">as</span> Eq Eq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;destruct_if&quot;</span> <span class="s2">&quot;in&quot;</span> hyp(H) <span class="s2">&quot;as&quot;</span> simple_intropattern(Eq) :=
  destruct_if <span class="kr">in</span> H <span class="kr">as</span> Eq Eq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;destruct_if&quot;</span> :=
  <span class="kr">let</span> <span class="nv">Eq</span> := <span class="kp">fresh</span> <span class="s2">&quot;C&quot;</span> <span class="kr">in</span> destruct_if <span class="kr">as</span> Eq Eq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;destruct_if&quot;</span> <span class="s2">&quot;in&quot;</span> hyp(H) :=
  <span class="kr">let</span> <span class="nv">Eq</span> := <span class="kp">fresh</span> <span class="s2">&quot;C&quot;</span> <span class="kr">in</span> destruct_if <span class="kr">in</span> H <span class="kr">as</span> Eq Eq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [cases&#39;] is provided for compatibility with [remember]. *)</span>

<span class="sd">(** [cases&#39; E] is similar to [case_eq E] except that it generates the</span>
<span class="sd">    equality in the context and not in the goal. The syntax [cases&#39; E as H]</span>
<span class="sd">    allows specifying the name [H] of that hypothesis. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cases&#39;&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;as&quot;</span> <span class="kn">ident</span>(H) :=
  <span class="kr">let</span> <span class="nv">X</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span>
  <span class="nb">set</span> (X := E) <span class="kr">in</span> *; def_to_eq X H E;
  <span class="nb">destruct</span> X.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cases&#39;&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="kr">let</span> <span class="nv">x</span> := <span class="kp">fresh</span> <span class="s2">&quot;Eq&quot;</span> <span class="kr">in</span> cases&#39; E <span class="kr">as</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [cases_if&#39;] is similar to [cases_if] except that it generates</span>
<span class="sd">    the symmetric equality. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">cases_if_on&#39;</span> E Eq :=
  <span class="kr">match</span> <span class="kp">type of</span> E <span class="kr">with</span>
  | {_}+{_} =&gt; <span class="nb">destruct</span> E <span class="kr">as</span> [Eq|Eq]; <span class="kp">try</span> subst_hyp Eq
  | _ =&gt; <span class="kr">let</span> <span class="nv">X</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span>
         sets_eq X Eq: E;
         <span class="nb">destruct</span> X
  <span class="kr">end</span>; case_if_post Eq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cases_if&#39;&quot;</span> <span class="s2">&quot;as&quot;</span> simple_intropattern(Eq) :=
  <span class="kr">match goal with</span>
  | |- <span class="kp">context</span> [<span class="kr">if</span> <span class="nl">?B</span> <span class="kr">then</span> _ <span class="kr">else</span> _] =&gt; cases_if_on&#39; B Eq
  | K: <span class="kp">context</span> [<span class="kr">if</span> <span class="nl">?B</span> <span class="kr">then</span> _ <span class="kr">else</span> _] |- _ =&gt; cases_if_on&#39; B Eq
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cases_if&#39;&quot;</span> :=
  <span class="kr">let</span> <span class="nv">Eq</span> := <span class="kp">fresh</span> <span class="s2">&quot;C&quot;</span> <span class="kr">in</span> cases_if&#39; <span class="kr">as</span> Eq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ################################################################# *)</span>
<span class="sd">(** * Induction *)</span>

<span class="sd">(** [inductions E] is a shorthand for [dependent induction E].</span>
<span class="sd">    [inductions E gen X1 .. XN] is a shorthand for</span>
<span class="sd">    [dependent induction E generalizing X1 .. XN]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Program.Equality.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">inductions_post</span> :=
  <span class="nb">unfold</span> eq&#39; <span class="kr">in</span> *.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inductions&quot;</span> <span class="kn">ident</span>(E) :=
  <span class="nb">dependent induction</span> E; inductions_post.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inductions&quot;</span> <span class="kn">ident</span>(E) <span class="s2">&quot;gen&quot;</span> <span class="kn">ident</span>(X1) :=
  <span class="nb">dependent induction</span> E <span class="nb">generalizing</span> X1; inductions_post.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inductions&quot;</span> <span class="kn">ident</span>(E) <span class="s2">&quot;gen&quot;</span> <span class="kn">ident</span>(X1) <span class="kn">ident</span>(X2) :=
  <span class="nb">dependent induction</span> E <span class="nb">generalizing</span> X1 X2; inductions_post.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inductions&quot;</span> <span class="kn">ident</span>(E) <span class="s2">&quot;gen&quot;</span> <span class="kn">ident</span>(X1) <span class="kn">ident</span>(X2)
 <span class="kn">ident</span>(X3) :=
  <span class="nb">dependent induction</span> E <span class="nb">generalizing</span> X1 X2 X3; inductions_post.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inductions&quot;</span> <span class="kn">ident</span>(E) <span class="s2">&quot;gen&quot;</span> <span class="kn">ident</span>(X1) <span class="kn">ident</span>(X2)
 <span class="kn">ident</span>(X3) <span class="kn">ident</span>(X4) :=
  <span class="nb">dependent induction</span> E <span class="nb">generalizing</span> X1 X2 X3 X4; inductions_post.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inductions&quot;</span> <span class="kn">ident</span>(E) <span class="s2">&quot;gen&quot;</span> <span class="kn">ident</span>(X1) <span class="kn">ident</span>(X2)
 <span class="kn">ident</span>(X3) <span class="kn">ident</span>(X4) <span class="kn">ident</span>(X5) :=
  <span class="nb">dependent induction</span> E <span class="nb">generalizing</span> X1 X2 X3 X4 X5; inductions_post.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inductions&quot;</span> <span class="kn">ident</span>(E) <span class="s2">&quot;gen&quot;</span> <span class="kn">ident</span>(X1) <span class="kn">ident</span>(X2)
 <span class="kn">ident</span>(X3) <span class="kn">ident</span>(X4) <span class="kn">ident</span>(X5) <span class="kn">ident</span>(X6) :=
  <span class="nb">dependent induction</span> E <span class="nb">generalizing</span> X1 X2 X3 X4 X5 X6; inductions_post.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inductions&quot;</span> <span class="kn">ident</span>(E) <span class="s2">&quot;gen&quot;</span> <span class="kn">ident</span>(X1) <span class="kn">ident</span>(X2)
 <span class="kn">ident</span>(X3) <span class="kn">ident</span>(X4) <span class="kn">ident</span>(X5) <span class="kn">ident</span>(X6) <span class="kn">ident</span>(X7) :=
  <span class="nb">dependent induction</span> E <span class="nb">generalizing</span> X1 X2 X3 X4 X5 X6 X7; inductions_post.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inductions&quot;</span> <span class="kn">ident</span>(E) <span class="s2">&quot;gen&quot;</span> <span class="kn">ident</span>(X1) <span class="kn">ident</span>(X2)
 <span class="kn">ident</span>(X3) <span class="kn">ident</span>(X4) <span class="kn">ident</span>(X5) <span class="kn">ident</span>(X6) <span class="kn">ident</span>(X7) <span class="kn">ident</span>(X8) :=
  <span class="nb">dependent induction</span> E <span class="nb">generalizing</span> X1 X2 X3 X4 X5 X6 X7 X8; inductions_post.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [induction_wf IH: E X] is used to apply the well-founded induction</span>
<span class="sd">    principle, for a given well-founded relation. It applies to a goal</span>
<span class="sd">    [PX] where [PX] is a proposition on [X]. First, it sets up the</span>
<span class="sd">    goal in the form [(fun a =&gt; P a) X], using [pattern X], and then</span>
<span class="sd">    it applies the well-founded induction principle instantiated on [E].</span>

<span class="sd">    Here [E] may be either:</span>
<span class="sd">   - a proof of [wf R] for [R] of type [A-&gt;A-&gt;Prop]</span>
<span class="sd">   - a binary relation of type [A-&gt;A-&gt;Prop]</span>
<span class="sd">   - a measure of type [A -&gt; nat] // only when LibWf is used. *)</span>

<span class="c">(* DEPRECATED</span>
<span class="c">Tactic Notation &quot;induction_wf&quot; ident(IH) &quot;:&quot; constr(E) ident(X) :=</span>
<span class="c">  pattern X; apply (well_founded_ind E); clear X; intros X IH.</span>
<span class="c">*)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">induction_wf_process_wf_hyp</span> tt := <span class="c">(* refined in LibWf *)</span>
  <span class="kp">idtac</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">induction_wf_process_measure</span> E := <span class="c">(* refined in LibWf *)</span>
  <span class="kp">fail</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">induction_wf_core_then</span> IH E X cont :=
  <span class="kr">let</span> <span class="nv">clearX</span> <span class="nv">tt</span> :=
    <span class="kp">first</span> [ <span class="nb">clear</span> X | <span class="kp">fail</span> <span class="mi">3</span> <span class="s2">&quot;the variable on which the induction is done appears in the hypotheses&quot;</span> ] <span class="kr">in</span>
  <span class="nb">pattern</span> X;
  <span class="kp">first</span> [ <span class="nb">eapply</span> (@well_founded_ind _ E)
        | <span class="nb">eapply</span> (@well_founded_ind _ (E _))
        | <span class="nb">eapply</span> (@well_founded_ind _ (E _ _))
        | <span class="nb">eapply</span> (@well_founded_ind _ (E _ _ _))
        | induction_wf_process_measure E
        | applys well_founded_ind E ];
  clearX tt;
  <span class="kp">first</span> [ induction_wf_process_wf_hyp tt
        | <span class="nb">intros</span> X IH; cont tt ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">induction_wf_core</span> IH E X :=
  induction_wf_core_then IH E X <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="kp">idtac</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;induction_wf&quot;</span> <span class="kn">ident</span>(IH) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) <span class="kn">ident</span>(X) :=
  induction_wf_core IH E X.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Induction on the height of a derivation: the helper tactic</span>
<span class="sd">    [induct_height] helps proving the equivalence of the auxiliary</span>
<span class="sd">    judgment that includes a counter for the maximal height</span>
<span class="sd">    (see LibTacticsDemos for an example) *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Arith.Compare_dec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.micromega.Lia.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk48"><span class="kn">Lemma</span> <span class="nf">induct_height_max2</span> : <span class="kr">forall</span> <span class="nv">n1</span> <span class="nv">n2</span> : nat,
  <span class="kr">exists</span> <span class="nv">n</span>, n1 &lt; n /\ n2 &lt; n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n1</span> <span class="nv">n2</span> : nat, <span class="kr">exists</span> <span class="nv">n</span> : nat, n1 &lt; n /\ n2 &lt; n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk49"><span class="kn">Proof using</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n1</span> <span class="nv">n2</span> : nat, <span class="kr">exists</span> <span class="nv">n</span> : nat, n1 &lt; n /\ n2 &lt; n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk4a"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">n</span> : nat, n1 &lt; n /\ n2 &lt; n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk4b"><span class="nb">destruct</span> (lt_dec n1 n2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>n1 &lt; n2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">n</span> : nat, n1 &lt; n /\ n2 &lt; n</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="libtactics-v-chk4c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>~ n1 &lt; n2</span></span></span><br></div><label class="goal-separator" for="libtactics-v-chk4c"><hr></label><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">n</span> : nat, n1 &lt; n /\ n2 &lt; n</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk4d"><span class="kr">exists</span> (<span class="nv">S</span> <span class="nv">n2</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>n1 &lt; n2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n1 &lt; S n2 /\ n2 &lt; S n2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="libtactics-v-chk4e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>~ n1 &lt; n2</span></span></span><br></div><label class="goal-separator" for="libtactics-v-chk4e"><hr></label><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">n</span> : nat, n1 &lt; n /\ n2 &lt; n</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk4f"><span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>~ n1 &lt; n2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">n</span> : nat, n1 &lt; n /\ n2 &lt; n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk50"><span class="kr">exists</span> (<span class="nv">S</span> <span class="nv">n1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>~ n1 &lt; n2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n1 &lt; S n1 /\ n2 &lt; S n1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">induct_height_step</span> x :=
  <span class="kr">match goal with</span>
  | H: <span class="kr">exists</span> <span class="nv">_</span>, _ |- _ =&gt;
     <span class="kr">let</span> <span class="nv">n</span> := <span class="kp">fresh</span> <span class="s2">&quot;n&quot;</span> <span class="kr">in</span> <span class="kr">let</span> <span class="nv">y</span> := <span class="kp">fresh</span> <span class="s2">&quot;x&quot;</span> <span class="kr">in</span>
     <span class="nb">destruct</span> H <span class="kr">as</span> [n ?];
     forwards (y&amp;?&amp;?): induct_height_max2 n x;
     induct_height_step y
  | _ =&gt; <span class="kr">exists</span> (<span class="nv">S</span> <span class="nv">x</span>); <span class="nb">eauto</span>
 <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">induct_height</span> := induct_height_step O.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ################################################################# *)</span>
<span class="sd">(** * Coinduction *)</span>

<span class="sd">(** Tactic [cofixs IH] is like [cofix IH] except that the</span>
<span class="sd">    coinduction hypothesis is tagged in the form [IH: COIND P]</span>
<span class="sd">    instead of being just [IH: P]. This helps other tactics</span>
<span class="sd">    clearing the coinduction hypothesis using [clear_coind] *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">COIND</span> (<span class="nv">P</span>:<span class="kt">Prop</span>) := P.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cofixs&quot;</span> <span class="kn">ident</span>(IH) :=
  <span class="kr">cofix</span> IH;
  <span class="kr">match</span> <span class="kp">type of</span> IH <span class="kr">with</span> <span class="nl">?P</span> =&gt; <span class="nb">change</span> P <span class="kr">with</span> (COIND P) <span class="kr">in</span> IH <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Tactic [clear_coind] clears all the coinduction hypotheses,</span>
<span class="sd">    assuming that they have been tagged *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">clear_coind</span> :=
  <span class="kp">repeat</span> <span class="kr">match goal with</span> H: COIND _ |- _ =&gt; <span class="nb">clear</span> H <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Tactic [abstracts tac] is like [abstract tac] except that</span>
<span class="sd">    it clears the coinduction hypotheses so that the productivity</span>
<span class="sd">    check will be happy. For example, one can use [abstracts lia]</span>
<span class="sd">    to obtain the same behavior as [lia] but with an auxiliary</span>
<span class="sd">    lemma being generated. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;abstracts&quot;</span> tactic(tac) :=
  clear_coind; tac.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

<span class="c">(* ################################################################# *)</span>
<span class="sd">(** * Decidable Equality *)</span>

<span class="sd">(** [decides_equality] is the same as [decide equality] excepts that it</span>
<span class="sd">    is able to unfold definitions at head of the current goal. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">decides_equality_tactic</span> :=
  <span class="kp">first</span> [ <span class="bp">decide equality</span> | <span class="kp">progress</span>(unfolds); decides_equality_tactic ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;decides_equality&quot;</span> :=
  decides_equality_tactic.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ################################################################# *)</span>
<span class="sd">(** * Equivalence *)</span>

<span class="sd">(** [iff H] can be used to prove an equivalence [P &lt;-&gt; Q] and name [H]</span>
<span class="sd">    the hypothesis obtained in each case. The syntaxes [iff] and [iff H1 H2]</span>
<span class="sd">    are also available to specify zero or two names. The tactic [iff &lt;- H]</span>
<span class="sd">    swaps the two subgoals, i.e. produces (Q -&gt; P) as first subgoal. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk51"><span class="kn">Lemma</span> <span class="nf">iff_intro_swap</span> : <span class="kr">forall</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>),
  (Q -&gt; P) -&gt; (P -&gt; Q) -&gt; (P &lt;-&gt; Q).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>, (Q -&gt; P) -&gt; (P -&gt; Q) -&gt; P &lt;-&gt; Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk52"><span class="kn">Proof using</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>, (Q -&gt; P) -&gt; (P -&gt; Q) -&gt; P &lt;-&gt; Q</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intuition</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;iff&quot;</span> simple_intropattern(H1) simple_intropattern(H2) :=
  <span class="nb">split</span>; [ <span class="nb">intros</span> H1 | <span class="nb">intros</span> H2 ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;iff&quot;</span> simple_intropattern(H) :=
  iff H H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;iff&quot;</span> :=
  <span class="kr">let</span> <span class="nv">H</span> := <span class="kp">fresh</span> <span class="s2">&quot;H&quot;</span> <span class="kr">in</span> iff H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;iff&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> simple_intropattern(H1) simple_intropattern(H2) :=
  <span class="nb">apply</span> iff_intro_swap; [ <span class="nb">intros</span> H1 | <span class="nb">intros</span> H2 ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;iff&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> simple_intropattern(H) :=
  iff &lt;- H H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;iff&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> :=
  <span class="kr">let</span> <span class="nv">H</span> := <span class="kp">fresh</span> <span class="s2">&quot;H&quot;</span> <span class="kr">in</span> iff &lt;- H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ################################################################# *)</span>
<span class="sd">(** * N-ary Conjunctions and Disjunctions *)</span>

<span class="sd">(** N-ary Conjunctions Splitting in Goals *)</span>

<span class="sd">(** Underlying implementation of [splits]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">splits_tactic</span> N :=
  <span class="kr">match</span> N <span class="kr">with</span>
  | O =&gt; <span class="kp">fail</span>
  | S O =&gt; <span class="kp">idtac</span>
  | S <span class="nl">?N&#39;</span> =&gt; <span class="nb">split</span>; [| splits_tactic N&#39;]
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">unfold_goal_until_conjunction</span> :=
  <span class="kr">match goal with</span>
  | |- _ /\ _ =&gt; <span class="kp">idtac</span>
  | _ =&gt; <span class="kp">progress</span>(unfolds); unfold_goal_until_conjunction
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">get_term_conjunction_arity</span> T :=
  <span class="kr">match</span> T <span class="kr">with</span>
  | _ /\ _ /\ _ /\ _ /\ _ /\ _ /\ _ /\ _ =&gt; <span class="kp">constr</span>:(<span class="mi">8</span>)
  | _ /\ _ /\ _ /\ _ /\ _ /\ _ /\ _ =&gt; <span class="kp">constr</span>:(<span class="mi">7</span>)
  | _ /\ _ /\ _ /\ _ /\ _ /\ _ =&gt; <span class="kp">constr</span>:(<span class="mi">6</span>)
  | _ /\ _ /\ _ /\ _ /\ _ =&gt; <span class="kp">constr</span>:(<span class="mi">5</span>)
  | _ /\ _ /\ _ /\ _ =&gt; <span class="kp">constr</span>:(<span class="mi">4</span>)
  | _ /\ _ /\ _ =&gt; <span class="kp">constr</span>:(<span class="mi">3</span>)
  | _ /\ _ =&gt; <span class="kp">constr</span>:(<span class="mi">2</span>)
  | _ -&gt; <span class="nl">?T&#39;</span> =&gt; get_term_conjunction_arity T&#39;
  | _ =&gt; <span class="kr">let</span> <span class="nv">P</span> := get_head T <span class="kr">in</span>
         <span class="kr">let</span> <span class="nv">T&#39;</span> := <span class="kp">eval</span> <span class="nb">unfold</span> P <span class="kr">in</span> T <span class="kr">in</span>
         <span class="kr">match</span> T&#39; <span class="kr">with</span>
         | T =&gt; <span class="kp">fail</span> <span class="mi">1</span>
         | _ =&gt; get_term_conjunction_arity T&#39;
         <span class="kr">end</span>
         <span class="c">(* --todo: warning this can loop... *)</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">get_goal_conjunction_arity</span> :=
  <span class="kr">match goal with</span> |- <span class="nl">?T</span> =&gt; get_term_conjunction_arity T <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [splits] applies to a goal of the form [(T1 /\ .. /\ TN)] and</span>
<span class="sd">    destruct it into [N] subgoals [T1] .. [TN]. If the goal is not a</span>
<span class="sd">    conjunction, then it unfolds the head definition. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;splits&quot;</span> :=
  unfold_goal_until_conjunction;
  <span class="kr">let</span> <span class="nv">N</span> := get_goal_conjunction_arity <span class="kr">in</span>
  splits_tactic N.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [splits N] is similar to [splits], except that it will unfold as many</span>
<span class="sd">    definitions as necessary to obtain an [N]-ary conjunction. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;splits&quot;</span> <span class="kp">constr</span>(N) :=
  <span class="kr">let</span> <span class="nv">N</span> := number_to_nat N <span class="kr">in</span>
  splits_tactic N.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** N-ary Conjunctions Deconstruction *)</span>

<span class="sd">(** Underlying implementation of [destructs]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">destructs_conjunction_tactic</span> N T :=
  <span class="kr">match</span> N <span class="kr">with</span>
  | <span class="mi">2</span> =&gt; <span class="nb">destruct</span> T <span class="kr">as</span> [? ?]
  | <span class="mi">3</span> =&gt; <span class="nb">destruct</span> T <span class="kr">as</span> [? [? ?]]
  | <span class="mi">4</span> =&gt; <span class="nb">destruct</span> T <span class="kr">as</span> [? [? [? ?]]]
  | <span class="mi">5</span> =&gt; <span class="nb">destruct</span> T <span class="kr">as</span> [? [? [? [? ?]]]]
  | <span class="mi">6</span> =&gt; <span class="nb">destruct</span> T <span class="kr">as</span> [? [? [? [? [? ?]]]]]
  | <span class="mi">7</span> =&gt; <span class="nb">destruct</span> T <span class="kr">as</span> [? [? [? [? [? [? ?]]]]]]
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [destructs T] allows destructing a term [T] which is a N-ary</span>
<span class="sd">    conjunction. It is equivalent to [destruct T as (H1 .. HN)],</span>
<span class="sd">    except that it does not require to manually specify N different</span>
<span class="sd">    names. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;destructs&quot;</span> <span class="kp">constr</span>(T) :=
  <span class="kr">let</span> <span class="nv">TT</span> := <span class="kp">type of</span> T <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">N</span> := get_term_conjunction_arity TT <span class="kr">in</span>
  destructs_conjunction_tactic N T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [destructs N T] is equivalent to [destruct T as (H1 .. HN)],</span>
<span class="sd">    except that it does not require to manually specify N different</span>
<span class="sd">    names. Remark that it is not restricted to N-ary conjunctions. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;destructs&quot;</span> <span class="kp">constr</span>(N) <span class="kp">constr</span>(T) :=
  <span class="kr">let</span> <span class="nv">N</span> := number_to_nat N <span class="kr">in</span>
  destructs_conjunction_tactic N T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Proving Goals that are N-ary Disjunctions *)</span>

<span class="sd">(** Underlying implementation of [branch]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">branch_tactic</span> K N :=
  <span class="kr">match</span> <span class="kp">constr</span>:((K,N)) <span class="kr">with</span>
  | (_,<span class="mi">0</span>) =&gt; <span class="kp">fail</span> <span class="mi">1</span>
  | (<span class="mi">0</span>,_) =&gt; <span class="kp">fail</span> <span class="mi">1</span>
  | (<span class="mi">1</span>,<span class="mi">1</span>) =&gt; <span class="kp">idtac</span>
  | (<span class="mi">1</span>,_) =&gt; <span class="nb">left</span>
  | (S <span class="nl">?K&#39;</span>, S <span class="nl">?N&#39;</span>) =&gt; <span class="nb">right</span>; branch_tactic K&#39; N&#39;
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">unfold_goal_until_disjunction</span> :=
  <span class="kr">match goal with</span>
  | |- _ \/ _ =&gt; <span class="kp">idtac</span>
  | _ =&gt; <span class="kp">progress</span>(unfolds); unfold_goal_until_disjunction
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">get_term_disjunction_arity</span> T :=
  <span class="kr">match</span> T <span class="kr">with</span>
  | _ \/ _ \/ _ \/ _ \/ _ \/ _ \/ _ \/ _ =&gt; <span class="kp">constr</span>:(<span class="mi">8</span>)
  | _ \/ _ \/ _ \/ _ \/ _ \/ _ \/ _ =&gt; <span class="kp">constr</span>:(<span class="mi">7</span>)
  | _ \/ _ \/ _ \/ _ \/ _ \/ _ =&gt; <span class="kp">constr</span>:(<span class="mi">6</span>)
  | _ \/ _ \/ _ \/ _ \/ _ =&gt; <span class="kp">constr</span>:(<span class="mi">5</span>)
  | _ \/ _ \/ _ \/ _ =&gt; <span class="kp">constr</span>:(<span class="mi">4</span>)
  | _ \/ _ \/ _ =&gt; <span class="kp">constr</span>:(<span class="mi">3</span>)
  | _ \/ _ =&gt; <span class="kp">constr</span>:(<span class="mi">2</span>)
  | _ -&gt; <span class="nl">?T&#39;</span> =&gt; get_term_disjunction_arity T&#39;
  | _ =&gt; <span class="kr">let</span> <span class="nv">P</span> := get_head T <span class="kr">in</span>
         <span class="kr">let</span> <span class="nv">T&#39;</span> := <span class="kp">eval</span> <span class="nb">unfold</span> P <span class="kr">in</span> T <span class="kr">in</span>
         <span class="kr">match</span> T&#39; <span class="kr">with</span>
         | T =&gt; <span class="kp">fail</span> <span class="mi">1</span>
         | _ =&gt; get_term_disjunction_arity T&#39;
         <span class="kr">end</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">get_goal_disjunction_arity</span> :=
  <span class="kr">match goal with</span> |- <span class="nl">?T</span> =&gt; get_term_disjunction_arity T <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [branch N] applies to a goal of the form</span>
<span class="sd">    [P1 \/ ... \/ PK \/ ... \/ PN] and leaves the goal [PK].</span>
<span class="sd">    It only able to unfold the head definition (if there is one),</span>
<span class="sd">    but for more complex unfolding one should use the tactic</span>
<span class="sd">    [branch K of N]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;branch&quot;</span> <span class="kp">constr</span>(K) :=
  <span class="kr">let</span> <span class="nv">K</span> := number_to_nat K <span class="kr">in</span>
  unfold_goal_until_disjunction;
  <span class="kr">let</span> <span class="nv">N</span> := get_goal_disjunction_arity <span class="kr">in</span>
  branch_tactic K N.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [branch K of N] is similar to [branch K] except that the</span>
<span class="sd">    arity of the disjunction [N] is given manually, and so this</span>
<span class="sd">    version of the tactic is able to unfold definitions.</span>
<span class="sd">    In other words, applies to a goal of the form</span>
<span class="sd">    [P1 \/ ... \/ PK \/ ... \/ PN] and leaves the goal [PK]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;branch&quot;</span> <span class="kp">constr</span>(K) <span class="s2">&quot;of&quot;</span> <span class="kp">constr</span>(N) :=
  <span class="kr">let</span> <span class="nv">N</span> := number_to_nat N <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">K</span> := number_to_nat K <span class="kr">in</span>
  branch_tactic K N.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** N-ary Disjunction Deconstruction *)</span>

<span class="sd">(** Underlying implementation of [branches]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">destructs_disjunction_tactic</span> N T :=
  <span class="kr">match</span> N <span class="kr">with</span>
  | <span class="mi">2</span> =&gt; <span class="nb">destruct</span> T <span class="kr">as</span> [? | ?]
  | <span class="mi">3</span> =&gt; <span class="nb">destruct</span> T <span class="kr">as</span> [? | [? | ?]]
  | <span class="mi">4</span> =&gt; <span class="nb">destruct</span> T <span class="kr">as</span> [? | [? | [? | ?]]]
  | <span class="mi">5</span> =&gt; <span class="nb">destruct</span> T <span class="kr">as</span> [? | [? | [? | [? | ?]]]]
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [branches T] allows destructing a term [T] which is a N-ary</span>
<span class="sd">    disjunction. It is equivalent to [destruct T as [ H1 | .. | HN ] ],</span>
<span class="sd">    and produces [N] subgoals corresponding to the [N] possible cases. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;branches&quot;</span> <span class="kp">constr</span>(T) :=
  <span class="kr">let</span> <span class="nv">TT</span> := <span class="kp">type of</span> T <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">N</span> := get_term_disjunction_arity TT <span class="kr">in</span>
  destructs_disjunction_tactic N T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [branches N T] is the same as [branches T] except that the arity is</span>
<span class="sd">    forced to [N]. This version is useful to unfold definitions</span>
<span class="sd">    on the fly. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;branches&quot;</span> <span class="kp">constr</span>(N) <span class="kp">constr</span>(T) :=
  <span class="kr">let</span> <span class="nv">N</span> := number_to_nat N <span class="kr">in</span>
  destructs_disjunction_tactic N T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [branches] automatically finds a hypothesis [h] that is a disjunction</span>
<span class="sd">    and destructs it. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;branches&quot;</span> :=
  <span class="kr">match goal with</span> h: _ \/ _ |- _ =&gt; branches h <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** N-ary Existentials *)</span>

<span class="c">(* Underlying implementation of [exists]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">get_term_existential_arity</span> T :=
  <span class="kr">match</span> T <span class="kr">with</span>
  | <span class="kr">exists</span> <span class="nv">x1</span> <span class="nv">x2</span> <span class="nv">x3</span> <span class="nv">x4</span> <span class="nv">x5</span> <span class="nv">x6</span> <span class="nv">x7</span> <span class="nv">x8</span>, _ =&gt; <span class="kp">constr</span>:(<span class="mi">8</span>)
  | <span class="kr">exists</span> <span class="nv">x1</span> <span class="nv">x2</span> <span class="nv">x3</span> <span class="nv">x4</span> <span class="nv">x5</span> <span class="nv">x6</span> <span class="nv">x7</span>, _ =&gt; <span class="kp">constr</span>:(<span class="mi">7</span>)
  | <span class="kr">exists</span> <span class="nv">x1</span> <span class="nv">x2</span> <span class="nv">x3</span> <span class="nv">x4</span> <span class="nv">x5</span> <span class="nv">x6</span>, _ =&gt; <span class="kp">constr</span>:(<span class="mi">6</span>)
  | <span class="kr">exists</span> <span class="nv">x1</span> <span class="nv">x2</span> <span class="nv">x3</span> <span class="nv">x4</span> <span class="nv">x5</span>, _ =&gt; <span class="kp">constr</span>:(<span class="mi">5</span>)
  | <span class="kr">exists</span> <span class="nv">x1</span> <span class="nv">x2</span> <span class="nv">x3</span> <span class="nv">x4</span>, _ =&gt; <span class="kp">constr</span>:(<span class="mi">4</span>)
  | <span class="kr">exists</span> <span class="nv">x1</span> <span class="nv">x2</span> <span class="nv">x3</span>, _ =&gt; <span class="kp">constr</span>:(<span class="mi">3</span>)
  | <span class="kr">exists</span> <span class="nv">x1</span> <span class="nv">x2</span>, _ =&gt; <span class="kp">constr</span>:(<span class="mi">2</span>)
  | <span class="kr">exists</span> <span class="nv">x1</span>, _ =&gt; <span class="kp">constr</span>:(<span class="mi">1</span>)
  | _ -&gt; <span class="nl">?T&#39;</span> =&gt; get_term_existential_arity T&#39;
  | _ =&gt; <span class="kr">let</span> <span class="nv">P</span> := get_head T <span class="kr">in</span>
         <span class="kr">let</span> <span class="nv">T&#39;</span> := <span class="kp">eval</span> <span class="nb">unfold</span> P <span class="kr">in</span> T <span class="kr">in</span>
         <span class="kr">match</span> T&#39; <span class="kr">with</span>
         | T =&gt; <span class="kp">fail</span> <span class="mi">1</span>
         | _ =&gt; get_term_existential_arity T&#39;
         <span class="kr">end</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">get_goal_existential_arity</span> :=
  <span class="kr">match goal with</span> |- <span class="nl">?T</span> =&gt; get_term_existential_arity T <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [exists T1 ... TN] is a shorthand for [exists T1; ...; exists TN].</span>
<span class="sd">    It is intended to prove goals of the form [exist X1 .. XN, P].</span>
<span class="sd">    If an argument provided is [__] (double underscore), then an</span>
<span class="sd">    evar is introduced. [exists T1 .. TN ___] is equivalent to</span>
<span class="sd">    [exists T1 .. TN __ __ __] with as many [__] as possible. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;exists_original&quot;</span> <span class="kp">constr</span>(T1) :=
  <span class="kr">exists</span> <span class="nv">T1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;exists&quot;</span> <span class="kp">constr</span>(T1) :=
  <span class="kr">match</span> T1 <span class="kr">with</span>
  | ltac_wild =&gt; <span class="nb">esplit</span>
  | ltac_wilds =&gt; <span class="kp">repeat</span> <span class="nb">esplit</span>
  | _ =&gt; <span class="kr">exists</span> <span class="nv">T1</span>
  <span class="nv">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;exists&quot;</span> <span class="kp">constr</span>(T1) <span class="kp">constr</span>(T2) :=
  <span class="kr">exists</span> <span class="nv">T1</span>; <span class="kr">exists</span> <span class="nv">T2</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;exists&quot;</span> <span class="kp">constr</span>(T1) <span class="kp">constr</span>(T2) <span class="kp">constr</span>(T3) :=
  <span class="kr">exists</span> <span class="nv">T1</span>; <span class="kr">exists</span> <span class="nv">T2</span>; <span class="kr">exists</span> <span class="nv">T3</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;exists&quot;</span> <span class="kp">constr</span>(T1) <span class="kp">constr</span>(T2) <span class="kp">constr</span>(T3) <span class="kp">constr</span>(T4) :=
  <span class="kr">exists</span> <span class="nv">T1</span>; <span class="kr">exists</span> <span class="nv">T2</span>; <span class="kr">exists</span> <span class="nv">T3</span>; <span class="kr">exists</span> <span class="nv">T4</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;exists&quot;</span> <span class="kp">constr</span>(T1) <span class="kp">constr</span>(T2) <span class="kp">constr</span>(T3) <span class="kp">constr</span>(T4)
 <span class="kp">constr</span>(T5) :=
  <span class="kr">exists</span> <span class="nv">T1</span>; <span class="kr">exists</span> <span class="nv">T2</span>; <span class="kr">exists</span> <span class="nv">T3</span>; <span class="kr">exists</span> <span class="nv">T4</span>; <span class="kr">exists</span> <span class="nv">T5</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;exists&quot;</span> <span class="kp">constr</span>(T1) <span class="kp">constr</span>(T2) <span class="kp">constr</span>(T3) <span class="kp">constr</span>(T4)
 <span class="kp">constr</span>(T5) <span class="kp">constr</span>(T6) :=
  <span class="kr">exists</span> <span class="nv">T1</span>; <span class="kr">exists</span> <span class="nv">T2</span>; <span class="kr">exists</span> <span class="nv">T3</span>; <span class="kr">exists</span> <span class="nv">T4</span>; <span class="kr">exists</span> <span class="nv">T5</span>; <span class="kr">exists</span> <span class="nv">T6</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** For compatibility with Coq syntax, [exists T1, .., TN] is also provided. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;exists&quot;</span> <span class="kp">constr</span>(T1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(T2) :=
  <span class="kr">exists</span> <span class="nv">T1</span> <span class="nv">T2</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;exists&quot;</span> <span class="kp">constr</span>(T1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(T2) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(T3) :=
  <span class="kr">exists</span> <span class="nv">T1</span> <span class="nv">T2</span> <span class="nv">T3</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;exists&quot;</span> <span class="kp">constr</span>(T1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(T2) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(T3) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(T4) :=
  <span class="kr">exists</span> <span class="nv">T1</span> <span class="nv">T2</span> <span class="nv">T3</span> <span class="nv">T4</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;exists&quot;</span> <span class="kp">constr</span>(T1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(T2) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(T3) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(T4) <span class="s2">&quot;,&quot;</span>
 <span class="kp">constr</span>(T5) :=
  <span class="kr">exists</span> <span class="nv">T1</span> <span class="nv">T2</span> <span class="nv">T3</span> <span class="nv">T4</span> <span class="nv">T5</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;exists&quot;</span> <span class="kp">constr</span>(T1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(T2) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(T3) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(T4) <span class="s2">&quot;,&quot;</span>
 <span class="kp">constr</span>(T5) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(T6) :=
  <span class="kr">exists</span> <span class="nv">T1</span> <span class="nv">T2</span> <span class="nv">T3</span> <span class="nv">T4</span> <span class="nv">T5</span> <span class="nv">T6</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* The tactic [exists___ N] is short for [exists __ ... __]</span>
<span class="c">   with [N] double-underscores. The tactic [exists] is equivalent</span>
<span class="c">   to calling [exists___ N], where the value of [N] is obtained</span>
<span class="c">   by counting the number of existentials syntactically present</span>
<span class="c">   at the head of the goal. The behaviour of [exists] differs</span>
<span class="c">   from that of [exists ___] is the case where the goal is a</span>
<span class="c">   definition which yields an existential only after unfolding. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;exists___&quot;</span> <span class="kp">constr</span>(N) :=
  <span class="kr">let rec</span> <span class="nv">aux</span> <span class="nv">N</span> :=
    <span class="kr">match</span> N <span class="kr">with</span>
    | <span class="mi">0</span> =&gt; <span class="kp">idtac</span>
    | S <span class="nl">?N&#39;</span> =&gt; <span class="nb">esplit</span>; aux N&#39;
    <span class="kr">end</span> <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">N</span> := number_to_nat N <span class="kr">in</span> aux N.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(* --todo: deprecated *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;exists___&quot;</span> :=
  <span class="kr">let</span> <span class="nv">N</span> := get_goal_existential_arity <span class="kr">in</span>
  exists___ N.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(* --todo: does not seem to work *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;exists&quot;</span> :=
  exists___.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(* --todo: [exists_all] is the new syntax for [exists___] *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;exists_all&quot;</span> := exists___.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Existentials and Conjunctions in Hypotheses *)</span>

<span class="sd">(** [unpack] or [unpack H] destructs conjunctions and existentials in</span>
<span class="sd">    all or one hypothesis. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">unpack_core</span> :=
  <span class="kp">repeat</span> <span class="kr">match goal with</span>
  | H: _ /\ _ |- _ =&gt; <span class="nb">destruct</span> H
  | H: <span class="kr">exists</span> (<span class="nv">varname</span>: _), _ |- _ =&gt;
      <span class="c">(* kludge to preserve the name of the quantified variable *)</span>
      <span class="kr">let</span> <span class="nv">name</span> := <span class="kp">fresh</span> varname <span class="kr">in</span>
      <span class="nb">destruct</span> H <span class="kr">as</span> [name ?]
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">unpack_hypothesis</span> H :=
  <span class="kp">try</span> <span class="kr">match</span> <span class="kp">type of</span> H <span class="kr">with</span>
  | _ /\ _ =&gt;
      <span class="kr">let</span> <span class="nv">h1</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span>
      <span class="kr">let</span> <span class="nv">h2</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span>
      <span class="nb">destruct</span> H <span class="kr">as</span> [ h1 h2 ];
      unpack_hypothesis h1;
      unpack_hypothesis h2
  | <span class="kr">exists</span> (<span class="nv">varname</span>: _), _ =&gt;
      <span class="c">(* kludge to preserve the name of the quantified variable *)</span>
      <span class="kr">let</span> <span class="nv">name</span> := <span class="kp">fresh</span> varname <span class="kr">in</span>
      <span class="kr">let</span> <span class="nv">body</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span>
      <span class="nb">destruct</span> H <span class="kr">as</span> [name body];
      unpack_hypothesis body
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;unpack&quot;</span> :=
  unpack_core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;unpack&quot;</span> <span class="kp">constr</span>(H) :=
  unpack_hypothesis H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ################################################################# *)</span>
<span class="sd">(** * Tactics to Prove Typeclass Instances *)</span>

<span class="sd">(** [typeclass] is an automation tactic specialized for finding</span>
<span class="sd">    typeclass instances. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;typeclass&quot;</span> :=
  <span class="kr">let</span> <span class="nv">go</span> <span class="nv">_</span> := <span class="nb">eauto with</span> typeclass_instances <span class="kr">in</span>
  <span class="kp">solve</span> [ go tt | <span class="nb">constructor</span>; go tt ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [solve_typeclass] is a simpler version of [typeclass], to use</span>
<span class="sd">    in hint tactics for resolving instances *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;solve_typeclass&quot;</span> :=
  <span class="kp">solve</span> [ <span class="nb">eauto with</span> typeclass_instances ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ################################################################# *)</span>
<span class="sd">(** * Tactics to Invoke Automation *)</span>

<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Definitions for Parsing Compatibility *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;f_equal&quot;</span> :=
  <span class="nb">f_equal</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;constructor&quot;</span> :=
  <span class="nb">constructor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;simple&quot;</span> :=
  <span class="nb">simpl</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;split&quot;</span> :=
  <span class="nb">split</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;right&quot;</span> :=
  <span class="nb">right</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;left&quot;</span> :=
  <span class="nb">left</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** [hint] to Add Hints Local to a Lemma *)</span>

<span class="sd">(** [hint E] adds [E] as an hypothesis so that automation can use it.</span>
<span class="sd">    Syntax [hint E1,..,EN] is available *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;hint&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="kr">let</span> <span class="nv">H</span> := <span class="kp">fresh</span> <span class="s2">&quot;Hint&quot;</span> <span class="kr">in</span> <span class="kr">let</span><span class="nv">s</span> <span class="nv">H</span>: E.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;hint&quot;</span> <span class="kp">constr</span>(E1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(E2) :=
  hint E1; hint E2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;hint&quot;</span> <span class="kp">constr</span>(E1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(E2) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(E3) :=
  hint E1; hint E2; hint(E3).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;hint&quot;</span> <span class="kp">constr</span>(E1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(E2) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(E3) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(E4) :=
  hint E1; hint E2; hint(E3); hint(E4 ).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** [jauto], a New Automation Tactic *)</span>

<span class="sd">(** [jauto] is better at [intuition eauto] because it can open existentials</span>
<span class="sd">    from the context. In the same time, [jauto] can be faster than</span>
<span class="sd">    [intuition eauto] because it does not destruct disjunctions from the</span>
<span class="sd">    context. The strategy of [jauto] can be summarized as follows:</span>
<span class="sd">    - open all the existentials and conjunctions from the context</span>
<span class="sd">    - call esplit and split on the existentials and conjunctions in the goal</span>
<span class="sd">    - call eauto. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;jauto&quot;</span> :=
  <span class="kp">try</span> <span class="kp">solve</span> [ jauto_set; <span class="nb">eauto</span> ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;jauto_fast&quot;</span> :=
  <span class="kp">try</span> <span class="kp">solve</span> [ <span class="nb">auto</span> | <span class="nb">eauto</span> | jauto ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [iauto] is a shorthand for [intuition eauto] *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;iauto&quot;</span> := <span class="kp">try</span> <span class="kp">solve</span> [<span class="nb">intuition</span> <span class="nb">eauto</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Definitions of Automation Tactics *)</span>

<span class="sd">(** The two following tactics defined the default behaviour of</span>
<span class="sd">    &quot;light automation&quot; and &quot;strong automation&quot;. These tactics</span>
<span class="sd">    may be redefined at any time using the syntax [Ltac .. ::= ..]. *)</span>

<span class="sd">(** [auto_tilde] is the tactic which will be called each time a symbol</span>
<span class="sd">    [~] is used after a tactic. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">auto_tilde_default</span> := <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">auto_tilde</span> := auto_tilde_default.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [auto_star] is the tactic which will be called each time a symbol</span>
<span class="sd">    [*] is used after a tactic. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">auto_star_default</span> := <span class="kp">try</span> <span class="kp">solve</span> [ <span class="nb">auto</span> | <span class="nb">eauto</span> | <span class="nb">intuition</span> <span class="nb">eauto</span> ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* --todo: should be jauto *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">auto_star</span> := <span class="kp">try</span> <span class="kp">solve</span> [ jauto ]. <span class="c">(* SPECIAL VERSION FOR SF *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [autos~] is a notation for tactic [auto_tilde]. It may be followed</span>
<span class="sd">    by lemmas (or proofs terms) which auto will be able to use</span>
<span class="sd">    for solving the goal.</span>

<span class="sd">    [autos] is an alias for [autos~] *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;autos&quot;</span> :=
  auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;autos&quot;</span> <span class="s2">&quot;~&quot;</span> :=
  auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;autos&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E1) :=
  <span class="kr">let</span><span class="nv">s</span>: E1; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;autos&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E1) <span class="kp">constr</span>(E2) :=
  <span class="kr">let</span><span class="nv">s</span>: E1; autos~ E2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;autos&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E1) <span class="kp">constr</span>(E2) <span class="kp">constr</span>(E3) :=
  <span class="kr">let</span><span class="nv">s</span>: E1; autos~ E2 E3.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;autos&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E1) <span class="kp">constr</span>(E2) <span class="kp">constr</span>(E3) <span class="kp">constr</span>(E4) :=
  <span class="kr">let</span><span class="nv">s</span>: E1; autos~ E2 E3 E4.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;autos&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E1) <span class="kp">constr</span>(E2) <span class="kp">constr</span>(E3) <span class="kp">constr</span>(E4)
 <span class="kp">constr</span>(E5):=
  <span class="kr">let</span><span class="nv">s</span>: E1; autos~ E2 E3 E4 E5.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* New syntax using coma *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;autos&quot;</span> :=
  auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;autos&quot;</span> <span class="s2">&quot;~&quot;</span> :=
  auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;autos&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E1) :=
  <span class="kr">let</span><span class="nv">s</span>: E1; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;autos&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(E2) :=
  <span class="kr">let</span><span class="nv">s</span>: E1; autos~ E2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;autos&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(E2) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(E3) :=
  <span class="kr">let</span><span class="nv">s</span>: E1; autos~ E2 E3.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;autos&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(E2) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(E3) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(E4) :=
  <span class="kr">let</span><span class="nv">s</span>: E1; autos~ E2 E3 E4.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;autos&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(E2) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(E3) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(E4) <span class="s2">&quot;,&quot;</span>
 <span class="kp">constr</span>(E5):=
  <span class="kr">let</span><span class="nv">s</span>: E1; autos~ E2 E3 E4 E5.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [autos*] is a notation for tactic [auto_star]. It may be followed</span>
<span class="sd">    by lemmas (or proofs terms) which auto will be able to use</span>
<span class="sd">    for solving the goal. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;autos&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;autos&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E1) :=
  <span class="kr">let</span><span class="nv">s</span>: E1; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;autos&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E1) <span class="kp">constr</span>(E2) :=
  <span class="kr">let</span><span class="nv">s</span>: E1; autos* E2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;autos&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E1) <span class="kp">constr</span>(E2) <span class="kp">constr</span>(E3) :=
  <span class="kr">let</span><span class="nv">s</span>: E1; autos* E2 E3.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;autos&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E1) <span class="kp">constr</span>(E2) <span class="kp">constr</span>(E3) <span class="kp">constr</span>(E4) :=
  <span class="kr">let</span><span class="nv">s</span>: E1; autos* E2 E3 E4.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;autos&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E1) <span class="kp">constr</span>(E2) <span class="kp">constr</span>(E3) <span class="kp">constr</span>(E4)
 <span class="kp">constr</span>(E5):=
  <span class="kr">let</span><span class="nv">s</span>: E1; autos* E2 E3 E4 E5.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* New syntax using coma *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;autos&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;autos&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E1) :=
  <span class="kr">let</span><span class="nv">s</span>: E1; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;autos&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(E2) :=
  <span class="kr">let</span><span class="nv">s</span>: E1; autos* E2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;autos&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(E2) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(E3) :=
  <span class="kr">let</span><span class="nv">s</span>: E1; autos* E2 E3.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;autos&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(E2) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(E3) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(E4) :=
  <span class="kr">let</span><span class="nv">s</span>: E1; autos* E2 E3 E4.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;autos&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(E2) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(E3) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(E4) <span class="s2">&quot;,&quot;</span>
 <span class="kp">constr</span>(E5):=
  <span class="kr">let</span><span class="nv">s</span>: E1; autos* E2 E3 E4 E5.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [auto_false] is a version of [auto] able to spot some contradictions.</span>
<span class="sd">    There is an ad-hoc support for goals in [&lt;-&gt;]: split is called first.</span>
<span class="sd">    [auto_false~] and [auto_false*] are also available. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">auto_false_base</span> cont :=
  <span class="kp">try</span> <span class="kp">solve</span> [
    intros_all; <span class="kp">try</span> <span class="kr">match goal with</span> |- _ &lt;-&gt; _ =&gt; <span class="nb">split</span> <span class="kr">end</span>;
    <span class="kp">solve</span> [ cont tt | intros_all; false; cont tt ] ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;auto_false&quot;</span> :=
   auto_false_base <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">tt</span> =&gt; <span class="nb">auto</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;auto_false&quot;</span> <span class="s2">&quot;~&quot;</span> :=
   auto_false_base <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">tt</span> =&gt; auto_tilde).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;auto_false&quot;</span> <span class="s2">&quot;*&quot;</span> :=
   auto_false_base <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">tt</span> =&gt; auto_star).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;dauto&quot;</span> :=
  <span class="nb">dintuition</span> <span class="nb">eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Parsing for Light Automation *)</span>

<span class="sd">(** Any tactic followed by the symbol [~] will have [auto_tilde] called</span>
<span class="sd">    on all of its subgoals. Three exceptions:</span>
<span class="sd">    - [cuts] and [asserts] only call [auto] on their first subgoal,</span>
<span class="sd">    - [apply~] relies on [sapply] rather than [apply],</span>
<span class="sd">    - [tryfalse~] is defined as [tryfalse by auto_tilde].</span>

<span class="sd">   Some builtin tactics are not defined using tactic notations</span>
<span class="sd">   and thus cannot be extended, e.g., [simpl] and [unfold].</span>
<span class="sd">   For these, notation such as [simpl~] will not be available. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;equates&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E) :=
   equates E; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;equates&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(n1) <span class="kp">constr</span>(n2) :=
  equates n1 n2; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;equates&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(n1) <span class="kp">constr</span>(n2) <span class="kp">constr</span>(n3) :=
  equates n1 n2 n3; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;equates&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(n1) <span class="kp">constr</span>(n2) <span class="kp">constr</span>(n3) <span class="kp">constr</span>(n4) :=
  equates n1 n2 n3 n4; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;applys_eq&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(H) :=
  applys_eq H; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;applys_eq&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(H) <span class="kp">constr</span>(E) :=
  applys_eq H E; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;applys_eq&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(H) <span class="kp">constr</span>(n1) <span class="kp">constr</span>(n2) :=
  applys_eq H n1 n2; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;applys_eq&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(H) <span class="kp">constr</span>(n1) <span class="kp">constr</span>(n2) <span class="kp">constr</span>(n3) :=
  applys_eq H n1 n2 n3; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;applys_eq&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(H) <span class="kp">constr</span>(n1) <span class="kp">constr</span>(n2) <span class="kp">constr</span>(n3) <span class="kp">constr</span>(n4) :=
  applys_eq H n1 n2 n3 n4; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;apply&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(H) :=
  sapply H; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;destruct&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(H) :=
  <span class="nb">destruct</span> H; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;destruct&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(H) <span class="s2">&quot;as&quot;</span> simple_intropattern(I) :=
  <span class="nb">destruct</span> H <span class="kr">as</span> I; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;f_equal&quot;</span> <span class="s2">&quot;~&quot;</span> :=
  <span class="nb">f_equal</span>; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;induction&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(H) :=
  <span class="nb">induction</span> H; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inversion&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(H) :=
  <span class="nb">inversion</span> H; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;split&quot;</span> <span class="s2">&quot;~&quot;</span> :=
  <span class="nb">split</span>; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;subst&quot;</span> <span class="s2">&quot;~&quot;</span> :=
  <span class="nb">subst</span>; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;right&quot;</span> <span class="s2">&quot;~&quot;</span> :=
  <span class="nb">right</span>; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;left&quot;</span> <span class="s2">&quot;~&quot;</span> :=
  <span class="nb">left</span>; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;constructor&quot;</span> <span class="s2">&quot;~&quot;</span> :=
  <span class="nb">constructor</span>; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;constructors&quot;</span> <span class="s2">&quot;~&quot;</span> :=
  constructors; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;false&quot;</span> <span class="s2">&quot;~&quot;</span> :=
  false; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;false&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E) :=
  false_then E <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">_</span> =&gt; auto_tilde).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;false&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E0) <span class="kp">constr</span>(E1) :=
  false~ (&gt;&gt; E0 E1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;false&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E0) <span class="kp">constr</span>(E1) <span class="kp">constr</span>(E2) :=
  false~ (&gt;&gt; E0 E1 E2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;false&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E0) <span class="kp">constr</span>(E1) <span class="kp">constr</span>(E2) <span class="kp">constr</span>(E3) :=
  false~ (&gt;&gt; E0 E1 E2 E3).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;false&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E0) <span class="kp">constr</span>(E1) <span class="kp">constr</span>(E2) <span class="kp">constr</span>(E3) <span class="kp">constr</span>(E4) :=
  false~ (&gt;&gt; E0 E1 E2 E3 E4).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;tryfalse&quot;</span> <span class="s2">&quot;~&quot;</span> :=
  <span class="kp">try</span> <span class="kp">solve</span> [ false~ ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;asserts&quot;</span> <span class="s2">&quot;~&quot;</span> simple_intropattern(H) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  asserts H: E; [ auto_tilde | <span class="kp">idtac</span> ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;asserts&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="kr">let</span> <span class="nv">H</span> := <span class="kp">fresh</span> <span class="s2">&quot;H&quot;</span> <span class="kr">in</span> asserts~ H: E.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cuts&quot;</span> <span class="s2">&quot;~&quot;</span> simple_intropattern(H) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  cuts H: E; [ auto_tilde | <span class="kp">idtac</span> ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cuts&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  cuts: E; [ auto_tilde | <span class="kp">idtac</span> ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> <span class="s2">&quot;~&quot;</span> simple_intropattern(I) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="kr">let</span><span class="nv">s</span> <span class="nv">I</span>: E; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> <span class="s2">&quot;~&quot;</span> simple_intropattern(I) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) :=
  <span class="kr">let</span><span class="nv">s</span> <span class="nv">I</span>: E0 A1; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> <span class="s2">&quot;~&quot;</span> simple_intropattern(I) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) :=
  <span class="kr">let</span><span class="nv">s</span> <span class="nv">I</span>: E0 A1 A2; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> <span class="s2">&quot;~&quot;</span> simple_intropattern(I) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) :=
  <span class="kr">let</span><span class="nv">s</span> <span class="nv">I</span>: E0 A1 A2 A3; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> <span class="s2">&quot;~&quot;</span> simple_intropattern(I) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) <span class="kp">constr</span>(A4) :=
  <span class="kr">let</span><span class="nv">s</span> <span class="nv">I</span>: E0 A1 A2 A3 A4; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> <span class="s2">&quot;~&quot;</span> simple_intropattern(I) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) <span class="kp">constr</span>(A4) <span class="kp">constr</span>(A5) :=
  <span class="kr">let</span><span class="nv">s</span> <span class="nv">I</span>: E0 A1 A2 A3 A4 A5; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="kr">let</span><span class="nv">s</span>: E; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) :=
  <span class="kr">let</span><span class="nv">s</span>: E0 A1; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) :=
  <span class="kr">let</span><span class="nv">s</span>: E0 A1 A2; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) :=
  <span class="kr">let</span><span class="nv">s</span>: E0 A1 A2 A3; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) <span class="kp">constr</span>(A4) :=
  <span class="kr">let</span><span class="nv">s</span>: E0 A1 A2 A3 A4; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) <span class="kp">constr</span>(A4) <span class="kp">constr</span>(A5) :=
  <span class="kr">let</span><span class="nv">s</span>: E0 A1 A2 A3 A4 A5; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;forwards&quot;</span> <span class="s2">&quot;~&quot;</span> simple_intropattern(I) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  forwards I: E; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;forwards&quot;</span> <span class="s2">&quot;~&quot;</span> simple_intropattern(I) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) :=
  forwards I: E0 A1; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;forwards&quot;</span> <span class="s2">&quot;~&quot;</span> simple_intropattern(I) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) :=
  forwards I: E0 A1 A2; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;forwards&quot;</span> <span class="s2">&quot;~&quot;</span> simple_intropattern(I) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) :=
  forwards I: E0 A1 A2 A3; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;forwards&quot;</span> <span class="s2">&quot;~&quot;</span> simple_intropattern(I) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) <span class="kp">constr</span>(A4) :=
  forwards I: E0 A1 A2 A3 A4; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;forwards&quot;</span> <span class="s2">&quot;~&quot;</span> simple_intropattern(I) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) <span class="kp">constr</span>(A4) <span class="kp">constr</span>(A5) :=
  forwards I: E0 A1 A2 A3 A4 A5; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;forwards&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  forwards: E; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;forwards&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) :=
  forwards: E0 A1; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;forwards&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) :=
  forwards: E0 A1 A2; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;forwards&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) :=
  forwards: E0 A1 A2 A3; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;forwards&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) <span class="kp">constr</span>(A4) :=
  forwards: E0 A1 A2 A3 A4; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;forwards&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) <span class="kp">constr</span>(A4) <span class="kp">constr</span>(A5) :=
  forwards: E0 A1 A2 A3 A4 A5; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;applys&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(H) :=
  sapply H; auto_tilde. <span class="c">(*todo?*)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;applys&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E0) <span class="kp">constr</span>(A1) :=
  applys E0 A1; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;applys&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E0) <span class="kp">constr</span>(A1) :=
  applys E0 A1; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;applys&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E0) <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) :=
  applys E0 A1 A2; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;applys&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E0) <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) :=
  applys E0 A1 A2 A3; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;applys&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E0) <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) <span class="kp">constr</span>(A4) :=
  applys E0 A1 A2 A3 A4; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;applys&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E0) <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) <span class="kp">constr</span>(A4) <span class="kp">constr</span>(A5) :=
  applys E0 A1 A2 A3 A4 A5; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;specializes&quot;</span> <span class="s2">&quot;~&quot;</span> hyp(H) :=
  specializes H; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;specializes&quot;</span> <span class="s2">&quot;~&quot;</span> hyp(H) <span class="kp">constr</span>(A1) :=
  specializes H A1; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;specializes&quot;</span> hyp(H) <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) :=
  specializes H A1 A2; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;specializes&quot;</span> hyp(H) <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) :=
  specializes H A1 A2 A3; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;specializes&quot;</span> hyp(H) <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) <span class="kp">constr</span>(A4) :=
  specializes H A1 A2 A3 A4; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;specializes&quot;</span> hyp(H) <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) <span class="kp">constr</span>(A4) <span class="kp">constr</span>(A5) :=
  specializes H A1 A2 A3 A4 A5; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;fapply&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E) :=
  fapply E; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;sapply&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E) :=
  sapply E; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;logic&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E) :=
  logic_base E <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">_</span> =&gt; auto_tilde).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;intros_all&quot;</span> <span class="s2">&quot;~&quot;</span> :=
  intros_all; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;unfolds&quot;</span> <span class="s2">&quot;~&quot;</span> :=
  unfolds; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;unfolds&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(F1) :=
  unfolds F1; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;unfolds&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(F1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F2) :=
  unfolds F1, F2; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;unfolds&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(F1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F2) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F3) :=
  unfolds F1, F2, F3; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;unfolds&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(F1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F2) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F3) <span class="s2">&quot;,&quot;</span>
 <span class="kp">constr</span>(F4) :=
  unfolds F1, F2, F3, F4; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;simple&quot;</span> <span class="s2">&quot;~&quot;</span> :=
  <span class="nb">simpl</span>; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;simple&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="s2">&quot;in&quot;</span> hyp(H) :=
  <span class="nb">simpl</span> <span class="kr">in</span> H; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;simpls&quot;</span> <span class="s2">&quot;~&quot;</span> :=
  simpls; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;hnfs&quot;</span> <span class="s2">&quot;~&quot;</span> :=
  hnfs; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;hnfs&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="s2">&quot;in&quot;</span> hyp(H) :=
  <span class="nb">hnf</span> <span class="kr">in</span> H; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;substs&quot;</span> <span class="s2">&quot;~&quot;</span> :=
  substs; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;intro_hyp&quot;</span> <span class="s2">&quot;~&quot;</span> hyp(H) :=
  subst_hyp H; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;intro_subst&quot;</span> <span class="s2">&quot;~&quot;</span> :=
  intro_subst; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;subst_eq&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E) :=
  subst_eq E; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrite&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="nb">rewrite</span> E; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrite&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="nb">rewrite</span> &lt;- E; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrite&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  <span class="nb">rewrite</span> E <span class="kr">in</span> H; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrite&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  <span class="nb">rewrite</span> &lt;- E <span class="kr">in</span> H; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrites&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E) :=
  rewrites E; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrites&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  rewrites E <span class="kr">in</span> H; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrites&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  rewrites E <span class="kr">in</span> *; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrites&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kp">constr</span>(E) :=
  rewrites &lt;- E; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrites&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  rewrites &lt;- E <span class="kr">in</span> H; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrites&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  rewrites &lt;- E <span class="kr">in</span> *; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrite_all&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E) :=
  rewrite_all E; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrite_all&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kp">constr</span>(E) :=
  rewrite_all &lt;- E; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrite_all&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> <span class="kn">ident</span>(H) :=
  rewrite_all E <span class="kr">in</span> H; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrite_all&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> <span class="kn">ident</span>(H) :=
  rewrite_all &lt;- E <span class="kr">in</span> H; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrite_all&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  rewrite_all E <span class="kr">in</span> *; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrite_all&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  rewrite_all &lt;- E <span class="kr">in</span> *; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;asserts_rewrite&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E) :=
  asserts_rewrite E; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;asserts_rewrite&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kp">constr</span>(E) :=
  asserts_rewrite &lt;- E; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;asserts_rewrite&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  asserts_rewrite E <span class="kr">in</span> H; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;asserts_rewrite&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  asserts_rewrite &lt;- E <span class="kr">in</span> H; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;asserts_rewrite&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  asserts_rewrite E <span class="kr">in</span> *; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;asserts_rewrite&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  asserts_rewrite &lt;- E <span class="kr">in</span> *; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cuts_rewrite&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E) :=
  cuts_rewrite E; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cuts_rewrite&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kp">constr</span>(E) :=
  cuts_rewrite &lt;- E; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cuts_rewrite&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  cuts_rewrite E <span class="kr">in</span> H; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cuts_rewrite&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  cuts_rewrite &lt;- E <span class="kr">in</span> H; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;erewrite&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="nb">erewrite</span> E; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;erewrites&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E) :=
  erewrites E; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;fequal&quot;</span> <span class="s2">&quot;~&quot;</span> :=
  fequal; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;fequals&quot;</span> <span class="s2">&quot;~&quot;</span> :=
  fequals; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;pi_rewrite&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E) :=
  pi_rewrite E; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;pi_rewrite&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  pi_rewrite E <span class="kr">in</span> H; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;invert&quot;</span> <span class="s2">&quot;~&quot;</span> hyp(H) :=
  invert H; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inverts&quot;</span> <span class="s2">&quot;~&quot;</span> hyp(H) :=
  inverts H; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inverts&quot;</span> <span class="s2">&quot;~&quot;</span> hyp(E) <span class="s2">&quot;as&quot;</span> :=
  inverts E <span class="kr">as</span>; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;injects&quot;</span> <span class="s2">&quot;~&quot;</span> hyp(H) :=
  injects H; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inversions&quot;</span> <span class="s2">&quot;~&quot;</span> hyp(H) :=
  inversions H; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cases&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;as&quot;</span> <span class="kn">ident</span>(H) :=
  cases E <span class="kr">as</span> H; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cases&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E) :=
  cases E; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;case_if&quot;</span> <span class="s2">&quot;~&quot;</span> :=
  case_if; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;case_ifs&quot;</span> <span class="s2">&quot;~&quot;</span> :=
  case_ifs; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;case_if&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="s2">&quot;in&quot;</span> hyp(H) :=
  case_if <span class="kr">in</span> H; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cases_if&quot;</span> <span class="s2">&quot;~&quot;</span> :=
  cases_if; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cases_if&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="s2">&quot;in&quot;</span> hyp(H) :=
  cases_if <span class="kr">in</span> H; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;destruct_if&quot;</span> <span class="s2">&quot;~&quot;</span> :=
  destruct_if; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;destruct_if&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="s2">&quot;in&quot;</span> hyp(H) :=
  destruct_if <span class="kr">in</span> H; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cases&#39;&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;as&quot;</span> <span class="kn">ident</span>(H) :=
  cases&#39; E <span class="kr">as</span> H; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cases&#39;&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(E) :=
  cases&#39; E; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cases_if&#39;&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="s2">&quot;as&quot;</span> <span class="kn">ident</span>(H) :=
  cases_if&#39; <span class="kr">as</span> H; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cases_if&#39;&quot;</span> <span class="s2">&quot;~&quot;</span> :=
  cases_if&#39;; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;decides_equality&quot;</span> <span class="s2">&quot;~&quot;</span> :=
  decides_equality; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;iff&quot;</span> <span class="s2">&quot;~&quot;</span> :=
  iff; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;iff&quot;</span> <span class="s2">&quot;~&quot;</span> simple_intropattern(I) :=
  iff I; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;splits&quot;</span> <span class="s2">&quot;~&quot;</span> :=
  splits; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;splits&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(N) :=
  splits N; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;destructs&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(T) :=
  destructs T; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;destructs&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(N) <span class="kp">constr</span>(T) :=
  destructs N T; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;branch&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(N) :=
  branch N; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;branch&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(K) <span class="s2">&quot;of&quot;</span> <span class="kp">constr</span>(N) :=
  branch K of N; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;branches&quot;</span> <span class="s2">&quot;~&quot;</span> :=
  branches; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;branches&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(T) :=
  branches T; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;branches&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(N) <span class="kp">constr</span>(T) :=
  branches N T; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;exists&quot;</span> <span class="s2">&quot;~&quot;</span> :=
  <span class="kr">exists</span>; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;exists___&quot;</span> <span class="s2">&quot;~&quot;</span> :=
  exists___; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;exists&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(T1) :=
  <span class="kr">exists</span> <span class="nv">T1</span>; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;exists&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(T1) <span class="kp">constr</span>(T2) :=
  <span class="kr">exists</span> <span class="nv">T1</span> <span class="nv">T2</span>; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;exists&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(T1) <span class="kp">constr</span>(T2) <span class="kp">constr</span>(T3) :=
  <span class="kr">exists</span> <span class="nv">T1</span> <span class="nv">T2</span> <span class="nv">T3</span>; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;exists&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(T1) <span class="kp">constr</span>(T2) <span class="kp">constr</span>(T3) <span class="kp">constr</span>(T4) :=
  <span class="kr">exists</span> <span class="nv">T1</span> <span class="nv">T2</span> <span class="nv">T3</span> <span class="nv">T4</span>; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;exists&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(T1) <span class="kp">constr</span>(T2) <span class="kp">constr</span>(T3) <span class="kp">constr</span>(T4)
 <span class="kp">constr</span>(T5) :=
  <span class="kr">exists</span> <span class="nv">T1</span> <span class="nv">T2</span> <span class="nv">T3</span> <span class="nv">T4</span> <span class="nv">T5</span>; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;exists&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(T1) <span class="kp">constr</span>(T2) <span class="kp">constr</span>(T3) <span class="kp">constr</span>(T4)
 <span class="kp">constr</span>(T5) <span class="kp">constr</span>(T6) :=
  <span class="kr">exists</span> <span class="nv">T1</span> <span class="nv">T2</span> <span class="nv">T3</span> <span class="nv">T4</span> <span class="nv">T5</span> <span class="nv">T6</span>; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;exists&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(T1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(T2) :=
  <span class="kr">exists</span> <span class="nv">T1</span> <span class="nv">T2</span>; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;exists&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(T1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(T2) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(T3) :=
  <span class="kr">exists</span> <span class="nv">T1</span> <span class="nv">T2</span> <span class="nv">T3</span>; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;exists&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(T1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(T2) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(T3) <span class="s2">&quot;,&quot;</span>
 <span class="kp">constr</span>(T4) :=
  <span class="kr">exists</span> <span class="nv">T1</span> <span class="nv">T2</span> <span class="nv">T3</span> <span class="nv">T4</span>; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;exists&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(T1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(T2) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(T3) <span class="s2">&quot;,&quot;</span>
 <span class="kp">constr</span>(T4) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(T5) :=
  <span class="kr">exists</span> <span class="nv">T1</span> <span class="nv">T2</span> <span class="nv">T3</span> <span class="nv">T4</span> <span class="nv">T5</span>; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;exists&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="kp">constr</span>(T1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(T2) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(T3) <span class="s2">&quot;,&quot;</span>
 <span class="kp">constr</span>(T4) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(T5) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(T6) :=
  <span class="kr">exists</span> <span class="nv">T1</span> <span class="nv">T2</span> <span class="nv">T3</span> <span class="nv">T4</span> <span class="nv">T5</span> <span class="nv">T6</span>; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Parsing for Strong Automation *)</span>

<span class="sd">(** Any tactic followed by the symbol [*] will have [auto*] called</span>
<span class="sd">    on all of its subgoals. The exceptions to these rules are the</span>
<span class="sd">    same as for light automation.</span>

<span class="sd">    Exception: use [subs*] instead of [subst*] if you</span>
<span class="sd">    import the library [Coq.Classes.Equivalence]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;equates&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E) :=
   equates E; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;equates&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(n1) <span class="kp">constr</span>(n2) :=
  equates n1 n2; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;equates&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(n1) <span class="kp">constr</span>(n2) <span class="kp">constr</span>(n3) :=
  equates n1 n2 n3; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;equates&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(n1) <span class="kp">constr</span>(n2) <span class="kp">constr</span>(n3) <span class="kp">constr</span>(n4) :=
  equates n1 n2 n3 n4; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;applys_eq&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(H) :=
  applys_eq H; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;applys_eq&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(H) <span class="kp">constr</span>(E) :=
  applys_eq H E; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;applys_eq&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(H) <span class="kp">constr</span>(n1) <span class="kp">constr</span>(n2) :=
  applys_eq H n1 n2; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;applys_eq&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(H) <span class="kp">constr</span>(n1) <span class="kp">constr</span>(n2) <span class="kp">constr</span>(n3) :=
  applys_eq H n1 n2 n3; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;applys_eq&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(H) <span class="kp">constr</span>(n1) <span class="kp">constr</span>(n2) <span class="kp">constr</span>(n3) <span class="kp">constr</span>(n4) :=
  applys_eq H n1 n2 n3 n4; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;apply&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(H) :=
  sapply H; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;destruct&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(H) :=
  <span class="nb">destruct</span> H; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;destruct&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(H) <span class="s2">&quot;as&quot;</span> simple_intropattern(I) :=
  <span class="nb">destruct</span> H <span class="kr">as</span> I; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;f_equal&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  <span class="nb">f_equal</span>; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;induction&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(H) :=
  <span class="nb">induction</span> H; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inversion&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(H) :=
  <span class="nb">inversion</span> H; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;split&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  <span class="nb">split</span>; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;subs&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  <span class="nb">subst</span>; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;subst&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  <span class="nb">subst</span>; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;right&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  <span class="nb">right</span>; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;left&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  <span class="nb">left</span>; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;constructor&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  <span class="nb">constructor</span>; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;constructors&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  constructors; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;false&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  false; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;false&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E) :=
  false_then E <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">_</span> =&gt; auto_star).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;false&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E0) <span class="kp">constr</span>(E1) :=
  false* (&gt;&gt; E0 E1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;false&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E0) <span class="kp">constr</span>(E1) <span class="kp">constr</span>(E2) :=
  false* (&gt;&gt; E0 E1 E2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;false&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E0) <span class="kp">constr</span>(E1) <span class="kp">constr</span>(E2) <span class="kp">constr</span>(E3) :=
  false* (&gt;&gt; E0 E1 E2 E3).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;false&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E0) <span class="kp">constr</span>(E1) <span class="kp">constr</span>(E2) <span class="kp">constr</span>(E3) <span class="kp">constr</span>(E4) :=
  false* (&gt;&gt; E0 E1 E2 E3 E4).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;tryfalse&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  <span class="kp">try</span> <span class="kp">solve</span> [ false* ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;asserts&quot;</span> <span class="s2">&quot;*&quot;</span> simple_intropattern(H) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  asserts H: E; [ auto_star | <span class="kp">idtac</span> ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;asserts&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="kr">let</span> <span class="nv">H</span> := <span class="kp">fresh</span> <span class="s2">&quot;H&quot;</span> <span class="kr">in</span> asserts* H: E.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cuts&quot;</span> <span class="s2">&quot;*&quot;</span> simple_intropattern(H) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  cuts H: E; [ auto_star | <span class="kp">idtac</span> ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cuts&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  cuts: E; [ auto_star | <span class="kp">idtac</span> ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> <span class="s2">&quot;*&quot;</span> simple_intropattern(I) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="kr">let</span><span class="nv">s</span> <span class="nv">I</span>: E; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> <span class="s2">&quot;*&quot;</span> simple_intropattern(I) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) :=
  <span class="kr">let</span><span class="nv">s</span> <span class="nv">I</span>: E0 A1; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> <span class="s2">&quot;*&quot;</span> simple_intropattern(I) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) :=
  <span class="kr">let</span><span class="nv">s</span> <span class="nv">I</span>: E0 A1 A2; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> <span class="s2">&quot;*&quot;</span> simple_intropattern(I) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) :=
  <span class="kr">let</span><span class="nv">s</span> <span class="nv">I</span>: E0 A1 A2 A3; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> <span class="s2">&quot;*&quot;</span> simple_intropattern(I) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) <span class="kp">constr</span>(A4) :=
  <span class="kr">let</span><span class="nv">s</span> <span class="nv">I</span>: E0 A1 A2 A3 A4; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> <span class="s2">&quot;*&quot;</span> simple_intropattern(I) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) <span class="kp">constr</span>(A4) <span class="kp">constr</span>(A5) :=
  <span class="kr">let</span><span class="nv">s</span> <span class="nv">I</span>: E0 A1 A2 A3 A4 A5; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="kr">let</span><span class="nv">s</span>: E; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) :=
  <span class="kr">let</span><span class="nv">s</span>: E0 A1; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) :=
  <span class="kr">let</span><span class="nv">s</span>: E0 A1 A2; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) :=
  <span class="kr">let</span><span class="nv">s</span>: E0 A1 A2 A3; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) <span class="kp">constr</span>(A4) :=
  <span class="kr">let</span><span class="nv">s</span>: E0 A1 A2 A3 A4; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;lets&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) <span class="kp">constr</span>(A4) <span class="kp">constr</span>(A5) :=
  <span class="kr">let</span><span class="nv">s</span>: E0 A1 A2 A3 A4 A5; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;forwards&quot;</span> <span class="s2">&quot;*&quot;</span> simple_intropattern(I) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  forwards I: E; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;forwards&quot;</span> <span class="s2">&quot;*&quot;</span> simple_intropattern(I) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) :=
  forwards I: E0 A1; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;forwards&quot;</span> <span class="s2">&quot;*&quot;</span> simple_intropattern(I) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) :=
  forwards I: E0 A1 A2; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;forwards&quot;</span> <span class="s2">&quot;*&quot;</span> simple_intropattern(I) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) :=
  forwards I: E0 A1 A2 A3; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;forwards&quot;</span> <span class="s2">&quot;*&quot;</span> simple_intropattern(I) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) <span class="kp">constr</span>(A4) :=
  forwards I: E0 A1 A2 A3 A4; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;forwards&quot;</span> <span class="s2">&quot;*&quot;</span> simple_intropattern(I) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) <span class="kp">constr</span>(A4) <span class="kp">constr</span>(A5) :=
  forwards I: E0 A1 A2 A3 A4 A5; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;forwards&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E) :=
  forwards: E; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;forwards&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) :=
  forwards: E0 A1; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;forwards&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) :=
  forwards: E0 A1 A2; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;forwards&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) :=
  forwards: E0 A1 A2 A3; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;forwards&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) <span class="kp">constr</span>(A4) :=
  forwards: E0 A1 A2 A3 A4; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;forwards&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(E0)
 <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) <span class="kp">constr</span>(A4) <span class="kp">constr</span>(A5) :=
  forwards: E0 A1 A2 A3 A4 A5; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;applys&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(H) :=
  sapply H; auto_star. <span class="c">(*todo?*)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;applys&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E0) <span class="kp">constr</span>(A1) :=
  applys E0 A1; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;applys&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E0) <span class="kp">constr</span>(A1) :=
  applys E0 A1; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;applys&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E0) <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) :=
  applys E0 A1 A2; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;applys&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E0) <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) :=
  applys E0 A1 A2 A3; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;applys&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E0) <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) <span class="kp">constr</span>(A4) :=
  applys E0 A1 A2 A3 A4; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;applys&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E0) <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) <span class="kp">constr</span>(A4) <span class="kp">constr</span>(A5) :=
  applys E0 A1 A2 A3 A4 A5; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;specializes&quot;</span> <span class="s2">&quot;*&quot;</span> hyp(H) :=
  specializes H; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;specializes&quot;</span> <span class="s2">&quot;~&quot;</span> hyp(H) <span class="kp">constr</span>(A1) :=
  specializes H A1; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;specializes&quot;</span> hyp(H) <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) :=
  specializes H A1 A2; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;specializes&quot;</span> hyp(H) <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) :=
  specializes H A1 A2 A3; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;specializes&quot;</span> hyp(H) <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) <span class="kp">constr</span>(A4) :=
  specializes H A1 A2 A3 A4; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;specializes&quot;</span> hyp(H) <span class="kp">constr</span>(A1) <span class="kp">constr</span>(A2) <span class="kp">constr</span>(A3) <span class="kp">constr</span>(A4) <span class="kp">constr</span>(A5) :=
  specializes H A1 A2 A3 A4 A5; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;fapply&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E) :=
  fapply E; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;sapply&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E) :=
  sapply E; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;logic&quot;</span> <span class="kp">constr</span>(E) :=
  logic_base E <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">_</span> =&gt; auto_star).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;intros_all&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  intros_all; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;unfolds&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  unfolds; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;unfolds&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(F1) :=
  unfolds F1; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;unfolds&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(F1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F2) :=
  unfolds F1, F2; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;unfolds&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(F1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F2) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F3) :=
  unfolds F1, F2, F3; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;unfolds&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(F1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F2) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(F3) <span class="s2">&quot;,&quot;</span>
 <span class="kp">constr</span>(F4) :=
  unfolds F1, F2, F3, F4; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;simple&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  <span class="nb">simpl</span>; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;simple&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="s2">&quot;in&quot;</span> hyp(H) :=
  <span class="nb">simpl</span> <span class="kr">in</span> H; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;simpls&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  simpls; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;hnfs&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  hnfs; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;hnfs&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="s2">&quot;in&quot;</span> hyp(H) :=
  <span class="nb">hnf</span> <span class="kr">in</span> H; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;substs&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  substs; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;intro_hyp&quot;</span> <span class="s2">&quot;*&quot;</span> hyp(H) :=
  subst_hyp H; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;intro_subst&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  intro_subst; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;subst_eq&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E) :=
  subst_eq E; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrite&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="nb">rewrite</span> E; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrite&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="nb">rewrite</span> &lt;- E; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrite&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  <span class="nb">rewrite</span> E <span class="kr">in</span> H; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrite&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  <span class="nb">rewrite</span> &lt;- E <span class="kr">in</span> H; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrites&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E) :=
  rewrites E; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrites&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> hyp(H):=
  rewrites E <span class="kr">in</span> H; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrites&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> <span class="s2">&quot;*&quot;</span>:=
  rewrites E <span class="kr">in</span> *; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrites&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kp">constr</span>(E) :=
  rewrites &lt;- E; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrites&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> hyp(H):=
  rewrites &lt;- E <span class="kr">in</span> H; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrites&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> <span class="s2">&quot;*&quot;</span>:=
  rewrites &lt;- E <span class="kr">in</span> *; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrite_all&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E) :=
  rewrite_all E; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrite_all&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kp">constr</span>(E) :=
  rewrite_all &lt;- E; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrite_all&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> <span class="kn">ident</span>(H) :=
  rewrite_all E <span class="kr">in</span> H; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrite_all&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> <span class="kn">ident</span>(H) :=
  rewrite_all &lt;- E <span class="kr">in</span> H; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrite_all&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  rewrite_all E <span class="kr">in</span> *; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;rewrite_all&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  rewrite_all &lt;- E <span class="kr">in</span> *; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;asserts_rewrite&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E) :=
  asserts_rewrite E; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;asserts_rewrite&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kp">constr</span>(E) :=
  asserts_rewrite &lt;- E; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;asserts_rewrite&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  asserts_rewrite E; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;asserts_rewrite&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  asserts_rewrite &lt;- E; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;asserts_rewrite&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  asserts_rewrite E <span class="kr">in</span> *; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;asserts_rewrite&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  asserts_rewrite &lt;- E <span class="kr">in</span> *; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cuts_rewrite&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E) :=
  cuts_rewrite E; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cuts_rewrite&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kp">constr</span>(E) :=
  cuts_rewrite &lt;- E; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cuts_rewrite&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  cuts_rewrite E <span class="kr">in</span> H; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cuts_rewrite&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  cuts_rewrite &lt;- E <span class="kr">in</span> H; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;erewrite&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="nb">erewrite</span> E; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;erewrites&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E) :=
  erewrites E; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;fequal&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  fequal; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;fequals&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  fequals; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;pi_rewrite&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E) :=
  pi_rewrite E; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;pi_rewrite&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  pi_rewrite E <span class="kr">in</span> H; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;invert&quot;</span> <span class="s2">&quot;*&quot;</span> hyp(H) :=
  invert H; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inverts&quot;</span> <span class="s2">&quot;*&quot;</span> hyp(H) :=
  inverts H; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inverts&quot;</span> <span class="s2">&quot;*&quot;</span> hyp(E) <span class="s2">&quot;as&quot;</span> :=
  inverts E <span class="kr">as</span>; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;injects&quot;</span> <span class="s2">&quot;*&quot;</span> hyp(H) :=
  injects H; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;inversions&quot;</span> <span class="s2">&quot;*&quot;</span> hyp(H) :=
  inversions H; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cases&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;as&quot;</span> <span class="kn">ident</span>(H) :=
  cases E <span class="kr">as</span> H; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cases&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E) :=
  cases E; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;case_if&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  case_if; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;case_ifs&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  case_ifs; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;case_if&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="s2">&quot;in&quot;</span> hyp(H) :=
  case_if <span class="kr">in</span> H; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cases_if&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  cases_if; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cases_if&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="s2">&quot;in&quot;</span> hyp(H) :=
  cases_if <span class="kr">in</span> H; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;destruct_if&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  destruct_if; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;destruct_if&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="s2">&quot;in&quot;</span> hyp(H) :=
  destruct_if <span class="kr">in</span> H; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cases&#39;&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;as&quot;</span> <span class="kn">ident</span>(H) :=
  cases&#39; E <span class="kr">as</span> H; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cases&#39;&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(E) :=
  cases&#39; E; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cases_if&#39;&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="s2">&quot;as&quot;</span> <span class="kn">ident</span>(H) :=
  cases_if&#39; <span class="kr">as</span> H; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;cases_if&#39;&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  cases_if&#39;; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;decides_equality&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  decides_equality; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;iff&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  iff; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;iff&quot;</span> <span class="s2">&quot;*&quot;</span> simple_intropattern(I) :=
  iff I; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;splits&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  splits; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;splits&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(N) :=
  splits N; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;destructs&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(T) :=
  destructs T; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;destructs&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(N) <span class="kp">constr</span>(T) :=
  destructs N T; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;branch&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(N) :=
  branch N; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;branch&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(K) <span class="s2">&quot;of&quot;</span> <span class="kp">constr</span>(N) :=
  branch K of N; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;branches&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(T) :=
  branches T; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;branches&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(N) <span class="kp">constr</span>(T) :=
  branches N T; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;exists&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  <span class="kr">exists</span>; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;exists___&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  exists___; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;exists&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(T1) :=
  <span class="kr">exists</span> <span class="nv">T1</span>; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;exists&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(T1) <span class="kp">constr</span>(T2) :=
  <span class="kr">exists</span> <span class="nv">T1</span> <span class="nv">T2</span>; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;exists&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(T1) <span class="kp">constr</span>(T2) <span class="kp">constr</span>(T3) :=
  <span class="kr">exists</span> <span class="nv">T1</span> <span class="nv">T2</span> <span class="nv">T3</span>; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;exists&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(T1) <span class="kp">constr</span>(T2) <span class="kp">constr</span>(T3) <span class="kp">constr</span>(T4) :=
  <span class="kr">exists</span> <span class="nv">T1</span> <span class="nv">T2</span> <span class="nv">T3</span> <span class="nv">T4</span>; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;exists&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(T1) <span class="kp">constr</span>(T2) <span class="kp">constr</span>(T3) <span class="kp">constr</span>(T4)
 <span class="kp">constr</span>(T5) :=
  <span class="kr">exists</span> <span class="nv">T1</span> <span class="nv">T2</span> <span class="nv">T3</span> <span class="nv">T4</span> <span class="nv">T5</span>; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;exists&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(T1) <span class="kp">constr</span>(T2) <span class="kp">constr</span>(T3) <span class="kp">constr</span>(T4)
 <span class="kp">constr</span>(T5) <span class="kp">constr</span>(T6) :=
  <span class="kr">exists</span> <span class="nv">T1</span> <span class="nv">T2</span> <span class="nv">T3</span> <span class="nv">T4</span> <span class="nv">T5</span> <span class="nv">T6</span>; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;exists&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(T1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(T2) :=
  <span class="kr">exists</span> <span class="nv">T1</span> <span class="nv">T2</span>; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;exists&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(T1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(T2) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(T3) :=
  <span class="kr">exists</span> <span class="nv">T1</span> <span class="nv">T2</span> <span class="nv">T3</span>; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;exists&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(T1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(T2) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(T3) <span class="s2">&quot;,&quot;</span>
  <span class="kp">constr</span>(T4) :=
  <span class="kr">exists</span> <span class="nv">T1</span> <span class="nv">T2</span> <span class="nv">T3</span> <span class="nv">T4</span>; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;exists&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(T1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(T2) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(T3) <span class="s2">&quot;,&quot;</span>
 <span class="kp">constr</span>(T4) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(T5) :=
  <span class="kr">exists</span> <span class="nv">T1</span> <span class="nv">T2</span> <span class="nv">T3</span> <span class="nv">T4</span> <span class="nv">T5</span>; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;exists&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(T1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(T2) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(T3) <span class="s2">&quot;,&quot;</span>
 <span class="kp">constr</span>(T4) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(T5) <span class="s2">&quot;,&quot;</span>  <span class="kp">constr</span>(T6) :=
  <span class="kr">exists</span> <span class="nv">T1</span> <span class="nv">T2</span> <span class="nv">T3</span> <span class="nv">T4</span> <span class="nv">T5</span> <span class="nv">T6</span>; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ################################################################# *)</span>
<span class="sd">(** * Tactics to Sort Out the Proof Context *)</span>

<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Hiding Hypotheses *)</span>

<span class="c">(* Implementation *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ltac_something</span> (<span class="nv">P</span>:<span class="kt">Type</span>) (<span class="nv">e</span>:P) := e.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;Something&#39;&quot;</span> :=
  (@ltac_something _ _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk53"><span class="kn">Lemma</span> <span class="nf">ltac_something_eq</span> : <span class="kr">forall</span> (<span class="nv">e</span>:<span class="kt">Type</span>),
  e = (@ltac_something _ e).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">e</span> : <span class="kt">Type</span>, e = Something</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk54"><span class="kn">Proof using</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">e</span> : <span class="kt">Type</span>, e = Something</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk55"><span class="kn">Lemma</span> <span class="nf">ltac_something_hide</span> : <span class="kr">forall</span> (<span class="nv">e</span>:<span class="kt">Type</span>),
  e -&gt; (@ltac_something _ e).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">e</span> : <span class="kt">Type</span>, e -&gt; Something</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk56"><span class="kn">Proof using</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">e</span> : <span class="kt">Type</span>, e -&gt; Something</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk57"><span class="kn">Lemma</span> <span class="nf">ltac_something_show</span> : <span class="kr">forall</span> (<span class="nv">e</span>:<span class="kt">Type</span>),
  (@ltac_something _ e) -&gt; e.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">e</span> : <span class="kt">Type</span>, Something -&gt; e</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk58"><span class="kn">Proof using</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">e</span> : <span class="kt">Type</span>, Something -&gt; e</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [hide_def x] and [show_def x] can be used to hide/show</span>
<span class="sd">    the body of the definition [x]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;hide_def&quot;</span> hyp(x) :=
  <span class="kr">let</span> <span class="nv">x&#39;</span> := <span class="kp">constr</span>:(x) <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">T</span> := <span class="kp">eval</span> <span class="nb">unfold</span> x <span class="kr">in</span> x&#39; <span class="kr">in</span>
  <span class="nb">change</span> T <span class="kr">with</span> (@ltac_something _ T) <span class="kr">in</span> x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;show_def&quot;</span> hyp(x) :=
  <span class="kr">let</span> <span class="nv">x&#39;</span> := <span class="kp">constr</span>:(x) <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">U</span> := <span class="kp">eval</span> <span class="nb">unfold</span> x <span class="kr">in</span> x&#39; <span class="kr">in</span>
  <span class="kr">match</span> U <span class="kr">with</span> @ltac_something _ <span class="nl">?T</span> =&gt;
    <span class="nb">change</span> U <span class="kr">with</span> T <span class="kr">in</span> x <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [show_def] unfolds [Something] in the goal *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;show_def&quot;</span> :=
  <span class="nb">unfold</span> ltac_something.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;show_def&quot;</span> <span class="s2">&quot;in&quot;</span> hyp(H) :=
  <span class="nb">unfold</span> ltac_something <span class="kr">in</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;show_def&quot;</span> <span class="s2">&quot;in&quot;</span> <span class="s2">&quot;*&quot;</span> :=
  <span class="nb">unfold</span> ltac_something <span class="kr">in</span> *.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [hide_defs] and [show_defs] applies to all definitions *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;hide_defs&quot;</span> :=
  <span class="kp">repeat</span> <span class="kr">match goal with</span> H := <span class="nl">?T</span> |- _ =&gt;
    <span class="kr">match</span> T <span class="kr">with</span>
    | @ltac_something _ _ =&gt; <span class="kp">fail</span> <span class="mi">1</span>
    | _ =&gt; <span class="nb">change</span> T <span class="kr">with</span> (@ltac_something _ T) <span class="kr">in</span> H
    <span class="kr">end</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;show_defs&quot;</span> :=
  <span class="kp">repeat</span> <span class="kr">match goal with</span> H := (@ltac_something _ <span class="nl">?T</span>) |- _ =&gt;
    <span class="nb">change</span> (@ltac_something _ T) <span class="kr">with</span> T <span class="kr">in</span> H <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [hide_hyp H] replaces the type of [H] with the notation [Something]</span>
<span class="sd">    and [show_hyp H] reveals the type of the hypothesis. Note that the</span>
<span class="sd">    hidden type of [H] remains convertible the real type of [H]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;show_hyp&quot;</span> hyp(H) :=
  <span class="nb">apply</span> ltac_something_show <span class="kr">in</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;hide_hyp&quot;</span> hyp(H) :=
  <span class="nb">apply</span> ltac_something_hide <span class="kr">in</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [hide_hyps] and [show_hyps] can be used to hide/show all hypotheses</span>
<span class="sd">    of type [Prop]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;show_hyps&quot;</span> :=
  <span class="kp">repeat</span> <span class="kr">match goal with</span>
    H: @ltac_something _ _ |- _ =&gt; show_hyp H <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;hide_hyps&quot;</span> :=
  <span class="kp">repeat</span> <span class="kr">match goal with</span> H: <span class="nl">?T</span> |- _ =&gt;
    <span class="kr">match</span> <span class="kp">type of</span> T <span class="kr">with</span>
    | <span class="kt">Prop</span> =&gt;
      <span class="kr">match</span> T <span class="kr">with</span>
      | @ltac_something _ _ =&gt; <span class="kp">fail</span> <span class="mi">2</span>
      | _ =&gt; hide_hyp H
      <span class="kr">end</span>
    | _ =&gt; <span class="kp">fail</span> <span class="mi">1</span>
    <span class="kr">end</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [hide H] and [show H] automatically select between</span>
<span class="sd">    [hide_hyp] or [hide_def], and [show_hyp] or [show_def].</span>
<span class="sd">    Similarly [hide_all] and [show_all] apply to all. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;hide&quot;</span> hyp(H) :=
  <span class="kp">first</span> [hide_def H | hide_hyp H].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;show&quot;</span> hyp(H) :=
  <span class="kp">first</span> [show_def H | show_hyp H].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;hide_all&quot;</span> :=
  hide_hyps; hide_defs.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;show_all&quot;</span> :=
  <span class="nb">unfold</span> ltac_something <span class="kr">in</span> *.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [hide_term E] can be used to hide a term from the goal.</span>
<span class="sd">    [show_term] or [show_term E] can be used to reveal it.</span>
<span class="sd">    [hide_term E in H] can be used to specify an hypothesis. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;hide_term&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="nb">change</span> E <span class="kr">with</span> (@ltac_something _ E).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;show_term&quot;</span> <span class="kp">constr</span>(E) :=
  <span class="nb">change</span> (@ltac_something _ E) <span class="kr">with</span> E.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;show_term&quot;</span> :=
  <span class="nb">unfold</span> ltac_something.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;hide_term&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  <span class="nb">change</span> E <span class="kr">with</span> (@ltac_something _ E) <span class="kr">in</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;show_term&quot;</span> <span class="kp">constr</span>(E) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  <span class="nb">change</span> (@ltac_something _ E) <span class="kr">with</span> E <span class="kr">in</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;show_term&quot;</span> <span class="s2">&quot;in&quot;</span> hyp(H) :=
  <span class="nb">unfold</span> ltac_something <span class="kr">in</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [show_unfold R] unfolds the definition of [R] and</span>
<span class="sd">    reveals the hidden definition of R. --todo:test,</span>
<span class="sd">    and implement using unfold simply *)</span>
    <span class="c">(* --todo: change &quot;unfolds&quot; *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;show_unfold&quot;</span> <span class="kp">constr</span>(R1) :=
  <span class="nb">unfold</span> R1; show_def.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;show_unfold&quot;</span> <span class="kp">constr</span>(R1) <span class="s2">&quot;,&quot;</span> <span class="kp">constr</span>(R2) :=
  <span class="nb">unfold</span> R1, R2; show_def.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Sorting Hypotheses *)</span>

<span class="sd">(** [sort] sorts out hypotheses from the context by moving all the</span>
<span class="sd">    propositions (hypotheses of type Prop) to the bottom of the context. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">sort_tactic</span> :=
  <span class="kp">try</span> <span class="kr">match goal with</span> H: <span class="nl">?T</span> |- _ =&gt;
  <span class="kr">match</span> <span class="kp">type of</span> T <span class="kr">with</span> <span class="kt">Prop</span> =&gt;
    generalizes H; (<span class="kp">try</span> sort_tactic); <span class="nb">intro</span>
  <span class="kr">end</span> <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;sort&quot;</span> :=
  sort_tactic.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Clearing Hypotheses *)</span>

<span class="sd">(** [clears X1 ... XN] is a variation on [clear] which clears</span>
<span class="sd">    the variables [X1]..[XN] as well as all the hypotheses which</span>
<span class="sd">    depend on them. Contrary to [clear], it never fails. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;clears&quot;</span> <span class="kn">ident</span>(X1) :=
  <span class="kr">let rec</span> <span class="nv">doit</span> <span class="nv">_</span> :=
  <span class="kr">match goal with</span>
  | H:<span class="kp">context</span>[X1] |- _ =&gt; <span class="nb">clear</span> H; <span class="kp">try</span> (doit tt)
  | _ =&gt; <span class="nb">clear</span> X1
  <span class="kr">end</span> <span class="kr">in</span> doit tt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;clears&quot;</span> <span class="kn">ident</span>(X1) <span class="kn">ident</span>(X2) :=
  clears X1; clears X2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;clears&quot;</span> <span class="kn">ident</span>(X1) <span class="kn">ident</span>(X2) <span class="kn">ident</span>(X3) :=
  clears X1; clears X2; clears X3.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;clears&quot;</span> <span class="kn">ident</span>(X1) <span class="kn">ident</span>(X2) <span class="kn">ident</span>(X3) <span class="kn">ident</span>(X4) :=
  clears X1; clears X2; clears X3; clears X4.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;clears&quot;</span> <span class="kn">ident</span>(X1) <span class="kn">ident</span>(X2) <span class="kn">ident</span>(X3) <span class="kn">ident</span>(X4)
 <span class="kn">ident</span>(X5) :=
  clears X1; clears X2; clears X3; clears X4; clears X5.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;clears&quot;</span> <span class="kn">ident</span>(X1) <span class="kn">ident</span>(X2) <span class="kn">ident</span>(X3) <span class="kn">ident</span>(X4)
 <span class="kn">ident</span>(X5) <span class="kn">ident</span>(X6) :=
  clears X1; clears X2; clears X3; clears X4; clears X5; clears X6.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [clears] (without any argument) clears all the unused variables</span>
<span class="sd">    from the context. In other words, it removes any variable</span>
<span class="sd">    which is not a proposition (i.e. not of type Prop) and which</span>
<span class="sd">    does not appear in another hypothesis nor in the goal. *)</span>
  <span class="c">(* --todo: rename to clears_var ? *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">clears_tactic</span> :=
  <span class="kr">match goal with</span> H: <span class="nl">?T</span> |- _ =&gt;
  <span class="kr">match</span> <span class="kp">type of</span> T <span class="kr">with</span>
  | <span class="kt">Prop</span> =&gt; generalizes H; (<span class="kp">try</span> clears_tactic); <span class="nb">intro</span>
  | <span class="nl">?TT</span> =&gt; <span class="nb">clear</span> H; (<span class="kp">try</span> clears_tactic)
  | <span class="nl">?TT</span> =&gt; generalizes H; (<span class="kp">try</span> clears_tactic); <span class="nb">intro</span>
  <span class="kr">end</span> <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;clears&quot;</span> :=
  clears_tactic.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [clears_all] clears all the hypotheses from the context</span>
<span class="sd">    that can be cleared. It leaves only the hypotheses that</span>
<span class="sd">    are mentioned in the goal. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">clears_or_generalizes_all_core</span> :=
  <span class="kp">repeat</span> <span class="kr">match goal with</span> H: _ |- _ =&gt;
           <span class="kp">first</span> [ <span class="nb">clear</span> H | generalizes H] <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;clears_all&quot;</span> :=
  <span class="nb">generalize</span> ltac_mark;
  clears_or_generalizes_all_core;
  intro_until_mark.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [clears_but H1 H2 .. HN] clears all hypotheses except the</span>
<span class="sd">    one that are mentioned and those that cannot be cleared. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">clears_but_core</span> cont :=
  <span class="nb">generalize</span> ltac_mark;
  cont tt;
  clears_or_generalizes_all_core;
  intro_until_mark.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;clears_but&quot;</span> :=
  clears_but_core <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="kp">idtac</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;clears_but&quot;</span> <span class="kn">ident</span>(H1) :=
  clears_but_core <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">_</span> =&gt; gen H1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;clears_but&quot;</span> <span class="kn">ident</span>(H1) <span class="kn">ident</span>(H2) :=
  clears_but_core <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">_</span> =&gt; gen H1 H2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;clears_but&quot;</span> <span class="kn">ident</span>(H1) <span class="kn">ident</span>(H2) <span class="kn">ident</span>(H3) :=
  clears_but_core <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">_</span> =&gt; gen H1 H2 H3).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;clears_but&quot;</span> <span class="kn">ident</span>(H1) <span class="kn">ident</span>(H2) <span class="kn">ident</span>(H3) <span class="kn">ident</span>(H4) :=
  clears_but_core <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">_</span> =&gt; gen H1 H2 H3 H4).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;clears_but&quot;</span> <span class="kn">ident</span>(H1) <span class="kn">ident</span>(H2) <span class="kn">ident</span>(H3) <span class="kn">ident</span>(H4) <span class="kn">ident</span>(H5) :=
  clears_but_core <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">_</span> =&gt; gen H1 H2 H3 H4 H5).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk59"><span class="kn">Lemma</span> <span class="nf">demo_clears_all_and_clears_but</span> :
  <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>:nat, y &lt; <span class="mi">2</span> -&gt; x = x -&gt; x &gt;= <span class="mi">2</span> -&gt; x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : nat,
y &lt; <span class="mi">2</span> -&gt; x = x -&gt; x &gt;= <span class="mi">2</span> -&gt; x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk5a"><span class="kn">Proof using</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : nat,
y &lt; <span class="mi">2</span> -&gt; x = x -&gt; x &gt;= <span class="mi">2</span> -&gt; x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk5b">introv M1 M2 M3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M1</var><span class="hyp-type"><b>: </b><span>y &lt; <span class="mi">2</span></span></span></span><br><span><var>M2</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>M3</var><span class="hyp-type"><b>: </b><span>x &gt;= <span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk5c">dup <span class="mi">6</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M1</var><span class="hyp-type"><b>: </b><span>y &lt; <span class="mi">2</span></span></span></span><br><span><var>M2</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>M3</var><span class="hyp-type"><b>: </b><span>x &gt;= <span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="libtactics-v-chk5d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M1</var><span class="hyp-type"><b>: </b><span>y &lt; <span class="mi">2</span></span></span></span><br><span><var>M2</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>M3</var><span class="hyp-type"><b>: </b><span>x &gt;= <span class="mi">2</span></span></span></span><br></div><label class="goal-separator" for="libtactics-v-chk5d"><hr></label><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="libtactics-v-chk5e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M1</var><span class="hyp-type"><b>: </b><span>y &lt; <span class="mi">2</span></span></span></span><br><span><var>M2</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>M3</var><span class="hyp-type"><b>: </b><span>x &gt;= <span class="mi">2</span></span></span></span><br></div><label class="goal-separator" for="libtactics-v-chk5e"><hr></label><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="libtactics-v-chk5f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M1</var><span class="hyp-type"><b>: </b><span>y &lt; <span class="mi">2</span></span></span></span><br><span><var>M2</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>M3</var><span class="hyp-type"><b>: </b><span>x &gt;= <span class="mi">2</span></span></span></span><br></div><label class="goal-separator" for="libtactics-v-chk5f"><hr></label><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="libtactics-v-chk60" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M1</var><span class="hyp-type"><b>: </b><span>y &lt; <span class="mi">2</span></span></span></span><br><span><var>M2</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>M3</var><span class="hyp-type"><b>: </b><span>x &gt;= <span class="mi">2</span></span></span></span><br></div><label class="goal-separator" for="libtactics-v-chk60"><hr></label><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="libtactics-v-chk61" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M1</var><span class="hyp-type"><b>: </b><span>y &lt; <span class="mi">2</span></span></span></span><br><span><var>M2</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>M3</var><span class="hyp-type"><b>: </b><span>x &gt;= <span class="mi">2</span></span></span></span><br></div><label class="goal-separator" for="libtactics-v-chk61"><hr></label><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* [clears_all] clears all hypotheses. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk62">clears_all.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="libtactics-v-chk63" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M1</var><span class="hyp-type"><b>: </b><span>y &lt; <span class="mi">2</span></span></span></span><br><span><var>M2</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>M3</var><span class="hyp-type"><b>: </b><span>x &gt;= <span class="mi">2</span></span></span></span><br></div><label class="goal-separator" for="libtactics-v-chk63"><hr></label><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="libtactics-v-chk64" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M1</var><span class="hyp-type"><b>: </b><span>y &lt; <span class="mi">2</span></span></span></span><br><span><var>M2</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>M3</var><span class="hyp-type"><b>: </b><span>x &gt;= <span class="mi">2</span></span></span></span><br></div><label class="goal-separator" for="libtactics-v-chk64"><hr></label><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="libtactics-v-chk65" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M1</var><span class="hyp-type"><b>: </b><span>y &lt; <span class="mi">2</span></span></span></span><br><span><var>M2</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>M3</var><span class="hyp-type"><b>: </b><span>x &gt;= <span class="mi">2</span></span></span></span><br></div><label class="goal-separator" for="libtactics-v-chk65"><hr></label><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="libtactics-v-chk66" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M1</var><span class="hyp-type"><b>: </b><span>y &lt; <span class="mi">2</span></span></span></span><br><span><var>M2</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>M3</var><span class="hyp-type"><b>: </b><span>x &gt;= <span class="mi">2</span></span></span></span><br></div><label class="goal-separator" for="libtactics-v-chk66"><hr></label><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="libtactics-v-chk67" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M1</var><span class="hyp-type"><b>: </b><span>y &lt; <span class="mi">2</span></span></span></span><br><span><var>M2</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>M3</var><span class="hyp-type"><b>: </b><span>x &gt;= <span class="mi">2</span></span></span></span><br></div><label class="goal-separator" for="libtactics-v-chk67"><hr></label><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk68"><span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M1</var><span class="hyp-type"><b>: </b><span>y &lt; <span class="mi">2</span></span></span></span><br><span><var>M2</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>M3</var><span class="hyp-type"><b>: </b><span>x &gt;= <span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="libtactics-v-chk69" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M1</var><span class="hyp-type"><b>: </b><span>y &lt; <span class="mi">2</span></span></span></span><br><span><var>M2</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>M3</var><span class="hyp-type"><b>: </b><span>x &gt;= <span class="mi">2</span></span></span></span><br></div><label class="goal-separator" for="libtactics-v-chk69"><hr></label><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="libtactics-v-chk6a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M1</var><span class="hyp-type"><b>: </b><span>y &lt; <span class="mi">2</span></span></span></span><br><span><var>M2</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>M3</var><span class="hyp-type"><b>: </b><span>x &gt;= <span class="mi">2</span></span></span></span><br></div><label class="goal-separator" for="libtactics-v-chk6a"><hr></label><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="libtactics-v-chk6b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M1</var><span class="hyp-type"><b>: </b><span>y &lt; <span class="mi">2</span></span></span></span><br><span><var>M2</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>M3</var><span class="hyp-type"><b>: </b><span>x &gt;= <span class="mi">2</span></span></span></span><br></div><label class="goal-separator" for="libtactics-v-chk6b"><hr></label><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="libtactics-v-chk6c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M1</var><span class="hyp-type"><b>: </b><span>y &lt; <span class="mi">2</span></span></span></span><br><span><var>M2</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>M3</var><span class="hyp-type"><b>: </b><span>x &gt;= <span class="mi">2</span></span></span></span><br></div><label class="goal-separator" for="libtactics-v-chk6c"><hr></label><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* [clears_but H] clears all but [H] *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk6d">clears_but M3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M3</var><span class="hyp-type"><b>: </b><span>x &gt;= <span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="libtactics-v-chk6e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M1</var><span class="hyp-type"><b>: </b><span>y &lt; <span class="mi">2</span></span></span></span><br><span><var>M2</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>M3</var><span class="hyp-type"><b>: </b><span>x &gt;= <span class="mi">2</span></span></span></span><br></div><label class="goal-separator" for="libtactics-v-chk6e"><hr></label><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="libtactics-v-chk6f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M1</var><span class="hyp-type"><b>: </b><span>y &lt; <span class="mi">2</span></span></span></span><br><span><var>M2</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>M3</var><span class="hyp-type"><b>: </b><span>x &gt;= <span class="mi">2</span></span></span></span><br></div><label class="goal-separator" for="libtactics-v-chk6f"><hr></label><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="libtactics-v-chk70" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M1</var><span class="hyp-type"><b>: </b><span>y &lt; <span class="mi">2</span></span></span></span><br><span><var>M2</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>M3</var><span class="hyp-type"><b>: </b><span>x &gt;= <span class="mi">2</span></span></span></span><br></div><label class="goal-separator" for="libtactics-v-chk70"><hr></label><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="libtactics-v-chk71" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M1</var><span class="hyp-type"><b>: </b><span>y &lt; <span class="mi">2</span></span></span></span><br><span><var>M2</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>M3</var><span class="hyp-type"><b>: </b><span>x &gt;= <span class="mi">2</span></span></span></span><br></div><label class="goal-separator" for="libtactics-v-chk71"><hr></label><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk72"><span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M1</var><span class="hyp-type"><b>: </b><span>y &lt; <span class="mi">2</span></span></span></span><br><span><var>M2</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>M3</var><span class="hyp-type"><b>: </b><span>x &gt;= <span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="libtactics-v-chk73" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M1</var><span class="hyp-type"><b>: </b><span>y &lt; <span class="mi">2</span></span></span></span><br><span><var>M2</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>M3</var><span class="hyp-type"><b>: </b><span>x &gt;= <span class="mi">2</span></span></span></span><br></div><label class="goal-separator" for="libtactics-v-chk73"><hr></label><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="libtactics-v-chk74" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M1</var><span class="hyp-type"><b>: </b><span>y &lt; <span class="mi">2</span></span></span></span><br><span><var>M2</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>M3</var><span class="hyp-type"><b>: </b><span>x &gt;= <span class="mi">2</span></span></span></span><br></div><label class="goal-separator" for="libtactics-v-chk74"><hr></label><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="libtactics-v-chk75" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M1</var><span class="hyp-type"><b>: </b><span>y &lt; <span class="mi">2</span></span></span></span><br><span><var>M2</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>M3</var><span class="hyp-type"><b>: </b><span>x &gt;= <span class="mi">2</span></span></span></span><br></div><label class="goal-separator" for="libtactics-v-chk75"><hr></label><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk76">clears_but y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M1</var><span class="hyp-type"><b>: </b><span>y &lt; <span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="libtactics-v-chk77" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M1</var><span class="hyp-type"><b>: </b><span>y &lt; <span class="mi">2</span></span></span></span><br><span><var>M2</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>M3</var><span class="hyp-type"><b>: </b><span>x &gt;= <span class="mi">2</span></span></span></span><br></div><label class="goal-separator" for="libtactics-v-chk77"><hr></label><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="libtactics-v-chk78" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M1</var><span class="hyp-type"><b>: </b><span>y &lt; <span class="mi">2</span></span></span></span><br><span><var>M2</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>M3</var><span class="hyp-type"><b>: </b><span>x &gt;= <span class="mi">2</span></span></span></span><br></div><label class="goal-separator" for="libtactics-v-chk78"><hr></label><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="libtactics-v-chk79" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M1</var><span class="hyp-type"><b>: </b><span>y &lt; <span class="mi">2</span></span></span></span><br><span><var>M2</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>M3</var><span class="hyp-type"><b>: </b><span>x &gt;= <span class="mi">2</span></span></span></span><br></div><label class="goal-separator" for="libtactics-v-chk79"><hr></label><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk7a"><span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M1</var><span class="hyp-type"><b>: </b><span>y &lt; <span class="mi">2</span></span></span></span><br><span><var>M2</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>M3</var><span class="hyp-type"><b>: </b><span>x &gt;= <span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="libtactics-v-chk7b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M1</var><span class="hyp-type"><b>: </b><span>y &lt; <span class="mi">2</span></span></span></span><br><span><var>M2</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>M3</var><span class="hyp-type"><b>: </b><span>x &gt;= <span class="mi">2</span></span></span></span><br></div><label class="goal-separator" for="libtactics-v-chk7b"><hr></label><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="libtactics-v-chk7c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M1</var><span class="hyp-type"><b>: </b><span>y &lt; <span class="mi">2</span></span></span></span><br><span><var>M2</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>M3</var><span class="hyp-type"><b>: </b><span>x &gt;= <span class="mi">2</span></span></span></span><br></div><label class="goal-separator" for="libtactics-v-chk7c"><hr></label><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk7d">clears_but x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M2</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>M3</var><span class="hyp-type"><b>: </b><span>x &gt;= <span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="libtactics-v-chk7e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M1</var><span class="hyp-type"><b>: </b><span>y &lt; <span class="mi">2</span></span></span></span><br><span><var>M2</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>M3</var><span class="hyp-type"><b>: </b><span>x &gt;= <span class="mi">2</span></span></span></span><br></div><label class="goal-separator" for="libtactics-v-chk7e"><hr></label><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="libtactics-v-chk7f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M1</var><span class="hyp-type"><b>: </b><span>y &lt; <span class="mi">2</span></span></span></span><br><span><var>M2</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>M3</var><span class="hyp-type"><b>: </b><span>x &gt;= <span class="mi">2</span></span></span></span><br></div><label class="goal-separator" for="libtactics-v-chk7f"><hr></label><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk80"><span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M1</var><span class="hyp-type"><b>: </b><span>y &lt; <span class="mi">2</span></span></span></span><br><span><var>M2</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>M3</var><span class="hyp-type"><b>: </b><span>x &gt;= <span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="libtactics-v-chk81" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M1</var><span class="hyp-type"><b>: </b><span>y &lt; <span class="mi">2</span></span></span></span><br><span><var>M2</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>M3</var><span class="hyp-type"><b>: </b><span>x &gt;= <span class="mi">2</span></span></span></span><br></div><label class="goal-separator" for="libtactics-v-chk81"><hr></label><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk82">clears_but M2 M3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M2</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>M3</var><span class="hyp-type"><b>: </b><span>x &gt;= <span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="libtactics-v-chk83" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M1</var><span class="hyp-type"><b>: </b><span>y &lt; <span class="mi">2</span></span></span></span><br><span><var>M2</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>M3</var><span class="hyp-type"><b>: </b><span>x &gt;= <span class="mi">2</span></span></span></span><br></div><label class="goal-separator" for="libtactics-v-chk83"><hr></label><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk84"><span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M1</var><span class="hyp-type"><b>: </b><span>y &lt; <span class="mi">2</span></span></span></span><br><span><var>M2</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>M3</var><span class="hyp-type"><b>: </b><span>x &gt;= <span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="libtactics-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="libtactics-v-chk85">clears_but x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M2</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>M3</var><span class="hyp-type"><b>: </b><span>x &gt;= <span class="mi">2</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>M1</var><span class="hyp-type"><b>: </b><span>y &lt; <span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x &lt; <span class="mi">3</span> -&gt; <span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [clears_last] clears the last hypothesis in the context.</span>
<span class="sd">    [clears_last N] clears the last [N] hypotheses in the context. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;clears_last&quot;</span> :=
  <span class="kr">match goal with</span> H: <span class="nl">?T</span> |- _ =&gt; <span class="nb">clear</span> H <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">clears_last_base</span> N :=
  <span class="kr">match</span> number_to_nat N <span class="kr">with</span>
  | <span class="mi">0</span> =&gt; <span class="kp">idtac</span>
  | S <span class="nl">?p</span> =&gt; clears_last; clears_last_base p
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;clears_last&quot;</span> <span class="kp">constr</span>(N) :=
  clears_last_base N.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ################################################################# *)</span>
<span class="sd">(** * Tactics for Development Purposes *)</span>

<span class="c">(* ================================================================= *)</span>
<span class="sd">(** ** Skipping Subgoals *)</span>

<span class="sd">(** SF DOES NOT NEED an alternative implementation of the [skip] tactic. *)</span>

<span class="sd">(** The [skip] tactic can be used at any time to admit the current</span>
<span class="sd">    goal. Unlike [admit], it does not require ending the proof with</span>
<span class="sd">    [Admitted] instead of [Qed]. It thus saves the pain of renaming [Qed]</span>
<span class="sd">    into [Admitted] and vice-versa all the time.</span>

<span class="sd">    The implementation of [skip] relies on an axiom [False].</span>
<span class="sd">    To obtain a safe development, it suffices to replace [False] with [True]</span>
<span class="sd">    in the statement of that axiom.</span>

<span class="sd">    Note that it is still necessary to instantiate all the existential</span>
<span class="sd">    variables introduced by other tactics in order for [Qed] to be accepted.</span>
<span class="sd">*)</span>

<span class="sd">(** To obtain a safe development, change to [skip_axiom : True] *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Axiom</span> <span class="nv">skip_axiom</span> : <span class="kt">True</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">skip_with_axiom</span> :=
  <span class="nb">elimtype</span> <span class="kt">False</span>; <span class="nb">apply</span> skip_axiom.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;skip&quot;</span> :=
  skip_with_axiom.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** To use traditional [admit] instead of [skip] in the tactics defined below,</span>
<span class="sd">    uncomment the following definition, to bind [skip] to [admit]. *)</span>
<span class="c">(*</span>
<span class="c">Tactic Notation &quot;skip&quot; :=</span>
<span class="c">  admit.</span>
<span class="c">*)</span>

<span class="sd">(** [demo] is like [admit] but it documents the fact that admit is intended *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;demo&quot;</span> :=
  skip.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [admits H: T] adds an assumption named [H] of type [T] to the</span>
<span class="sd">    current context, blindly assuming that it is true.</span>
<span class="sd">    [admit: T] is another possible syntax.</span>
<span class="sd">    Note that H may be an intro pattern. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;admits&quot;</span> simple_intropattern(I) <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(T) :=
  asserts I: T; [ skip | ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;admits&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(T) :=
  <span class="kr">let</span> <span class="nv">H</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span> admits H: T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;admits&quot;</span> <span class="s2">&quot;~&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(T) :=
  admits: T; auto_tilde.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;admits&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="kp">constr</span>(T) :=
  admits: T; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [admit_cuts T] simply replaces the current goal with [T]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;admit_cuts&quot;</span> <span class="kp">constr</span>(T) :=
  cuts: T; [ skip | ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [admit_goal H] applies to any goal. It simply assumes</span>
<span class="sd">    the current goal to be true. The assumption is named &quot;H&quot;.</span>
<span class="sd">    It is useful to set up proof by induction or coinduction.</span>
<span class="sd">    Syntax [admit_goal] is also accepted.*)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;admit_goal&quot;</span> <span class="kn">ident</span>(H) :=
  <span class="kr">match goal with</span> |- <span class="nl">?G</span> =&gt; admits H: G <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;admit_goal&quot;</span> :=
  <span class="kr">let</span> <span class="nv">IH</span> := <span class="kp">fresh</span> <span class="s2">&quot;IH&quot;</span> <span class="kr">in</span> admit_goal IH.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [admit_rewrite T] can be applied when [T] is an equality.</span>
<span class="sd">    It blindly assumes this equality to be true, and rewrite it in</span>
<span class="sd">    the goal. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;admit_rewrite&quot;</span> <span class="kp">constr</span>(T) :=
  <span class="kr">let</span> <span class="nv">M</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span> admits M: T; <span class="nb">rewrite</span> M; <span class="nb">clear</span> M.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [admit_rewrite T in H] is similar as [admit_rewrite], except that</span>
<span class="sd">    it rewrites in hypothesis [H]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;admit_rewrite&quot;</span> <span class="kp">constr</span>(T) <span class="s2">&quot;in&quot;</span> hyp(H) :=
  <span class="kr">let</span> <span class="nv">M</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span> admits M: T; <span class="nb">rewrite</span> M <span class="kr">in</span> H; <span class="nb">clear</span> M.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [admit_rewrites_all T] is similar as [admit_rewrite], except that</span>
<span class="sd">    it rewrites everywhere (goal and all hypotheses). *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;admit_rewrite_all&quot;</span> <span class="kp">constr</span>(T) :=
  <span class="kr">let</span> <span class="nv">M</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span> admits M: T; rewrite_all M; <span class="nb">clear</span> M.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [forwards_nounfold_admit_sides_then E ltac:(fun K =&gt; ..)]</span>
<span class="sd">    is like [forwards: E] but it provides the resulting term</span>
<span class="sd">    to a continuation, under the name [K], and it admits</span>
<span class="sd">    any side-condition produced by the instantiation of [E],</span>
<span class="sd">    using the [skip] tactic. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">ltac_goal_to_discard</span> := ltac_goal_to_discard_intro.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">forwards_nounfold_admit_sides_then</span> S cont :=
  <span class="kr">let</span> <span class="nv">MARK</span> := <span class="kp">fresh</span> <span class="s2">&quot;TEMP&quot;</span> <span class="kr">in</span>
  <span class="nb">generalize</span> ltac_goal_to_discard_intro;
  <span class="nb">intro</span> MARK;
  forwards_nounfold_then S <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">K</span> =&gt;
    <span class="nb">clear</span> MARK;
    cont K);
  <span class="kr">match goal with</span>
  | MARK: ltac_goal_to_discard |- _ =&gt; skip
  | _ =&gt; <span class="kp">idtac</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

<span class="c">(* ################################################################# *)</span>
<span class="sd">(** * Compatibility with standard library *)</span>

<span class="sd">(** The module [Program] contains definitions that conflict with the</span>
<span class="sd">    current module. If you import [Program], either directly or indirectly</span>
<span class="sd">    (e.g. through [Setoid] or [ZArith]), you will need to import the</span>
<span class="sd">    compability definitions through the top-level command:</span>
<span class="sd">    [Import LibTacticsCompatibility]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">LibTacticsCompatibility</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;apply&quot;</span> <span class="s2">&quot;*&quot;</span> <span class="kp">constr</span>(H) :=
    sapply H; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;subst&quot;</span> <span class="s2">&quot;*&quot;</span> :=
    <span class="nb">subst</span>; auto_star.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">LibTacticsCompatibility</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> nat_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* end hide *)</span>

<span class="c">(* 2021-05-25 14:19 *)</span></span></pre>
</div>
</div></body>
</html>
